// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::doc_markdown,
)]

pub type AppId = String;
pub type EmailAddress = String;
pub type FilePath = String;
pub type IpAddress = String;
pub type NamespaceId = String;
pub type RequestId = String;
pub type TeamEventList = Vec<TeamEvent>;

/// Retrieves team events. If the result's [`GetTeamEventsResult::has_more`](GetTeamEventsResult)
/// field is `true`, call [`get_events_continue()`](get_events_continue) with the returned cursor to
/// retrieve more entries. If end_time is not specified in your request, you may use the returned
/// cursor to poll [`get_events_continue()`](get_events_continue) for new events. Many attributes
/// note 'may be missing due to historical data gap'. Note that the file_operations category and &
/// analogous paper events are not available on all Dropbox Business
/// [plans](/business/plans-comparison). Use
/// [features/get_values](/developers/documentation/http/teams#team-features-get_values) to check
/// for this feature. Permission : Team Auditing.
pub fn get_events(
    client: &dyn crate::client_trait::HttpClient,
    arg: &GetTeamEventsArg,
) -> crate::Result<Result<GetTeamEventsResult, GetTeamEventsError>> {
    crate::client_helpers::request(
        client,
        crate::client_trait::Endpoint::Api,
        crate::client_trait::Style::Rpc,
        "team_log/get_events",
        arg,
        None)
}

/// Once a cursor has been retrieved from [`get_events()`](get_events), use this to paginate through
/// all events. Permission : Team Auditing.
pub fn get_events_continue(
    client: &dyn crate::client_trait::HttpClient,
    arg: &GetTeamEventsContinueArg,
) -> crate::Result<Result<GetTeamEventsResult, GetTeamEventsContinueError>> {
    crate::client_helpers::request(
        client,
        crate::client_trait::Endpoint::Api,
        crate::client_trait::Style::Rpc,
        "team_log/get_events/continue",
        arg,
        None)
}

/// Indicates the method in which the action was performed.
#[derive(Debug)]
pub enum AccessMethodLogInfo {
    /// End user session details.
    EndUser(SessionLogInfo),
    /// Sign in as session details.
    SignInAs(WebSessionLogInfo),
    /// Content manager session details.
    ContentManager(WebSessionLogInfo),
    /// Admin console session details.
    AdminConsole(WebSessionLogInfo),
    /// Enterprise console session details.
    EnterpriseConsole(WebSessionLogInfo),
    /// Api session details.
    Api(ApiSessionLogInfo),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccessMethodLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccessMethodLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccessMethodLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "end_user" => {
                        match map.next_key()? {
                            Some("end_user") => Ok(AccessMethodLogInfo::EndUser(map.next_value()?)),
                            None => Err(de::Error::missing_field("end_user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "sign_in_as" => Ok(AccessMethodLogInfo::SignInAs(WebSessionLogInfo::internal_deserialize(map)?)),
                    "content_manager" => Ok(AccessMethodLogInfo::ContentManager(WebSessionLogInfo::internal_deserialize(map)?)),
                    "admin_console" => Ok(AccessMethodLogInfo::AdminConsole(WebSessionLogInfo::internal_deserialize(map)?)),
                    "enterprise_console" => Ok(AccessMethodLogInfo::EnterpriseConsole(WebSessionLogInfo::internal_deserialize(map)?)),
                    "api" => Ok(AccessMethodLogInfo::Api(ApiSessionLogInfo::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccessMethodLogInfo::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["end_user",
                                    "sign_in_as",
                                    "content_manager",
                                    "admin_console",
                                    "enterprise_console",
                                    "api",
                                    "other"];
        deserializer.deserialize_struct("AccessMethodLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccessMethodLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccessMethodLogInfo::EndUser(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "end_user")?;
                s.serialize_field("end_user", x)?;
                s.end()
            }
            AccessMethodLogInfo::SignInAs(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "sign_in_as")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::ContentManager(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "content_manager")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::AdminConsole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "admin_console")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::EnterpriseConsole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "enterprise_console")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::Api(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AccessMethodLogInfo", 2)?;
                s.serialize_field(".tag", "api")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AccessMethodLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum AccountCaptureAvailability {
    Unavailable,
    Available,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureAvailability {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountCaptureAvailability;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureAvailability structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "unavailable" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCaptureAvailability::Unavailable)
                    }
                    "available" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCaptureAvailability::Available)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCaptureAvailability::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["unavailable",
                                    "available",
                                    "other"];
        deserializer.deserialize_struct("AccountCaptureAvailability", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureAvailability {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountCaptureAvailability::Unavailable => {
                // unit
                let mut s = serializer.serialize_struct("AccountCaptureAvailability", 1)?;
                s.serialize_field(".tag", "unavailable")?;
                s.end()
            }
            AccountCaptureAvailability::Available => {
                // unit
                let mut s = serializer.serialize_struct("AccountCaptureAvailability", 1)?;
                s.serialize_field(".tag", "available")?;
                s.end()
            }
            AccountCaptureAvailability::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Granted/revoked option to enable account capture on team domains.
#[derive(Debug)]
pub struct AccountCaptureChangeAvailabilityDetails {
    /// New account capture availabilty value.
    pub new_value: AccountCaptureAvailability,
    /// Previous account capture availabilty value. Might be missing due to historical data gap.
    pub previous_value: Option<AccountCaptureAvailability>,
}

impl AccountCaptureChangeAvailabilityDetails {
    pub fn new(new_value: AccountCaptureAvailability) -> Self {
        AccountCaptureChangeAvailabilityDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<AccountCaptureAvailability>) -> Self {
        self.previous_value = value;
        self
    }

}

const ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                      "previous_value"];
impl AccountCaptureChangeAvailabilityDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureChangeAvailabilityDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureChangeAvailabilityDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureChangeAvailabilityDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangeAvailabilityDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangeAvailabilityDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangeAvailabilityDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangeAvailabilityDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangeAvailabilityDetails", ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangeAvailabilityDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangeAvailabilityDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureChangeAvailabilityType {
    pub description: String,
}

impl AccountCaptureChangeAvailabilityType {
    pub fn new(description: String) -> Self {
        AccountCaptureChangeAvailabilityType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureChangeAvailabilityType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureChangeAvailabilityType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureChangeAvailabilityType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureChangeAvailabilityType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangeAvailabilityType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangeAvailabilityType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangeAvailabilityType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangeAvailabilityType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangeAvailabilityType", ACCOUNT_CAPTURE_CHANGE_AVAILABILITY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangeAvailabilityType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangeAvailabilityType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed account capture setting on team domain.
#[derive(Debug)]
pub struct AccountCaptureChangePolicyDetails {
    /// New account capture policy.
    pub new_value: AccountCapturePolicy,
    /// Previous account capture policy. Might be missing due to historical data gap.
    pub previous_value: Option<AccountCapturePolicy>,
}

impl AccountCaptureChangePolicyDetails {
    pub fn new(new_value: AccountCapturePolicy) -> Self {
        AccountCaptureChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<AccountCapturePolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const ACCOUNT_CAPTURE_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl AccountCaptureChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangePolicyDetails", ACCOUNT_CAPTURE_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureChangePolicyType {
    pub description: String,
}

impl AccountCaptureChangePolicyType {
    pub fn new(description: String) -> Self {
        AccountCaptureChangePolicyType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureChangePolicyType", ACCOUNT_CAPTURE_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Account-captured user migrated account to team.
#[derive(Debug)]
pub struct AccountCaptureMigrateAccountDetails {
    /// Domain name.
    pub domain_name: String,
}

impl AccountCaptureMigrateAccountDetails {
    pub fn new(domain_name: String) -> Self {
        AccountCaptureMigrateAccountDetails {
            domain_name,
        }
    }

}

const ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_DETAILS_FIELDS: &[&str] = &["domain_name"];
impl AccountCaptureMigrateAccountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureMigrateAccountDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureMigrateAccountDetails>, V::Error> {
        let mut field_domain_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureMigrateAccountDetails {
            domain_name: field_domain_name.ok_or_else(|| ::serde::de::Error::missing_field("domain_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureMigrateAccountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureMigrateAccountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureMigrateAccountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureMigrateAccountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureMigrateAccountDetails", ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureMigrateAccountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureMigrateAccountDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureMigrateAccountType {
    pub description: String,
}

impl AccountCaptureMigrateAccountType {
    pub fn new(description: String) -> Self {
        AccountCaptureMigrateAccountType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureMigrateAccountType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureMigrateAccountType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureMigrateAccountType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureMigrateAccountType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureMigrateAccountType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureMigrateAccountType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureMigrateAccountType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureMigrateAccountType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureMigrateAccountType", ACCOUNT_CAPTURE_MIGRATE_ACCOUNT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureMigrateAccountType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureMigrateAccountType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sent account capture email to all unmanaged members.
#[derive(Debug)]
pub struct AccountCaptureNotificationEmailsSentDetails {
    /// Domain name.
    pub domain_name: String,
    /// Account-capture email notification type.
    pub notification_type: Option<AccountCaptureNotificationType>,
}

impl AccountCaptureNotificationEmailsSentDetails {
    pub fn new(domain_name: String) -> Self {
        AccountCaptureNotificationEmailsSentDetails {
            domain_name,
            notification_type: None,
        }
    }

    pub fn with_notification_type(
        mut self,
        value: Option<AccountCaptureNotificationType>,
    ) -> Self {
        self.notification_type = value;
        self
    }

}

const ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_DETAILS_FIELDS: &[&str] = &["domain_name",
                                                                           "notification_type"];
impl AccountCaptureNotificationEmailsSentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureNotificationEmailsSentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureNotificationEmailsSentDetails>, V::Error> {
        let mut field_domain_name = None;
        let mut field_notification_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                "notification_type" => {
                    if field_notification_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("notification_type"));
                    }
                    field_notification_type = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureNotificationEmailsSentDetails {
            domain_name: field_domain_name.ok_or_else(|| ::serde::de::Error::missing_field("domain_name"))?,
            notification_type: field_notification_type,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)?;
        s.serialize_field("notification_type", &self.notification_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureNotificationEmailsSentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureNotificationEmailsSentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureNotificationEmailsSentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureNotificationEmailsSentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureNotificationEmailsSentDetails", ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureNotificationEmailsSentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureNotificationEmailsSentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureNotificationEmailsSentType {
    pub description: String,
}

impl AccountCaptureNotificationEmailsSentType {
    pub fn new(description: String) -> Self {
        AccountCaptureNotificationEmailsSentType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureNotificationEmailsSentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureNotificationEmailsSentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureNotificationEmailsSentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureNotificationEmailsSentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureNotificationEmailsSentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureNotificationEmailsSentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureNotificationEmailsSentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureNotificationEmailsSentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureNotificationEmailsSentType", ACCOUNT_CAPTURE_NOTIFICATION_EMAILS_SENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureNotificationEmailsSentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureNotificationEmailsSentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum AccountCaptureNotificationType {
    ProactiveWarningNotification,
    ActionableNotification,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureNotificationType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountCaptureNotificationType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureNotificationType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "proactive_warning_notification" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCaptureNotificationType::ProactiveWarningNotification)
                    }
                    "actionable_notification" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCaptureNotificationType::ActionableNotification)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCaptureNotificationType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["proactive_warning_notification",
                                    "actionable_notification",
                                    "other"];
        deserializer.deserialize_struct("AccountCaptureNotificationType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureNotificationType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountCaptureNotificationType::ProactiveWarningNotification => {
                // unit
                let mut s = serializer.serialize_struct("AccountCaptureNotificationType", 1)?;
                s.serialize_field(".tag", "proactive_warning_notification")?;
                s.end()
            }
            AccountCaptureNotificationType::ActionableNotification => {
                // unit
                let mut s = serializer.serialize_struct("AccountCaptureNotificationType", 1)?;
                s.serialize_field(".tag", "actionable_notification")?;
                s.end()
            }
            AccountCaptureNotificationType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum AccountCapturePolicy {
    Disabled,
    InvitedUsers,
    AllUsers,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCapturePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountCapturePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCapturePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCapturePolicy::Disabled)
                    }
                    "invited_users" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCapturePolicy::InvitedUsers)
                    }
                    "all_users" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCapturePolicy::AllUsers)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountCapturePolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "invited_users",
                                    "all_users",
                                    "other"];
        deserializer.deserialize_struct("AccountCapturePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCapturePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountCapturePolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("AccountCapturePolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            AccountCapturePolicy::InvitedUsers => {
                // unit
                let mut s = serializer.serialize_struct("AccountCapturePolicy", 1)?;
                s.serialize_field(".tag", "invited_users")?;
                s.end()
            }
            AccountCapturePolicy::AllUsers => {
                // unit
                let mut s = serializer.serialize_struct("AccountCapturePolicy", 1)?;
                s.serialize_field(".tag", "all_users")?;
                s.end()
            }
            AccountCapturePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Account-captured user changed account email to personal email.
#[derive(Debug)]
pub struct AccountCaptureRelinquishAccountDetails {
    /// Domain name.
    pub domain_name: String,
}

impl AccountCaptureRelinquishAccountDetails {
    pub fn new(domain_name: String) -> Self {
        AccountCaptureRelinquishAccountDetails {
            domain_name,
        }
    }

}

const ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_DETAILS_FIELDS: &[&str] = &["domain_name"];
impl AccountCaptureRelinquishAccountDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureRelinquishAccountDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureRelinquishAccountDetails>, V::Error> {
        let mut field_domain_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureRelinquishAccountDetails {
            domain_name: field_domain_name.ok_or_else(|| ::serde::de::Error::missing_field("domain_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureRelinquishAccountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureRelinquishAccountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureRelinquishAccountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureRelinquishAccountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureRelinquishAccountDetails", ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureRelinquishAccountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureRelinquishAccountDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountCaptureRelinquishAccountType {
    pub description: String,
}

impl AccountCaptureRelinquishAccountType {
    pub fn new(description: String) -> Self {
        AccountCaptureRelinquishAccountType {
            description,
        }
    }

}

const ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_TYPE_FIELDS: &[&str] = &["description"];
impl AccountCaptureRelinquishAccountType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCaptureRelinquishAccountType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCaptureRelinquishAccountType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCaptureRelinquishAccountType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCaptureRelinquishAccountType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCaptureRelinquishAccountType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCaptureRelinquishAccountType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCaptureRelinquishAccountType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountCaptureRelinquishAccountType", ACCOUNT_CAPTURE_RELINQUISH_ACCOUNT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountCaptureRelinquishAccountType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCaptureRelinquishAccountType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unlocked/locked account after failed sign in attempts.
#[derive(Debug)]
pub struct AccountLockOrUnlockedDetails {
    /// The previous account status.
    pub previous_value: AccountState,
    /// The new account status.
    pub new_value: AccountState,
}

impl AccountLockOrUnlockedDetails {
    pub fn new(previous_value: AccountState, new_value: AccountState) -> Self {
        AccountLockOrUnlockedDetails {
            previous_value,
            new_value,
        }
    }

}

const ACCOUNT_LOCK_OR_UNLOCKED_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                           "new_value"];
impl AccountLockOrUnlockedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountLockOrUnlockedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountLockOrUnlockedDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountLockOrUnlockedDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountLockOrUnlockedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountLockOrUnlockedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountLockOrUnlockedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountLockOrUnlockedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountLockOrUnlockedDetails", ACCOUNT_LOCK_OR_UNLOCKED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountLockOrUnlockedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountLockOrUnlockedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AccountLockOrUnlockedType {
    pub description: String,
}

impl AccountLockOrUnlockedType {
    pub fn new(description: String) -> Self {
        AccountLockOrUnlockedType {
            description,
        }
    }

}

const ACCOUNT_LOCK_OR_UNLOCKED_TYPE_FIELDS: &[&str] = &["description"];
impl AccountLockOrUnlockedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountLockOrUnlockedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountLockOrUnlockedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountLockOrUnlockedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountLockOrUnlockedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountLockOrUnlockedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountLockOrUnlockedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountLockOrUnlockedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountLockOrUnlockedType", ACCOUNT_LOCK_OR_UNLOCKED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountLockOrUnlockedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountLockOrUnlockedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum AccountState {
    Locked,
    Unlocked,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountState {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountState;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountState structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "locked" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountState::Locked)
                    }
                    "unlocked" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountState::Unlocked)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AccountState::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["locked",
                                    "unlocked",
                                    "other"];
        deserializer.deserialize_struct("AccountState", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountState {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountState::Locked => {
                // unit
                let mut s = serializer.serialize_struct("AccountState", 1)?;
                s.serialize_field(".tag", "locked")?;
                s.end()
            }
            AccountState::Unlocked => {
                // unit
                let mut s = serializer.serialize_struct("AccountState", 1)?;
                s.serialize_field(".tag", "unlocked")?;
                s.end()
            }
            AccountState::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Additional information indicating the action taken that caused status change.
#[derive(Debug)]
pub enum ActionDetails {
    /// Additional information relevant when a new member joins the team.
    TeamJoinDetails(JoinTeamDetails),
    /// Define how the user was removed from the team.
    RemoveAction(MemberRemoveActionType),
    /// Additional information relevant when someone is invited to the team.
    TeamInviteDetails(TeamInviteDetails),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ActionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ActionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ActionDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_join_details" => Ok(ActionDetails::TeamJoinDetails(JoinTeamDetails::internal_deserialize(map)?)),
                    "remove_action" => {
                        match map.next_key()? {
                            Some("remove_action") => Ok(ActionDetails::RemoveAction(map.next_value()?)),
                            None => Err(de::Error::missing_field("remove_action")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "team_invite_details" => Ok(ActionDetails::TeamInviteDetails(TeamInviteDetails::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ActionDetails::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["team_join_details",
                                    "remove_action",
                                    "team_invite_details",
                                    "other"];
        deserializer.deserialize_struct("ActionDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ActionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ActionDetails::TeamJoinDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ActionDetails", 10)?;
                s.serialize_field(".tag", "team_join_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ActionDetails::RemoveAction(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("ActionDetails", 2)?;
                s.serialize_field(".tag", "remove_action")?;
                s.serialize_field("remove_action", x)?;
                s.end()
            }
            ActionDetails::TeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ActionDetails", 2)?;
                s.serialize_field(".tag", "team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ActionDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The entity who performed the action.
#[derive(Debug)]
pub enum ActorLogInfo {
    /// The user who did the action.
    User(UserLogInfo),
    /// The admin who did the action.
    Admin(UserLogInfo),
    /// The application who did the action.
    App(AppLogInfo),
    /// Action done by reseller.
    Reseller(ResellerLogInfo),
    /// Action done by Dropbox.
    Dropbox,
    /// Anonymous actor.
    Anonymous,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ActorLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ActorLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ActorLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user" => {
                        match map.next_key()? {
                            Some("user") => Ok(ActorLogInfo::User(map.next_value()?)),
                            None => Err(de::Error::missing_field("user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "admin" => {
                        match map.next_key()? {
                            Some("admin") => Ok(ActorLogInfo::Admin(map.next_value()?)),
                            None => Err(de::Error::missing_field("admin")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "app" => {
                        match map.next_key()? {
                            Some("app") => Ok(ActorLogInfo::App(map.next_value()?)),
                            None => Err(de::Error::missing_field("app")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "reseller" => Ok(ActorLogInfo::Reseller(ResellerLogInfo::internal_deserialize(map)?)),
                    "dropbox" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ActorLogInfo::Dropbox)
                    }
                    "anonymous" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ActorLogInfo::Anonymous)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ActorLogInfo::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["user",
                                    "admin",
                                    "app",
                                    "reseller",
                                    "dropbox",
                                    "anonymous",
                                    "other"];
        deserializer.deserialize_struct("ActorLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ActorLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ActorLogInfo::User(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("ActorLogInfo", 2)?;
                s.serialize_field(".tag", "user")?;
                s.serialize_field("user", x)?;
                s.end()
            }
            ActorLogInfo::Admin(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("ActorLogInfo", 2)?;
                s.serialize_field(".tag", "admin")?;
                s.serialize_field("admin", x)?;
                s.end()
            }
            ActorLogInfo::App(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("ActorLogInfo", 2)?;
                s.serialize_field(".tag", "app")?;
                s.serialize_field("app", x)?;
                s.end()
            }
            ActorLogInfo::Reseller(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ActorLogInfo", 3)?;
                s.serialize_field(".tag", "reseller")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ActorLogInfo::Dropbox => {
                // unit
                let mut s = serializer.serialize_struct("ActorLogInfo", 1)?;
                s.serialize_field(".tag", "dropbox")?;
                s.end()
            }
            ActorLogInfo::Anonymous => {
                // unit
                let mut s = serializer.serialize_struct("ActorLogInfo", 1)?;
                s.serialize_field(".tag", "anonymous")?;
                s.end()
            }
            ActorLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum AdminRole {
    TeamAdmin,
    UserManagementAdmin,
    SupportAdmin,
    LimitedAdmin,
    MemberOnly,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AdminRole {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AdminRole;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AdminRole structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_admin" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AdminRole::TeamAdmin)
                    }
                    "user_management_admin" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AdminRole::UserManagementAdmin)
                    }
                    "support_admin" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AdminRole::SupportAdmin)
                    }
                    "limited_admin" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AdminRole::LimitedAdmin)
                    }
                    "member_only" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AdminRole::MemberOnly)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AdminRole::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["team_admin",
                                    "user_management_admin",
                                    "support_admin",
                                    "limited_admin",
                                    "member_only",
                                    "other"];
        deserializer.deserialize_struct("AdminRole", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AdminRole {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AdminRole::TeamAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "team_admin")?;
                s.end()
            }
            AdminRole::UserManagementAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "user_management_admin")?;
                s.end()
            }
            AdminRole::SupportAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "support_admin")?;
                s.end()
            }
            AdminRole::LimitedAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "limited_admin")?;
                s.end()
            }
            AdminRole::MemberOnly => {
                // unit
                let mut s = serializer.serialize_struct("AdminRole", 1)?;
                s.serialize_field(".tag", "member_only")?;
                s.end()
            }
            AdminRole::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Disabled downloads.
#[derive(Debug)]
pub struct AllowDownloadDisabledDetails {
}

impl Default for AllowDownloadDisabledDetails {
    fn default() -> Self {
        AllowDownloadDisabledDetails {
        }
    }
}

const ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS: &[&str] = &[];
impl AllowDownloadDisabledDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AllowDownloadDisabledDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(AllowDownloadDisabledDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadDisabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadDisabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadDisabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadDisabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadDisabledDetails", ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadDisabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("AllowDownloadDisabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct AllowDownloadDisabledType {
    pub description: String,
}

impl AllowDownloadDisabledType {
    pub fn new(description: String) -> Self {
        AllowDownloadDisabledType {
            description,
        }
    }

}

const ALLOW_DOWNLOAD_DISABLED_TYPE_FIELDS: &[&str] = &["description"];
impl AllowDownloadDisabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AllowDownloadDisabledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AllowDownloadDisabledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AllowDownloadDisabledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadDisabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadDisabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadDisabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadDisabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadDisabledType", ALLOW_DOWNLOAD_DISABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadDisabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AllowDownloadDisabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled downloads.
#[derive(Debug)]
pub struct AllowDownloadEnabledDetails {
}

impl Default for AllowDownloadEnabledDetails {
    fn default() -> Self {
        AllowDownloadEnabledDetails {
        }
    }
}

const ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS: &[&str] = &[];
impl AllowDownloadEnabledDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AllowDownloadEnabledDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(AllowDownloadEnabledDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadEnabledDetails", ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("AllowDownloadEnabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct AllowDownloadEnabledType {
    pub description: String,
}

impl AllowDownloadEnabledType {
    pub fn new(description: String) -> Self {
        AllowDownloadEnabledType {
            description,
        }
    }

}

const ALLOW_DOWNLOAD_ENABLED_TYPE_FIELDS: &[&str] = &["description"];
impl AllowDownloadEnabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AllowDownloadEnabledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AllowDownloadEnabledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AllowDownloadEnabledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AllowDownloadEnabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AllowDownloadEnabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AllowDownloadEnabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AllowDownloadEnabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AllowDownloadEnabledType", ALLOW_DOWNLOAD_ENABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AllowDownloadEnabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AllowDownloadEnabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Api session.
#[derive(Debug)]
pub struct ApiSessionLogInfo {
    /// Api request ID.
    pub request_id: RequestId,
}

impl ApiSessionLogInfo {
    pub fn new(request_id: RequestId) -> Self {
        ApiSessionLogInfo {
            request_id,
        }
    }

}

const API_SESSION_LOG_INFO_FIELDS: &[&str] = &["request_id"];
impl ApiSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ApiSessionLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ApiSessionLogInfo>, V::Error> {
        let mut field_request_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "request_id" => {
                    if field_request_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("request_id"));
                    }
                    field_request_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ApiSessionLogInfo {
            request_id: field_request_id.ok_or_else(|| ::serde::de::Error::missing_field("request_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_id", &self.request_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ApiSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ApiSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ApiSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ApiSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ApiSessionLogInfo", API_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ApiSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ApiSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked app for team.
#[derive(Debug)]
pub struct AppLinkTeamDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppLinkTeamDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppLinkTeamDetails {
            app_info,
        }
    }

}

const APP_LINK_TEAM_DETAILS_FIELDS: &[&str] = &["app_info"];
impl AppLinkTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AppLinkTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AppLinkTeamDetails>, V::Error> {
        let mut field_app_info = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AppLinkTeamDetails {
            app_info: field_app_info.ok_or_else(|| ::serde::de::Error::missing_field("app_info"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AppLinkTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkTeamDetails", APP_LINK_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AppLinkTeamType {
    pub description: String,
}

impl AppLinkTeamType {
    pub fn new(description: String) -> Self {
        AppLinkTeamType {
            description,
        }
    }

}

const APP_LINK_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl AppLinkTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AppLinkTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AppLinkTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AppLinkTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AppLinkTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkTeamType", APP_LINK_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked app for member.
#[derive(Debug)]
pub struct AppLinkUserDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppLinkUserDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppLinkUserDetails {
            app_info,
        }
    }

}

const APP_LINK_USER_DETAILS_FIELDS: &[&str] = &["app_info"];
impl AppLinkUserDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AppLinkUserDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AppLinkUserDetails>, V::Error> {
        let mut field_app_info = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AppLinkUserDetails {
            app_info: field_app_info.ok_or_else(|| ::serde::de::Error::missing_field("app_info"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkUserDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkUserDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AppLinkUserDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkUserDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkUserDetails", APP_LINK_USER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkUserDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkUserDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AppLinkUserType {
    pub description: String,
}

impl AppLinkUserType {
    pub fn new(description: String) -> Self {
        AppLinkUserType {
            description,
        }
    }

}

const APP_LINK_USER_TYPE_FIELDS: &[&str] = &["description"];
impl AppLinkUserType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AppLinkUserType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AppLinkUserType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AppLinkUserType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppLinkUserType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppLinkUserType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AppLinkUserType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppLinkUserType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppLinkUserType", APP_LINK_USER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppLinkUserType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppLinkUserType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// App's logged information.
#[derive(Debug)]
pub enum AppLogInfo {
    UserOrTeamLinkedApp(UserOrTeamLinkedAppLogInfo),
    UserLinkedApp(UserLinkedAppLogInfo),
    TeamLinkedApp(TeamLinkedAppLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for AppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AppLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_or_team_linked_app" => Ok(AppLogInfo::UserOrTeamLinkedApp(UserOrTeamLinkedAppLogInfo::internal_deserialize(map)?)),
                    "user_linked_app" => Ok(AppLogInfo::UserLinkedApp(UserLinkedAppLogInfo::internal_deserialize(map)?)),
                    "team_linked_app" => Ok(AppLogInfo::TeamLinkedApp(TeamLinkedAppLogInfo::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AppLogInfo::_Unknown)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["team_linked_app",
                                    "team_linked_app",
                                    "team_linked_app"];
        deserializer.deserialize_struct("AppLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            AppLogInfo::UserOrTeamLinkedApp(ref x) => {
                let mut s = serializer.serialize_struct("AppLogInfo", 3)?;
                s.serialize_field(".tag", "user_or_team_linked_app")?;
                s.serialize_field("app_id", &x.app_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.end()
            }
            AppLogInfo::UserLinkedApp(ref x) => {
                let mut s = serializer.serialize_struct("AppLogInfo", 3)?;
                s.serialize_field(".tag", "user_linked_app")?;
                s.serialize_field("app_id", &x.app_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.end()
            }
            AppLogInfo::TeamLinkedApp(ref x) => {
                let mut s = serializer.serialize_struct("AppLogInfo", 3)?;
                s.serialize_field(".tag", "team_linked_app")?;
                s.serialize_field("app_id", &x.app_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.end()
            }
            AppLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// Unlinked app for team.
#[derive(Debug)]
pub struct AppUnlinkTeamDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppUnlinkTeamDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppUnlinkTeamDetails {
            app_info,
        }
    }

}

const APP_UNLINK_TEAM_DETAILS_FIELDS: &[&str] = &["app_info"];
impl AppUnlinkTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AppUnlinkTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AppUnlinkTeamDetails>, V::Error> {
        let mut field_app_info = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AppUnlinkTeamDetails {
            app_info: field_app_info.ok_or_else(|| ::serde::de::Error::missing_field("app_info"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkTeamDetails", APP_UNLINK_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AppUnlinkTeamType {
    pub description: String,
}

impl AppUnlinkTeamType {
    pub fn new(description: String) -> Self {
        AppUnlinkTeamType {
            description,
        }
    }

}

const APP_UNLINK_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl AppUnlinkTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AppUnlinkTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AppUnlinkTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AppUnlinkTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkTeamType", APP_UNLINK_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unlinked app for member.
#[derive(Debug)]
pub struct AppUnlinkUserDetails {
    /// Relevant application details.
    pub app_info: AppLogInfo,
}

impl AppUnlinkUserDetails {
    pub fn new(app_info: AppLogInfo) -> Self {
        AppUnlinkUserDetails {
            app_info,
        }
    }

}

const APP_UNLINK_USER_DETAILS_FIELDS: &[&str] = &["app_info"];
impl AppUnlinkUserDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AppUnlinkUserDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AppUnlinkUserDetails>, V::Error> {
        let mut field_app_info = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "app_info" => {
                    if field_app_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("app_info"));
                    }
                    field_app_info = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AppUnlinkUserDetails {
            app_info: field_app_info.ok_or_else(|| ::serde::de::Error::missing_field("app_info"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_info", &self.app_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkUserDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkUserDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkUserDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkUserDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkUserDetails", APP_UNLINK_USER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkUserDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkUserDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct AppUnlinkUserType {
    pub description: String,
}

impl AppUnlinkUserType {
    pub fn new(description: String) -> Self {
        AppUnlinkUserType {
            description,
        }
    }

}

const APP_UNLINK_USER_TYPE_FIELDS: &[&str] = &["description"];
impl AppUnlinkUserType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AppUnlinkUserType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AppUnlinkUserType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AppUnlinkUserType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AppUnlinkUserType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AppUnlinkUserType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AppUnlinkUserType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AppUnlinkUserType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AppUnlinkUserType", APP_UNLINK_USER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AppUnlinkUserType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AppUnlinkUserType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Asset details.
#[derive(Debug)]
pub enum AssetLogInfo {
    /// File's details.
    File(FileLogInfo),
    /// Folder's details.
    Folder(FolderLogInfo),
    /// Paper document's details.
    PaperDocument(PaperDocumentLogInfo),
    /// Paper folder's details.
    PaperFolder(PaperFolderLogInfo),
    /// Showcase document's details.
    ShowcaseDocument(ShowcaseDocumentLogInfo),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "file" => Ok(AssetLogInfo::File(FileLogInfo::internal_deserialize(map)?)),
                    "folder" => Ok(AssetLogInfo::Folder(FolderLogInfo::internal_deserialize(map)?)),
                    "paper_document" => Ok(AssetLogInfo::PaperDocument(PaperDocumentLogInfo::internal_deserialize(map)?)),
                    "paper_folder" => Ok(AssetLogInfo::PaperFolder(PaperFolderLogInfo::internal_deserialize(map)?)),
                    "showcase_document" => Ok(AssetLogInfo::ShowcaseDocument(ShowcaseDocumentLogInfo::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(AssetLogInfo::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["file",
                                    "folder",
                                    "paper_document",
                                    "paper_folder",
                                    "showcase_document",
                                    "other"];
        deserializer.deserialize_struct("AssetLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetLogInfo::File(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 5)?;
                s.serialize_field(".tag", "file")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::Folder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 6)?;
                s.serialize_field(".tag", "folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::PaperDocument(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 3)?;
                s.serialize_field(".tag", "paper_document")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::PaperFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 3)?;
                s.serialize_field(".tag", "paper_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::ShowcaseDocument(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetLogInfo", 3)?;
                s.serialize_field(".tag", "showcase_document")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added Binder page.
#[derive(Debug)]
pub struct BinderAddPageDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Title of the Binder doc.
    pub doc_title: String,
    /// Name of the Binder page/section.
    pub binder_item_name: String,
}

impl BinderAddPageDetails {
    pub fn new(event_uuid: String, doc_title: String, binder_item_name: String) -> Self {
        BinderAddPageDetails {
            event_uuid,
            doc_title,
            binder_item_name,
        }
    }

}

const BINDER_ADD_PAGE_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                  "doc_title",
                                                  "binder_item_name"];
impl BinderAddPageDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderAddPageDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderAddPageDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_doc_title = None;
        let mut field_binder_item_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                "binder_item_name" => {
                    if field_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("binder_item_name"));
                    }
                    field_binder_item_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderAddPageDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            doc_title: field_doc_title.ok_or_else(|| ::serde::de::Error::missing_field("doc_title"))?,
            binder_item_name: field_binder_item_name.ok_or_else(|| ::serde::de::Error::missing_field("binder_item_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("doc_title", &self.doc_title)?;
        s.serialize_field("binder_item_name", &self.binder_item_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderAddPageDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderAddPageDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderAddPageDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderAddPageDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderAddPageDetails", BINDER_ADD_PAGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderAddPageDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderAddPageDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct BinderAddPageType {
    pub description: String,
}

impl BinderAddPageType {
    pub fn new(description: String) -> Self {
        BinderAddPageType {
            description,
        }
    }

}

const BINDER_ADD_PAGE_TYPE_FIELDS: &[&str] = &["description"];
impl BinderAddPageType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderAddPageType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderAddPageType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderAddPageType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderAddPageType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderAddPageType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderAddPageType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderAddPageType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderAddPageType", BINDER_ADD_PAGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderAddPageType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderAddPageType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added Binder section.
#[derive(Debug)]
pub struct BinderAddSectionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Title of the Binder doc.
    pub doc_title: String,
    /// Name of the Binder page/section.
    pub binder_item_name: String,
}

impl BinderAddSectionDetails {
    pub fn new(event_uuid: String, doc_title: String, binder_item_name: String) -> Self {
        BinderAddSectionDetails {
            event_uuid,
            doc_title,
            binder_item_name,
        }
    }

}

const BINDER_ADD_SECTION_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                     "doc_title",
                                                     "binder_item_name"];
impl BinderAddSectionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderAddSectionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderAddSectionDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_doc_title = None;
        let mut field_binder_item_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                "binder_item_name" => {
                    if field_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("binder_item_name"));
                    }
                    field_binder_item_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderAddSectionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            doc_title: field_doc_title.ok_or_else(|| ::serde::de::Error::missing_field("doc_title"))?,
            binder_item_name: field_binder_item_name.ok_or_else(|| ::serde::de::Error::missing_field("binder_item_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("doc_title", &self.doc_title)?;
        s.serialize_field("binder_item_name", &self.binder_item_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderAddSectionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderAddSectionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderAddSectionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderAddSectionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderAddSectionDetails", BINDER_ADD_SECTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderAddSectionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderAddSectionDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct BinderAddSectionType {
    pub description: String,
}

impl BinderAddSectionType {
    pub fn new(description: String) -> Self {
        BinderAddSectionType {
            description,
        }
    }

}

const BINDER_ADD_SECTION_TYPE_FIELDS: &[&str] = &["description"];
impl BinderAddSectionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderAddSectionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderAddSectionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderAddSectionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderAddSectionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderAddSectionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderAddSectionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderAddSectionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderAddSectionType", BINDER_ADD_SECTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderAddSectionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderAddSectionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed Binder page.
#[derive(Debug)]
pub struct BinderRemovePageDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Title of the Binder doc.
    pub doc_title: String,
    /// Name of the Binder page/section.
    pub binder_item_name: String,
}

impl BinderRemovePageDetails {
    pub fn new(event_uuid: String, doc_title: String, binder_item_name: String) -> Self {
        BinderRemovePageDetails {
            event_uuid,
            doc_title,
            binder_item_name,
        }
    }

}

const BINDER_REMOVE_PAGE_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                     "doc_title",
                                                     "binder_item_name"];
impl BinderRemovePageDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderRemovePageDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderRemovePageDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_doc_title = None;
        let mut field_binder_item_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                "binder_item_name" => {
                    if field_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("binder_item_name"));
                    }
                    field_binder_item_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderRemovePageDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            doc_title: field_doc_title.ok_or_else(|| ::serde::de::Error::missing_field("doc_title"))?,
            binder_item_name: field_binder_item_name.ok_or_else(|| ::serde::de::Error::missing_field("binder_item_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("doc_title", &self.doc_title)?;
        s.serialize_field("binder_item_name", &self.binder_item_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderRemovePageDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderRemovePageDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderRemovePageDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderRemovePageDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderRemovePageDetails", BINDER_REMOVE_PAGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderRemovePageDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderRemovePageDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct BinderRemovePageType {
    pub description: String,
}

impl BinderRemovePageType {
    pub fn new(description: String) -> Self {
        BinderRemovePageType {
            description,
        }
    }

}

const BINDER_REMOVE_PAGE_TYPE_FIELDS: &[&str] = &["description"];
impl BinderRemovePageType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderRemovePageType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderRemovePageType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderRemovePageType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderRemovePageType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderRemovePageType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderRemovePageType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderRemovePageType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderRemovePageType", BINDER_REMOVE_PAGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderRemovePageType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderRemovePageType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed Binder section.
#[derive(Debug)]
pub struct BinderRemoveSectionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Title of the Binder doc.
    pub doc_title: String,
    /// Name of the Binder page/section.
    pub binder_item_name: String,
}

impl BinderRemoveSectionDetails {
    pub fn new(event_uuid: String, doc_title: String, binder_item_name: String) -> Self {
        BinderRemoveSectionDetails {
            event_uuid,
            doc_title,
            binder_item_name,
        }
    }

}

const BINDER_REMOVE_SECTION_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                        "doc_title",
                                                        "binder_item_name"];
impl BinderRemoveSectionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderRemoveSectionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderRemoveSectionDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_doc_title = None;
        let mut field_binder_item_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                "binder_item_name" => {
                    if field_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("binder_item_name"));
                    }
                    field_binder_item_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderRemoveSectionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            doc_title: field_doc_title.ok_or_else(|| ::serde::de::Error::missing_field("doc_title"))?,
            binder_item_name: field_binder_item_name.ok_or_else(|| ::serde::de::Error::missing_field("binder_item_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("doc_title", &self.doc_title)?;
        s.serialize_field("binder_item_name", &self.binder_item_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderRemoveSectionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderRemoveSectionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderRemoveSectionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderRemoveSectionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderRemoveSectionDetails", BINDER_REMOVE_SECTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderRemoveSectionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderRemoveSectionDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct BinderRemoveSectionType {
    pub description: String,
}

impl BinderRemoveSectionType {
    pub fn new(description: String) -> Self {
        BinderRemoveSectionType {
            description,
        }
    }

}

const BINDER_REMOVE_SECTION_TYPE_FIELDS: &[&str] = &["description"];
impl BinderRemoveSectionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderRemoveSectionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderRemoveSectionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderRemoveSectionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderRemoveSectionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderRemoveSectionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderRemoveSectionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderRemoveSectionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderRemoveSectionType", BINDER_REMOVE_SECTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderRemoveSectionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderRemoveSectionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed Binder page.
#[derive(Debug)]
pub struct BinderRenamePageDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Title of the Binder doc.
    pub doc_title: String,
    /// Name of the Binder page/section.
    pub binder_item_name: String,
    /// Previous name of the Binder page/section.
    pub previous_binder_item_name: Option<String>,
}

impl BinderRenamePageDetails {
    pub fn new(event_uuid: String, doc_title: String, binder_item_name: String) -> Self {
        BinderRenamePageDetails {
            event_uuid,
            doc_title,
            binder_item_name,
            previous_binder_item_name: None,
        }
    }

    pub fn with_previous_binder_item_name(mut self, value: Option<String>) -> Self {
        self.previous_binder_item_name = value;
        self
    }

}

const BINDER_RENAME_PAGE_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                     "doc_title",
                                                     "binder_item_name",
                                                     "previous_binder_item_name"];
impl BinderRenamePageDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderRenamePageDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderRenamePageDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_doc_title = None;
        let mut field_binder_item_name = None;
        let mut field_previous_binder_item_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                "binder_item_name" => {
                    if field_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("binder_item_name"));
                    }
                    field_binder_item_name = Some(map.next_value()?);
                }
                "previous_binder_item_name" => {
                    if field_previous_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_binder_item_name"));
                    }
                    field_previous_binder_item_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderRenamePageDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            doc_title: field_doc_title.ok_or_else(|| ::serde::de::Error::missing_field("doc_title"))?,
            binder_item_name: field_binder_item_name.ok_or_else(|| ::serde::de::Error::missing_field("binder_item_name"))?,
            previous_binder_item_name: field_previous_binder_item_name,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("doc_title", &self.doc_title)?;
        s.serialize_field("binder_item_name", &self.binder_item_name)?;
        s.serialize_field("previous_binder_item_name", &self.previous_binder_item_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderRenamePageDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderRenamePageDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderRenamePageDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderRenamePageDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderRenamePageDetails", BINDER_RENAME_PAGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderRenamePageDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderRenamePageDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct BinderRenamePageType {
    pub description: String,
}

impl BinderRenamePageType {
    pub fn new(description: String) -> Self {
        BinderRenamePageType {
            description,
        }
    }

}

const BINDER_RENAME_PAGE_TYPE_FIELDS: &[&str] = &["description"];
impl BinderRenamePageType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderRenamePageType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderRenamePageType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderRenamePageType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderRenamePageType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderRenamePageType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderRenamePageType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderRenamePageType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderRenamePageType", BINDER_RENAME_PAGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderRenamePageType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderRenamePageType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed Binder section.
#[derive(Debug)]
pub struct BinderRenameSectionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Title of the Binder doc.
    pub doc_title: String,
    /// Name of the Binder page/section.
    pub binder_item_name: String,
    /// Previous name of the Binder page/section.
    pub previous_binder_item_name: Option<String>,
}

impl BinderRenameSectionDetails {
    pub fn new(event_uuid: String, doc_title: String, binder_item_name: String) -> Self {
        BinderRenameSectionDetails {
            event_uuid,
            doc_title,
            binder_item_name,
            previous_binder_item_name: None,
        }
    }

    pub fn with_previous_binder_item_name(mut self, value: Option<String>) -> Self {
        self.previous_binder_item_name = value;
        self
    }

}

const BINDER_RENAME_SECTION_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                        "doc_title",
                                                        "binder_item_name",
                                                        "previous_binder_item_name"];
impl BinderRenameSectionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderRenameSectionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderRenameSectionDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_doc_title = None;
        let mut field_binder_item_name = None;
        let mut field_previous_binder_item_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                "binder_item_name" => {
                    if field_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("binder_item_name"));
                    }
                    field_binder_item_name = Some(map.next_value()?);
                }
                "previous_binder_item_name" => {
                    if field_previous_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_binder_item_name"));
                    }
                    field_previous_binder_item_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderRenameSectionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            doc_title: field_doc_title.ok_or_else(|| ::serde::de::Error::missing_field("doc_title"))?,
            binder_item_name: field_binder_item_name.ok_or_else(|| ::serde::de::Error::missing_field("binder_item_name"))?,
            previous_binder_item_name: field_previous_binder_item_name,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("doc_title", &self.doc_title)?;
        s.serialize_field("binder_item_name", &self.binder_item_name)?;
        s.serialize_field("previous_binder_item_name", &self.previous_binder_item_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderRenameSectionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderRenameSectionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderRenameSectionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderRenameSectionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderRenameSectionDetails", BINDER_RENAME_SECTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderRenameSectionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderRenameSectionDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct BinderRenameSectionType {
    pub description: String,
}

impl BinderRenameSectionType {
    pub fn new(description: String) -> Self {
        BinderRenameSectionType {
            description,
        }
    }

}

const BINDER_RENAME_SECTION_TYPE_FIELDS: &[&str] = &["description"];
impl BinderRenameSectionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderRenameSectionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderRenameSectionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderRenameSectionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderRenameSectionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderRenameSectionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderRenameSectionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderRenameSectionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderRenameSectionType", BINDER_RENAME_SECTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderRenameSectionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderRenameSectionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reordered Binder page.
#[derive(Debug)]
pub struct BinderReorderPageDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Title of the Binder doc.
    pub doc_title: String,
    /// Name of the Binder page/section.
    pub binder_item_name: String,
}

impl BinderReorderPageDetails {
    pub fn new(event_uuid: String, doc_title: String, binder_item_name: String) -> Self {
        BinderReorderPageDetails {
            event_uuid,
            doc_title,
            binder_item_name,
        }
    }

}

const BINDER_REORDER_PAGE_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                      "doc_title",
                                                      "binder_item_name"];
impl BinderReorderPageDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderReorderPageDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderReorderPageDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_doc_title = None;
        let mut field_binder_item_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                "binder_item_name" => {
                    if field_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("binder_item_name"));
                    }
                    field_binder_item_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderReorderPageDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            doc_title: field_doc_title.ok_or_else(|| ::serde::de::Error::missing_field("doc_title"))?,
            binder_item_name: field_binder_item_name.ok_or_else(|| ::serde::de::Error::missing_field("binder_item_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("doc_title", &self.doc_title)?;
        s.serialize_field("binder_item_name", &self.binder_item_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderReorderPageDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderReorderPageDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderReorderPageDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderReorderPageDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderReorderPageDetails", BINDER_REORDER_PAGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderReorderPageDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderReorderPageDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct BinderReorderPageType {
    pub description: String,
}

impl BinderReorderPageType {
    pub fn new(description: String) -> Self {
        BinderReorderPageType {
            description,
        }
    }

}

const BINDER_REORDER_PAGE_TYPE_FIELDS: &[&str] = &["description"];
impl BinderReorderPageType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderReorderPageType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderReorderPageType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderReorderPageType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderReorderPageType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderReorderPageType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderReorderPageType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderReorderPageType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderReorderPageType", BINDER_REORDER_PAGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderReorderPageType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderReorderPageType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reordered Binder section.
#[derive(Debug)]
pub struct BinderReorderSectionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Title of the Binder doc.
    pub doc_title: String,
    /// Name of the Binder page/section.
    pub binder_item_name: String,
}

impl BinderReorderSectionDetails {
    pub fn new(event_uuid: String, doc_title: String, binder_item_name: String) -> Self {
        BinderReorderSectionDetails {
            event_uuid,
            doc_title,
            binder_item_name,
        }
    }

}

const BINDER_REORDER_SECTION_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                         "doc_title",
                                                         "binder_item_name"];
impl BinderReorderSectionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderReorderSectionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderReorderSectionDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_doc_title = None;
        let mut field_binder_item_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                "binder_item_name" => {
                    if field_binder_item_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("binder_item_name"));
                    }
                    field_binder_item_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderReorderSectionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            doc_title: field_doc_title.ok_or_else(|| ::serde::de::Error::missing_field("doc_title"))?,
            binder_item_name: field_binder_item_name.ok_or_else(|| ::serde::de::Error::missing_field("binder_item_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("doc_title", &self.doc_title)?;
        s.serialize_field("binder_item_name", &self.binder_item_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderReorderSectionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderReorderSectionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderReorderSectionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderReorderSectionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderReorderSectionDetails", BINDER_REORDER_SECTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderReorderSectionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderReorderSectionDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct BinderReorderSectionType {
    pub description: String,
}

impl BinderReorderSectionType {
    pub fn new(description: String) -> Self {
        BinderReorderSectionType {
            description,
        }
    }

}

const BINDER_REORDER_SECTION_TYPE_FIELDS: &[&str] = &["description"];
impl BinderReorderSectionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BinderReorderSectionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BinderReorderSectionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BinderReorderSectionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BinderReorderSectionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BinderReorderSectionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BinderReorderSectionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BinderReorderSectionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BinderReorderSectionType", BINDER_REORDER_SECTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BinderReorderSectionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BinderReorderSectionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if team members can activate camera uploads
#[derive(Debug)]
pub enum CameraUploadsPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for CameraUploadsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = CameraUploadsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CameraUploadsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(CameraUploadsPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(CameraUploadsPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(CameraUploadsPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("CameraUploadsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for CameraUploadsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            CameraUploadsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("CameraUploadsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            CameraUploadsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("CameraUploadsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            CameraUploadsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed camera uploads setting for team.
#[derive(Debug)]
pub struct CameraUploadsPolicyChangedDetails {
    /// New camera uploads setting.
    pub new_value: CameraUploadsPolicy,
    /// Previous camera uploads setting.
    pub previous_value: CameraUploadsPolicy,
}

impl CameraUploadsPolicyChangedDetails {
    pub fn new(new_value: CameraUploadsPolicy, previous_value: CameraUploadsPolicy) -> Self {
        CameraUploadsPolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const CAMERA_UPLOADS_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl CameraUploadsPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<CameraUploadsPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<CameraUploadsPolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = CameraUploadsPolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CameraUploadsPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CameraUploadsPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CameraUploadsPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CameraUploadsPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CameraUploadsPolicyChangedDetails", CAMERA_UPLOADS_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CameraUploadsPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CameraUploadsPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct CameraUploadsPolicyChangedType {
    pub description: String,
}

impl CameraUploadsPolicyChangedType {
    pub fn new(description: String) -> Self {
        CameraUploadsPolicyChangedType {
            description,
        }
    }

}

const CAMERA_UPLOADS_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl CameraUploadsPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<CameraUploadsPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<CameraUploadsPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = CameraUploadsPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CameraUploadsPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CameraUploadsPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CameraUploadsPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CameraUploadsPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CameraUploadsPolicyChangedType", CAMERA_UPLOADS_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CameraUploadsPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CameraUploadsPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Certificate details.
#[derive(Debug)]
pub struct Certificate {
    /// Certificate subject.
    pub subject: String,
    /// Certificate issuer.
    pub issuer: String,
    /// Certificate issue date.
    pub issue_date: String,
    /// Certificate expiration date.
    pub expiration_date: String,
    /// Certificate serial number.
    pub serial_number: String,
    /// Certificate sha1 fingerprint.
    pub sha1_fingerprint: String,
    /// Certificate common name.
    pub common_name: Option<String>,
}

impl Certificate {
    pub fn new(
        subject: String,
        issuer: String,
        issue_date: String,
        expiration_date: String,
        serial_number: String,
        sha1_fingerprint: String,
    ) -> Self {
        Certificate {
            subject,
            issuer,
            issue_date,
            expiration_date,
            serial_number,
            sha1_fingerprint,
            common_name: None,
        }
    }

    pub fn with_common_name(mut self, value: Option<String>) -> Self {
        self.common_name = value;
        self
    }

}

const CERTIFICATE_FIELDS: &[&str] = &["subject",
                                      "issuer",
                                      "issue_date",
                                      "expiration_date",
                                      "serial_number",
                                      "sha1_fingerprint",
                                      "common_name"];
impl Certificate {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<Certificate, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<Certificate>, V::Error> {
        let mut field_subject = None;
        let mut field_issuer = None;
        let mut field_issue_date = None;
        let mut field_expiration_date = None;
        let mut field_serial_number = None;
        let mut field_sha1_fingerprint = None;
        let mut field_common_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "subject" => {
                    if field_subject.is_some() {
                        return Err(::serde::de::Error::duplicate_field("subject"));
                    }
                    field_subject = Some(map.next_value()?);
                }
                "issuer" => {
                    if field_issuer.is_some() {
                        return Err(::serde::de::Error::duplicate_field("issuer"));
                    }
                    field_issuer = Some(map.next_value()?);
                }
                "issue_date" => {
                    if field_issue_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("issue_date"));
                    }
                    field_issue_date = Some(map.next_value()?);
                }
                "expiration_date" => {
                    if field_expiration_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("expiration_date"));
                    }
                    field_expiration_date = Some(map.next_value()?);
                }
                "serial_number" => {
                    if field_serial_number.is_some() {
                        return Err(::serde::de::Error::duplicate_field("serial_number"));
                    }
                    field_serial_number = Some(map.next_value()?);
                }
                "sha1_fingerprint" => {
                    if field_sha1_fingerprint.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sha1_fingerprint"));
                    }
                    field_sha1_fingerprint = Some(map.next_value()?);
                }
                "common_name" => {
                    if field_common_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("common_name"));
                    }
                    field_common_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = Certificate {
            subject: field_subject.ok_or_else(|| ::serde::de::Error::missing_field("subject"))?,
            issuer: field_issuer.ok_or_else(|| ::serde::de::Error::missing_field("issuer"))?,
            issue_date: field_issue_date.ok_or_else(|| ::serde::de::Error::missing_field("issue_date"))?,
            expiration_date: field_expiration_date.ok_or_else(|| ::serde::de::Error::missing_field("expiration_date"))?,
            serial_number: field_serial_number.ok_or_else(|| ::serde::de::Error::missing_field("serial_number"))?,
            sha1_fingerprint: field_sha1_fingerprint.ok_or_else(|| ::serde::de::Error::missing_field("sha1_fingerprint"))?,
            common_name: field_common_name,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("subject", &self.subject)?;
        s.serialize_field("issuer", &self.issuer)?;
        s.serialize_field("issue_date", &self.issue_date)?;
        s.serialize_field("expiration_date", &self.expiration_date)?;
        s.serialize_field("serial_number", &self.serial_number)?;
        s.serialize_field("sha1_fingerprint", &self.sha1_fingerprint)?;
        s.serialize_field("common_name", &self.common_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for Certificate {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = Certificate;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a Certificate struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                Certificate::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("Certificate", CERTIFICATE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for Certificate {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("Certificate", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed enterprise admin role.
#[derive(Debug)]
pub struct ChangedEnterpriseAdminRoleDetails {
    /// The member&#x2019s previous enterprise admin role.
    pub previous_value: FedAdminRole,
    /// The member&#x2019s new enterprise admin role.
    pub new_value: FedAdminRole,
    /// The name of the member&#x2019s team.
    pub team_name: String,
}

impl ChangedEnterpriseAdminRoleDetails {
    pub fn new(previous_value: FedAdminRole, new_value: FedAdminRole, team_name: String) -> Self {
        ChangedEnterpriseAdminRoleDetails {
            previous_value,
            new_value,
            team_name,
        }
    }

}

const CHANGED_ENTERPRISE_ADMIN_ROLE_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                "new_value",
                                                                "team_name"];
impl ChangedEnterpriseAdminRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ChangedEnterpriseAdminRoleDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ChangedEnterpriseAdminRoleDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut field_team_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ChangedEnterpriseAdminRoleDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            team_name: field_team_name.ok_or_else(|| ::serde::de::Error::missing_field("team_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("team_name", &self.team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ChangedEnterpriseAdminRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ChangedEnterpriseAdminRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ChangedEnterpriseAdminRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ChangedEnterpriseAdminRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ChangedEnterpriseAdminRoleDetails", CHANGED_ENTERPRISE_ADMIN_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ChangedEnterpriseAdminRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ChangedEnterpriseAdminRoleDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ChangedEnterpriseAdminRoleType {
    pub description: String,
}

impl ChangedEnterpriseAdminRoleType {
    pub fn new(description: String) -> Self {
        ChangedEnterpriseAdminRoleType {
            description,
        }
    }

}

const CHANGED_ENTERPRISE_ADMIN_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl ChangedEnterpriseAdminRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ChangedEnterpriseAdminRoleType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ChangedEnterpriseAdminRoleType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ChangedEnterpriseAdminRoleType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ChangedEnterpriseAdminRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ChangedEnterpriseAdminRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ChangedEnterpriseAdminRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ChangedEnterpriseAdminRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ChangedEnterpriseAdminRoleType", CHANGED_ENTERPRISE_ADMIN_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ChangedEnterpriseAdminRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ChangedEnterpriseAdminRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed enterprise-connected team status.
#[derive(Debug)]
pub struct ChangedEnterpriseConnectedTeamStatusDetails {
    /// The preformed change in the team&#x2019s connection status.
    pub action: FedHandshakeAction,
    /// Additional information about the organization or team.
    pub additional_info: FederationStatusChangeAdditionalInfo,
    /// Previous request state.
    pub previous_value: TrustedTeamsRequestState,
    /// New request state.
    pub new_value: TrustedTeamsRequestState,
}

impl ChangedEnterpriseConnectedTeamStatusDetails {
    pub fn new(
        action: FedHandshakeAction,
        additional_info: FederationStatusChangeAdditionalInfo,
        previous_value: TrustedTeamsRequestState,
        new_value: TrustedTeamsRequestState,
    ) -> Self {
        ChangedEnterpriseConnectedTeamStatusDetails {
            action,
            additional_info,
            previous_value,
            new_value,
        }
    }

}

const CHANGED_ENTERPRISE_CONNECTED_TEAM_STATUS_DETAILS_FIELDS: &[&str] = &["action",
                                                                           "additional_info",
                                                                           "previous_value",
                                                                           "new_value"];
impl ChangedEnterpriseConnectedTeamStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ChangedEnterpriseConnectedTeamStatusDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ChangedEnterpriseConnectedTeamStatusDetails>, V::Error> {
        let mut field_action = None;
        let mut field_additional_info = None;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "action" => {
                    if field_action.is_some() {
                        return Err(::serde::de::Error::duplicate_field("action"));
                    }
                    field_action = Some(map.next_value()?);
                }
                "additional_info" => {
                    if field_additional_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("additional_info"));
                    }
                    field_additional_info = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ChangedEnterpriseConnectedTeamStatusDetails {
            action: field_action.ok_or_else(|| ::serde::de::Error::missing_field("action"))?,
            additional_info: field_additional_info.ok_or_else(|| ::serde::de::Error::missing_field("additional_info"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("action", &self.action)?;
        s.serialize_field("additional_info", &self.additional_info)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ChangedEnterpriseConnectedTeamStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ChangedEnterpriseConnectedTeamStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ChangedEnterpriseConnectedTeamStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ChangedEnterpriseConnectedTeamStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ChangedEnterpriseConnectedTeamStatusDetails", CHANGED_ENTERPRISE_CONNECTED_TEAM_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ChangedEnterpriseConnectedTeamStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ChangedEnterpriseConnectedTeamStatusDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ChangedEnterpriseConnectedTeamStatusType {
    pub description: String,
}

impl ChangedEnterpriseConnectedTeamStatusType {
    pub fn new(description: String) -> Self {
        ChangedEnterpriseConnectedTeamStatusType {
            description,
        }
    }

}

const CHANGED_ENTERPRISE_CONNECTED_TEAM_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl ChangedEnterpriseConnectedTeamStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ChangedEnterpriseConnectedTeamStatusType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ChangedEnterpriseConnectedTeamStatusType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ChangedEnterpriseConnectedTeamStatusType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ChangedEnterpriseConnectedTeamStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ChangedEnterpriseConnectedTeamStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ChangedEnterpriseConnectedTeamStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ChangedEnterpriseConnectedTeamStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ChangedEnterpriseConnectedTeamStatusType", CHANGED_ENTERPRISE_CONNECTED_TEAM_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ChangedEnterpriseConnectedTeamStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ChangedEnterpriseConnectedTeamStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared album.
#[derive(Debug)]
pub struct CollectionShareDetails {
    /// Album name.
    pub album_name: String,
}

impl CollectionShareDetails {
    pub fn new(album_name: String) -> Self {
        CollectionShareDetails {
            album_name,
        }
    }

}

const COLLECTION_SHARE_DETAILS_FIELDS: &[&str] = &["album_name"];
impl CollectionShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<CollectionShareDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<CollectionShareDetails>, V::Error> {
        let mut field_album_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "album_name" => {
                    if field_album_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("album_name"));
                    }
                    field_album_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = CollectionShareDetails {
            album_name: field_album_name.ok_or_else(|| ::serde::de::Error::missing_field("album_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("album_name", &self.album_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CollectionShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CollectionShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CollectionShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CollectionShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CollectionShareDetails", COLLECTION_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CollectionShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CollectionShareDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct CollectionShareType {
    pub description: String,
}

impl CollectionShareType {
    pub fn new(description: String) -> Self {
        CollectionShareType {
            description,
        }
    }

}

const COLLECTION_SHARE_TYPE_FIELDS: &[&str] = &["description"];
impl CollectionShareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<CollectionShareType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<CollectionShareType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = CollectionShareType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CollectionShareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CollectionShareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CollectionShareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CollectionShareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CollectionShareType", COLLECTION_SHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CollectionShareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CollectionShareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The name of the team
#[derive(Debug)]
pub struct ConnectedTeamName {
    /// The name of the team.
    pub team: String,
}

impl ConnectedTeamName {
    pub fn new(team: String) -> Self {
        ConnectedTeamName {
            team,
        }
    }

}

const CONNECTED_TEAM_NAME_FIELDS: &[&str] = &["team"];
impl ConnectedTeamName {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ConnectedTeamName, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ConnectedTeamName>, V::Error> {
        let mut field_team = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "team" => {
                    if field_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team"));
                    }
                    field_team = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ConnectedTeamName {
            team: field_team.ok_or_else(|| ::serde::de::Error::missing_field("team"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team", &self.team)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ConnectedTeamName {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ConnectedTeamName;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ConnectedTeamName struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ConnectedTeamName::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ConnectedTeamName", CONNECTED_TEAM_NAME_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ConnectedTeamName {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ConnectedTeamName", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for pemanent content deletion
#[derive(Debug)]
pub enum ContentPermanentDeletePolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ContentPermanentDeletePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ContentPermanentDeletePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ContentPermanentDeletePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ContentPermanentDeletePolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ContentPermanentDeletePolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ContentPermanentDeletePolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("ContentPermanentDeletePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ContentPermanentDeletePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ContentPermanentDeletePolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("ContentPermanentDeletePolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            ContentPermanentDeletePolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("ContentPermanentDeletePolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            ContentPermanentDeletePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The primary entity on which the action was done.
#[derive(Debug)]
pub enum ContextLogInfo {
    /// Action was done on behalf of a team member.
    TeamMember(TeamMemberLogInfo),
    /// Action was done on behalf of a non team member.
    NonTeamMember(NonTeamMemberLogInfo),
    /// Anonymous context.
    Anonymous,
    /// Action was done on behalf of the team.
    Team,
    /// Action was done on behalf of a team that's part of an organization.
    OrganizationTeam(TeamLogInfo),
    /// Action was done on behalf of a trusted non team member.
    TrustedNonTeamMember(TrustedNonTeamMemberLogInfo),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ContextLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ContextLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ContextLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_member" => Ok(ContextLogInfo::TeamMember(TeamMemberLogInfo::internal_deserialize(map)?)),
                    "non_team_member" => Ok(ContextLogInfo::NonTeamMember(NonTeamMemberLogInfo::internal_deserialize(map)?)),
                    "anonymous" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ContextLogInfo::Anonymous)
                    }
                    "team" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ContextLogInfo::Team)
                    }
                    "organization_team" => Ok(ContextLogInfo::OrganizationTeam(TeamLogInfo::internal_deserialize(map)?)),
                    "trusted_non_team_member" => Ok(ContextLogInfo::TrustedNonTeamMember(TrustedNonTeamMemberLogInfo::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ContextLogInfo::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["team_member",
                                    "non_team_member",
                                    "anonymous",
                                    "team",
                                    "organization_team",
                                    "trusted_non_team_member",
                                    "other"];
        deserializer.deserialize_struct("ContextLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ContextLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ContextLogInfo::TeamMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ContextLogInfo", 7)?;
                s.serialize_field(".tag", "team_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ContextLogInfo::NonTeamMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ContextLogInfo", 4)?;
                s.serialize_field(".tag", "non_team_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ContextLogInfo::Anonymous => {
                // unit
                let mut s = serializer.serialize_struct("ContextLogInfo", 1)?;
                s.serialize_field(".tag", "anonymous")?;
                s.end()
            }
            ContextLogInfo::Team => {
                // unit
                let mut s = serializer.serialize_struct("ContextLogInfo", 1)?;
                s.serialize_field(".tag", "team")?;
                s.end()
            }
            ContextLogInfo::OrganizationTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ContextLogInfo", 2)?;
                s.serialize_field(".tag", "organization_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ContextLogInfo::TrustedNonTeamMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ContextLogInfo", 6)?;
                s.serialize_field(".tag", "trusted_non_team_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ContextLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Created folders.
#[derive(Debug)]
pub struct CreateFolderDetails {
}

impl Default for CreateFolderDetails {
    fn default() -> Self {
        CreateFolderDetails {
        }
    }
}

const CREATE_FOLDER_DETAILS_FIELDS: &[&str] = &[];
impl CreateFolderDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<CreateFolderDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(CreateFolderDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CreateFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateFolderDetails", CREATE_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("CreateFolderDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct CreateFolderType {
    pub description: String,
}

impl CreateFolderType {
    pub fn new(description: String) -> Self {
        CreateFolderType {
            description,
        }
    }

}

const CREATE_FOLDER_TYPE_FIELDS: &[&str] = &["description"];
impl CreateFolderType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<CreateFolderType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<CreateFolderType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = CreateFolderType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateFolderType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateFolderType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CreateFolderType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateFolderType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateFolderType", CREATE_FOLDER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateFolderType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CreateFolderType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created team invite link.
#[derive(Debug)]
pub struct CreateTeamInviteLinkDetails {
    /// The invite link url that was created.
    pub link_url: String,
    /// The expiration date of the invite link.
    pub expiry_date: String,
}

impl CreateTeamInviteLinkDetails {
    pub fn new(link_url: String, expiry_date: String) -> Self {
        CreateTeamInviteLinkDetails {
            link_url,
            expiry_date,
        }
    }

}

const CREATE_TEAM_INVITE_LINK_DETAILS_FIELDS: &[&str] = &["link_url",
                                                          "expiry_date"];
impl CreateTeamInviteLinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<CreateTeamInviteLinkDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<CreateTeamInviteLinkDetails>, V::Error> {
        let mut field_link_url = None;
        let mut field_expiry_date = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "link_url" => {
                    if field_link_url.is_some() {
                        return Err(::serde::de::Error::duplicate_field("link_url"));
                    }
                    field_link_url = Some(map.next_value()?);
                }
                "expiry_date" => {
                    if field_expiry_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("expiry_date"));
                    }
                    field_expiry_date = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = CreateTeamInviteLinkDetails {
            link_url: field_link_url.ok_or_else(|| ::serde::de::Error::missing_field("link_url"))?,
            expiry_date: field_expiry_date.ok_or_else(|| ::serde::de::Error::missing_field("expiry_date"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("link_url", &self.link_url)?;
        s.serialize_field("expiry_date", &self.expiry_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateTeamInviteLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateTeamInviteLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CreateTeamInviteLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateTeamInviteLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateTeamInviteLinkDetails", CREATE_TEAM_INVITE_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateTeamInviteLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CreateTeamInviteLinkDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct CreateTeamInviteLinkType {
    pub description: String,
}

impl CreateTeamInviteLinkType {
    pub fn new(description: String) -> Self {
        CreateTeamInviteLinkType {
            description,
        }
    }

}

const CREATE_TEAM_INVITE_LINK_TYPE_FIELDS: &[&str] = &["description"];
impl CreateTeamInviteLinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<CreateTeamInviteLinkType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<CreateTeamInviteLinkType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = CreateTeamInviteLinkType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CreateTeamInviteLinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CreateTeamInviteLinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CreateTeamInviteLinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CreateTeamInviteLinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CreateTeamInviteLinkType", CREATE_TEAM_INVITE_LINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CreateTeamInviteLinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CreateTeamInviteLinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set restrictions on data center locations where team data resides.
#[derive(Debug)]
pub struct DataPlacementRestrictionChangePolicyDetails {
    /// Previous placement restriction.
    pub previous_value: PlacementRestriction,
    /// New placement restriction.
    pub new_value: PlacementRestriction,
}

impl DataPlacementRestrictionChangePolicyDetails {
    pub fn new(previous_value: PlacementRestriction, new_value: PlacementRestriction) -> Self {
        DataPlacementRestrictionChangePolicyDetails {
            previous_value,
            new_value,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                           "new_value"];
impl DataPlacementRestrictionChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DataPlacementRestrictionChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DataPlacementRestrictionChangePolicyDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DataPlacementRestrictionChangePolicyDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionChangePolicyDetails", DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DataPlacementRestrictionChangePolicyType {
    pub description: String,
}

impl DataPlacementRestrictionChangePolicyType {
    pub fn new(description: String) -> Self {
        DataPlacementRestrictionChangePolicyType {
            description,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl DataPlacementRestrictionChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DataPlacementRestrictionChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DataPlacementRestrictionChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DataPlacementRestrictionChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionChangePolicyType", DATA_PLACEMENT_RESTRICTION_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Completed restrictions on data center locations where team data resides.
#[derive(Debug)]
pub struct DataPlacementRestrictionSatisfyPolicyDetails {
    /// Placement restriction.
    pub placement_restriction: PlacementRestriction,
}

impl DataPlacementRestrictionSatisfyPolicyDetails {
    pub fn new(placement_restriction: PlacementRestriction) -> Self {
        DataPlacementRestrictionSatisfyPolicyDetails {
            placement_restriction,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_DETAILS_FIELDS: &[&str] = &["placement_restriction"];
impl DataPlacementRestrictionSatisfyPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DataPlacementRestrictionSatisfyPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DataPlacementRestrictionSatisfyPolicyDetails>, V::Error> {
        let mut field_placement_restriction = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "placement_restriction" => {
                    if field_placement_restriction.is_some() {
                        return Err(::serde::de::Error::duplicate_field("placement_restriction"));
                    }
                    field_placement_restriction = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DataPlacementRestrictionSatisfyPolicyDetails {
            placement_restriction: field_placement_restriction.ok_or_else(|| ::serde::de::Error::missing_field("placement_restriction"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("placement_restriction", &self.placement_restriction)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionSatisfyPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionSatisfyPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionSatisfyPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionSatisfyPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionSatisfyPolicyDetails", DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionSatisfyPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionSatisfyPolicyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DataPlacementRestrictionSatisfyPolicyType {
    pub description: String,
}

impl DataPlacementRestrictionSatisfyPolicyType {
    pub fn new(description: String) -> Self {
        DataPlacementRestrictionSatisfyPolicyType {
            description,
        }
    }

}

const DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl DataPlacementRestrictionSatisfyPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DataPlacementRestrictionSatisfyPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DataPlacementRestrictionSatisfyPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DataPlacementRestrictionSatisfyPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DataPlacementRestrictionSatisfyPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DataPlacementRestrictionSatisfyPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DataPlacementRestrictionSatisfyPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DataPlacementRestrictionSatisfyPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DataPlacementRestrictionSatisfyPolicyType", DATA_PLACEMENT_RESTRICTION_SATISFY_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DataPlacementRestrictionSatisfyPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DataPlacementRestrictionSatisfyPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted team invite link.
#[derive(Debug)]
pub struct DeleteTeamInviteLinkDetails {
    /// The invite link url that was deleted.
    pub link_url: String,
}

impl DeleteTeamInviteLinkDetails {
    pub fn new(link_url: String) -> Self {
        DeleteTeamInviteLinkDetails {
            link_url,
        }
    }

}

const DELETE_TEAM_INVITE_LINK_DETAILS_FIELDS: &[&str] = &["link_url"];
impl DeleteTeamInviteLinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeleteTeamInviteLinkDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeleteTeamInviteLinkDetails>, V::Error> {
        let mut field_link_url = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "link_url" => {
                    if field_link_url.is_some() {
                        return Err(::serde::de::Error::duplicate_field("link_url"));
                    }
                    field_link_url = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeleteTeamInviteLinkDetails {
            link_url: field_link_url.ok_or_else(|| ::serde::de::Error::missing_field("link_url"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("link_url", &self.link_url)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeleteTeamInviteLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeleteTeamInviteLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeleteTeamInviteLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeleteTeamInviteLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeleteTeamInviteLinkDetails", DELETE_TEAM_INVITE_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeleteTeamInviteLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeleteTeamInviteLinkDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeleteTeamInviteLinkType {
    pub description: String,
}

impl DeleteTeamInviteLinkType {
    pub fn new(description: String) -> Self {
        DeleteTeamInviteLinkType {
            description,
        }
    }

}

const DELETE_TEAM_INVITE_LINK_TYPE_FIELDS: &[&str] = &["description"];
impl DeleteTeamInviteLinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeleteTeamInviteLinkType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeleteTeamInviteLinkType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeleteTeamInviteLinkType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeleteTeamInviteLinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeleteTeamInviteLinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeleteTeamInviteLinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeleteTeamInviteLinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeleteTeamInviteLinkType", DELETE_TEAM_INVITE_LINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeleteTeamInviteLinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeleteTeamInviteLinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information about linked Dropbox desktop client sessions
#[derive(Debug)]
pub struct DesktopDeviceSessionLogInfo {
    /// Name of the hosting desktop.
    pub host_name: String,
    /// The Dropbox desktop client type.
    pub client_type: super::team::DesktopPlatform,
    /// Information on the hosting platform.
    pub platform: String,
    /// Whether itu2019s possible to delete all of the account files upon unlinking.
    pub is_delete_on_unlink_supported: bool,
    /// The IP address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub ip_address: Option<IpAddress>,
    /// The time this session was created. Might be missing due to historical data gap.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session. Might be missing due to historical data
    /// gap.
    pub updated: Option<super::common::DropboxTimestamp>,
    /// Desktop session unique id. Might be missing due to historical data gap.
    pub session_info: Option<DesktopSessionLogInfo>,
    /// The Dropbox client version.
    pub client_version: Option<String>,
}

impl DesktopDeviceSessionLogInfo {
    pub fn new(
        host_name: String,
        client_type: super::team::DesktopPlatform,
        platform: String,
        is_delete_on_unlink_supported: bool,
    ) -> Self {
        DesktopDeviceSessionLogInfo {
            host_name,
            client_type,
            platform,
            is_delete_on_unlink_supported,
            ip_address: None,
            created: None,
            updated: None,
            session_info: None,
            client_version: None,
        }
    }

    pub fn with_ip_address(mut self, value: Option<IpAddress>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

    pub fn with_session_info(mut self, value: Option<DesktopSessionLogInfo>) -> Self {
        self.session_info = value;
        self
    }

    pub fn with_client_version(mut self, value: Option<String>) -> Self {
        self.client_version = value;
        self
    }

}

const DESKTOP_DEVICE_SESSION_LOG_INFO_FIELDS: &[&str] = &["host_name",
                                                          "client_type",
                                                          "platform",
                                                          "is_delete_on_unlink_supported",
                                                          "ip_address",
                                                          "created",
                                                          "updated",
                                                          "session_info",
                                                          "client_version"];
impl DesktopDeviceSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DesktopDeviceSessionLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DesktopDeviceSessionLogInfo>, V::Error> {
        let mut field_host_name = None;
        let mut field_client_type = None;
        let mut field_platform = None;
        let mut field_is_delete_on_unlink_supported = None;
        let mut field_ip_address = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut field_session_info = None;
        let mut field_client_version = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "host_name" => {
                    if field_host_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("host_name"));
                    }
                    field_host_name = Some(map.next_value()?);
                }
                "client_type" => {
                    if field_client_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("client_type"));
                    }
                    field_client_type = Some(map.next_value()?);
                }
                "platform" => {
                    if field_platform.is_some() {
                        return Err(::serde::de::Error::duplicate_field("platform"));
                    }
                    field_platform = Some(map.next_value()?);
                }
                "is_delete_on_unlink_supported" => {
                    if field_is_delete_on_unlink_supported.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_delete_on_unlink_supported"));
                    }
                    field_is_delete_on_unlink_supported = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(::serde::de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(::serde::de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(::serde::de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                "session_info" => {
                    if field_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_info"));
                    }
                    field_session_info = Some(map.next_value()?);
                }
                "client_version" => {
                    if field_client_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("client_version"));
                    }
                    field_client_version = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DesktopDeviceSessionLogInfo {
            host_name: field_host_name.ok_or_else(|| ::serde::de::Error::missing_field("host_name"))?,
            client_type: field_client_type.ok_or_else(|| ::serde::de::Error::missing_field("client_type"))?,
            platform: field_platform.ok_or_else(|| ::serde::de::Error::missing_field("platform"))?,
            is_delete_on_unlink_supported: field_is_delete_on_unlink_supported.ok_or_else(|| ::serde::de::Error::missing_field("is_delete_on_unlink_supported"))?,
            ip_address: field_ip_address,
            created: field_created,
            updated: field_updated,
            session_info: field_session_info,
            client_version: field_client_version,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("host_name", &self.host_name)?;
        s.serialize_field("client_type", &self.client_type)?;
        s.serialize_field("platform", &self.platform)?;
        s.serialize_field("is_delete_on_unlink_supported", &self.is_delete_on_unlink_supported)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)?;
        s.serialize_field("session_info", &self.session_info)?;
        s.serialize_field("client_version", &self.client_version)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DesktopDeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DesktopDeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DesktopDeviceSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DesktopDeviceSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DesktopDeviceSessionLogInfo", DESKTOP_DEVICE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DesktopDeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DesktopDeviceSessionLogInfo", 9)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Desktop session.
#[derive(Debug)]
pub struct DesktopSessionLogInfo {
    /// Session ID. Might be missing due to historical data gap.
    pub session_id: Option<super::common::SessionId>,
}

impl Default for DesktopSessionLogInfo {
    fn default() -> Self {
        DesktopSessionLogInfo {
            session_id: None,
        }
    }
}

const DESKTOP_SESSION_LOG_INFO_FIELDS: &[&str] = &["session_id"];
impl DesktopSessionLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DesktopSessionLogInfo, V::Error> {
        let mut field_session_id = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = DesktopSessionLogInfo {
            session_id: field_session_id,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DesktopSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DesktopSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DesktopSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DesktopSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DesktopSessionLogInfo", DESKTOP_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DesktopSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DesktopSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added members to device approvals exception list.
#[derive(Debug)]
pub struct DeviceApprovalsAddExceptionDetails {
}

impl Default for DeviceApprovalsAddExceptionDetails {
    fn default() -> Self {
        DeviceApprovalsAddExceptionDetails {
        }
    }
}

const DEVICE_APPROVALS_ADD_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl DeviceApprovalsAddExceptionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsAddExceptionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DeviceApprovalsAddExceptionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsAddExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsAddExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsAddExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsAddExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsAddExceptionDetails", DEVICE_APPROVALS_ADD_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsAddExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DeviceApprovalsAddExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsAddExceptionType {
    pub description: String,
}

impl DeviceApprovalsAddExceptionType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsAddExceptionType {
            description,
        }
    }

}

const DEVICE_APPROVALS_ADD_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsAddExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceApprovalsAddExceptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceApprovalsAddExceptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceApprovalsAddExceptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsAddExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsAddExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsAddExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsAddExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsAddExceptionType", DEVICE_APPROVALS_ADD_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsAddExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsAddExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set/removed limit on number of computers member can link to team Dropbox account.
#[derive(Debug)]
pub struct DeviceApprovalsChangeDesktopPolicyDetails {
    /// New desktop device approvals policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceApprovalsPolicy>,
    /// Previous desktop device approvals policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceApprovalsPolicy>,
}

impl Default for DeviceApprovalsChangeDesktopPolicyDetails {
    fn default() -> Self {
        DeviceApprovalsChangeDesktopPolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl DeviceApprovalsChangeDesktopPolicyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeDesktopPolicyDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = DeviceApprovalsChangeDesktopPolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeDesktopPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeDesktopPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeDesktopPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeDesktopPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeDesktopPolicyDetails", DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeDesktopPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeDesktopPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsChangeDesktopPolicyType {
    pub description: String,
}

impl DeviceApprovalsChangeDesktopPolicyType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsChangeDesktopPolicyType {
            description,
        }
    }

}

const DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsChangeDesktopPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceApprovalsChangeDesktopPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceApprovalsChangeDesktopPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceApprovalsChangeDesktopPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeDesktopPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeDesktopPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeDesktopPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeDesktopPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeDesktopPolicyType", DEVICE_APPROVALS_CHANGE_DESKTOP_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeDesktopPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeDesktopPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set/removed limit on number of mobile devices member can link to team Dropbox account.
#[derive(Debug)]
pub struct DeviceApprovalsChangeMobilePolicyDetails {
    /// New mobile device approvals policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceApprovalsPolicy>,
    /// Previous mobile device approvals policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceApprovalsPolicy>,
}

impl Default for DeviceApprovalsChangeMobilePolicyDetails {
    fn default() -> Self {
        DeviceApprovalsChangeMobilePolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                        "previous_value"];
impl DeviceApprovalsChangeMobilePolicyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeMobilePolicyDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = DeviceApprovalsChangeMobilePolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeMobilePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeMobilePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeMobilePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeMobilePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeMobilePolicyDetails", DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeMobilePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeMobilePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsChangeMobilePolicyType {
    pub description: String,
}

impl DeviceApprovalsChangeMobilePolicyType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsChangeMobilePolicyType {
            description,
        }
    }

}

const DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsChangeMobilePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceApprovalsChangeMobilePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceApprovalsChangeMobilePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceApprovalsChangeMobilePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeMobilePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeMobilePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeMobilePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeMobilePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeMobilePolicyType", DEVICE_APPROVALS_CHANGE_MOBILE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeMobilePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeMobilePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed device approvals setting when member is over limit.
#[derive(Debug)]
pub struct DeviceApprovalsChangeOverageActionDetails {
    /// New over the limits policy. Might be missing due to historical data gap.
    pub new_value: Option<super::team_policies::RolloutMethod>,
    /// Previous over the limit policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::RolloutMethod>,
}

impl Default for DeviceApprovalsChangeOverageActionDetails {
    fn default() -> Self {
        DeviceApprovalsChangeOverageActionDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl DeviceApprovalsChangeOverageActionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeOverageActionDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = DeviceApprovalsChangeOverageActionDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeOverageActionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeOverageActionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeOverageActionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeOverageActionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeOverageActionDetails", DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeOverageActionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeOverageActionDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsChangeOverageActionType {
    pub description: String,
}

impl DeviceApprovalsChangeOverageActionType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsChangeOverageActionType {
            description,
        }
    }

}

const DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsChangeOverageActionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceApprovalsChangeOverageActionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceApprovalsChangeOverageActionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceApprovalsChangeOverageActionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeOverageActionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeOverageActionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeOverageActionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeOverageActionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeOverageActionType", DEVICE_APPROVALS_CHANGE_OVERAGE_ACTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeOverageActionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeOverageActionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed device approvals setting when member unlinks approved device.
#[derive(Debug)]
pub struct DeviceApprovalsChangeUnlinkActionDetails {
    /// New device unlink policy. Might be missing due to historical data gap.
    pub new_value: Option<DeviceUnlinkPolicy>,
    /// Previous device unlink policy. Might be missing due to historical data gap.
    pub previous_value: Option<DeviceUnlinkPolicy>,
}

impl Default for DeviceApprovalsChangeUnlinkActionDetails {
    fn default() -> Self {
        DeviceApprovalsChangeUnlinkActionDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                        "previous_value"];
impl DeviceApprovalsChangeUnlinkActionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsChangeUnlinkActionDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = DeviceApprovalsChangeUnlinkActionDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeUnlinkActionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeUnlinkActionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeUnlinkActionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeUnlinkActionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeUnlinkActionDetails", DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeUnlinkActionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeUnlinkActionDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsChangeUnlinkActionType {
    pub description: String,
}

impl DeviceApprovalsChangeUnlinkActionType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsChangeUnlinkActionType {
            description,
        }
    }

}

const DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsChangeUnlinkActionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceApprovalsChangeUnlinkActionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceApprovalsChangeUnlinkActionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceApprovalsChangeUnlinkActionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsChangeUnlinkActionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsChangeUnlinkActionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsChangeUnlinkActionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsChangeUnlinkActionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsChangeUnlinkActionType", DEVICE_APPROVALS_CHANGE_UNLINK_ACTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsChangeUnlinkActionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsChangeUnlinkActionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum DeviceApprovalsPolicy {
    Unlimited,
    Limited,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceApprovalsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "unlimited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceApprovalsPolicy::Unlimited)
                    }
                    "limited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceApprovalsPolicy::Limited)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceApprovalsPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["unlimited",
                                    "limited",
                                    "other"];
        deserializer.deserialize_struct("DeviceApprovalsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceApprovalsPolicy::Unlimited => {
                // unit
                let mut s = serializer.serialize_struct("DeviceApprovalsPolicy", 1)?;
                s.serialize_field(".tag", "unlimited")?;
                s.end()
            }
            DeviceApprovalsPolicy::Limited => {
                // unit
                let mut s = serializer.serialize_struct("DeviceApprovalsPolicy", 1)?;
                s.serialize_field(".tag", "limited")?;
                s.end()
            }
            DeviceApprovalsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Removed members from device approvals exception list.
#[derive(Debug)]
pub struct DeviceApprovalsRemoveExceptionDetails {
}

impl Default for DeviceApprovalsRemoveExceptionDetails {
    fn default() -> Self {
        DeviceApprovalsRemoveExceptionDetails {
        }
    }
}

const DEVICE_APPROVALS_REMOVE_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl DeviceApprovalsRemoveExceptionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceApprovalsRemoveExceptionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DeviceApprovalsRemoveExceptionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsRemoveExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsRemoveExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsRemoveExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsRemoveExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsRemoveExceptionDetails", DEVICE_APPROVALS_REMOVE_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsRemoveExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DeviceApprovalsRemoveExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DeviceApprovalsRemoveExceptionType {
    pub description: String,
}

impl DeviceApprovalsRemoveExceptionType {
    pub fn new(description: String) -> Self {
        DeviceApprovalsRemoveExceptionType {
            description,
        }
    }

}

const DEVICE_APPROVALS_REMOVE_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceApprovalsRemoveExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceApprovalsRemoveExceptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceApprovalsRemoveExceptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceApprovalsRemoveExceptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceApprovalsRemoveExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceApprovalsRemoveExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceApprovalsRemoveExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceApprovalsRemoveExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceApprovalsRemoveExceptionType", DEVICE_APPROVALS_REMOVE_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceApprovalsRemoveExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceApprovalsRemoveExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed IP address associated with active desktop session.
#[derive(Debug)]
pub struct DeviceChangeIpDesktopDetails {
    /// Device's session logged information.
    pub device_session_info: DeviceSessionLogInfo,
}

impl DeviceChangeIpDesktopDetails {
    pub fn new(device_session_info: DeviceSessionLogInfo) -> Self {
        DeviceChangeIpDesktopDetails {
            device_session_info,
        }
    }

}

const DEVICE_CHANGE_IP_DESKTOP_DETAILS_FIELDS: &[&str] = &["device_session_info"];
impl DeviceChangeIpDesktopDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceChangeIpDesktopDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceChangeIpDesktopDetails>, V::Error> {
        let mut field_device_session_info = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "device_session_info" => {
                    if field_device_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("device_session_info"));
                    }
                    field_device_session_info = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceChangeIpDesktopDetails {
            device_session_info: field_device_session_info.ok_or_else(|| ::serde::de::Error::missing_field("device_session_info"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_session_info", &self.device_session_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpDesktopDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpDesktopDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpDesktopDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpDesktopDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpDesktopDetails", DEVICE_CHANGE_IP_DESKTOP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpDesktopDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpDesktopDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceChangeIpDesktopType {
    pub description: String,
}

impl DeviceChangeIpDesktopType {
    pub fn new(description: String) -> Self {
        DeviceChangeIpDesktopType {
            description,
        }
    }

}

const DEVICE_CHANGE_IP_DESKTOP_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceChangeIpDesktopType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceChangeIpDesktopType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceChangeIpDesktopType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceChangeIpDesktopType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpDesktopType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpDesktopType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpDesktopType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpDesktopType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpDesktopType", DEVICE_CHANGE_IP_DESKTOP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpDesktopType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpDesktopType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed IP address associated with active mobile session.
#[derive(Debug)]
pub struct DeviceChangeIpMobileDetails {
    /// Device's session logged information.
    pub device_session_info: Option<DeviceSessionLogInfo>,
}

impl Default for DeviceChangeIpMobileDetails {
    fn default() -> Self {
        DeviceChangeIpMobileDetails {
            device_session_info: None,
        }
    }
}

const DEVICE_CHANGE_IP_MOBILE_DETAILS_FIELDS: &[&str] = &["device_session_info"];
impl DeviceChangeIpMobileDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceChangeIpMobileDetails, V::Error> {
        let mut field_device_session_info = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "device_session_info" => {
                    if field_device_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("device_session_info"));
                    }
                    field_device_session_info = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = DeviceChangeIpMobileDetails {
            device_session_info: field_device_session_info,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_session_info", &self.device_session_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpMobileDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpMobileDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpMobileDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpMobileDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpMobileDetails", DEVICE_CHANGE_IP_MOBILE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpMobileDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpMobileDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceChangeIpMobileType {
    pub description: String,
}

impl DeviceChangeIpMobileType {
    pub fn new(description: String) -> Self {
        DeviceChangeIpMobileType {
            description,
        }
    }

}

const DEVICE_CHANGE_IP_MOBILE_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceChangeIpMobileType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceChangeIpMobileType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceChangeIpMobileType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceChangeIpMobileType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpMobileType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpMobileType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpMobileType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpMobileType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpMobileType", DEVICE_CHANGE_IP_MOBILE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpMobileType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpMobileType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed IP address associated with active web session.
#[derive(Debug)]
pub struct DeviceChangeIpWebDetails {
    /// Web browser name.
    pub user_agent: String,
}

impl DeviceChangeIpWebDetails {
    pub fn new(user_agent: String) -> Self {
        DeviceChangeIpWebDetails {
            user_agent,
        }
    }

}

const DEVICE_CHANGE_IP_WEB_DETAILS_FIELDS: &[&str] = &["user_agent"];
impl DeviceChangeIpWebDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceChangeIpWebDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceChangeIpWebDetails>, V::Error> {
        let mut field_user_agent = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "user_agent" => {
                    if field_user_agent.is_some() {
                        return Err(::serde::de::Error::duplicate_field("user_agent"));
                    }
                    field_user_agent = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceChangeIpWebDetails {
            user_agent: field_user_agent.ok_or_else(|| ::serde::de::Error::missing_field("user_agent"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_agent", &self.user_agent)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpWebDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpWebDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpWebDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpWebDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpWebDetails", DEVICE_CHANGE_IP_WEB_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpWebDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpWebDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceChangeIpWebType {
    pub description: String,
}

impl DeviceChangeIpWebType {
    pub fn new(description: String) -> Self {
        DeviceChangeIpWebType {
            description,
        }
    }

}

const DEVICE_CHANGE_IP_WEB_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceChangeIpWebType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceChangeIpWebType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceChangeIpWebType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceChangeIpWebType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceChangeIpWebType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceChangeIpWebType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceChangeIpWebType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceChangeIpWebType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceChangeIpWebType", DEVICE_CHANGE_IP_WEB_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceChangeIpWebType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceChangeIpWebType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to delete all files from unlinked device.
#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkFailDetails {
    /// The number of times that remote file deletion failed.
    pub num_failures: i64,
    /// Session unique id. Might be missing due to historical data gap.
    pub session_info: Option<SessionLogInfo>,
    /// The device name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl DeviceDeleteOnUnlinkFailDetails {
    pub fn new(num_failures: i64) -> Self {
        DeviceDeleteOnUnlinkFailDetails {
            num_failures,
            session_info: None,
            display_name: None,
        }
    }

    pub fn with_session_info(mut self, value: Option<SessionLogInfo>) -> Self {
        self.session_info = value;
        self
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

}

const DEVICE_DELETE_ON_UNLINK_FAIL_DETAILS_FIELDS: &[&str] = &["num_failures",
                                                               "session_info",
                                                               "display_name"];
impl DeviceDeleteOnUnlinkFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceDeleteOnUnlinkFailDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceDeleteOnUnlinkFailDetails>, V::Error> {
        let mut field_num_failures = None;
        let mut field_session_info = None;
        let mut field_display_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "num_failures" => {
                    if field_num_failures.is_some() {
                        return Err(::serde::de::Error::duplicate_field("num_failures"));
                    }
                    field_num_failures = Some(map.next_value()?);
                }
                "session_info" => {
                    if field_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_info"));
                    }
                    field_session_info = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceDeleteOnUnlinkFailDetails {
            num_failures: field_num_failures.ok_or_else(|| ::serde::de::Error::missing_field("num_failures"))?,
            session_info: field_session_info,
            display_name: field_display_name,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("num_failures", &self.num_failures)?;
        s.serialize_field("session_info", &self.session_info)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkFailDetails", DEVICE_DELETE_ON_UNLINK_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkFailDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkFailType {
    pub description: String,
}

impl DeviceDeleteOnUnlinkFailType {
    pub fn new(description: String) -> Self {
        DeviceDeleteOnUnlinkFailType {
            description,
        }
    }

}

const DEVICE_DELETE_ON_UNLINK_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceDeleteOnUnlinkFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceDeleteOnUnlinkFailType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceDeleteOnUnlinkFailType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceDeleteOnUnlinkFailType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkFailType", DEVICE_DELETE_ON_UNLINK_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted all files from unlinked device.
#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkSuccessDetails {
    /// Session unique id. Might be missing due to historical data gap.
    pub session_info: Option<SessionLogInfo>,
    /// The device name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for DeviceDeleteOnUnlinkSuccessDetails {
    fn default() -> Self {
        DeviceDeleteOnUnlinkSuccessDetails {
            session_info: None,
            display_name: None,
        }
    }
}

const DEVICE_DELETE_ON_UNLINK_SUCCESS_DETAILS_FIELDS: &[&str] = &["session_info",
                                                                  "display_name"];
impl DeviceDeleteOnUnlinkSuccessDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceDeleteOnUnlinkSuccessDetails, V::Error> {
        let mut field_session_info = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "session_info" => {
                    if field_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_info"));
                    }
                    field_session_info = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = DeviceDeleteOnUnlinkSuccessDetails {
            session_info: field_session_info,
            display_name: field_display_name,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_info", &self.session_info)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkSuccessDetails", DEVICE_DELETE_ON_UNLINK_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkSuccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceDeleteOnUnlinkSuccessType {
    pub description: String,
}

impl DeviceDeleteOnUnlinkSuccessType {
    pub fn new(description: String) -> Self {
        DeviceDeleteOnUnlinkSuccessType {
            description,
        }
    }

}

const DEVICE_DELETE_ON_UNLINK_SUCCESS_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceDeleteOnUnlinkSuccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceDeleteOnUnlinkSuccessType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceDeleteOnUnlinkSuccessType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceDeleteOnUnlinkSuccessType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceDeleteOnUnlinkSuccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceDeleteOnUnlinkSuccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceDeleteOnUnlinkSuccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceDeleteOnUnlinkSuccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceDeleteOnUnlinkSuccessType", DEVICE_DELETE_ON_UNLINK_SUCCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceDeleteOnUnlinkSuccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceDeleteOnUnlinkSuccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to link device.
#[derive(Debug)]
pub struct DeviceLinkFailDetails {
    /// A description of the device used while user approval blocked.
    pub device_type: DeviceType,
    /// IP address. Might be missing due to historical data gap.
    pub ip_address: Option<IpAddress>,
}

impl DeviceLinkFailDetails {
    pub fn new(device_type: DeviceType) -> Self {
        DeviceLinkFailDetails {
            device_type,
            ip_address: None,
        }
    }

    pub fn with_ip_address(mut self, value: Option<IpAddress>) -> Self {
        self.ip_address = value;
        self
    }

}

const DEVICE_LINK_FAIL_DETAILS_FIELDS: &[&str] = &["device_type",
                                                   "ip_address"];
impl DeviceLinkFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceLinkFailDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceLinkFailDetails>, V::Error> {
        let mut field_device_type = None;
        let mut field_ip_address = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "device_type" => {
                    if field_device_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("device_type"));
                    }
                    field_device_type = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(::serde::de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceLinkFailDetails {
            device_type: field_device_type.ok_or_else(|| ::serde::de::Error::missing_field("device_type"))?,
            ip_address: field_ip_address,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_type", &self.device_type)?;
        s.serialize_field("ip_address", &self.ip_address)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkFailDetails", DEVICE_LINK_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkFailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceLinkFailType {
    pub description: String,
}

impl DeviceLinkFailType {
    pub fn new(description: String) -> Self {
        DeviceLinkFailType {
            description,
        }
    }

}

const DEVICE_LINK_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceLinkFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceLinkFailType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceLinkFailType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceLinkFailType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkFailType", DEVICE_LINK_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Linked device.
#[derive(Debug)]
pub struct DeviceLinkSuccessDetails {
    /// Device's session logged information.
    pub device_session_info: Option<DeviceSessionLogInfo>,
}

impl Default for DeviceLinkSuccessDetails {
    fn default() -> Self {
        DeviceLinkSuccessDetails {
            device_session_info: None,
        }
    }
}

const DEVICE_LINK_SUCCESS_DETAILS_FIELDS: &[&str] = &["device_session_info"];
impl DeviceLinkSuccessDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceLinkSuccessDetails, V::Error> {
        let mut field_device_session_info = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "device_session_info" => {
                    if field_device_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("device_session_info"));
                    }
                    field_device_session_info = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = DeviceLinkSuccessDetails {
            device_session_info: field_device_session_info,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_session_info", &self.device_session_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkSuccessDetails", DEVICE_LINK_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkSuccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceLinkSuccessType {
    pub description: String,
}

impl DeviceLinkSuccessType {
    pub fn new(description: String) -> Self {
        DeviceLinkSuccessType {
            description,
        }
    }

}

const DEVICE_LINK_SUCCESS_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceLinkSuccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceLinkSuccessType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceLinkSuccessType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceLinkSuccessType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceLinkSuccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceLinkSuccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceLinkSuccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceLinkSuccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceLinkSuccessType", DEVICE_LINK_SUCCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceLinkSuccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceLinkSuccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Disabled device management.
#[derive(Debug)]
pub struct DeviceManagementDisabledDetails {
}

impl Default for DeviceManagementDisabledDetails {
    fn default() -> Self {
        DeviceManagementDisabledDetails {
        }
    }
}

const DEVICE_MANAGEMENT_DISABLED_DETAILS_FIELDS: &[&str] = &[];
impl DeviceManagementDisabledDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceManagementDisabledDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DeviceManagementDisabledDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementDisabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementDisabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementDisabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementDisabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementDisabledDetails", DEVICE_MANAGEMENT_DISABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementDisabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DeviceManagementDisabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DeviceManagementDisabledType {
    pub description: String,
}

impl DeviceManagementDisabledType {
    pub fn new(description: String) -> Self {
        DeviceManagementDisabledType {
            description,
        }
    }

}

const DEVICE_MANAGEMENT_DISABLED_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceManagementDisabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceManagementDisabledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceManagementDisabledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceManagementDisabledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementDisabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementDisabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementDisabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementDisabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementDisabledType", DEVICE_MANAGEMENT_DISABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementDisabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceManagementDisabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled device management.
#[derive(Debug)]
pub struct DeviceManagementEnabledDetails {
}

impl Default for DeviceManagementEnabledDetails {
    fn default() -> Self {
        DeviceManagementEnabledDetails {
        }
    }
}

const DEVICE_MANAGEMENT_ENABLED_DETAILS_FIELDS: &[&str] = &[];
impl DeviceManagementEnabledDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DeviceManagementEnabledDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DeviceManagementEnabledDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementEnabledDetails", DEVICE_MANAGEMENT_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DeviceManagementEnabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DeviceManagementEnabledType {
    pub description: String,
}

impl DeviceManagementEnabledType {
    pub fn new(description: String) -> Self {
        DeviceManagementEnabledType {
            description,
        }
    }

}

const DEVICE_MANAGEMENT_ENABLED_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceManagementEnabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceManagementEnabledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceManagementEnabledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceManagementEnabledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceManagementEnabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceManagementEnabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceManagementEnabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceManagementEnabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceManagementEnabledType", DEVICE_MANAGEMENT_ENABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceManagementEnabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceManagementEnabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Device's session logged information.
#[derive(Debug)]
pub enum DeviceSessionLogInfo {
    DesktopDeviceSession(DesktopDeviceSessionLogInfo),
    MobileDeviceSession(MobileDeviceSessionLogInfo),
    WebDeviceSession(WebDeviceSessionLogInfo),
    LegacyDeviceSession(LegacyDeviceSessionLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceSessionLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "desktop_device_session" => Ok(DeviceSessionLogInfo::DesktopDeviceSession(DesktopDeviceSessionLogInfo::internal_deserialize(map)?)),
                    "mobile_device_session" => Ok(DeviceSessionLogInfo::MobileDeviceSession(MobileDeviceSessionLogInfo::internal_deserialize(map)?)),
                    "web_device_session" => Ok(DeviceSessionLogInfo::WebDeviceSession(WebDeviceSessionLogInfo::internal_deserialize(map)?)),
                    "legacy_device_session" => Ok(DeviceSessionLogInfo::LegacyDeviceSession(LegacyDeviceSessionLogInfo::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceSessionLogInfo::_Unknown)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["legacy_device_session",
                                    "legacy_device_session",
                                    "legacy_device_session",
                                    "legacy_device_session"];
        deserializer.deserialize_struct("DeviceSessionLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceSessionLogInfo::DesktopDeviceSession(ref x) => {
                let mut s = serializer.serialize_struct("DeviceSessionLogInfo", 10)?;
                s.serialize_field(".tag", "desktop_device_session")?;
                s.serialize_field("host_name", &x.host_name)?;
                s.serialize_field("client_type", &x.client_type)?;
                s.serialize_field("platform", &x.platform)?;
                s.serialize_field("is_delete_on_unlink_supported", &x.is_delete_on_unlink_supported)?;
                s.serialize_field("ip_address", &x.ip_address)?;
                s.serialize_field("created", &x.created)?;
                s.serialize_field("updated", &x.updated)?;
                s.serialize_field("session_info", &x.session_info)?;
                s.serialize_field("client_version", &x.client_version)?;
                s.end()
            }
            DeviceSessionLogInfo::MobileDeviceSession(ref x) => {
                let mut s = serializer.serialize_struct("DeviceSessionLogInfo", 10)?;
                s.serialize_field(".tag", "mobile_device_session")?;
                s.serialize_field("device_name", &x.device_name)?;
                s.serialize_field("client_type", &x.client_type)?;
                s.serialize_field("ip_address", &x.ip_address)?;
                s.serialize_field("created", &x.created)?;
                s.serialize_field("updated", &x.updated)?;
                s.serialize_field("session_info", &x.session_info)?;
                s.serialize_field("client_version", &x.client_version)?;
                s.serialize_field("os_version", &x.os_version)?;
                s.serialize_field("last_carrier", &x.last_carrier)?;
                s.end()
            }
            DeviceSessionLogInfo::WebDeviceSession(ref x) => {
                let mut s = serializer.serialize_struct("DeviceSessionLogInfo", 8)?;
                s.serialize_field(".tag", "web_device_session")?;
                s.serialize_field("user_agent", &x.user_agent)?;
                s.serialize_field("os", &x.os)?;
                s.serialize_field("browser", &x.browser)?;
                s.serialize_field("ip_address", &x.ip_address)?;
                s.serialize_field("created", &x.created)?;
                s.serialize_field("updated", &x.updated)?;
                s.serialize_field("session_info", &x.session_info)?;
                s.end()
            }
            DeviceSessionLogInfo::LegacyDeviceSession(ref x) => {
                let mut s = serializer.serialize_struct("DeviceSessionLogInfo", 13)?;
                s.serialize_field(".tag", "legacy_device_session")?;
                s.serialize_field("ip_address", &x.ip_address)?;
                s.serialize_field("created", &x.created)?;
                s.serialize_field("updated", &x.updated)?;
                s.serialize_field("session_info", &x.session_info)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.serialize_field("is_emm_managed", &x.is_emm_managed)?;
                s.serialize_field("platform", &x.platform)?;
                s.serialize_field("mac_address", &x.mac_address)?;
                s.serialize_field("os_version", &x.os_version)?;
                s.serialize_field("device_type", &x.device_type)?;
                s.serialize_field("client_version", &x.client_version)?;
                s.serialize_field("legacy_uniq_id", &x.legacy_uniq_id)?;
                s.end()
            }
            DeviceSessionLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

#[derive(Debug)]
pub enum DeviceType {
    Desktop,
    Mobile,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "desktop" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceType::Desktop)
                    }
                    "mobile" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceType::Mobile)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["desktop",
                                    "mobile",
                                    "other"];
        deserializer.deserialize_struct("DeviceType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceType::Desktop => {
                // unit
                let mut s = serializer.serialize_struct("DeviceType", 1)?;
                s.serialize_field(".tag", "desktop")?;
                s.end()
            }
            DeviceType::Mobile => {
                // unit
                let mut s = serializer.serialize_struct("DeviceType", 1)?;
                s.serialize_field(".tag", "mobile")?;
                s.end()
            }
            DeviceType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Disconnected device.
#[derive(Debug)]
pub struct DeviceUnlinkDetails {
    /// True if the user requested to delete data after device unlink, false otherwise.
    pub delete_data: bool,
    /// Session unique id.
    pub session_info: Option<SessionLogInfo>,
    /// The device name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl DeviceUnlinkDetails {
    pub fn new(delete_data: bool) -> Self {
        DeviceUnlinkDetails {
            delete_data,
            session_info: None,
            display_name: None,
        }
    }

    pub fn with_session_info(mut self, value: Option<SessionLogInfo>) -> Self {
        self.session_info = value;
        self
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

}

const DEVICE_UNLINK_DETAILS_FIELDS: &[&str] = &["delete_data",
                                                "session_info",
                                                "display_name"];
impl DeviceUnlinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceUnlinkDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceUnlinkDetails>, V::Error> {
        let mut field_delete_data = None;
        let mut field_session_info = None;
        let mut field_display_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "delete_data" => {
                    if field_delete_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("delete_data"));
                    }
                    field_delete_data = Some(map.next_value()?);
                }
                "session_info" => {
                    if field_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_info"));
                    }
                    field_session_info = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceUnlinkDetails {
            delete_data: field_delete_data.ok_or_else(|| ::serde::de::Error::missing_field("delete_data"))?,
            session_info: field_session_info,
            display_name: field_display_name,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("delete_data", &self.delete_data)?;
        s.serialize_field("session_info", &self.session_info)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceUnlinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceUnlinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceUnlinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceUnlinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceUnlinkDetails", DEVICE_UNLINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceUnlinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceUnlinkDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum DeviceUnlinkPolicy {
    Remove,
    Keep,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceUnlinkPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DeviceUnlinkPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceUnlinkPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "remove" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceUnlinkPolicy::Remove)
                    }
                    "keep" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceUnlinkPolicy::Keep)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DeviceUnlinkPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["remove",
                                    "keep",
                                    "other"];
        deserializer.deserialize_struct("DeviceUnlinkPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceUnlinkPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DeviceUnlinkPolicy::Remove => {
                // unit
                let mut s = serializer.serialize_struct("DeviceUnlinkPolicy", 1)?;
                s.serialize_field(".tag", "remove")?;
                s.end()
            }
            DeviceUnlinkPolicy::Keep => {
                // unit
                let mut s = serializer.serialize_struct("DeviceUnlinkPolicy", 1)?;
                s.serialize_field(".tag", "keep")?;
                s.end()
            }
            DeviceUnlinkPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct DeviceUnlinkType {
    pub description: String,
}

impl DeviceUnlinkType {
    pub fn new(description: String) -> Self {
        DeviceUnlinkType {
            description,
        }
    }

}

const DEVICE_UNLINK_TYPE_FIELDS: &[&str] = &["description"];
impl DeviceUnlinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceUnlinkType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceUnlinkType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceUnlinkType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceUnlinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceUnlinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DeviceUnlinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceUnlinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceUnlinkType", DEVICE_UNLINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceUnlinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceUnlinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added members to directory restrictions list.
#[derive(Debug)]
pub struct DirectoryRestrictionsAddMembersDetails {
}

impl Default for DirectoryRestrictionsAddMembersDetails {
    fn default() -> Self {
        DirectoryRestrictionsAddMembersDetails {
        }
    }
}

const DIRECTORY_RESTRICTIONS_ADD_MEMBERS_DETAILS_FIELDS: &[&str] = &[];
impl DirectoryRestrictionsAddMembersDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DirectoryRestrictionsAddMembersDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DirectoryRestrictionsAddMembersDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DirectoryRestrictionsAddMembersDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DirectoryRestrictionsAddMembersDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DirectoryRestrictionsAddMembersDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DirectoryRestrictionsAddMembersDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DirectoryRestrictionsAddMembersDetails", DIRECTORY_RESTRICTIONS_ADD_MEMBERS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DirectoryRestrictionsAddMembersDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DirectoryRestrictionsAddMembersDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DirectoryRestrictionsAddMembersType {
    pub description: String,
}

impl DirectoryRestrictionsAddMembersType {
    pub fn new(description: String) -> Self {
        DirectoryRestrictionsAddMembersType {
            description,
        }
    }

}

const DIRECTORY_RESTRICTIONS_ADD_MEMBERS_TYPE_FIELDS: &[&str] = &["description"];
impl DirectoryRestrictionsAddMembersType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DirectoryRestrictionsAddMembersType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DirectoryRestrictionsAddMembersType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DirectoryRestrictionsAddMembersType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DirectoryRestrictionsAddMembersType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DirectoryRestrictionsAddMembersType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DirectoryRestrictionsAddMembersType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DirectoryRestrictionsAddMembersType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DirectoryRestrictionsAddMembersType", DIRECTORY_RESTRICTIONS_ADD_MEMBERS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DirectoryRestrictionsAddMembersType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DirectoryRestrictionsAddMembersType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed members from directory restrictions list.
#[derive(Debug)]
pub struct DirectoryRestrictionsRemoveMembersDetails {
}

impl Default for DirectoryRestrictionsRemoveMembersDetails {
    fn default() -> Self {
        DirectoryRestrictionsRemoveMembersDetails {
        }
    }
}

const DIRECTORY_RESTRICTIONS_REMOVE_MEMBERS_DETAILS_FIELDS: &[&str] = &[];
impl DirectoryRestrictionsRemoveMembersDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DirectoryRestrictionsRemoveMembersDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DirectoryRestrictionsRemoveMembersDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DirectoryRestrictionsRemoveMembersDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DirectoryRestrictionsRemoveMembersDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DirectoryRestrictionsRemoveMembersDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DirectoryRestrictionsRemoveMembersDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DirectoryRestrictionsRemoveMembersDetails", DIRECTORY_RESTRICTIONS_REMOVE_MEMBERS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DirectoryRestrictionsRemoveMembersDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DirectoryRestrictionsRemoveMembersDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DirectoryRestrictionsRemoveMembersType {
    pub description: String,
}

impl DirectoryRestrictionsRemoveMembersType {
    pub fn new(description: String) -> Self {
        DirectoryRestrictionsRemoveMembersType {
            description,
        }
    }

}

const DIRECTORY_RESTRICTIONS_REMOVE_MEMBERS_TYPE_FIELDS: &[&str] = &["description"];
impl DirectoryRestrictionsRemoveMembersType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DirectoryRestrictionsRemoveMembersType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DirectoryRestrictionsRemoveMembersType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DirectoryRestrictionsRemoveMembersType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DirectoryRestrictionsRemoveMembersType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DirectoryRestrictionsRemoveMembersType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DirectoryRestrictionsRemoveMembersType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DirectoryRestrictionsRemoveMembersType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DirectoryRestrictionsRemoveMembersType", DIRECTORY_RESTRICTIONS_REMOVE_MEMBERS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DirectoryRestrictionsRemoveMembersType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DirectoryRestrictionsRemoveMembersType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Disabled domain invites.
#[derive(Debug)]
pub struct DisabledDomainInvitesDetails {
}

impl Default for DisabledDomainInvitesDetails {
    fn default() -> Self {
        DisabledDomainInvitesDetails {
        }
    }
}

const DISABLED_DOMAIN_INVITES_DETAILS_FIELDS: &[&str] = &[];
impl DisabledDomainInvitesDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DisabledDomainInvitesDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DisabledDomainInvitesDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DisabledDomainInvitesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DisabledDomainInvitesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DisabledDomainInvitesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DisabledDomainInvitesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DisabledDomainInvitesDetails", DISABLED_DOMAIN_INVITES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DisabledDomainInvitesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DisabledDomainInvitesDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DisabledDomainInvitesType {
    pub description: String,
}

impl DisabledDomainInvitesType {
    pub fn new(description: String) -> Self {
        DisabledDomainInvitesType {
            description,
        }
    }

}

const DISABLED_DOMAIN_INVITES_TYPE_FIELDS: &[&str] = &["description"];
impl DisabledDomainInvitesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DisabledDomainInvitesType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DisabledDomainInvitesType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DisabledDomainInvitesType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DisabledDomainInvitesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DisabledDomainInvitesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DisabledDomainInvitesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DisabledDomainInvitesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DisabledDomainInvitesType", DISABLED_DOMAIN_INVITES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DisabledDomainInvitesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DisabledDomainInvitesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Approved user's request to join team.
#[derive(Debug)]
pub struct DomainInvitesApproveRequestToJoinTeamDetails {
}

impl Default for DomainInvitesApproveRequestToJoinTeamDetails {
    fn default() -> Self {
        DomainInvitesApproveRequestToJoinTeamDetails {
        }
    }
}

const DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesApproveRequestToJoinTeamDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesApproveRequestToJoinTeamDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DomainInvitesApproveRequestToJoinTeamDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesApproveRequestToJoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesApproveRequestToJoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesApproveRequestToJoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesApproveRequestToJoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesApproveRequestToJoinTeamDetails", DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesApproveRequestToJoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesApproveRequestToJoinTeamDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesApproveRequestToJoinTeamType {
    pub description: String,
}

impl DomainInvitesApproveRequestToJoinTeamType {
    pub fn new(description: String) -> Self {
        DomainInvitesApproveRequestToJoinTeamType {
            description,
        }
    }

}

const DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesApproveRequestToJoinTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainInvitesApproveRequestToJoinTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainInvitesApproveRequestToJoinTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainInvitesApproveRequestToJoinTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesApproveRequestToJoinTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesApproveRequestToJoinTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesApproveRequestToJoinTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesApproveRequestToJoinTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesApproveRequestToJoinTeamType", DOMAIN_INVITES_APPROVE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesApproveRequestToJoinTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesApproveRequestToJoinTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Declined user's request to join team.
#[derive(Debug)]
pub struct DomainInvitesDeclineRequestToJoinTeamDetails {
}

impl Default for DomainInvitesDeclineRequestToJoinTeamDetails {
    fn default() -> Self {
        DomainInvitesDeclineRequestToJoinTeamDetails {
        }
    }
}

const DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesDeclineRequestToJoinTeamDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesDeclineRequestToJoinTeamDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DomainInvitesDeclineRequestToJoinTeamDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesDeclineRequestToJoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesDeclineRequestToJoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesDeclineRequestToJoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesDeclineRequestToJoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesDeclineRequestToJoinTeamDetails", DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesDeclineRequestToJoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesDeclineRequestToJoinTeamDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesDeclineRequestToJoinTeamType {
    pub description: String,
}

impl DomainInvitesDeclineRequestToJoinTeamType {
    pub fn new(description: String) -> Self {
        DomainInvitesDeclineRequestToJoinTeamType {
            description,
        }
    }

}

const DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesDeclineRequestToJoinTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainInvitesDeclineRequestToJoinTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainInvitesDeclineRequestToJoinTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainInvitesDeclineRequestToJoinTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesDeclineRequestToJoinTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesDeclineRequestToJoinTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesDeclineRequestToJoinTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesDeclineRequestToJoinTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesDeclineRequestToJoinTeamType", DOMAIN_INVITES_DECLINE_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesDeclineRequestToJoinTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesDeclineRequestToJoinTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sent domain invites to existing domain accounts.
#[derive(Debug)]
pub struct DomainInvitesEmailExistingUsersDetails {
    /// Domain names.
    pub domain_name: String,
    /// Number of recipients.
    pub num_recipients: u64,
}

impl DomainInvitesEmailExistingUsersDetails {
    pub fn new(domain_name: String, num_recipients: u64) -> Self {
        DomainInvitesEmailExistingUsersDetails {
            domain_name,
            num_recipients,
        }
    }

}

const DOMAIN_INVITES_EMAIL_EXISTING_USERS_DETAILS_FIELDS: &[&str] = &["domain_name",
                                                                      "num_recipients"];
impl DomainInvitesEmailExistingUsersDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainInvitesEmailExistingUsersDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainInvitesEmailExistingUsersDetails>, V::Error> {
        let mut field_domain_name = None;
        let mut field_num_recipients = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                "num_recipients" => {
                    if field_num_recipients.is_some() {
                        return Err(::serde::de::Error::duplicate_field("num_recipients"));
                    }
                    field_num_recipients = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainInvitesEmailExistingUsersDetails {
            domain_name: field_domain_name.ok_or_else(|| ::serde::de::Error::missing_field("domain_name"))?,
            num_recipients: field_num_recipients.ok_or_else(|| ::serde::de::Error::missing_field("num_recipients"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)?;
        s.serialize_field("num_recipients", &self.num_recipients)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesEmailExistingUsersDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesEmailExistingUsersDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesEmailExistingUsersDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesEmailExistingUsersDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesEmailExistingUsersDetails", DOMAIN_INVITES_EMAIL_EXISTING_USERS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesEmailExistingUsersDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesEmailExistingUsersDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesEmailExistingUsersType {
    pub description: String,
}

impl DomainInvitesEmailExistingUsersType {
    pub fn new(description: String) -> Self {
        DomainInvitesEmailExistingUsersType {
            description,
        }
    }

}

const DOMAIN_INVITES_EMAIL_EXISTING_USERS_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesEmailExistingUsersType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainInvitesEmailExistingUsersType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainInvitesEmailExistingUsersType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainInvitesEmailExistingUsersType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesEmailExistingUsersType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesEmailExistingUsersType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesEmailExistingUsersType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesEmailExistingUsersType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesEmailExistingUsersType", DOMAIN_INVITES_EMAIL_EXISTING_USERS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesEmailExistingUsersType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesEmailExistingUsersType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested to join team.
#[derive(Debug)]
pub struct DomainInvitesRequestToJoinTeamDetails {
}

impl Default for DomainInvitesRequestToJoinTeamDetails {
    fn default() -> Self {
        DomainInvitesRequestToJoinTeamDetails {
        }
    }
}

const DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesRequestToJoinTeamDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesRequestToJoinTeamDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DomainInvitesRequestToJoinTeamDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesRequestToJoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesRequestToJoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesRequestToJoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesRequestToJoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesRequestToJoinTeamDetails", DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesRequestToJoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesRequestToJoinTeamDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesRequestToJoinTeamType {
    pub description: String,
}

impl DomainInvitesRequestToJoinTeamType {
    pub fn new(description: String) -> Self {
        DomainInvitesRequestToJoinTeamType {
            description,
        }
    }

}

const DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesRequestToJoinTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainInvitesRequestToJoinTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainInvitesRequestToJoinTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainInvitesRequestToJoinTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesRequestToJoinTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesRequestToJoinTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesRequestToJoinTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesRequestToJoinTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesRequestToJoinTeamType", DOMAIN_INVITES_REQUEST_TO_JOIN_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesRequestToJoinTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesRequestToJoinTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Disabled "Automatically invite new users".
#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToNoDetails {
}

impl Default for DomainInvitesSetInviteNewUserPrefToNoDetails {
    fn default() -> Self {
        DomainInvitesSetInviteNewUserPrefToNoDetails {
        }
    }
}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesSetInviteNewUserPrefToNoDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesSetInviteNewUserPrefToNoDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DomainInvitesSetInviteNewUserPrefToNoDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToNoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToNoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToNoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToNoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToNoDetails", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToNoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToNoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToNoType {
    pub description: String,
}

impl DomainInvitesSetInviteNewUserPrefToNoType {
    pub fn new(description: String) -> Self {
        DomainInvitesSetInviteNewUserPrefToNoType {
            description,
        }
    }

}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesSetInviteNewUserPrefToNoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainInvitesSetInviteNewUserPrefToNoType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainInvitesSetInviteNewUserPrefToNoType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainInvitesSetInviteNewUserPrefToNoType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToNoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToNoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToNoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToNoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToNoType", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_NO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToNoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToNoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled "Automatically invite new users".
#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToYesDetails {
}

impl Default for DomainInvitesSetInviteNewUserPrefToYesDetails {
    fn default() -> Self {
        DomainInvitesSetInviteNewUserPrefToYesDetails {
        }
    }
}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_DETAILS_FIELDS: &[&str] = &[];
impl DomainInvitesSetInviteNewUserPrefToYesDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DomainInvitesSetInviteNewUserPrefToYesDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(DomainInvitesSetInviteNewUserPrefToYesDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToYesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToYesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToYesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToYesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToYesDetails", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToYesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToYesDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct DomainInvitesSetInviteNewUserPrefToYesType {
    pub description: String,
}

impl DomainInvitesSetInviteNewUserPrefToYesType {
    pub fn new(description: String) -> Self {
        DomainInvitesSetInviteNewUserPrefToYesType {
            description,
        }
    }

}

const DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_TYPE_FIELDS: &[&str] = &["description"];
impl DomainInvitesSetInviteNewUserPrefToYesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainInvitesSetInviteNewUserPrefToYesType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainInvitesSetInviteNewUserPrefToYesType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainInvitesSetInviteNewUserPrefToYesType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainInvitesSetInviteNewUserPrefToYesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainInvitesSetInviteNewUserPrefToYesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainInvitesSetInviteNewUserPrefToYesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainInvitesSetInviteNewUserPrefToYesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainInvitesSetInviteNewUserPrefToYesType", DOMAIN_INVITES_SET_INVITE_NEW_USER_PREF_TO_YES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainInvitesSetInviteNewUserPrefToYesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainInvitesSetInviteNewUserPrefToYesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to verify team domain.
#[derive(Debug)]
pub struct DomainVerificationAddDomainFailDetails {
    /// Domain name.
    pub domain_name: String,
    /// Domain name verification method. Might be missing due to historical data gap.
    pub verification_method: Option<String>,
}

impl DomainVerificationAddDomainFailDetails {
    pub fn new(domain_name: String) -> Self {
        DomainVerificationAddDomainFailDetails {
            domain_name,
            verification_method: None,
        }
    }

    pub fn with_verification_method(mut self, value: Option<String>) -> Self {
        self.verification_method = value;
        self
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_DETAILS_FIELDS: &[&str] = &["domain_name",
                                                                      "verification_method"];
impl DomainVerificationAddDomainFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainVerificationAddDomainFailDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainVerificationAddDomainFailDetails>, V::Error> {
        let mut field_domain_name = None;
        let mut field_verification_method = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "domain_name" => {
                    if field_domain_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("domain_name"));
                    }
                    field_domain_name = Some(map.next_value()?);
                }
                "verification_method" => {
                    if field_verification_method.is_some() {
                        return Err(::serde::de::Error::duplicate_field("verification_method"));
                    }
                    field_verification_method = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainVerificationAddDomainFailDetails {
            domain_name: field_domain_name.ok_or_else(|| ::serde::de::Error::missing_field("domain_name"))?,
            verification_method: field_verification_method,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_name", &self.domain_name)?;
        s.serialize_field("verification_method", &self.verification_method)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainFailDetails", DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainFailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DomainVerificationAddDomainFailType {
    pub description: String,
}

impl DomainVerificationAddDomainFailType {
    pub fn new(description: String) -> Self {
        DomainVerificationAddDomainFailType {
            description,
        }
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl DomainVerificationAddDomainFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainVerificationAddDomainFailType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainVerificationAddDomainFailType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainVerificationAddDomainFailType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainFailType", DOMAIN_VERIFICATION_ADD_DOMAIN_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Verified team domain.
#[derive(Debug)]
pub struct DomainVerificationAddDomainSuccessDetails {
    /// Domain names.
    pub domain_names: Vec<String>,
    /// Domain name verification method. Might be missing due to historical data gap.
    pub verification_method: Option<String>,
}

impl DomainVerificationAddDomainSuccessDetails {
    pub fn new(domain_names: Vec<String>) -> Self {
        DomainVerificationAddDomainSuccessDetails {
            domain_names,
            verification_method: None,
        }
    }

    pub fn with_verification_method(mut self, value: Option<String>) -> Self {
        self.verification_method = value;
        self
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_DETAILS_FIELDS: &[&str] = &["domain_names",
                                                                         "verification_method"];
impl DomainVerificationAddDomainSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainVerificationAddDomainSuccessDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainVerificationAddDomainSuccessDetails>, V::Error> {
        let mut field_domain_names = None;
        let mut field_verification_method = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "domain_names" => {
                    if field_domain_names.is_some() {
                        return Err(::serde::de::Error::duplicate_field("domain_names"));
                    }
                    field_domain_names = Some(map.next_value()?);
                }
                "verification_method" => {
                    if field_verification_method.is_some() {
                        return Err(::serde::de::Error::duplicate_field("verification_method"));
                    }
                    field_verification_method = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainVerificationAddDomainSuccessDetails {
            domain_names: field_domain_names.ok_or_else(|| ::serde::de::Error::missing_field("domain_names"))?,
            verification_method: field_verification_method,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_names", &self.domain_names)?;
        s.serialize_field("verification_method", &self.verification_method)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainSuccessDetails", DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainSuccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DomainVerificationAddDomainSuccessType {
    pub description: String,
}

impl DomainVerificationAddDomainSuccessType {
    pub fn new(description: String) -> Self {
        DomainVerificationAddDomainSuccessType {
            description,
        }
    }

}

const DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_TYPE_FIELDS: &[&str] = &["description"];
impl DomainVerificationAddDomainSuccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainVerificationAddDomainSuccessType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainVerificationAddDomainSuccessType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainVerificationAddDomainSuccessType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationAddDomainSuccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationAddDomainSuccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationAddDomainSuccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationAddDomainSuccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationAddDomainSuccessType", DOMAIN_VERIFICATION_ADD_DOMAIN_SUCCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationAddDomainSuccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationAddDomainSuccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed domain from list of verified team domains.
#[derive(Debug)]
pub struct DomainVerificationRemoveDomainDetails {
    /// Domain names.
    pub domain_names: Vec<String>,
}

impl DomainVerificationRemoveDomainDetails {
    pub fn new(domain_names: Vec<String>) -> Self {
        DomainVerificationRemoveDomainDetails {
            domain_names,
        }
    }

}

const DOMAIN_VERIFICATION_REMOVE_DOMAIN_DETAILS_FIELDS: &[&str] = &["domain_names"];
impl DomainVerificationRemoveDomainDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainVerificationRemoveDomainDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainVerificationRemoveDomainDetails>, V::Error> {
        let mut field_domain_names = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "domain_names" => {
                    if field_domain_names.is_some() {
                        return Err(::serde::de::Error::duplicate_field("domain_names"));
                    }
                    field_domain_names = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainVerificationRemoveDomainDetails {
            domain_names: field_domain_names.ok_or_else(|| ::serde::de::Error::missing_field("domain_names"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("domain_names", &self.domain_names)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationRemoveDomainDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationRemoveDomainDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationRemoveDomainDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationRemoveDomainDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationRemoveDomainDetails", DOMAIN_VERIFICATION_REMOVE_DOMAIN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationRemoveDomainDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationRemoveDomainDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DomainVerificationRemoveDomainType {
    pub description: String,
}

impl DomainVerificationRemoveDomainType {
    pub fn new(description: String) -> Self {
        DomainVerificationRemoveDomainType {
            description,
        }
    }

}

const DOMAIN_VERIFICATION_REMOVE_DOMAIN_TYPE_FIELDS: &[&str] = &["description"];
impl DomainVerificationRemoveDomainType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DomainVerificationRemoveDomainType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DomainVerificationRemoveDomainType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DomainVerificationRemoveDomainType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DomainVerificationRemoveDomainType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DomainVerificationRemoveDomainType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DomainVerificationRemoveDomainType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DomainVerificationRemoveDomainType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DomainVerificationRemoveDomainType", DOMAIN_VERIFICATION_REMOVE_DOMAIN_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DomainVerificationRemoveDomainType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DomainVerificationRemoveDomainType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared content downloads policy
#[derive(Debug)]
pub enum DownloadPolicyType {
    Allow,
    Disallow,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DownloadPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DownloadPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DownloadPolicyType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "allow" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DownloadPolicyType::Allow)
                    }
                    "disallow" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DownloadPolicyType::Disallow)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(DownloadPolicyType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["allow",
                                    "disallow",
                                    "other"];
        deserializer.deserialize_struct("DownloadPolicyType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DownloadPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DownloadPolicyType::Allow => {
                // unit
                let mut s = serializer.serialize_struct("DownloadPolicyType", 1)?;
                s.serialize_field(".tag", "allow")?;
                s.end()
            }
            DownloadPolicyType::Disallow => {
                // unit
                let mut s = serializer.serialize_struct("DownloadPolicyType", 1)?;
                s.serialize_field(".tag", "disallow")?;
                s.end()
            }
            DownloadPolicyType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Represents a time duration: unit and amount
#[derive(Debug)]
pub struct DurationLogInfo {
    /// Time unit.
    pub unit: TimeUnit,
    /// Amount of time.
    pub amount: u64,
}

impl DurationLogInfo {
    pub fn new(unit: TimeUnit, amount: u64) -> Self {
        DurationLogInfo {
            unit,
            amount,
        }
    }

}

const DURATION_LOG_INFO_FIELDS: &[&str] = &["unit",
                                            "amount"];
impl DurationLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DurationLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DurationLogInfo>, V::Error> {
        let mut field_unit = None;
        let mut field_amount = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "unit" => {
                    if field_unit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("unit"));
                    }
                    field_unit = Some(map.next_value()?);
                }
                "amount" => {
                    if field_amount.is_some() {
                        return Err(::serde::de::Error::duplicate_field("amount"));
                    }
                    field_amount = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DurationLogInfo {
            unit: field_unit.ok_or_else(|| ::serde::de::Error::missing_field("unit"))?,
            amount: field_amount.ok_or_else(|| ::serde::de::Error::missing_field("amount"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("unit", &self.unit)?;
        s.serialize_field("amount", &self.amount)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DurationLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DurationLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a DurationLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DurationLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DurationLogInfo", DURATION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DurationLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DurationLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added members to EMM exception list.
#[derive(Debug)]
pub struct EmmAddExceptionDetails {
}

impl Default for EmmAddExceptionDetails {
    fn default() -> Self {
        EmmAddExceptionDetails {
        }
    }
}

const EMM_ADD_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl EmmAddExceptionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmAddExceptionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(EmmAddExceptionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmAddExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmAddExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmAddExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmAddExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmAddExceptionDetails", EMM_ADD_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmAddExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmAddExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmAddExceptionType {
    pub description: String,
}

impl EmmAddExceptionType {
    pub fn new(description: String) -> Self {
        EmmAddExceptionType {
            description,
        }
    }

}

const EMM_ADD_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl EmmAddExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmmAddExceptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmmAddExceptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmmAddExceptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmAddExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmAddExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmAddExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmAddExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmAddExceptionType", EMM_ADD_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmAddExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmAddExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled enterprise mobility management for members.
#[derive(Debug)]
pub struct EmmChangePolicyDetails {
    /// New enterprise mobility management policy.
    pub new_value: super::team_policies::EmmState,
    /// Previous enterprise mobility management policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::EmmState>,
}

impl EmmChangePolicyDetails {
    pub fn new(new_value: super::team_policies::EmmState) -> Self {
        EmmChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::team_policies::EmmState>) -> Self {
        self.previous_value = value;
        self
    }

}

const EMM_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                    "previous_value"];
impl EmmChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmmChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmmChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmmChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmChangePolicyDetails", EMM_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct EmmChangePolicyType {
    pub description: String,
}

impl EmmChangePolicyType {
    pub fn new(description: String) -> Self {
        EmmChangePolicyType {
            description,
        }
    }

}

const EMM_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl EmmChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmmChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmmChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmmChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmChangePolicyType", EMM_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created EMM-excluded users report.
#[derive(Debug)]
pub struct EmmCreateExceptionsReportDetails {
}

impl Default for EmmCreateExceptionsReportDetails {
    fn default() -> Self {
        EmmCreateExceptionsReportDetails {
        }
    }
}

const EMM_CREATE_EXCEPTIONS_REPORT_DETAILS_FIELDS: &[&str] = &[];
impl EmmCreateExceptionsReportDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmCreateExceptionsReportDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(EmmCreateExceptionsReportDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateExceptionsReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateExceptionsReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmCreateExceptionsReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateExceptionsReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateExceptionsReportDetails", EMM_CREATE_EXCEPTIONS_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateExceptionsReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmCreateExceptionsReportDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmCreateExceptionsReportType {
    pub description: String,
}

impl EmmCreateExceptionsReportType {
    pub fn new(description: String) -> Self {
        EmmCreateExceptionsReportType {
            description,
        }
    }

}

const EMM_CREATE_EXCEPTIONS_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl EmmCreateExceptionsReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmmCreateExceptionsReportType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmmCreateExceptionsReportType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmmCreateExceptionsReportType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateExceptionsReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateExceptionsReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmCreateExceptionsReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateExceptionsReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateExceptionsReportType", EMM_CREATE_EXCEPTIONS_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateExceptionsReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmCreateExceptionsReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created EMM mobile app usage report.
#[derive(Debug)]
pub struct EmmCreateUsageReportDetails {
}

impl Default for EmmCreateUsageReportDetails {
    fn default() -> Self {
        EmmCreateUsageReportDetails {
        }
    }
}

const EMM_CREATE_USAGE_REPORT_DETAILS_FIELDS: &[&str] = &[];
impl EmmCreateUsageReportDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmCreateUsageReportDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(EmmCreateUsageReportDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateUsageReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateUsageReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmCreateUsageReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateUsageReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateUsageReportDetails", EMM_CREATE_USAGE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateUsageReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmCreateUsageReportDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmCreateUsageReportType {
    pub description: String,
}

impl EmmCreateUsageReportType {
    pub fn new(description: String) -> Self {
        EmmCreateUsageReportType {
            description,
        }
    }

}

const EMM_CREATE_USAGE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl EmmCreateUsageReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmmCreateUsageReportType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmmCreateUsageReportType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmmCreateUsageReportType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmCreateUsageReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmCreateUsageReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmCreateUsageReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmCreateUsageReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmCreateUsageReportType", EMM_CREATE_USAGE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmCreateUsageReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmCreateUsageReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to sign in via EMM.
#[derive(Debug)]
pub struct EmmErrorDetails {
    /// Error details.
    pub error_details: FailureDetailsLogInfo,
}

impl EmmErrorDetails {
    pub fn new(error_details: FailureDetailsLogInfo) -> Self {
        EmmErrorDetails {
            error_details,
        }
    }

}

const EMM_ERROR_DETAILS_FIELDS: &[&str] = &["error_details"];
impl EmmErrorDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmmErrorDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmmErrorDetails>, V::Error> {
        let mut field_error_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "error_details" => {
                    if field_error_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("error_details"));
                    }
                    field_error_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmmErrorDetails {
            error_details: field_error_details.ok_or_else(|| ::serde::de::Error::missing_field("error_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("error_details", &self.error_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmErrorDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmErrorDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmErrorDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmErrorDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmErrorDetails", EMM_ERROR_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmErrorDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmErrorDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct EmmErrorType {
    pub description: String,
}

impl EmmErrorType {
    pub fn new(description: String) -> Self {
        EmmErrorType {
            description,
        }
    }

}

const EMM_ERROR_TYPE_FIELDS: &[&str] = &["description"];
impl EmmErrorType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmmErrorType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmmErrorType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmmErrorType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmErrorType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmErrorType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmErrorType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmErrorType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmErrorType", EMM_ERROR_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmErrorType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmErrorType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Refreshed auth token used for setting up EMM.
#[derive(Debug)]
pub struct EmmRefreshAuthTokenDetails {
}

impl Default for EmmRefreshAuthTokenDetails {
    fn default() -> Self {
        EmmRefreshAuthTokenDetails {
        }
    }
}

const EMM_REFRESH_AUTH_TOKEN_DETAILS_FIELDS: &[&str] = &[];
impl EmmRefreshAuthTokenDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmRefreshAuthTokenDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(EmmRefreshAuthTokenDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRefreshAuthTokenDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRefreshAuthTokenDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmRefreshAuthTokenDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRefreshAuthTokenDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRefreshAuthTokenDetails", EMM_REFRESH_AUTH_TOKEN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRefreshAuthTokenDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmRefreshAuthTokenDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmRefreshAuthTokenType {
    pub description: String,
}

impl EmmRefreshAuthTokenType {
    pub fn new(description: String) -> Self {
        EmmRefreshAuthTokenType {
            description,
        }
    }

}

const EMM_REFRESH_AUTH_TOKEN_TYPE_FIELDS: &[&str] = &["description"];
impl EmmRefreshAuthTokenType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmmRefreshAuthTokenType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmmRefreshAuthTokenType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmmRefreshAuthTokenType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRefreshAuthTokenType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRefreshAuthTokenType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmRefreshAuthTokenType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRefreshAuthTokenType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRefreshAuthTokenType", EMM_REFRESH_AUTH_TOKEN_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRefreshAuthTokenType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmRefreshAuthTokenType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed members from EMM exception list.
#[derive(Debug)]
pub struct EmmRemoveExceptionDetails {
}

impl Default for EmmRemoveExceptionDetails {
    fn default() -> Self {
        EmmRemoveExceptionDetails {
        }
    }
}

const EMM_REMOVE_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl EmmRemoveExceptionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmmRemoveExceptionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(EmmRemoveExceptionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRemoveExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRemoveExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmRemoveExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRemoveExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRemoveExceptionDetails", EMM_REMOVE_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRemoveExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EmmRemoveExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EmmRemoveExceptionType {
    pub description: String,
}

impl EmmRemoveExceptionType {
    pub fn new(description: String) -> Self {
        EmmRemoveExceptionType {
            description,
        }
    }

}

const EMM_REMOVE_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl EmmRemoveExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmmRemoveExceptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmmRemoveExceptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmmRemoveExceptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmmRemoveExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmmRemoveExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmmRemoveExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmmRemoveExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EmmRemoveExceptionType", EMM_REMOVE_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EmmRemoveExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmmRemoveExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled domain invites.
#[derive(Debug)]
pub struct EnabledDomainInvitesDetails {
}

impl Default for EnabledDomainInvitesDetails {
    fn default() -> Self {
        EnabledDomainInvitesDetails {
        }
    }
}

const ENABLED_DOMAIN_INVITES_DETAILS_FIELDS: &[&str] = &[];
impl EnabledDomainInvitesDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EnabledDomainInvitesDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(EnabledDomainInvitesDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EnabledDomainInvitesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EnabledDomainInvitesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EnabledDomainInvitesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EnabledDomainInvitesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EnabledDomainInvitesDetails", ENABLED_DOMAIN_INVITES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EnabledDomainInvitesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EnabledDomainInvitesDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EnabledDomainInvitesType {
    pub description: String,
}

impl EnabledDomainInvitesType {
    pub fn new(description: String) -> Self {
        EnabledDomainInvitesType {
            description,
        }
    }

}

const ENABLED_DOMAIN_INVITES_TYPE_FIELDS: &[&str] = &["description"];
impl EnabledDomainInvitesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EnabledDomainInvitesType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EnabledDomainInvitesType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EnabledDomainInvitesType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EnabledDomainInvitesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EnabledDomainInvitesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EnabledDomainInvitesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EnabledDomainInvitesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EnabledDomainInvitesType", ENABLED_DOMAIN_INVITES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EnabledDomainInvitesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EnabledDomainInvitesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Ended enterprise admin session.
#[derive(Debug)]
pub struct EndedEnterpriseAdminSessionDeprecatedDetails {
    /// More information about the organization or team.
    pub federation_extra_details: FedExtraDetails,
}

impl EndedEnterpriseAdminSessionDeprecatedDetails {
    pub fn new(federation_extra_details: FedExtraDetails) -> Self {
        EndedEnterpriseAdminSessionDeprecatedDetails {
            federation_extra_details,
        }
    }

}

const ENDED_ENTERPRISE_ADMIN_SESSION_DEPRECATED_DETAILS_FIELDS: &[&str] = &["federation_extra_details"];
impl EndedEnterpriseAdminSessionDeprecatedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EndedEnterpriseAdminSessionDeprecatedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EndedEnterpriseAdminSessionDeprecatedDetails>, V::Error> {
        let mut field_federation_extra_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "federation_extra_details" => {
                    if field_federation_extra_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("federation_extra_details"));
                    }
                    field_federation_extra_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EndedEnterpriseAdminSessionDeprecatedDetails {
            federation_extra_details: field_federation_extra_details.ok_or_else(|| ::serde::de::Error::missing_field("federation_extra_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("federation_extra_details", &self.federation_extra_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EndedEnterpriseAdminSessionDeprecatedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EndedEnterpriseAdminSessionDeprecatedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EndedEnterpriseAdminSessionDeprecatedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EndedEnterpriseAdminSessionDeprecatedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EndedEnterpriseAdminSessionDeprecatedDetails", ENDED_ENTERPRISE_ADMIN_SESSION_DEPRECATED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EndedEnterpriseAdminSessionDeprecatedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EndedEnterpriseAdminSessionDeprecatedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct EndedEnterpriseAdminSessionDeprecatedType {
    pub description: String,
}

impl EndedEnterpriseAdminSessionDeprecatedType {
    pub fn new(description: String) -> Self {
        EndedEnterpriseAdminSessionDeprecatedType {
            description,
        }
    }

}

const ENDED_ENTERPRISE_ADMIN_SESSION_DEPRECATED_TYPE_FIELDS: &[&str] = &["description"];
impl EndedEnterpriseAdminSessionDeprecatedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EndedEnterpriseAdminSessionDeprecatedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EndedEnterpriseAdminSessionDeprecatedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EndedEnterpriseAdminSessionDeprecatedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EndedEnterpriseAdminSessionDeprecatedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EndedEnterpriseAdminSessionDeprecatedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EndedEnterpriseAdminSessionDeprecatedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EndedEnterpriseAdminSessionDeprecatedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EndedEnterpriseAdminSessionDeprecatedType", ENDED_ENTERPRISE_ADMIN_SESSION_DEPRECATED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EndedEnterpriseAdminSessionDeprecatedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EndedEnterpriseAdminSessionDeprecatedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Ended enterprise admin session.
#[derive(Debug)]
pub struct EndedEnterpriseAdminSessionDetails {
}

impl Default for EndedEnterpriseAdminSessionDetails {
    fn default() -> Self {
        EndedEnterpriseAdminSessionDetails {
        }
    }
}

const ENDED_ENTERPRISE_ADMIN_SESSION_DETAILS_FIELDS: &[&str] = &[];
impl EndedEnterpriseAdminSessionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EndedEnterpriseAdminSessionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(EndedEnterpriseAdminSessionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EndedEnterpriseAdminSessionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EndedEnterpriseAdminSessionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EndedEnterpriseAdminSessionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EndedEnterpriseAdminSessionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EndedEnterpriseAdminSessionDetails", ENDED_ENTERPRISE_ADMIN_SESSION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EndedEnterpriseAdminSessionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("EndedEnterpriseAdminSessionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct EndedEnterpriseAdminSessionType {
    pub description: String,
}

impl EndedEnterpriseAdminSessionType {
    pub fn new(description: String) -> Self {
        EndedEnterpriseAdminSessionType {
            description,
        }
    }

}

const ENDED_ENTERPRISE_ADMIN_SESSION_TYPE_FIELDS: &[&str] = &["description"];
impl EndedEnterpriseAdminSessionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EndedEnterpriseAdminSessionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EndedEnterpriseAdminSessionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EndedEnterpriseAdminSessionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EndedEnterpriseAdminSessionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EndedEnterpriseAdminSessionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EndedEnterpriseAdminSessionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EndedEnterpriseAdminSessionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EndedEnterpriseAdminSessionType", ENDED_ENTERPRISE_ADMIN_SESSION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EndedEnterpriseAdminSessionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EndedEnterpriseAdminSessionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can update a setting.
#[derive(Debug)]
pub struct EnterpriseSettingsLockingDetails {
    /// The secondary team name.
    pub team_name: String,
    /// Settings page name.
    pub settings_page_name: String,
    /// Previous locked settings page state.
    pub previous_settings_page_locking_state: String,
    /// New locked settings page state.
    pub new_settings_page_locking_state: String,
}

impl EnterpriseSettingsLockingDetails {
    pub fn new(
        team_name: String,
        settings_page_name: String,
        previous_settings_page_locking_state: String,
        new_settings_page_locking_state: String,
    ) -> Self {
        EnterpriseSettingsLockingDetails {
            team_name,
            settings_page_name,
            previous_settings_page_locking_state,
            new_settings_page_locking_state,
        }
    }

}

const ENTERPRISE_SETTINGS_LOCKING_DETAILS_FIELDS: &[&str] = &["team_name",
                                                              "settings_page_name",
                                                              "previous_settings_page_locking_state",
                                                              "new_settings_page_locking_state"];
impl EnterpriseSettingsLockingDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EnterpriseSettingsLockingDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EnterpriseSettingsLockingDetails>, V::Error> {
        let mut field_team_name = None;
        let mut field_settings_page_name = None;
        let mut field_previous_settings_page_locking_state = None;
        let mut field_new_settings_page_locking_state = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                "settings_page_name" => {
                    if field_settings_page_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("settings_page_name"));
                    }
                    field_settings_page_name = Some(map.next_value()?);
                }
                "previous_settings_page_locking_state" => {
                    if field_previous_settings_page_locking_state.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_settings_page_locking_state"));
                    }
                    field_previous_settings_page_locking_state = Some(map.next_value()?);
                }
                "new_settings_page_locking_state" => {
                    if field_new_settings_page_locking_state.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_settings_page_locking_state"));
                    }
                    field_new_settings_page_locking_state = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EnterpriseSettingsLockingDetails {
            team_name: field_team_name.ok_or_else(|| ::serde::de::Error::missing_field("team_name"))?,
            settings_page_name: field_settings_page_name.ok_or_else(|| ::serde::de::Error::missing_field("settings_page_name"))?,
            previous_settings_page_locking_state: field_previous_settings_page_locking_state.ok_or_else(|| ::serde::de::Error::missing_field("previous_settings_page_locking_state"))?,
            new_settings_page_locking_state: field_new_settings_page_locking_state.ok_or_else(|| ::serde::de::Error::missing_field("new_settings_page_locking_state"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_name", &self.team_name)?;
        s.serialize_field("settings_page_name", &self.settings_page_name)?;
        s.serialize_field("previous_settings_page_locking_state", &self.previous_settings_page_locking_state)?;
        s.serialize_field("new_settings_page_locking_state", &self.new_settings_page_locking_state)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EnterpriseSettingsLockingDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EnterpriseSettingsLockingDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EnterpriseSettingsLockingDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EnterpriseSettingsLockingDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EnterpriseSettingsLockingDetails", ENTERPRISE_SETTINGS_LOCKING_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EnterpriseSettingsLockingDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EnterpriseSettingsLockingDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct EnterpriseSettingsLockingType {
    pub description: String,
}

impl EnterpriseSettingsLockingType {
    pub fn new(description: String) -> Self {
        EnterpriseSettingsLockingType {
            description,
        }
    }

}

const ENTERPRISE_SETTINGS_LOCKING_TYPE_FIELDS: &[&str] = &["description"];
impl EnterpriseSettingsLockingType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EnterpriseSettingsLockingType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EnterpriseSettingsLockingType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EnterpriseSettingsLockingType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EnterpriseSettingsLockingType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EnterpriseSettingsLockingType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EnterpriseSettingsLockingType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EnterpriseSettingsLockingType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("EnterpriseSettingsLockingType", ENTERPRISE_SETTINGS_LOCKING_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for EnterpriseSettingsLockingType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EnterpriseSettingsLockingType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Category of events in event audit log.
#[derive(Debug)]
pub enum EventCategory {
    /// Events that apply to management of linked apps.
    Apps,
    /// Events that have to do with comments on files and Paper documents.
    Comments,
    /// Events that apply to linked devices on mobile, desktop and Web platforms.
    Devices,
    /// Events that involve domain management feature: domain verification, invite enforcement and
    /// account capture.
    Domains,
    /// Events that have to do with filesystem operations on files and folders: copy, move, delete,
    /// etc.
    FileOperations,
    /// Events that apply to the file requests feature.
    FileRequests,
    /// Events that involve group management.
    Groups,
    /// Events that involve placing holds on content for litigation reasons
    LegalHolds,
    /// Events that involve users signing in to or out of Dropbox.
    Logins,
    /// Events that involve team member management.
    Members,
    /// Events that apply to Dropbox Paper.
    Paper,
    /// Events that involve using, changing or resetting passwords.
    Passwords,
    /// Events that concern generation of admin reports, including team activity and device usage.
    Reports,
    /// Events that apply to all types of sharing and collaboration.
    Sharing,
    /// Events that apply to Dropbox Showcase.
    Showcase,
    /// Events that involve using or configuring single sign-on as well as administrative policies
    /// concerning single sign-on.
    Sso,
    /// Events that involve team folder management.
    TeamFolders,
    /// Events that involve a change in team-wide policies.
    TeamPolicies,
    /// Events that involve a change in the team profile.
    TeamProfile,
    /// Events that involve using or configuring two factor authentication as well as administrative
    /// policies concerning two factor authentication.
    Tfa,
    /// Events that apply to cross-team trust establishment.
    TrustedTeams,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EventCategory {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EventCategory;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EventCategory structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "apps" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Apps)
                    }
                    "comments" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Comments)
                    }
                    "devices" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Devices)
                    }
                    "domains" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Domains)
                    }
                    "file_operations" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::FileOperations)
                    }
                    "file_requests" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::FileRequests)
                    }
                    "groups" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Groups)
                    }
                    "legal_holds" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::LegalHolds)
                    }
                    "logins" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Logins)
                    }
                    "members" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Members)
                    }
                    "paper" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Paper)
                    }
                    "passwords" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Passwords)
                    }
                    "reports" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Reports)
                    }
                    "sharing" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Sharing)
                    }
                    "showcase" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Showcase)
                    }
                    "sso" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Sso)
                    }
                    "team_folders" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::TeamFolders)
                    }
                    "team_policies" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::TeamPolicies)
                    }
                    "team_profile" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::TeamProfile)
                    }
                    "tfa" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Tfa)
                    }
                    "trusted_teams" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::TrustedTeams)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventCategory::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["apps",
                                    "comments",
                                    "devices",
                                    "domains",
                                    "file_operations",
                                    "file_requests",
                                    "groups",
                                    "legal_holds",
                                    "logins",
                                    "members",
                                    "paper",
                                    "passwords",
                                    "reports",
                                    "sharing",
                                    "showcase",
                                    "sso",
                                    "team_folders",
                                    "team_policies",
                                    "team_profile",
                                    "tfa",
                                    "trusted_teams",
                                    "other"];
        deserializer.deserialize_struct("EventCategory", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EventCategory {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EventCategory::Apps => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "apps")?;
                s.end()
            }
            EventCategory::Comments => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "comments")?;
                s.end()
            }
            EventCategory::Devices => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "devices")?;
                s.end()
            }
            EventCategory::Domains => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "domains")?;
                s.end()
            }
            EventCategory::FileOperations => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "file_operations")?;
                s.end()
            }
            EventCategory::FileRequests => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "file_requests")?;
                s.end()
            }
            EventCategory::Groups => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "groups")?;
                s.end()
            }
            EventCategory::LegalHolds => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "legal_holds")?;
                s.end()
            }
            EventCategory::Logins => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "logins")?;
                s.end()
            }
            EventCategory::Members => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "members")?;
                s.end()
            }
            EventCategory::Paper => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "paper")?;
                s.end()
            }
            EventCategory::Passwords => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "passwords")?;
                s.end()
            }
            EventCategory::Reports => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "reports")?;
                s.end()
            }
            EventCategory::Sharing => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "sharing")?;
                s.end()
            }
            EventCategory::Showcase => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "showcase")?;
                s.end()
            }
            EventCategory::Sso => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "sso")?;
                s.end()
            }
            EventCategory::TeamFolders => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "team_folders")?;
                s.end()
            }
            EventCategory::TeamPolicies => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "team_policies")?;
                s.end()
            }
            EventCategory::TeamProfile => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "team_profile")?;
                s.end()
            }
            EventCategory::Tfa => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "tfa")?;
                s.end()
            }
            EventCategory::TrustedTeams => {
                // unit
                let mut s = serializer.serialize_struct("EventCategory", 1)?;
                s.serialize_field(".tag", "trusted_teams")?;
                s.end()
            }
            EventCategory::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Additional fields depending on the event type.
#[derive(Debug)]
pub enum EventDetails {
    AppLinkTeamDetails(AppLinkTeamDetails),
    AppLinkUserDetails(AppLinkUserDetails),
    AppUnlinkTeamDetails(AppUnlinkTeamDetails),
    AppUnlinkUserDetails(AppUnlinkUserDetails),
    IntegrationConnectedDetails(IntegrationConnectedDetails),
    IntegrationDisconnectedDetails(IntegrationDisconnectedDetails),
    FileAddCommentDetails(FileAddCommentDetails),
    FileChangeCommentSubscriptionDetails(FileChangeCommentSubscriptionDetails),
    FileDeleteCommentDetails(FileDeleteCommentDetails),
    FileEditCommentDetails(FileEditCommentDetails),
    FileLikeCommentDetails(FileLikeCommentDetails),
    FileResolveCommentDetails(FileResolveCommentDetails),
    FileUnlikeCommentDetails(FileUnlikeCommentDetails),
    FileUnresolveCommentDetails(FileUnresolveCommentDetails),
    DeviceChangeIpDesktopDetails(DeviceChangeIpDesktopDetails),
    DeviceChangeIpMobileDetails(DeviceChangeIpMobileDetails),
    DeviceChangeIpWebDetails(DeviceChangeIpWebDetails),
    DeviceDeleteOnUnlinkFailDetails(DeviceDeleteOnUnlinkFailDetails),
    DeviceDeleteOnUnlinkSuccessDetails(DeviceDeleteOnUnlinkSuccessDetails),
    DeviceLinkFailDetails(DeviceLinkFailDetails),
    DeviceLinkSuccessDetails(DeviceLinkSuccessDetails),
    DeviceManagementDisabledDetails(DeviceManagementDisabledDetails),
    DeviceManagementEnabledDetails(DeviceManagementEnabledDetails),
    DeviceUnlinkDetails(DeviceUnlinkDetails),
    EmmRefreshAuthTokenDetails(EmmRefreshAuthTokenDetails),
    AccountCaptureChangeAvailabilityDetails(AccountCaptureChangeAvailabilityDetails),
    AccountCaptureMigrateAccountDetails(AccountCaptureMigrateAccountDetails),
    AccountCaptureNotificationEmailsSentDetails(AccountCaptureNotificationEmailsSentDetails),
    AccountCaptureRelinquishAccountDetails(AccountCaptureRelinquishAccountDetails),
    DisabledDomainInvitesDetails(DisabledDomainInvitesDetails),
    DomainInvitesApproveRequestToJoinTeamDetails(DomainInvitesApproveRequestToJoinTeamDetails),
    DomainInvitesDeclineRequestToJoinTeamDetails(DomainInvitesDeclineRequestToJoinTeamDetails),
    DomainInvitesEmailExistingUsersDetails(DomainInvitesEmailExistingUsersDetails),
    DomainInvitesRequestToJoinTeamDetails(DomainInvitesRequestToJoinTeamDetails),
    DomainInvitesSetInviteNewUserPrefToNoDetails(DomainInvitesSetInviteNewUserPrefToNoDetails),
    DomainInvitesSetInviteNewUserPrefToYesDetails(DomainInvitesSetInviteNewUserPrefToYesDetails),
    DomainVerificationAddDomainFailDetails(DomainVerificationAddDomainFailDetails),
    DomainVerificationAddDomainSuccessDetails(DomainVerificationAddDomainSuccessDetails),
    DomainVerificationRemoveDomainDetails(DomainVerificationRemoveDomainDetails),
    EnabledDomainInvitesDetails(EnabledDomainInvitesDetails),
    CreateFolderDetails(CreateFolderDetails),
    FileAddDetails(FileAddDetails),
    FileCopyDetails(FileCopyDetails),
    FileDeleteDetails(FileDeleteDetails),
    FileDownloadDetails(FileDownloadDetails),
    FileEditDetails(FileEditDetails),
    FileGetCopyReferenceDetails(FileGetCopyReferenceDetails),
    FileLockingLockStatusChangedDetails(FileLockingLockStatusChangedDetails),
    FileMoveDetails(FileMoveDetails),
    FilePermanentlyDeleteDetails(FilePermanentlyDeleteDetails),
    FilePreviewDetails(FilePreviewDetails),
    FileRenameDetails(FileRenameDetails),
    FileRestoreDetails(FileRestoreDetails),
    FileRevertDetails(FileRevertDetails),
    FileRollbackChangesDetails(FileRollbackChangesDetails),
    FileSaveCopyReferenceDetails(FileSaveCopyReferenceDetails),
    FolderOverviewDescriptionChangedDetails(FolderOverviewDescriptionChangedDetails),
    FolderOverviewItemPinnedDetails(FolderOverviewItemPinnedDetails),
    FolderOverviewItemUnpinnedDetails(FolderOverviewItemUnpinnedDetails),
    RewindFolderDetails(RewindFolderDetails),
    FileRequestChangeDetails(FileRequestChangeDetails),
    FileRequestCloseDetails(FileRequestCloseDetails),
    FileRequestCreateDetails(FileRequestCreateDetails),
    FileRequestDeleteDetails(FileRequestDeleteDetails),
    FileRequestReceiveFileDetails(FileRequestReceiveFileDetails),
    GroupAddExternalIdDetails(GroupAddExternalIdDetails),
    GroupAddMemberDetails(GroupAddMemberDetails),
    GroupChangeExternalIdDetails(GroupChangeExternalIdDetails),
    GroupChangeManagementTypeDetails(GroupChangeManagementTypeDetails),
    GroupChangeMemberRoleDetails(GroupChangeMemberRoleDetails),
    GroupCreateDetails(GroupCreateDetails),
    GroupDeleteDetails(GroupDeleteDetails),
    GroupDescriptionUpdatedDetails(GroupDescriptionUpdatedDetails),
    GroupJoinPolicyUpdatedDetails(GroupJoinPolicyUpdatedDetails),
    GroupMovedDetails(GroupMovedDetails),
    GroupRemoveExternalIdDetails(GroupRemoveExternalIdDetails),
    GroupRemoveMemberDetails(GroupRemoveMemberDetails),
    GroupRenameDetails(GroupRenameDetails),
    LegalHoldsActivateAHoldDetails(LegalHoldsActivateAHoldDetails),
    LegalHoldsAddMembersDetails(LegalHoldsAddMembersDetails),
    LegalHoldsChangeHoldDetailsDetails(LegalHoldsChangeHoldDetailsDetails),
    LegalHoldsChangeHoldNameDetails(LegalHoldsChangeHoldNameDetails),
    LegalHoldsExportAHoldDetails(LegalHoldsExportAHoldDetails),
    LegalHoldsExportCancelledDetails(LegalHoldsExportCancelledDetails),
    LegalHoldsExportDownloadedDetails(LegalHoldsExportDownloadedDetails),
    LegalHoldsExportRemovedDetails(LegalHoldsExportRemovedDetails),
    LegalHoldsReleaseAHoldDetails(LegalHoldsReleaseAHoldDetails),
    LegalHoldsRemoveMembersDetails(LegalHoldsRemoveMembersDetails),
    LegalHoldsReportAHoldDetails(LegalHoldsReportAHoldDetails),
    AccountLockOrUnlockedDetails(AccountLockOrUnlockedDetails),
    EmmErrorDetails(EmmErrorDetails),
    GuestAdminSignedInViaTrustedTeamsDetails(GuestAdminSignedInViaTrustedTeamsDetails),
    GuestAdminSignedOutViaTrustedTeamsDetails(GuestAdminSignedOutViaTrustedTeamsDetails),
    LoginFailDetails(LoginFailDetails),
    LoginSuccessDetails(LoginSuccessDetails),
    LogoutDetails(LogoutDetails),
    ResellerSupportSessionEndDetails(ResellerSupportSessionEndDetails),
    ResellerSupportSessionStartDetails(ResellerSupportSessionStartDetails),
    SignInAsSessionEndDetails(SignInAsSessionEndDetails),
    SignInAsSessionStartDetails(SignInAsSessionStartDetails),
    SsoErrorDetails(SsoErrorDetails),
    CreateTeamInviteLinkDetails(CreateTeamInviteLinkDetails),
    DeleteTeamInviteLinkDetails(DeleteTeamInviteLinkDetails),
    MemberAddExternalIdDetails(MemberAddExternalIdDetails),
    MemberAddNameDetails(MemberAddNameDetails),
    MemberChangeAdminRoleDetails(MemberChangeAdminRoleDetails),
    MemberChangeEmailDetails(MemberChangeEmailDetails),
    MemberChangeExternalIdDetails(MemberChangeExternalIdDetails),
    MemberChangeMembershipTypeDetails(MemberChangeMembershipTypeDetails),
    MemberChangeNameDetails(MemberChangeNameDetails),
    MemberChangeStatusDetails(MemberChangeStatusDetails),
    MemberDeleteManualContactsDetails(MemberDeleteManualContactsDetails),
    MemberDeleteProfilePhotoDetails(MemberDeleteProfilePhotoDetails),
    MemberPermanentlyDeleteAccountContentsDetails(MemberPermanentlyDeleteAccountContentsDetails),
    MemberRemoveExternalIdDetails(MemberRemoveExternalIdDetails),
    MemberSetProfilePhotoDetails(MemberSetProfilePhotoDetails),
    MemberSpaceLimitsAddCustomQuotaDetails(MemberSpaceLimitsAddCustomQuotaDetails),
    MemberSpaceLimitsChangeCustomQuotaDetails(MemberSpaceLimitsChangeCustomQuotaDetails),
    MemberSpaceLimitsChangeStatusDetails(MemberSpaceLimitsChangeStatusDetails),
    MemberSpaceLimitsRemoveCustomQuotaDetails(MemberSpaceLimitsRemoveCustomQuotaDetails),
    MemberSuggestDetails(MemberSuggestDetails),
    MemberTransferAccountContentsDetails(MemberTransferAccountContentsDetails),
    PendingSecondaryEmailAddedDetails(PendingSecondaryEmailAddedDetails),
    SecondaryEmailDeletedDetails(SecondaryEmailDeletedDetails),
    SecondaryEmailVerifiedDetails(SecondaryEmailVerifiedDetails),
    SecondaryMailsPolicyChangedDetails(SecondaryMailsPolicyChangedDetails),
    BinderAddPageDetails(BinderAddPageDetails),
    BinderAddSectionDetails(BinderAddSectionDetails),
    BinderRemovePageDetails(BinderRemovePageDetails),
    BinderRemoveSectionDetails(BinderRemoveSectionDetails),
    BinderRenamePageDetails(BinderRenamePageDetails),
    BinderRenameSectionDetails(BinderRenameSectionDetails),
    BinderReorderPageDetails(BinderReorderPageDetails),
    BinderReorderSectionDetails(BinderReorderSectionDetails),
    PaperContentAddMemberDetails(PaperContentAddMemberDetails),
    PaperContentAddToFolderDetails(PaperContentAddToFolderDetails),
    PaperContentArchiveDetails(PaperContentArchiveDetails),
    PaperContentCreateDetails(PaperContentCreateDetails),
    PaperContentPermanentlyDeleteDetails(PaperContentPermanentlyDeleteDetails),
    PaperContentRemoveFromFolderDetails(PaperContentRemoveFromFolderDetails),
    PaperContentRemoveMemberDetails(PaperContentRemoveMemberDetails),
    PaperContentRenameDetails(PaperContentRenameDetails),
    PaperContentRestoreDetails(PaperContentRestoreDetails),
    PaperDocAddCommentDetails(PaperDocAddCommentDetails),
    PaperDocChangeMemberRoleDetails(PaperDocChangeMemberRoleDetails),
    PaperDocChangeSharingPolicyDetails(PaperDocChangeSharingPolicyDetails),
    PaperDocChangeSubscriptionDetails(PaperDocChangeSubscriptionDetails),
    PaperDocDeletedDetails(PaperDocDeletedDetails),
    PaperDocDeleteCommentDetails(PaperDocDeleteCommentDetails),
    PaperDocDownloadDetails(PaperDocDownloadDetails),
    PaperDocEditDetails(PaperDocEditDetails),
    PaperDocEditCommentDetails(PaperDocEditCommentDetails),
    PaperDocFollowedDetails(PaperDocFollowedDetails),
    PaperDocMentionDetails(PaperDocMentionDetails),
    PaperDocOwnershipChangedDetails(PaperDocOwnershipChangedDetails),
    PaperDocRequestAccessDetails(PaperDocRequestAccessDetails),
    PaperDocResolveCommentDetails(PaperDocResolveCommentDetails),
    PaperDocRevertDetails(PaperDocRevertDetails),
    PaperDocSlackShareDetails(PaperDocSlackShareDetails),
    PaperDocTeamInviteDetails(PaperDocTeamInviteDetails),
    PaperDocTrashedDetails(PaperDocTrashedDetails),
    PaperDocUnresolveCommentDetails(PaperDocUnresolveCommentDetails),
    PaperDocUntrashedDetails(PaperDocUntrashedDetails),
    PaperDocViewDetails(PaperDocViewDetails),
    PaperExternalViewAllowDetails(PaperExternalViewAllowDetails),
    PaperExternalViewDefaultTeamDetails(PaperExternalViewDefaultTeamDetails),
    PaperExternalViewForbidDetails(PaperExternalViewForbidDetails),
    PaperFolderChangeSubscriptionDetails(PaperFolderChangeSubscriptionDetails),
    PaperFolderDeletedDetails(PaperFolderDeletedDetails),
    PaperFolderFollowedDetails(PaperFolderFollowedDetails),
    PaperFolderTeamInviteDetails(PaperFolderTeamInviteDetails),
    PaperPublishedLinkChangePermissionDetails(PaperPublishedLinkChangePermissionDetails),
    PaperPublishedLinkCreateDetails(PaperPublishedLinkCreateDetails),
    PaperPublishedLinkDisabledDetails(PaperPublishedLinkDisabledDetails),
    PaperPublishedLinkViewDetails(PaperPublishedLinkViewDetails),
    PasswordChangeDetails(PasswordChangeDetails),
    PasswordResetDetails(PasswordResetDetails),
    PasswordResetAllDetails(PasswordResetAllDetails),
    EmmCreateExceptionsReportDetails(EmmCreateExceptionsReportDetails),
    EmmCreateUsageReportDetails(EmmCreateUsageReportDetails),
    ExportMembersReportDetails(ExportMembersReportDetails),
    ExportMembersReportFailDetails(ExportMembersReportFailDetails),
    NoExpirationLinkGenCreateReportDetails(NoExpirationLinkGenCreateReportDetails),
    NoExpirationLinkGenReportFailedDetails(NoExpirationLinkGenReportFailedDetails),
    NoPasswordLinkGenCreateReportDetails(NoPasswordLinkGenCreateReportDetails),
    NoPasswordLinkGenReportFailedDetails(NoPasswordLinkGenReportFailedDetails),
    NoPasswordLinkViewCreateReportDetails(NoPasswordLinkViewCreateReportDetails),
    NoPasswordLinkViewReportFailedDetails(NoPasswordLinkViewReportFailedDetails),
    OutdatedLinkViewCreateReportDetails(OutdatedLinkViewCreateReportDetails),
    OutdatedLinkViewReportFailedDetails(OutdatedLinkViewReportFailedDetails),
    PaperAdminExportStartDetails(PaperAdminExportStartDetails),
    SmartSyncCreateAdminPrivilegeReportDetails(SmartSyncCreateAdminPrivilegeReportDetails),
    TeamActivityCreateReportDetails(TeamActivityCreateReportDetails),
    TeamActivityCreateReportFailDetails(TeamActivityCreateReportFailDetails),
    CollectionShareDetails(CollectionShareDetails),
    FileTransfersFileAddDetails(FileTransfersFileAddDetails),
    FileTransfersTransferDeleteDetails(FileTransfersTransferDeleteDetails),
    FileTransfersTransferDownloadDetails(FileTransfersTransferDownloadDetails),
    FileTransfersTransferSendDetails(FileTransfersTransferSendDetails),
    FileTransfersTransferViewDetails(FileTransfersTransferViewDetails),
    NoteAclInviteOnlyDetails(NoteAclInviteOnlyDetails),
    NoteAclLinkDetails(NoteAclLinkDetails),
    NoteAclTeamLinkDetails(NoteAclTeamLinkDetails),
    NoteSharedDetails(NoteSharedDetails),
    NoteShareReceiveDetails(NoteShareReceiveDetails),
    OpenNoteSharedDetails(OpenNoteSharedDetails),
    SfAddGroupDetails(SfAddGroupDetails),
    SfAllowNonMembersToViewSharedLinksDetails(SfAllowNonMembersToViewSharedLinksDetails),
    SfExternalInviteWarnDetails(SfExternalInviteWarnDetails),
    SfFbInviteDetails(SfFbInviteDetails),
    SfFbInviteChangeRoleDetails(SfFbInviteChangeRoleDetails),
    SfFbUninviteDetails(SfFbUninviteDetails),
    SfInviteGroupDetails(SfInviteGroupDetails),
    SfTeamGrantAccessDetails(SfTeamGrantAccessDetails),
    SfTeamInviteDetails(SfTeamInviteDetails),
    SfTeamInviteChangeRoleDetails(SfTeamInviteChangeRoleDetails),
    SfTeamJoinDetails(SfTeamJoinDetails),
    SfTeamJoinFromOobLinkDetails(SfTeamJoinFromOobLinkDetails),
    SfTeamUninviteDetails(SfTeamUninviteDetails),
    SharedContentAddInviteesDetails(SharedContentAddInviteesDetails),
    SharedContentAddLinkExpiryDetails(SharedContentAddLinkExpiryDetails),
    SharedContentAddLinkPasswordDetails(SharedContentAddLinkPasswordDetails),
    SharedContentAddMemberDetails(SharedContentAddMemberDetails),
    SharedContentChangeDownloadsPolicyDetails(SharedContentChangeDownloadsPolicyDetails),
    SharedContentChangeInviteeRoleDetails(SharedContentChangeInviteeRoleDetails),
    SharedContentChangeLinkAudienceDetails(SharedContentChangeLinkAudienceDetails),
    SharedContentChangeLinkExpiryDetails(SharedContentChangeLinkExpiryDetails),
    SharedContentChangeLinkPasswordDetails(SharedContentChangeLinkPasswordDetails),
    SharedContentChangeMemberRoleDetails(SharedContentChangeMemberRoleDetails),
    SharedContentChangeViewerInfoPolicyDetails(SharedContentChangeViewerInfoPolicyDetails),
    SharedContentClaimInvitationDetails(SharedContentClaimInvitationDetails),
    SharedContentCopyDetails(SharedContentCopyDetails),
    SharedContentDownloadDetails(SharedContentDownloadDetails),
    SharedContentRelinquishMembershipDetails(SharedContentRelinquishMembershipDetails),
    SharedContentRemoveInviteesDetails(SharedContentRemoveInviteesDetails),
    SharedContentRemoveLinkExpiryDetails(SharedContentRemoveLinkExpiryDetails),
    SharedContentRemoveLinkPasswordDetails(SharedContentRemoveLinkPasswordDetails),
    SharedContentRemoveMemberDetails(SharedContentRemoveMemberDetails),
    SharedContentRequestAccessDetails(SharedContentRequestAccessDetails),
    SharedContentRestoreInviteesDetails(SharedContentRestoreInviteesDetails),
    SharedContentRestoreMemberDetails(SharedContentRestoreMemberDetails),
    SharedContentUnshareDetails(SharedContentUnshareDetails),
    SharedContentViewDetails(SharedContentViewDetails),
    SharedFolderChangeLinkPolicyDetails(SharedFolderChangeLinkPolicyDetails),
    SharedFolderChangeMembersInheritancePolicyDetails(SharedFolderChangeMembersInheritancePolicyDetails),
    SharedFolderChangeMembersManagementPolicyDetails(SharedFolderChangeMembersManagementPolicyDetails),
    SharedFolderChangeMembersPolicyDetails(SharedFolderChangeMembersPolicyDetails),
    SharedFolderCreateDetails(SharedFolderCreateDetails),
    SharedFolderDeclineInvitationDetails(SharedFolderDeclineInvitationDetails),
    SharedFolderMountDetails(SharedFolderMountDetails),
    SharedFolderNestDetails(SharedFolderNestDetails),
    SharedFolderTransferOwnershipDetails(SharedFolderTransferOwnershipDetails),
    SharedFolderUnmountDetails(SharedFolderUnmountDetails),
    SharedLinkAddExpiryDetails(SharedLinkAddExpiryDetails),
    SharedLinkChangeExpiryDetails(SharedLinkChangeExpiryDetails),
    SharedLinkChangeVisibilityDetails(SharedLinkChangeVisibilityDetails),
    SharedLinkCopyDetails(SharedLinkCopyDetails),
    SharedLinkCreateDetails(SharedLinkCreateDetails),
    SharedLinkDisableDetails(SharedLinkDisableDetails),
    SharedLinkDownloadDetails(SharedLinkDownloadDetails),
    SharedLinkRemoveExpiryDetails(SharedLinkRemoveExpiryDetails),
    SharedLinkSettingsAddExpirationDetails(SharedLinkSettingsAddExpirationDetails),
    SharedLinkSettingsAddPasswordDetails(SharedLinkSettingsAddPasswordDetails),
    SharedLinkSettingsAllowDownloadDisabledDetails(SharedLinkSettingsAllowDownloadDisabledDetails),
    SharedLinkSettingsAllowDownloadEnabledDetails(SharedLinkSettingsAllowDownloadEnabledDetails),
    SharedLinkSettingsChangeAudienceDetails(SharedLinkSettingsChangeAudienceDetails),
    SharedLinkSettingsChangeExpirationDetails(SharedLinkSettingsChangeExpirationDetails),
    SharedLinkSettingsChangePasswordDetails(SharedLinkSettingsChangePasswordDetails),
    SharedLinkSettingsRemoveExpirationDetails(SharedLinkSettingsRemoveExpirationDetails),
    SharedLinkSettingsRemovePasswordDetails(SharedLinkSettingsRemovePasswordDetails),
    SharedLinkShareDetails(SharedLinkShareDetails),
    SharedLinkViewDetails(SharedLinkViewDetails),
    SharedNoteOpenedDetails(SharedNoteOpenedDetails),
    ShmodelGroupShareDetails(ShmodelGroupShareDetails),
    ShowcaseAccessGrantedDetails(ShowcaseAccessGrantedDetails),
    ShowcaseAddMemberDetails(ShowcaseAddMemberDetails),
    ShowcaseArchivedDetails(ShowcaseArchivedDetails),
    ShowcaseCreatedDetails(ShowcaseCreatedDetails),
    ShowcaseDeleteCommentDetails(ShowcaseDeleteCommentDetails),
    ShowcaseEditedDetails(ShowcaseEditedDetails),
    ShowcaseEditCommentDetails(ShowcaseEditCommentDetails),
    ShowcaseFileAddedDetails(ShowcaseFileAddedDetails),
    ShowcaseFileDownloadDetails(ShowcaseFileDownloadDetails),
    ShowcaseFileRemovedDetails(ShowcaseFileRemovedDetails),
    ShowcaseFileViewDetails(ShowcaseFileViewDetails),
    ShowcasePermanentlyDeletedDetails(ShowcasePermanentlyDeletedDetails),
    ShowcasePostCommentDetails(ShowcasePostCommentDetails),
    ShowcaseRemoveMemberDetails(ShowcaseRemoveMemberDetails),
    ShowcaseRenamedDetails(ShowcaseRenamedDetails),
    ShowcaseRequestAccessDetails(ShowcaseRequestAccessDetails),
    ShowcaseResolveCommentDetails(ShowcaseResolveCommentDetails),
    ShowcaseRestoredDetails(ShowcaseRestoredDetails),
    ShowcaseTrashedDetails(ShowcaseTrashedDetails),
    ShowcaseTrashedDeprecatedDetails(ShowcaseTrashedDeprecatedDetails),
    ShowcaseUnresolveCommentDetails(ShowcaseUnresolveCommentDetails),
    ShowcaseUntrashedDetails(ShowcaseUntrashedDetails),
    ShowcaseUntrashedDeprecatedDetails(ShowcaseUntrashedDeprecatedDetails),
    ShowcaseViewDetails(ShowcaseViewDetails),
    SsoAddCertDetails(SsoAddCertDetails),
    SsoAddLoginUrlDetails(SsoAddLoginUrlDetails),
    SsoAddLogoutUrlDetails(SsoAddLogoutUrlDetails),
    SsoChangeCertDetails(SsoChangeCertDetails),
    SsoChangeLoginUrlDetails(SsoChangeLoginUrlDetails),
    SsoChangeLogoutUrlDetails(SsoChangeLogoutUrlDetails),
    SsoChangeSamlIdentityModeDetails(SsoChangeSamlIdentityModeDetails),
    SsoRemoveCertDetails(SsoRemoveCertDetails),
    SsoRemoveLoginUrlDetails(SsoRemoveLoginUrlDetails),
    SsoRemoveLogoutUrlDetails(SsoRemoveLogoutUrlDetails),
    TeamFolderChangeStatusDetails(TeamFolderChangeStatusDetails),
    TeamFolderCreateDetails(TeamFolderCreateDetails),
    TeamFolderDowngradeDetails(TeamFolderDowngradeDetails),
    TeamFolderPermanentlyDeleteDetails(TeamFolderPermanentlyDeleteDetails),
    TeamFolderRenameDetails(TeamFolderRenameDetails),
    TeamSelectiveSyncSettingsChangedDetails(TeamSelectiveSyncSettingsChangedDetails),
    AccountCaptureChangePolicyDetails(AccountCaptureChangePolicyDetails),
    AllowDownloadDisabledDetails(AllowDownloadDisabledDetails),
    AllowDownloadEnabledDetails(AllowDownloadEnabledDetails),
    CameraUploadsPolicyChangedDetails(CameraUploadsPolicyChangedDetails),
    DataPlacementRestrictionChangePolicyDetails(DataPlacementRestrictionChangePolicyDetails),
    DataPlacementRestrictionSatisfyPolicyDetails(DataPlacementRestrictionSatisfyPolicyDetails),
    DeviceApprovalsAddExceptionDetails(DeviceApprovalsAddExceptionDetails),
    DeviceApprovalsChangeDesktopPolicyDetails(DeviceApprovalsChangeDesktopPolicyDetails),
    DeviceApprovalsChangeMobilePolicyDetails(DeviceApprovalsChangeMobilePolicyDetails),
    DeviceApprovalsChangeOverageActionDetails(DeviceApprovalsChangeOverageActionDetails),
    DeviceApprovalsChangeUnlinkActionDetails(DeviceApprovalsChangeUnlinkActionDetails),
    DeviceApprovalsRemoveExceptionDetails(DeviceApprovalsRemoveExceptionDetails),
    DirectoryRestrictionsAddMembersDetails(DirectoryRestrictionsAddMembersDetails),
    DirectoryRestrictionsRemoveMembersDetails(DirectoryRestrictionsRemoveMembersDetails),
    EmmAddExceptionDetails(EmmAddExceptionDetails),
    EmmChangePolicyDetails(EmmChangePolicyDetails),
    EmmRemoveExceptionDetails(EmmRemoveExceptionDetails),
    ExtendedVersionHistoryChangePolicyDetails(ExtendedVersionHistoryChangePolicyDetails),
    FileCommentsChangePolicyDetails(FileCommentsChangePolicyDetails),
    FileLockingPolicyChangedDetails(FileLockingPolicyChangedDetails),
    FileRequestsChangePolicyDetails(FileRequestsChangePolicyDetails),
    FileRequestsEmailsEnabledDetails(FileRequestsEmailsEnabledDetails),
    FileRequestsEmailsRestrictedToTeamOnlyDetails(FileRequestsEmailsRestrictedToTeamOnlyDetails),
    FileTransfersPolicyChangedDetails(FileTransfersPolicyChangedDetails),
    GoogleSsoChangePolicyDetails(GoogleSsoChangePolicyDetails),
    GroupUserManagementChangePolicyDetails(GroupUserManagementChangePolicyDetails),
    IntegrationPolicyChangedDetails(IntegrationPolicyChangedDetails),
    MemberRequestsChangePolicyDetails(MemberRequestsChangePolicyDetails),
    MemberSendInvitePolicyChangedDetails(MemberSendInvitePolicyChangedDetails),
    MemberSpaceLimitsAddExceptionDetails(MemberSpaceLimitsAddExceptionDetails),
    MemberSpaceLimitsChangeCapsTypePolicyDetails(MemberSpaceLimitsChangeCapsTypePolicyDetails),
    MemberSpaceLimitsChangePolicyDetails(MemberSpaceLimitsChangePolicyDetails),
    MemberSpaceLimitsRemoveExceptionDetails(MemberSpaceLimitsRemoveExceptionDetails),
    MemberSuggestionsChangePolicyDetails(MemberSuggestionsChangePolicyDetails),
    MicrosoftOfficeAddinChangePolicyDetails(MicrosoftOfficeAddinChangePolicyDetails),
    NetworkControlChangePolicyDetails(NetworkControlChangePolicyDetails),
    PaperChangeDeploymentPolicyDetails(PaperChangeDeploymentPolicyDetails),
    PaperChangeMemberLinkPolicyDetails(PaperChangeMemberLinkPolicyDetails),
    PaperChangeMemberPolicyDetails(PaperChangeMemberPolicyDetails),
    PaperChangePolicyDetails(PaperChangePolicyDetails),
    PaperDefaultFolderPolicyChangedDetails(PaperDefaultFolderPolicyChangedDetails),
    PaperDesktopPolicyChangedDetails(PaperDesktopPolicyChangedDetails),
    PaperEnabledUsersGroupAdditionDetails(PaperEnabledUsersGroupAdditionDetails),
    PaperEnabledUsersGroupRemovalDetails(PaperEnabledUsersGroupRemovalDetails),
    PasswordStrengthRequirementsChangePolicyDetails(PasswordStrengthRequirementsChangePolicyDetails),
    PermanentDeleteChangePolicyDetails(PermanentDeleteChangePolicyDetails),
    ResellerSupportChangePolicyDetails(ResellerSupportChangePolicyDetails),
    RewindPolicyChangedDetails(RewindPolicyChangedDetails),
    SharingChangeFolderJoinPolicyDetails(SharingChangeFolderJoinPolicyDetails),
    SharingChangeLinkPolicyDetails(SharingChangeLinkPolicyDetails),
    SharingChangeMemberPolicyDetails(SharingChangeMemberPolicyDetails),
    ShowcaseChangeDownloadPolicyDetails(ShowcaseChangeDownloadPolicyDetails),
    ShowcaseChangeEnabledPolicyDetails(ShowcaseChangeEnabledPolicyDetails),
    ShowcaseChangeExternalSharingPolicyDetails(ShowcaseChangeExternalSharingPolicyDetails),
    SmarterSmartSyncPolicyChangedDetails(SmarterSmartSyncPolicyChangedDetails),
    SmartSyncChangePolicyDetails(SmartSyncChangePolicyDetails),
    SmartSyncNotOptOutDetails(SmartSyncNotOptOutDetails),
    SmartSyncOptOutDetails(SmartSyncOptOutDetails),
    SsoChangePolicyDetails(SsoChangePolicyDetails),
    TeamExtensionsPolicyChangedDetails(TeamExtensionsPolicyChangedDetails),
    TeamSelectiveSyncPolicyChangedDetails(TeamSelectiveSyncPolicyChangedDetails),
    TeamSharingWhitelistSubjectsChangedDetails(TeamSharingWhitelistSubjectsChangedDetails),
    TfaAddExceptionDetails(TfaAddExceptionDetails),
    TfaChangePolicyDetails(TfaChangePolicyDetails),
    TfaRemoveExceptionDetails(TfaRemoveExceptionDetails),
    TwoAccountChangePolicyDetails(TwoAccountChangePolicyDetails),
    ViewerInfoPolicyChangedDetails(ViewerInfoPolicyChangedDetails),
    WatermarkingPolicyChangedDetails(WatermarkingPolicyChangedDetails),
    WebSessionsChangeActiveSessionLimitDetails(WebSessionsChangeActiveSessionLimitDetails),
    WebSessionsChangeFixedLengthPolicyDetails(WebSessionsChangeFixedLengthPolicyDetails),
    WebSessionsChangeIdleLengthPolicyDetails(WebSessionsChangeIdleLengthPolicyDetails),
    TeamMergeFromDetails(TeamMergeFromDetails),
    TeamMergeToDetails(TeamMergeToDetails),
    TeamProfileAddLogoDetails(TeamProfileAddLogoDetails),
    TeamProfileChangeDefaultLanguageDetails(TeamProfileChangeDefaultLanguageDetails),
    TeamProfileChangeLogoDetails(TeamProfileChangeLogoDetails),
    TeamProfileChangeNameDetails(TeamProfileChangeNameDetails),
    TeamProfileRemoveLogoDetails(TeamProfileRemoveLogoDetails),
    TfaAddBackupPhoneDetails(TfaAddBackupPhoneDetails),
    TfaAddSecurityKeyDetails(TfaAddSecurityKeyDetails),
    TfaChangeBackupPhoneDetails(TfaChangeBackupPhoneDetails),
    TfaChangeStatusDetails(TfaChangeStatusDetails),
    TfaRemoveBackupPhoneDetails(TfaRemoveBackupPhoneDetails),
    TfaRemoveSecurityKeyDetails(TfaRemoveSecurityKeyDetails),
    TfaResetDetails(TfaResetDetails),
    ChangedEnterpriseAdminRoleDetails(ChangedEnterpriseAdminRoleDetails),
    ChangedEnterpriseConnectedTeamStatusDetails(ChangedEnterpriseConnectedTeamStatusDetails),
    EndedEnterpriseAdminSessionDetails(EndedEnterpriseAdminSessionDetails),
    EndedEnterpriseAdminSessionDeprecatedDetails(EndedEnterpriseAdminSessionDeprecatedDetails),
    EnterpriseSettingsLockingDetails(EnterpriseSettingsLockingDetails),
    GuestAdminChangeStatusDetails(GuestAdminChangeStatusDetails),
    StartedEnterpriseAdminSessionDetails(StartedEnterpriseAdminSessionDetails),
    TeamMergeRequestAcceptedDetails(TeamMergeRequestAcceptedDetails),
    TeamMergeRequestAcceptedShownToPrimaryTeamDetails(TeamMergeRequestAcceptedShownToPrimaryTeamDetails),
    TeamMergeRequestAcceptedShownToSecondaryTeamDetails(TeamMergeRequestAcceptedShownToSecondaryTeamDetails),
    TeamMergeRequestAutoCanceledDetails(TeamMergeRequestAutoCanceledDetails),
    TeamMergeRequestCanceledDetails(TeamMergeRequestCanceledDetails),
    TeamMergeRequestCanceledShownToPrimaryTeamDetails(TeamMergeRequestCanceledShownToPrimaryTeamDetails),
    TeamMergeRequestCanceledShownToSecondaryTeamDetails(TeamMergeRequestCanceledShownToSecondaryTeamDetails),
    TeamMergeRequestExpiredDetails(TeamMergeRequestExpiredDetails),
    TeamMergeRequestExpiredShownToPrimaryTeamDetails(TeamMergeRequestExpiredShownToPrimaryTeamDetails),
    TeamMergeRequestExpiredShownToSecondaryTeamDetails(TeamMergeRequestExpiredShownToSecondaryTeamDetails),
    TeamMergeRequestRejectedShownToPrimaryTeamDetails(TeamMergeRequestRejectedShownToPrimaryTeamDetails),
    TeamMergeRequestRejectedShownToSecondaryTeamDetails(TeamMergeRequestRejectedShownToSecondaryTeamDetails),
    TeamMergeRequestReminderDetails(TeamMergeRequestReminderDetails),
    TeamMergeRequestReminderShownToPrimaryTeamDetails(TeamMergeRequestReminderShownToPrimaryTeamDetails),
    TeamMergeRequestReminderShownToSecondaryTeamDetails(TeamMergeRequestReminderShownToSecondaryTeamDetails),
    TeamMergeRequestRevokedDetails(TeamMergeRequestRevokedDetails),
    TeamMergeRequestSentShownToPrimaryTeamDetails(TeamMergeRequestSentShownToPrimaryTeamDetails),
    TeamMergeRequestSentShownToSecondaryTeamDetails(TeamMergeRequestSentShownToSecondaryTeamDetails),
    /// Hints that this event was returned with missing details due to an internal error.
    MissingDetails(MissingDetails),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EventDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EventDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EventDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "app_link_team_details" => Ok(EventDetails::AppLinkTeamDetails(AppLinkTeamDetails::internal_deserialize(map)?)),
                    "app_link_user_details" => Ok(EventDetails::AppLinkUserDetails(AppLinkUserDetails::internal_deserialize(map)?)),
                    "app_unlink_team_details" => Ok(EventDetails::AppUnlinkTeamDetails(AppUnlinkTeamDetails::internal_deserialize(map)?)),
                    "app_unlink_user_details" => Ok(EventDetails::AppUnlinkUserDetails(AppUnlinkUserDetails::internal_deserialize(map)?)),
                    "integration_connected_details" => Ok(EventDetails::IntegrationConnectedDetails(IntegrationConnectedDetails::internal_deserialize(map)?)),
                    "integration_disconnected_details" => Ok(EventDetails::IntegrationDisconnectedDetails(IntegrationDisconnectedDetails::internal_deserialize(map)?)),
                    "file_add_comment_details" => Ok(EventDetails::FileAddCommentDetails(FileAddCommentDetails::internal_deserialize(map)?)),
                    "file_change_comment_subscription_details" => Ok(EventDetails::FileChangeCommentSubscriptionDetails(FileChangeCommentSubscriptionDetails::internal_deserialize(map)?)),
                    "file_delete_comment_details" => Ok(EventDetails::FileDeleteCommentDetails(FileDeleteCommentDetails::internal_deserialize(map)?)),
                    "file_edit_comment_details" => Ok(EventDetails::FileEditCommentDetails(FileEditCommentDetails::internal_deserialize(map)?)),
                    "file_like_comment_details" => Ok(EventDetails::FileLikeCommentDetails(FileLikeCommentDetails::internal_deserialize(map)?)),
                    "file_resolve_comment_details" => Ok(EventDetails::FileResolveCommentDetails(FileResolveCommentDetails::internal_deserialize(map)?)),
                    "file_unlike_comment_details" => Ok(EventDetails::FileUnlikeCommentDetails(FileUnlikeCommentDetails::internal_deserialize(map)?)),
                    "file_unresolve_comment_details" => Ok(EventDetails::FileUnresolveCommentDetails(FileUnresolveCommentDetails::internal_deserialize(map)?)),
                    "device_change_ip_desktop_details" => Ok(EventDetails::DeviceChangeIpDesktopDetails(DeviceChangeIpDesktopDetails::internal_deserialize(map)?)),
                    "device_change_ip_mobile_details" => Ok(EventDetails::DeviceChangeIpMobileDetails(DeviceChangeIpMobileDetails::internal_deserialize(map)?)),
                    "device_change_ip_web_details" => Ok(EventDetails::DeviceChangeIpWebDetails(DeviceChangeIpWebDetails::internal_deserialize(map)?)),
                    "device_delete_on_unlink_fail_details" => Ok(EventDetails::DeviceDeleteOnUnlinkFailDetails(DeviceDeleteOnUnlinkFailDetails::internal_deserialize(map)?)),
                    "device_delete_on_unlink_success_details" => Ok(EventDetails::DeviceDeleteOnUnlinkSuccessDetails(DeviceDeleteOnUnlinkSuccessDetails::internal_deserialize(map)?)),
                    "device_link_fail_details" => Ok(EventDetails::DeviceLinkFailDetails(DeviceLinkFailDetails::internal_deserialize(map)?)),
                    "device_link_success_details" => Ok(EventDetails::DeviceLinkSuccessDetails(DeviceLinkSuccessDetails::internal_deserialize(map)?)),
                    "device_management_disabled_details" => Ok(EventDetails::DeviceManagementDisabledDetails(DeviceManagementDisabledDetails::internal_deserialize(map)?)),
                    "device_management_enabled_details" => Ok(EventDetails::DeviceManagementEnabledDetails(DeviceManagementEnabledDetails::internal_deserialize(map)?)),
                    "device_unlink_details" => Ok(EventDetails::DeviceUnlinkDetails(DeviceUnlinkDetails::internal_deserialize(map)?)),
                    "emm_refresh_auth_token_details" => Ok(EventDetails::EmmRefreshAuthTokenDetails(EmmRefreshAuthTokenDetails::internal_deserialize(map)?)),
                    "account_capture_change_availability_details" => Ok(EventDetails::AccountCaptureChangeAvailabilityDetails(AccountCaptureChangeAvailabilityDetails::internal_deserialize(map)?)),
                    "account_capture_migrate_account_details" => Ok(EventDetails::AccountCaptureMigrateAccountDetails(AccountCaptureMigrateAccountDetails::internal_deserialize(map)?)),
                    "account_capture_notification_emails_sent_details" => Ok(EventDetails::AccountCaptureNotificationEmailsSentDetails(AccountCaptureNotificationEmailsSentDetails::internal_deserialize(map)?)),
                    "account_capture_relinquish_account_details" => Ok(EventDetails::AccountCaptureRelinquishAccountDetails(AccountCaptureRelinquishAccountDetails::internal_deserialize(map)?)),
                    "disabled_domain_invites_details" => Ok(EventDetails::DisabledDomainInvitesDetails(DisabledDomainInvitesDetails::internal_deserialize(map)?)),
                    "domain_invites_approve_request_to_join_team_details" => Ok(EventDetails::DomainInvitesApproveRequestToJoinTeamDetails(DomainInvitesApproveRequestToJoinTeamDetails::internal_deserialize(map)?)),
                    "domain_invites_decline_request_to_join_team_details" => Ok(EventDetails::DomainInvitesDeclineRequestToJoinTeamDetails(DomainInvitesDeclineRequestToJoinTeamDetails::internal_deserialize(map)?)),
                    "domain_invites_email_existing_users_details" => Ok(EventDetails::DomainInvitesEmailExistingUsersDetails(DomainInvitesEmailExistingUsersDetails::internal_deserialize(map)?)),
                    "domain_invites_request_to_join_team_details" => Ok(EventDetails::DomainInvitesRequestToJoinTeamDetails(DomainInvitesRequestToJoinTeamDetails::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_no_details" => Ok(EventDetails::DomainInvitesSetInviteNewUserPrefToNoDetails(DomainInvitesSetInviteNewUserPrefToNoDetails::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_yes_details" => Ok(EventDetails::DomainInvitesSetInviteNewUserPrefToYesDetails(DomainInvitesSetInviteNewUserPrefToYesDetails::internal_deserialize(map)?)),
                    "domain_verification_add_domain_fail_details" => Ok(EventDetails::DomainVerificationAddDomainFailDetails(DomainVerificationAddDomainFailDetails::internal_deserialize(map)?)),
                    "domain_verification_add_domain_success_details" => Ok(EventDetails::DomainVerificationAddDomainSuccessDetails(DomainVerificationAddDomainSuccessDetails::internal_deserialize(map)?)),
                    "domain_verification_remove_domain_details" => Ok(EventDetails::DomainVerificationRemoveDomainDetails(DomainVerificationRemoveDomainDetails::internal_deserialize(map)?)),
                    "enabled_domain_invites_details" => Ok(EventDetails::EnabledDomainInvitesDetails(EnabledDomainInvitesDetails::internal_deserialize(map)?)),
                    "create_folder_details" => Ok(EventDetails::CreateFolderDetails(CreateFolderDetails::internal_deserialize(map)?)),
                    "file_add_details" => Ok(EventDetails::FileAddDetails(FileAddDetails::internal_deserialize(map)?)),
                    "file_copy_details" => Ok(EventDetails::FileCopyDetails(FileCopyDetails::internal_deserialize(map)?)),
                    "file_delete_details" => Ok(EventDetails::FileDeleteDetails(FileDeleteDetails::internal_deserialize(map)?)),
                    "file_download_details" => Ok(EventDetails::FileDownloadDetails(FileDownloadDetails::internal_deserialize(map)?)),
                    "file_edit_details" => Ok(EventDetails::FileEditDetails(FileEditDetails::internal_deserialize(map)?)),
                    "file_get_copy_reference_details" => Ok(EventDetails::FileGetCopyReferenceDetails(FileGetCopyReferenceDetails::internal_deserialize(map)?)),
                    "file_locking_lock_status_changed_details" => Ok(EventDetails::FileLockingLockStatusChangedDetails(FileLockingLockStatusChangedDetails::internal_deserialize(map)?)),
                    "file_move_details" => Ok(EventDetails::FileMoveDetails(FileMoveDetails::internal_deserialize(map)?)),
                    "file_permanently_delete_details" => Ok(EventDetails::FilePermanentlyDeleteDetails(FilePermanentlyDeleteDetails::internal_deserialize(map)?)),
                    "file_preview_details" => Ok(EventDetails::FilePreviewDetails(FilePreviewDetails::internal_deserialize(map)?)),
                    "file_rename_details" => Ok(EventDetails::FileRenameDetails(FileRenameDetails::internal_deserialize(map)?)),
                    "file_restore_details" => Ok(EventDetails::FileRestoreDetails(FileRestoreDetails::internal_deserialize(map)?)),
                    "file_revert_details" => Ok(EventDetails::FileRevertDetails(FileRevertDetails::internal_deserialize(map)?)),
                    "file_rollback_changes_details" => Ok(EventDetails::FileRollbackChangesDetails(FileRollbackChangesDetails::internal_deserialize(map)?)),
                    "file_save_copy_reference_details" => Ok(EventDetails::FileSaveCopyReferenceDetails(FileSaveCopyReferenceDetails::internal_deserialize(map)?)),
                    "folder_overview_description_changed_details" => Ok(EventDetails::FolderOverviewDescriptionChangedDetails(FolderOverviewDescriptionChangedDetails::internal_deserialize(map)?)),
                    "folder_overview_item_pinned_details" => Ok(EventDetails::FolderOverviewItemPinnedDetails(FolderOverviewItemPinnedDetails::internal_deserialize(map)?)),
                    "folder_overview_item_unpinned_details" => Ok(EventDetails::FolderOverviewItemUnpinnedDetails(FolderOverviewItemUnpinnedDetails::internal_deserialize(map)?)),
                    "rewind_folder_details" => Ok(EventDetails::RewindFolderDetails(RewindFolderDetails::internal_deserialize(map)?)),
                    "file_request_change_details" => Ok(EventDetails::FileRequestChangeDetails(FileRequestChangeDetails::internal_deserialize(map)?)),
                    "file_request_close_details" => Ok(EventDetails::FileRequestCloseDetails(FileRequestCloseDetails::internal_deserialize(map)?)),
                    "file_request_create_details" => Ok(EventDetails::FileRequestCreateDetails(FileRequestCreateDetails::internal_deserialize(map)?)),
                    "file_request_delete_details" => Ok(EventDetails::FileRequestDeleteDetails(FileRequestDeleteDetails::internal_deserialize(map)?)),
                    "file_request_receive_file_details" => Ok(EventDetails::FileRequestReceiveFileDetails(FileRequestReceiveFileDetails::internal_deserialize(map)?)),
                    "group_add_external_id_details" => Ok(EventDetails::GroupAddExternalIdDetails(GroupAddExternalIdDetails::internal_deserialize(map)?)),
                    "group_add_member_details" => Ok(EventDetails::GroupAddMemberDetails(GroupAddMemberDetails::internal_deserialize(map)?)),
                    "group_change_external_id_details" => Ok(EventDetails::GroupChangeExternalIdDetails(GroupChangeExternalIdDetails::internal_deserialize(map)?)),
                    "group_change_management_type_details" => Ok(EventDetails::GroupChangeManagementTypeDetails(GroupChangeManagementTypeDetails::internal_deserialize(map)?)),
                    "group_change_member_role_details" => Ok(EventDetails::GroupChangeMemberRoleDetails(GroupChangeMemberRoleDetails::internal_deserialize(map)?)),
                    "group_create_details" => Ok(EventDetails::GroupCreateDetails(GroupCreateDetails::internal_deserialize(map)?)),
                    "group_delete_details" => Ok(EventDetails::GroupDeleteDetails(GroupDeleteDetails::internal_deserialize(map)?)),
                    "group_description_updated_details" => Ok(EventDetails::GroupDescriptionUpdatedDetails(GroupDescriptionUpdatedDetails::internal_deserialize(map)?)),
                    "group_join_policy_updated_details" => Ok(EventDetails::GroupJoinPolicyUpdatedDetails(GroupJoinPolicyUpdatedDetails::internal_deserialize(map)?)),
                    "group_moved_details" => Ok(EventDetails::GroupMovedDetails(GroupMovedDetails::internal_deserialize(map)?)),
                    "group_remove_external_id_details" => Ok(EventDetails::GroupRemoveExternalIdDetails(GroupRemoveExternalIdDetails::internal_deserialize(map)?)),
                    "group_remove_member_details" => Ok(EventDetails::GroupRemoveMemberDetails(GroupRemoveMemberDetails::internal_deserialize(map)?)),
                    "group_rename_details" => Ok(EventDetails::GroupRenameDetails(GroupRenameDetails::internal_deserialize(map)?)),
                    "legal_holds_activate_a_hold_details" => Ok(EventDetails::LegalHoldsActivateAHoldDetails(LegalHoldsActivateAHoldDetails::internal_deserialize(map)?)),
                    "legal_holds_add_members_details" => Ok(EventDetails::LegalHoldsAddMembersDetails(LegalHoldsAddMembersDetails::internal_deserialize(map)?)),
                    "legal_holds_change_hold_details_details" => Ok(EventDetails::LegalHoldsChangeHoldDetailsDetails(LegalHoldsChangeHoldDetailsDetails::internal_deserialize(map)?)),
                    "legal_holds_change_hold_name_details" => Ok(EventDetails::LegalHoldsChangeHoldNameDetails(LegalHoldsChangeHoldNameDetails::internal_deserialize(map)?)),
                    "legal_holds_export_a_hold_details" => Ok(EventDetails::LegalHoldsExportAHoldDetails(LegalHoldsExportAHoldDetails::internal_deserialize(map)?)),
                    "legal_holds_export_cancelled_details" => Ok(EventDetails::LegalHoldsExportCancelledDetails(LegalHoldsExportCancelledDetails::internal_deserialize(map)?)),
                    "legal_holds_export_downloaded_details" => Ok(EventDetails::LegalHoldsExportDownloadedDetails(LegalHoldsExportDownloadedDetails::internal_deserialize(map)?)),
                    "legal_holds_export_removed_details" => Ok(EventDetails::LegalHoldsExportRemovedDetails(LegalHoldsExportRemovedDetails::internal_deserialize(map)?)),
                    "legal_holds_release_a_hold_details" => Ok(EventDetails::LegalHoldsReleaseAHoldDetails(LegalHoldsReleaseAHoldDetails::internal_deserialize(map)?)),
                    "legal_holds_remove_members_details" => Ok(EventDetails::LegalHoldsRemoveMembersDetails(LegalHoldsRemoveMembersDetails::internal_deserialize(map)?)),
                    "legal_holds_report_a_hold_details" => Ok(EventDetails::LegalHoldsReportAHoldDetails(LegalHoldsReportAHoldDetails::internal_deserialize(map)?)),
                    "account_lock_or_unlocked_details" => Ok(EventDetails::AccountLockOrUnlockedDetails(AccountLockOrUnlockedDetails::internal_deserialize(map)?)),
                    "emm_error_details" => Ok(EventDetails::EmmErrorDetails(EmmErrorDetails::internal_deserialize(map)?)),
                    "guest_admin_signed_in_via_trusted_teams_details" => Ok(EventDetails::GuestAdminSignedInViaTrustedTeamsDetails(GuestAdminSignedInViaTrustedTeamsDetails::internal_deserialize(map)?)),
                    "guest_admin_signed_out_via_trusted_teams_details" => Ok(EventDetails::GuestAdminSignedOutViaTrustedTeamsDetails(GuestAdminSignedOutViaTrustedTeamsDetails::internal_deserialize(map)?)),
                    "login_fail_details" => Ok(EventDetails::LoginFailDetails(LoginFailDetails::internal_deserialize(map)?)),
                    "login_success_details" => Ok(EventDetails::LoginSuccessDetails(LoginSuccessDetails::internal_deserialize(map)?)),
                    "logout_details" => Ok(EventDetails::LogoutDetails(LogoutDetails::internal_deserialize(map)?)),
                    "reseller_support_session_end_details" => Ok(EventDetails::ResellerSupportSessionEndDetails(ResellerSupportSessionEndDetails::internal_deserialize(map)?)),
                    "reseller_support_session_start_details" => Ok(EventDetails::ResellerSupportSessionStartDetails(ResellerSupportSessionStartDetails::internal_deserialize(map)?)),
                    "sign_in_as_session_end_details" => Ok(EventDetails::SignInAsSessionEndDetails(SignInAsSessionEndDetails::internal_deserialize(map)?)),
                    "sign_in_as_session_start_details" => Ok(EventDetails::SignInAsSessionStartDetails(SignInAsSessionStartDetails::internal_deserialize(map)?)),
                    "sso_error_details" => Ok(EventDetails::SsoErrorDetails(SsoErrorDetails::internal_deserialize(map)?)),
                    "create_team_invite_link_details" => Ok(EventDetails::CreateTeamInviteLinkDetails(CreateTeamInviteLinkDetails::internal_deserialize(map)?)),
                    "delete_team_invite_link_details" => Ok(EventDetails::DeleteTeamInviteLinkDetails(DeleteTeamInviteLinkDetails::internal_deserialize(map)?)),
                    "member_add_external_id_details" => Ok(EventDetails::MemberAddExternalIdDetails(MemberAddExternalIdDetails::internal_deserialize(map)?)),
                    "member_add_name_details" => Ok(EventDetails::MemberAddNameDetails(MemberAddNameDetails::internal_deserialize(map)?)),
                    "member_change_admin_role_details" => Ok(EventDetails::MemberChangeAdminRoleDetails(MemberChangeAdminRoleDetails::internal_deserialize(map)?)),
                    "member_change_email_details" => Ok(EventDetails::MemberChangeEmailDetails(MemberChangeEmailDetails::internal_deserialize(map)?)),
                    "member_change_external_id_details" => Ok(EventDetails::MemberChangeExternalIdDetails(MemberChangeExternalIdDetails::internal_deserialize(map)?)),
                    "member_change_membership_type_details" => Ok(EventDetails::MemberChangeMembershipTypeDetails(MemberChangeMembershipTypeDetails::internal_deserialize(map)?)),
                    "member_change_name_details" => Ok(EventDetails::MemberChangeNameDetails(MemberChangeNameDetails::internal_deserialize(map)?)),
                    "member_change_status_details" => Ok(EventDetails::MemberChangeStatusDetails(MemberChangeStatusDetails::internal_deserialize(map)?)),
                    "member_delete_manual_contacts_details" => Ok(EventDetails::MemberDeleteManualContactsDetails(MemberDeleteManualContactsDetails::internal_deserialize(map)?)),
                    "member_delete_profile_photo_details" => Ok(EventDetails::MemberDeleteProfilePhotoDetails(MemberDeleteProfilePhotoDetails::internal_deserialize(map)?)),
                    "member_permanently_delete_account_contents_details" => Ok(EventDetails::MemberPermanentlyDeleteAccountContentsDetails(MemberPermanentlyDeleteAccountContentsDetails::internal_deserialize(map)?)),
                    "member_remove_external_id_details" => Ok(EventDetails::MemberRemoveExternalIdDetails(MemberRemoveExternalIdDetails::internal_deserialize(map)?)),
                    "member_set_profile_photo_details" => Ok(EventDetails::MemberSetProfilePhotoDetails(MemberSetProfilePhotoDetails::internal_deserialize(map)?)),
                    "member_space_limits_add_custom_quota_details" => Ok(EventDetails::MemberSpaceLimitsAddCustomQuotaDetails(MemberSpaceLimitsAddCustomQuotaDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_custom_quota_details" => Ok(EventDetails::MemberSpaceLimitsChangeCustomQuotaDetails(MemberSpaceLimitsChangeCustomQuotaDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_status_details" => Ok(EventDetails::MemberSpaceLimitsChangeStatusDetails(MemberSpaceLimitsChangeStatusDetails::internal_deserialize(map)?)),
                    "member_space_limits_remove_custom_quota_details" => Ok(EventDetails::MemberSpaceLimitsRemoveCustomQuotaDetails(MemberSpaceLimitsRemoveCustomQuotaDetails::internal_deserialize(map)?)),
                    "member_suggest_details" => Ok(EventDetails::MemberSuggestDetails(MemberSuggestDetails::internal_deserialize(map)?)),
                    "member_transfer_account_contents_details" => Ok(EventDetails::MemberTransferAccountContentsDetails(MemberTransferAccountContentsDetails::internal_deserialize(map)?)),
                    "pending_secondary_email_added_details" => Ok(EventDetails::PendingSecondaryEmailAddedDetails(PendingSecondaryEmailAddedDetails::internal_deserialize(map)?)),
                    "secondary_email_deleted_details" => Ok(EventDetails::SecondaryEmailDeletedDetails(SecondaryEmailDeletedDetails::internal_deserialize(map)?)),
                    "secondary_email_verified_details" => Ok(EventDetails::SecondaryEmailVerifiedDetails(SecondaryEmailVerifiedDetails::internal_deserialize(map)?)),
                    "secondary_mails_policy_changed_details" => Ok(EventDetails::SecondaryMailsPolicyChangedDetails(SecondaryMailsPolicyChangedDetails::internal_deserialize(map)?)),
                    "binder_add_page_details" => Ok(EventDetails::BinderAddPageDetails(BinderAddPageDetails::internal_deserialize(map)?)),
                    "binder_add_section_details" => Ok(EventDetails::BinderAddSectionDetails(BinderAddSectionDetails::internal_deserialize(map)?)),
                    "binder_remove_page_details" => Ok(EventDetails::BinderRemovePageDetails(BinderRemovePageDetails::internal_deserialize(map)?)),
                    "binder_remove_section_details" => Ok(EventDetails::BinderRemoveSectionDetails(BinderRemoveSectionDetails::internal_deserialize(map)?)),
                    "binder_rename_page_details" => Ok(EventDetails::BinderRenamePageDetails(BinderRenamePageDetails::internal_deserialize(map)?)),
                    "binder_rename_section_details" => Ok(EventDetails::BinderRenameSectionDetails(BinderRenameSectionDetails::internal_deserialize(map)?)),
                    "binder_reorder_page_details" => Ok(EventDetails::BinderReorderPageDetails(BinderReorderPageDetails::internal_deserialize(map)?)),
                    "binder_reorder_section_details" => Ok(EventDetails::BinderReorderSectionDetails(BinderReorderSectionDetails::internal_deserialize(map)?)),
                    "paper_content_add_member_details" => Ok(EventDetails::PaperContentAddMemberDetails(PaperContentAddMemberDetails::internal_deserialize(map)?)),
                    "paper_content_add_to_folder_details" => Ok(EventDetails::PaperContentAddToFolderDetails(PaperContentAddToFolderDetails::internal_deserialize(map)?)),
                    "paper_content_archive_details" => Ok(EventDetails::PaperContentArchiveDetails(PaperContentArchiveDetails::internal_deserialize(map)?)),
                    "paper_content_create_details" => Ok(EventDetails::PaperContentCreateDetails(PaperContentCreateDetails::internal_deserialize(map)?)),
                    "paper_content_permanently_delete_details" => Ok(EventDetails::PaperContentPermanentlyDeleteDetails(PaperContentPermanentlyDeleteDetails::internal_deserialize(map)?)),
                    "paper_content_remove_from_folder_details" => Ok(EventDetails::PaperContentRemoveFromFolderDetails(PaperContentRemoveFromFolderDetails::internal_deserialize(map)?)),
                    "paper_content_remove_member_details" => Ok(EventDetails::PaperContentRemoveMemberDetails(PaperContentRemoveMemberDetails::internal_deserialize(map)?)),
                    "paper_content_rename_details" => Ok(EventDetails::PaperContentRenameDetails(PaperContentRenameDetails::internal_deserialize(map)?)),
                    "paper_content_restore_details" => Ok(EventDetails::PaperContentRestoreDetails(PaperContentRestoreDetails::internal_deserialize(map)?)),
                    "paper_doc_add_comment_details" => Ok(EventDetails::PaperDocAddCommentDetails(PaperDocAddCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_change_member_role_details" => Ok(EventDetails::PaperDocChangeMemberRoleDetails(PaperDocChangeMemberRoleDetails::internal_deserialize(map)?)),
                    "paper_doc_change_sharing_policy_details" => Ok(EventDetails::PaperDocChangeSharingPolicyDetails(PaperDocChangeSharingPolicyDetails::internal_deserialize(map)?)),
                    "paper_doc_change_subscription_details" => Ok(EventDetails::PaperDocChangeSubscriptionDetails(PaperDocChangeSubscriptionDetails::internal_deserialize(map)?)),
                    "paper_doc_deleted_details" => Ok(EventDetails::PaperDocDeletedDetails(PaperDocDeletedDetails::internal_deserialize(map)?)),
                    "paper_doc_delete_comment_details" => Ok(EventDetails::PaperDocDeleteCommentDetails(PaperDocDeleteCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_download_details" => Ok(EventDetails::PaperDocDownloadDetails(PaperDocDownloadDetails::internal_deserialize(map)?)),
                    "paper_doc_edit_details" => Ok(EventDetails::PaperDocEditDetails(PaperDocEditDetails::internal_deserialize(map)?)),
                    "paper_doc_edit_comment_details" => Ok(EventDetails::PaperDocEditCommentDetails(PaperDocEditCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_followed_details" => Ok(EventDetails::PaperDocFollowedDetails(PaperDocFollowedDetails::internal_deserialize(map)?)),
                    "paper_doc_mention_details" => Ok(EventDetails::PaperDocMentionDetails(PaperDocMentionDetails::internal_deserialize(map)?)),
                    "paper_doc_ownership_changed_details" => Ok(EventDetails::PaperDocOwnershipChangedDetails(PaperDocOwnershipChangedDetails::internal_deserialize(map)?)),
                    "paper_doc_request_access_details" => Ok(EventDetails::PaperDocRequestAccessDetails(PaperDocRequestAccessDetails::internal_deserialize(map)?)),
                    "paper_doc_resolve_comment_details" => Ok(EventDetails::PaperDocResolveCommentDetails(PaperDocResolveCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_revert_details" => Ok(EventDetails::PaperDocRevertDetails(PaperDocRevertDetails::internal_deserialize(map)?)),
                    "paper_doc_slack_share_details" => Ok(EventDetails::PaperDocSlackShareDetails(PaperDocSlackShareDetails::internal_deserialize(map)?)),
                    "paper_doc_team_invite_details" => Ok(EventDetails::PaperDocTeamInviteDetails(PaperDocTeamInviteDetails::internal_deserialize(map)?)),
                    "paper_doc_trashed_details" => Ok(EventDetails::PaperDocTrashedDetails(PaperDocTrashedDetails::internal_deserialize(map)?)),
                    "paper_doc_unresolve_comment_details" => Ok(EventDetails::PaperDocUnresolveCommentDetails(PaperDocUnresolveCommentDetails::internal_deserialize(map)?)),
                    "paper_doc_untrashed_details" => Ok(EventDetails::PaperDocUntrashedDetails(PaperDocUntrashedDetails::internal_deserialize(map)?)),
                    "paper_doc_view_details" => Ok(EventDetails::PaperDocViewDetails(PaperDocViewDetails::internal_deserialize(map)?)),
                    "paper_external_view_allow_details" => Ok(EventDetails::PaperExternalViewAllowDetails(PaperExternalViewAllowDetails::internal_deserialize(map)?)),
                    "paper_external_view_default_team_details" => Ok(EventDetails::PaperExternalViewDefaultTeamDetails(PaperExternalViewDefaultTeamDetails::internal_deserialize(map)?)),
                    "paper_external_view_forbid_details" => Ok(EventDetails::PaperExternalViewForbidDetails(PaperExternalViewForbidDetails::internal_deserialize(map)?)),
                    "paper_folder_change_subscription_details" => Ok(EventDetails::PaperFolderChangeSubscriptionDetails(PaperFolderChangeSubscriptionDetails::internal_deserialize(map)?)),
                    "paper_folder_deleted_details" => Ok(EventDetails::PaperFolderDeletedDetails(PaperFolderDeletedDetails::internal_deserialize(map)?)),
                    "paper_folder_followed_details" => Ok(EventDetails::PaperFolderFollowedDetails(PaperFolderFollowedDetails::internal_deserialize(map)?)),
                    "paper_folder_team_invite_details" => Ok(EventDetails::PaperFolderTeamInviteDetails(PaperFolderTeamInviteDetails::internal_deserialize(map)?)),
                    "paper_published_link_change_permission_details" => Ok(EventDetails::PaperPublishedLinkChangePermissionDetails(PaperPublishedLinkChangePermissionDetails::internal_deserialize(map)?)),
                    "paper_published_link_create_details" => Ok(EventDetails::PaperPublishedLinkCreateDetails(PaperPublishedLinkCreateDetails::internal_deserialize(map)?)),
                    "paper_published_link_disabled_details" => Ok(EventDetails::PaperPublishedLinkDisabledDetails(PaperPublishedLinkDisabledDetails::internal_deserialize(map)?)),
                    "paper_published_link_view_details" => Ok(EventDetails::PaperPublishedLinkViewDetails(PaperPublishedLinkViewDetails::internal_deserialize(map)?)),
                    "password_change_details" => Ok(EventDetails::PasswordChangeDetails(PasswordChangeDetails::internal_deserialize(map)?)),
                    "password_reset_details" => Ok(EventDetails::PasswordResetDetails(PasswordResetDetails::internal_deserialize(map)?)),
                    "password_reset_all_details" => Ok(EventDetails::PasswordResetAllDetails(PasswordResetAllDetails::internal_deserialize(map)?)),
                    "emm_create_exceptions_report_details" => Ok(EventDetails::EmmCreateExceptionsReportDetails(EmmCreateExceptionsReportDetails::internal_deserialize(map)?)),
                    "emm_create_usage_report_details" => Ok(EventDetails::EmmCreateUsageReportDetails(EmmCreateUsageReportDetails::internal_deserialize(map)?)),
                    "export_members_report_details" => Ok(EventDetails::ExportMembersReportDetails(ExportMembersReportDetails::internal_deserialize(map)?)),
                    "export_members_report_fail_details" => Ok(EventDetails::ExportMembersReportFailDetails(ExportMembersReportFailDetails::internal_deserialize(map)?)),
                    "no_expiration_link_gen_create_report_details" => Ok(EventDetails::NoExpirationLinkGenCreateReportDetails(NoExpirationLinkGenCreateReportDetails::internal_deserialize(map)?)),
                    "no_expiration_link_gen_report_failed_details" => Ok(EventDetails::NoExpirationLinkGenReportFailedDetails(NoExpirationLinkGenReportFailedDetails::internal_deserialize(map)?)),
                    "no_password_link_gen_create_report_details" => Ok(EventDetails::NoPasswordLinkGenCreateReportDetails(NoPasswordLinkGenCreateReportDetails::internal_deserialize(map)?)),
                    "no_password_link_gen_report_failed_details" => Ok(EventDetails::NoPasswordLinkGenReportFailedDetails(NoPasswordLinkGenReportFailedDetails::internal_deserialize(map)?)),
                    "no_password_link_view_create_report_details" => Ok(EventDetails::NoPasswordLinkViewCreateReportDetails(NoPasswordLinkViewCreateReportDetails::internal_deserialize(map)?)),
                    "no_password_link_view_report_failed_details" => Ok(EventDetails::NoPasswordLinkViewReportFailedDetails(NoPasswordLinkViewReportFailedDetails::internal_deserialize(map)?)),
                    "outdated_link_view_create_report_details" => Ok(EventDetails::OutdatedLinkViewCreateReportDetails(OutdatedLinkViewCreateReportDetails::internal_deserialize(map)?)),
                    "outdated_link_view_report_failed_details" => Ok(EventDetails::OutdatedLinkViewReportFailedDetails(OutdatedLinkViewReportFailedDetails::internal_deserialize(map)?)),
                    "paper_admin_export_start_details" => Ok(EventDetails::PaperAdminExportStartDetails(PaperAdminExportStartDetails::internal_deserialize(map)?)),
                    "smart_sync_create_admin_privilege_report_details" => Ok(EventDetails::SmartSyncCreateAdminPrivilegeReportDetails(SmartSyncCreateAdminPrivilegeReportDetails::internal_deserialize(map)?)),
                    "team_activity_create_report_details" => Ok(EventDetails::TeamActivityCreateReportDetails(TeamActivityCreateReportDetails::internal_deserialize(map)?)),
                    "team_activity_create_report_fail_details" => Ok(EventDetails::TeamActivityCreateReportFailDetails(TeamActivityCreateReportFailDetails::internal_deserialize(map)?)),
                    "collection_share_details" => Ok(EventDetails::CollectionShareDetails(CollectionShareDetails::internal_deserialize(map)?)),
                    "file_transfers_file_add_details" => Ok(EventDetails::FileTransfersFileAddDetails(FileTransfersFileAddDetails::internal_deserialize(map)?)),
                    "file_transfers_transfer_delete_details" => Ok(EventDetails::FileTransfersTransferDeleteDetails(FileTransfersTransferDeleteDetails::internal_deserialize(map)?)),
                    "file_transfers_transfer_download_details" => Ok(EventDetails::FileTransfersTransferDownloadDetails(FileTransfersTransferDownloadDetails::internal_deserialize(map)?)),
                    "file_transfers_transfer_send_details" => Ok(EventDetails::FileTransfersTransferSendDetails(FileTransfersTransferSendDetails::internal_deserialize(map)?)),
                    "file_transfers_transfer_view_details" => Ok(EventDetails::FileTransfersTransferViewDetails(FileTransfersTransferViewDetails::internal_deserialize(map)?)),
                    "note_acl_invite_only_details" => Ok(EventDetails::NoteAclInviteOnlyDetails(NoteAclInviteOnlyDetails::internal_deserialize(map)?)),
                    "note_acl_link_details" => Ok(EventDetails::NoteAclLinkDetails(NoteAclLinkDetails::internal_deserialize(map)?)),
                    "note_acl_team_link_details" => Ok(EventDetails::NoteAclTeamLinkDetails(NoteAclTeamLinkDetails::internal_deserialize(map)?)),
                    "note_shared_details" => Ok(EventDetails::NoteSharedDetails(NoteSharedDetails::internal_deserialize(map)?)),
                    "note_share_receive_details" => Ok(EventDetails::NoteShareReceiveDetails(NoteShareReceiveDetails::internal_deserialize(map)?)),
                    "open_note_shared_details" => Ok(EventDetails::OpenNoteSharedDetails(OpenNoteSharedDetails::internal_deserialize(map)?)),
                    "sf_add_group_details" => Ok(EventDetails::SfAddGroupDetails(SfAddGroupDetails::internal_deserialize(map)?)),
                    "sf_allow_non_members_to_view_shared_links_details" => Ok(EventDetails::SfAllowNonMembersToViewSharedLinksDetails(SfAllowNonMembersToViewSharedLinksDetails::internal_deserialize(map)?)),
                    "sf_external_invite_warn_details" => Ok(EventDetails::SfExternalInviteWarnDetails(SfExternalInviteWarnDetails::internal_deserialize(map)?)),
                    "sf_fb_invite_details" => Ok(EventDetails::SfFbInviteDetails(SfFbInviteDetails::internal_deserialize(map)?)),
                    "sf_fb_invite_change_role_details" => Ok(EventDetails::SfFbInviteChangeRoleDetails(SfFbInviteChangeRoleDetails::internal_deserialize(map)?)),
                    "sf_fb_uninvite_details" => Ok(EventDetails::SfFbUninviteDetails(SfFbUninviteDetails::internal_deserialize(map)?)),
                    "sf_invite_group_details" => Ok(EventDetails::SfInviteGroupDetails(SfInviteGroupDetails::internal_deserialize(map)?)),
                    "sf_team_grant_access_details" => Ok(EventDetails::SfTeamGrantAccessDetails(SfTeamGrantAccessDetails::internal_deserialize(map)?)),
                    "sf_team_invite_details" => Ok(EventDetails::SfTeamInviteDetails(SfTeamInviteDetails::internal_deserialize(map)?)),
                    "sf_team_invite_change_role_details" => Ok(EventDetails::SfTeamInviteChangeRoleDetails(SfTeamInviteChangeRoleDetails::internal_deserialize(map)?)),
                    "sf_team_join_details" => Ok(EventDetails::SfTeamJoinDetails(SfTeamJoinDetails::internal_deserialize(map)?)),
                    "sf_team_join_from_oob_link_details" => Ok(EventDetails::SfTeamJoinFromOobLinkDetails(SfTeamJoinFromOobLinkDetails::internal_deserialize(map)?)),
                    "sf_team_uninvite_details" => Ok(EventDetails::SfTeamUninviteDetails(SfTeamUninviteDetails::internal_deserialize(map)?)),
                    "shared_content_add_invitees_details" => Ok(EventDetails::SharedContentAddInviteesDetails(SharedContentAddInviteesDetails::internal_deserialize(map)?)),
                    "shared_content_add_link_expiry_details" => Ok(EventDetails::SharedContentAddLinkExpiryDetails(SharedContentAddLinkExpiryDetails::internal_deserialize(map)?)),
                    "shared_content_add_link_password_details" => Ok(EventDetails::SharedContentAddLinkPasswordDetails(SharedContentAddLinkPasswordDetails::internal_deserialize(map)?)),
                    "shared_content_add_member_details" => Ok(EventDetails::SharedContentAddMemberDetails(SharedContentAddMemberDetails::internal_deserialize(map)?)),
                    "shared_content_change_downloads_policy_details" => Ok(EventDetails::SharedContentChangeDownloadsPolicyDetails(SharedContentChangeDownloadsPolicyDetails::internal_deserialize(map)?)),
                    "shared_content_change_invitee_role_details" => Ok(EventDetails::SharedContentChangeInviteeRoleDetails(SharedContentChangeInviteeRoleDetails::internal_deserialize(map)?)),
                    "shared_content_change_link_audience_details" => Ok(EventDetails::SharedContentChangeLinkAudienceDetails(SharedContentChangeLinkAudienceDetails::internal_deserialize(map)?)),
                    "shared_content_change_link_expiry_details" => Ok(EventDetails::SharedContentChangeLinkExpiryDetails(SharedContentChangeLinkExpiryDetails::internal_deserialize(map)?)),
                    "shared_content_change_link_password_details" => Ok(EventDetails::SharedContentChangeLinkPasswordDetails(SharedContentChangeLinkPasswordDetails::internal_deserialize(map)?)),
                    "shared_content_change_member_role_details" => Ok(EventDetails::SharedContentChangeMemberRoleDetails(SharedContentChangeMemberRoleDetails::internal_deserialize(map)?)),
                    "shared_content_change_viewer_info_policy_details" => Ok(EventDetails::SharedContentChangeViewerInfoPolicyDetails(SharedContentChangeViewerInfoPolicyDetails::internal_deserialize(map)?)),
                    "shared_content_claim_invitation_details" => Ok(EventDetails::SharedContentClaimInvitationDetails(SharedContentClaimInvitationDetails::internal_deserialize(map)?)),
                    "shared_content_copy_details" => Ok(EventDetails::SharedContentCopyDetails(SharedContentCopyDetails::internal_deserialize(map)?)),
                    "shared_content_download_details" => Ok(EventDetails::SharedContentDownloadDetails(SharedContentDownloadDetails::internal_deserialize(map)?)),
                    "shared_content_relinquish_membership_details" => Ok(EventDetails::SharedContentRelinquishMembershipDetails(SharedContentRelinquishMembershipDetails::internal_deserialize(map)?)),
                    "shared_content_remove_invitees_details" => Ok(EventDetails::SharedContentRemoveInviteesDetails(SharedContentRemoveInviteesDetails::internal_deserialize(map)?)),
                    "shared_content_remove_link_expiry_details" => Ok(EventDetails::SharedContentRemoveLinkExpiryDetails(SharedContentRemoveLinkExpiryDetails::internal_deserialize(map)?)),
                    "shared_content_remove_link_password_details" => Ok(EventDetails::SharedContentRemoveLinkPasswordDetails(SharedContentRemoveLinkPasswordDetails::internal_deserialize(map)?)),
                    "shared_content_remove_member_details" => Ok(EventDetails::SharedContentRemoveMemberDetails(SharedContentRemoveMemberDetails::internal_deserialize(map)?)),
                    "shared_content_request_access_details" => Ok(EventDetails::SharedContentRequestAccessDetails(SharedContentRequestAccessDetails::internal_deserialize(map)?)),
                    "shared_content_restore_invitees_details" => Ok(EventDetails::SharedContentRestoreInviteesDetails(SharedContentRestoreInviteesDetails::internal_deserialize(map)?)),
                    "shared_content_restore_member_details" => Ok(EventDetails::SharedContentRestoreMemberDetails(SharedContentRestoreMemberDetails::internal_deserialize(map)?)),
                    "shared_content_unshare_details" => Ok(EventDetails::SharedContentUnshareDetails(SharedContentUnshareDetails::internal_deserialize(map)?)),
                    "shared_content_view_details" => Ok(EventDetails::SharedContentViewDetails(SharedContentViewDetails::internal_deserialize(map)?)),
                    "shared_folder_change_link_policy_details" => Ok(EventDetails::SharedFolderChangeLinkPolicyDetails(SharedFolderChangeLinkPolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_change_members_inheritance_policy_details" => Ok(EventDetails::SharedFolderChangeMembersInheritancePolicyDetails(SharedFolderChangeMembersInheritancePolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_change_members_management_policy_details" => Ok(EventDetails::SharedFolderChangeMembersManagementPolicyDetails(SharedFolderChangeMembersManagementPolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_change_members_policy_details" => Ok(EventDetails::SharedFolderChangeMembersPolicyDetails(SharedFolderChangeMembersPolicyDetails::internal_deserialize(map)?)),
                    "shared_folder_create_details" => Ok(EventDetails::SharedFolderCreateDetails(SharedFolderCreateDetails::internal_deserialize(map)?)),
                    "shared_folder_decline_invitation_details" => Ok(EventDetails::SharedFolderDeclineInvitationDetails(SharedFolderDeclineInvitationDetails::internal_deserialize(map)?)),
                    "shared_folder_mount_details" => Ok(EventDetails::SharedFolderMountDetails(SharedFolderMountDetails::internal_deserialize(map)?)),
                    "shared_folder_nest_details" => Ok(EventDetails::SharedFolderNestDetails(SharedFolderNestDetails::internal_deserialize(map)?)),
                    "shared_folder_transfer_ownership_details" => Ok(EventDetails::SharedFolderTransferOwnershipDetails(SharedFolderTransferOwnershipDetails::internal_deserialize(map)?)),
                    "shared_folder_unmount_details" => Ok(EventDetails::SharedFolderUnmountDetails(SharedFolderUnmountDetails::internal_deserialize(map)?)),
                    "shared_link_add_expiry_details" => Ok(EventDetails::SharedLinkAddExpiryDetails(SharedLinkAddExpiryDetails::internal_deserialize(map)?)),
                    "shared_link_change_expiry_details" => Ok(EventDetails::SharedLinkChangeExpiryDetails(SharedLinkChangeExpiryDetails::internal_deserialize(map)?)),
                    "shared_link_change_visibility_details" => Ok(EventDetails::SharedLinkChangeVisibilityDetails(SharedLinkChangeVisibilityDetails::internal_deserialize(map)?)),
                    "shared_link_copy_details" => Ok(EventDetails::SharedLinkCopyDetails(SharedLinkCopyDetails::internal_deserialize(map)?)),
                    "shared_link_create_details" => Ok(EventDetails::SharedLinkCreateDetails(SharedLinkCreateDetails::internal_deserialize(map)?)),
                    "shared_link_disable_details" => Ok(EventDetails::SharedLinkDisableDetails(SharedLinkDisableDetails::internal_deserialize(map)?)),
                    "shared_link_download_details" => Ok(EventDetails::SharedLinkDownloadDetails(SharedLinkDownloadDetails::internal_deserialize(map)?)),
                    "shared_link_remove_expiry_details" => Ok(EventDetails::SharedLinkRemoveExpiryDetails(SharedLinkRemoveExpiryDetails::internal_deserialize(map)?)),
                    "shared_link_settings_add_expiration_details" => Ok(EventDetails::SharedLinkSettingsAddExpirationDetails(SharedLinkSettingsAddExpirationDetails::internal_deserialize(map)?)),
                    "shared_link_settings_add_password_details" => Ok(EventDetails::SharedLinkSettingsAddPasswordDetails(SharedLinkSettingsAddPasswordDetails::internal_deserialize(map)?)),
                    "shared_link_settings_allow_download_disabled_details" => Ok(EventDetails::SharedLinkSettingsAllowDownloadDisabledDetails(SharedLinkSettingsAllowDownloadDisabledDetails::internal_deserialize(map)?)),
                    "shared_link_settings_allow_download_enabled_details" => Ok(EventDetails::SharedLinkSettingsAllowDownloadEnabledDetails(SharedLinkSettingsAllowDownloadEnabledDetails::internal_deserialize(map)?)),
                    "shared_link_settings_change_audience_details" => Ok(EventDetails::SharedLinkSettingsChangeAudienceDetails(SharedLinkSettingsChangeAudienceDetails::internal_deserialize(map)?)),
                    "shared_link_settings_change_expiration_details" => Ok(EventDetails::SharedLinkSettingsChangeExpirationDetails(SharedLinkSettingsChangeExpirationDetails::internal_deserialize(map)?)),
                    "shared_link_settings_change_password_details" => Ok(EventDetails::SharedLinkSettingsChangePasswordDetails(SharedLinkSettingsChangePasswordDetails::internal_deserialize(map)?)),
                    "shared_link_settings_remove_expiration_details" => Ok(EventDetails::SharedLinkSettingsRemoveExpirationDetails(SharedLinkSettingsRemoveExpirationDetails::internal_deserialize(map)?)),
                    "shared_link_settings_remove_password_details" => Ok(EventDetails::SharedLinkSettingsRemovePasswordDetails(SharedLinkSettingsRemovePasswordDetails::internal_deserialize(map)?)),
                    "shared_link_share_details" => Ok(EventDetails::SharedLinkShareDetails(SharedLinkShareDetails::internal_deserialize(map)?)),
                    "shared_link_view_details" => Ok(EventDetails::SharedLinkViewDetails(SharedLinkViewDetails::internal_deserialize(map)?)),
                    "shared_note_opened_details" => Ok(EventDetails::SharedNoteOpenedDetails(SharedNoteOpenedDetails::internal_deserialize(map)?)),
                    "shmodel_group_share_details" => Ok(EventDetails::ShmodelGroupShareDetails(ShmodelGroupShareDetails::internal_deserialize(map)?)),
                    "showcase_access_granted_details" => Ok(EventDetails::ShowcaseAccessGrantedDetails(ShowcaseAccessGrantedDetails::internal_deserialize(map)?)),
                    "showcase_add_member_details" => Ok(EventDetails::ShowcaseAddMemberDetails(ShowcaseAddMemberDetails::internal_deserialize(map)?)),
                    "showcase_archived_details" => Ok(EventDetails::ShowcaseArchivedDetails(ShowcaseArchivedDetails::internal_deserialize(map)?)),
                    "showcase_created_details" => Ok(EventDetails::ShowcaseCreatedDetails(ShowcaseCreatedDetails::internal_deserialize(map)?)),
                    "showcase_delete_comment_details" => Ok(EventDetails::ShowcaseDeleteCommentDetails(ShowcaseDeleteCommentDetails::internal_deserialize(map)?)),
                    "showcase_edited_details" => Ok(EventDetails::ShowcaseEditedDetails(ShowcaseEditedDetails::internal_deserialize(map)?)),
                    "showcase_edit_comment_details" => Ok(EventDetails::ShowcaseEditCommentDetails(ShowcaseEditCommentDetails::internal_deserialize(map)?)),
                    "showcase_file_added_details" => Ok(EventDetails::ShowcaseFileAddedDetails(ShowcaseFileAddedDetails::internal_deserialize(map)?)),
                    "showcase_file_download_details" => Ok(EventDetails::ShowcaseFileDownloadDetails(ShowcaseFileDownloadDetails::internal_deserialize(map)?)),
                    "showcase_file_removed_details" => Ok(EventDetails::ShowcaseFileRemovedDetails(ShowcaseFileRemovedDetails::internal_deserialize(map)?)),
                    "showcase_file_view_details" => Ok(EventDetails::ShowcaseFileViewDetails(ShowcaseFileViewDetails::internal_deserialize(map)?)),
                    "showcase_permanently_deleted_details" => Ok(EventDetails::ShowcasePermanentlyDeletedDetails(ShowcasePermanentlyDeletedDetails::internal_deserialize(map)?)),
                    "showcase_post_comment_details" => Ok(EventDetails::ShowcasePostCommentDetails(ShowcasePostCommentDetails::internal_deserialize(map)?)),
                    "showcase_remove_member_details" => Ok(EventDetails::ShowcaseRemoveMemberDetails(ShowcaseRemoveMemberDetails::internal_deserialize(map)?)),
                    "showcase_renamed_details" => Ok(EventDetails::ShowcaseRenamedDetails(ShowcaseRenamedDetails::internal_deserialize(map)?)),
                    "showcase_request_access_details" => Ok(EventDetails::ShowcaseRequestAccessDetails(ShowcaseRequestAccessDetails::internal_deserialize(map)?)),
                    "showcase_resolve_comment_details" => Ok(EventDetails::ShowcaseResolveCommentDetails(ShowcaseResolveCommentDetails::internal_deserialize(map)?)),
                    "showcase_restored_details" => Ok(EventDetails::ShowcaseRestoredDetails(ShowcaseRestoredDetails::internal_deserialize(map)?)),
                    "showcase_trashed_details" => Ok(EventDetails::ShowcaseTrashedDetails(ShowcaseTrashedDetails::internal_deserialize(map)?)),
                    "showcase_trashed_deprecated_details" => Ok(EventDetails::ShowcaseTrashedDeprecatedDetails(ShowcaseTrashedDeprecatedDetails::internal_deserialize(map)?)),
                    "showcase_unresolve_comment_details" => Ok(EventDetails::ShowcaseUnresolveCommentDetails(ShowcaseUnresolveCommentDetails::internal_deserialize(map)?)),
                    "showcase_untrashed_details" => Ok(EventDetails::ShowcaseUntrashedDetails(ShowcaseUntrashedDetails::internal_deserialize(map)?)),
                    "showcase_untrashed_deprecated_details" => Ok(EventDetails::ShowcaseUntrashedDeprecatedDetails(ShowcaseUntrashedDeprecatedDetails::internal_deserialize(map)?)),
                    "showcase_view_details" => Ok(EventDetails::ShowcaseViewDetails(ShowcaseViewDetails::internal_deserialize(map)?)),
                    "sso_add_cert_details" => Ok(EventDetails::SsoAddCertDetails(SsoAddCertDetails::internal_deserialize(map)?)),
                    "sso_add_login_url_details" => Ok(EventDetails::SsoAddLoginUrlDetails(SsoAddLoginUrlDetails::internal_deserialize(map)?)),
                    "sso_add_logout_url_details" => Ok(EventDetails::SsoAddLogoutUrlDetails(SsoAddLogoutUrlDetails::internal_deserialize(map)?)),
                    "sso_change_cert_details" => Ok(EventDetails::SsoChangeCertDetails(SsoChangeCertDetails::internal_deserialize(map)?)),
                    "sso_change_login_url_details" => Ok(EventDetails::SsoChangeLoginUrlDetails(SsoChangeLoginUrlDetails::internal_deserialize(map)?)),
                    "sso_change_logout_url_details" => Ok(EventDetails::SsoChangeLogoutUrlDetails(SsoChangeLogoutUrlDetails::internal_deserialize(map)?)),
                    "sso_change_saml_identity_mode_details" => Ok(EventDetails::SsoChangeSamlIdentityModeDetails(SsoChangeSamlIdentityModeDetails::internal_deserialize(map)?)),
                    "sso_remove_cert_details" => Ok(EventDetails::SsoRemoveCertDetails(SsoRemoveCertDetails::internal_deserialize(map)?)),
                    "sso_remove_login_url_details" => Ok(EventDetails::SsoRemoveLoginUrlDetails(SsoRemoveLoginUrlDetails::internal_deserialize(map)?)),
                    "sso_remove_logout_url_details" => Ok(EventDetails::SsoRemoveLogoutUrlDetails(SsoRemoveLogoutUrlDetails::internal_deserialize(map)?)),
                    "team_folder_change_status_details" => Ok(EventDetails::TeamFolderChangeStatusDetails(TeamFolderChangeStatusDetails::internal_deserialize(map)?)),
                    "team_folder_create_details" => Ok(EventDetails::TeamFolderCreateDetails(TeamFolderCreateDetails::internal_deserialize(map)?)),
                    "team_folder_downgrade_details" => Ok(EventDetails::TeamFolderDowngradeDetails(TeamFolderDowngradeDetails::internal_deserialize(map)?)),
                    "team_folder_permanently_delete_details" => Ok(EventDetails::TeamFolderPermanentlyDeleteDetails(TeamFolderPermanentlyDeleteDetails::internal_deserialize(map)?)),
                    "team_folder_rename_details" => Ok(EventDetails::TeamFolderRenameDetails(TeamFolderRenameDetails::internal_deserialize(map)?)),
                    "team_selective_sync_settings_changed_details" => Ok(EventDetails::TeamSelectiveSyncSettingsChangedDetails(TeamSelectiveSyncSettingsChangedDetails::internal_deserialize(map)?)),
                    "account_capture_change_policy_details" => Ok(EventDetails::AccountCaptureChangePolicyDetails(AccountCaptureChangePolicyDetails::internal_deserialize(map)?)),
                    "allow_download_disabled_details" => Ok(EventDetails::AllowDownloadDisabledDetails(AllowDownloadDisabledDetails::internal_deserialize(map)?)),
                    "allow_download_enabled_details" => Ok(EventDetails::AllowDownloadEnabledDetails(AllowDownloadEnabledDetails::internal_deserialize(map)?)),
                    "camera_uploads_policy_changed_details" => Ok(EventDetails::CameraUploadsPolicyChangedDetails(CameraUploadsPolicyChangedDetails::internal_deserialize(map)?)),
                    "data_placement_restriction_change_policy_details" => Ok(EventDetails::DataPlacementRestrictionChangePolicyDetails(DataPlacementRestrictionChangePolicyDetails::internal_deserialize(map)?)),
                    "data_placement_restriction_satisfy_policy_details" => Ok(EventDetails::DataPlacementRestrictionSatisfyPolicyDetails(DataPlacementRestrictionSatisfyPolicyDetails::internal_deserialize(map)?)),
                    "device_approvals_add_exception_details" => Ok(EventDetails::DeviceApprovalsAddExceptionDetails(DeviceApprovalsAddExceptionDetails::internal_deserialize(map)?)),
                    "device_approvals_change_desktop_policy_details" => Ok(EventDetails::DeviceApprovalsChangeDesktopPolicyDetails(DeviceApprovalsChangeDesktopPolicyDetails::internal_deserialize(map)?)),
                    "device_approvals_change_mobile_policy_details" => Ok(EventDetails::DeviceApprovalsChangeMobilePolicyDetails(DeviceApprovalsChangeMobilePolicyDetails::internal_deserialize(map)?)),
                    "device_approvals_change_overage_action_details" => Ok(EventDetails::DeviceApprovalsChangeOverageActionDetails(DeviceApprovalsChangeOverageActionDetails::internal_deserialize(map)?)),
                    "device_approvals_change_unlink_action_details" => Ok(EventDetails::DeviceApprovalsChangeUnlinkActionDetails(DeviceApprovalsChangeUnlinkActionDetails::internal_deserialize(map)?)),
                    "device_approvals_remove_exception_details" => Ok(EventDetails::DeviceApprovalsRemoveExceptionDetails(DeviceApprovalsRemoveExceptionDetails::internal_deserialize(map)?)),
                    "directory_restrictions_add_members_details" => Ok(EventDetails::DirectoryRestrictionsAddMembersDetails(DirectoryRestrictionsAddMembersDetails::internal_deserialize(map)?)),
                    "directory_restrictions_remove_members_details" => Ok(EventDetails::DirectoryRestrictionsRemoveMembersDetails(DirectoryRestrictionsRemoveMembersDetails::internal_deserialize(map)?)),
                    "emm_add_exception_details" => Ok(EventDetails::EmmAddExceptionDetails(EmmAddExceptionDetails::internal_deserialize(map)?)),
                    "emm_change_policy_details" => Ok(EventDetails::EmmChangePolicyDetails(EmmChangePolicyDetails::internal_deserialize(map)?)),
                    "emm_remove_exception_details" => Ok(EventDetails::EmmRemoveExceptionDetails(EmmRemoveExceptionDetails::internal_deserialize(map)?)),
                    "extended_version_history_change_policy_details" => Ok(EventDetails::ExtendedVersionHistoryChangePolicyDetails(ExtendedVersionHistoryChangePolicyDetails::internal_deserialize(map)?)),
                    "file_comments_change_policy_details" => Ok(EventDetails::FileCommentsChangePolicyDetails(FileCommentsChangePolicyDetails::internal_deserialize(map)?)),
                    "file_locking_policy_changed_details" => Ok(EventDetails::FileLockingPolicyChangedDetails(FileLockingPolicyChangedDetails::internal_deserialize(map)?)),
                    "file_requests_change_policy_details" => Ok(EventDetails::FileRequestsChangePolicyDetails(FileRequestsChangePolicyDetails::internal_deserialize(map)?)),
                    "file_requests_emails_enabled_details" => Ok(EventDetails::FileRequestsEmailsEnabledDetails(FileRequestsEmailsEnabledDetails::internal_deserialize(map)?)),
                    "file_requests_emails_restricted_to_team_only_details" => Ok(EventDetails::FileRequestsEmailsRestrictedToTeamOnlyDetails(FileRequestsEmailsRestrictedToTeamOnlyDetails::internal_deserialize(map)?)),
                    "file_transfers_policy_changed_details" => Ok(EventDetails::FileTransfersPolicyChangedDetails(FileTransfersPolicyChangedDetails::internal_deserialize(map)?)),
                    "google_sso_change_policy_details" => Ok(EventDetails::GoogleSsoChangePolicyDetails(GoogleSsoChangePolicyDetails::internal_deserialize(map)?)),
                    "group_user_management_change_policy_details" => Ok(EventDetails::GroupUserManagementChangePolicyDetails(GroupUserManagementChangePolicyDetails::internal_deserialize(map)?)),
                    "integration_policy_changed_details" => Ok(EventDetails::IntegrationPolicyChangedDetails(IntegrationPolicyChangedDetails::internal_deserialize(map)?)),
                    "member_requests_change_policy_details" => Ok(EventDetails::MemberRequestsChangePolicyDetails(MemberRequestsChangePolicyDetails::internal_deserialize(map)?)),
                    "member_send_invite_policy_changed_details" => Ok(EventDetails::MemberSendInvitePolicyChangedDetails(MemberSendInvitePolicyChangedDetails::internal_deserialize(map)?)),
                    "member_space_limits_add_exception_details" => Ok(EventDetails::MemberSpaceLimitsAddExceptionDetails(MemberSpaceLimitsAddExceptionDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_caps_type_policy_details" => Ok(EventDetails::MemberSpaceLimitsChangeCapsTypePolicyDetails(MemberSpaceLimitsChangeCapsTypePolicyDetails::internal_deserialize(map)?)),
                    "member_space_limits_change_policy_details" => Ok(EventDetails::MemberSpaceLimitsChangePolicyDetails(MemberSpaceLimitsChangePolicyDetails::internal_deserialize(map)?)),
                    "member_space_limits_remove_exception_details" => Ok(EventDetails::MemberSpaceLimitsRemoveExceptionDetails(MemberSpaceLimitsRemoveExceptionDetails::internal_deserialize(map)?)),
                    "member_suggestions_change_policy_details" => Ok(EventDetails::MemberSuggestionsChangePolicyDetails(MemberSuggestionsChangePolicyDetails::internal_deserialize(map)?)),
                    "microsoft_office_addin_change_policy_details" => Ok(EventDetails::MicrosoftOfficeAddinChangePolicyDetails(MicrosoftOfficeAddinChangePolicyDetails::internal_deserialize(map)?)),
                    "network_control_change_policy_details" => Ok(EventDetails::NetworkControlChangePolicyDetails(NetworkControlChangePolicyDetails::internal_deserialize(map)?)),
                    "paper_change_deployment_policy_details" => Ok(EventDetails::PaperChangeDeploymentPolicyDetails(PaperChangeDeploymentPolicyDetails::internal_deserialize(map)?)),
                    "paper_change_member_link_policy_details" => Ok(EventDetails::PaperChangeMemberLinkPolicyDetails(PaperChangeMemberLinkPolicyDetails::internal_deserialize(map)?)),
                    "paper_change_member_policy_details" => Ok(EventDetails::PaperChangeMemberPolicyDetails(PaperChangeMemberPolicyDetails::internal_deserialize(map)?)),
                    "paper_change_policy_details" => Ok(EventDetails::PaperChangePolicyDetails(PaperChangePolicyDetails::internal_deserialize(map)?)),
                    "paper_default_folder_policy_changed_details" => Ok(EventDetails::PaperDefaultFolderPolicyChangedDetails(PaperDefaultFolderPolicyChangedDetails::internal_deserialize(map)?)),
                    "paper_desktop_policy_changed_details" => Ok(EventDetails::PaperDesktopPolicyChangedDetails(PaperDesktopPolicyChangedDetails::internal_deserialize(map)?)),
                    "paper_enabled_users_group_addition_details" => Ok(EventDetails::PaperEnabledUsersGroupAdditionDetails(PaperEnabledUsersGroupAdditionDetails::internal_deserialize(map)?)),
                    "paper_enabled_users_group_removal_details" => Ok(EventDetails::PaperEnabledUsersGroupRemovalDetails(PaperEnabledUsersGroupRemovalDetails::internal_deserialize(map)?)),
                    "password_strength_requirements_change_policy_details" => Ok(EventDetails::PasswordStrengthRequirementsChangePolicyDetails(PasswordStrengthRequirementsChangePolicyDetails::internal_deserialize(map)?)),
                    "permanent_delete_change_policy_details" => Ok(EventDetails::PermanentDeleteChangePolicyDetails(PermanentDeleteChangePolicyDetails::internal_deserialize(map)?)),
                    "reseller_support_change_policy_details" => Ok(EventDetails::ResellerSupportChangePolicyDetails(ResellerSupportChangePolicyDetails::internal_deserialize(map)?)),
                    "rewind_policy_changed_details" => Ok(EventDetails::RewindPolicyChangedDetails(RewindPolicyChangedDetails::internal_deserialize(map)?)),
                    "sharing_change_folder_join_policy_details" => Ok(EventDetails::SharingChangeFolderJoinPolicyDetails(SharingChangeFolderJoinPolicyDetails::internal_deserialize(map)?)),
                    "sharing_change_link_policy_details" => Ok(EventDetails::SharingChangeLinkPolicyDetails(SharingChangeLinkPolicyDetails::internal_deserialize(map)?)),
                    "sharing_change_member_policy_details" => Ok(EventDetails::SharingChangeMemberPolicyDetails(SharingChangeMemberPolicyDetails::internal_deserialize(map)?)),
                    "showcase_change_download_policy_details" => Ok(EventDetails::ShowcaseChangeDownloadPolicyDetails(ShowcaseChangeDownloadPolicyDetails::internal_deserialize(map)?)),
                    "showcase_change_enabled_policy_details" => Ok(EventDetails::ShowcaseChangeEnabledPolicyDetails(ShowcaseChangeEnabledPolicyDetails::internal_deserialize(map)?)),
                    "showcase_change_external_sharing_policy_details" => Ok(EventDetails::ShowcaseChangeExternalSharingPolicyDetails(ShowcaseChangeExternalSharingPolicyDetails::internal_deserialize(map)?)),
                    "smarter_smart_sync_policy_changed_details" => Ok(EventDetails::SmarterSmartSyncPolicyChangedDetails(SmarterSmartSyncPolicyChangedDetails::internal_deserialize(map)?)),
                    "smart_sync_change_policy_details" => Ok(EventDetails::SmartSyncChangePolicyDetails(SmartSyncChangePolicyDetails::internal_deserialize(map)?)),
                    "smart_sync_not_opt_out_details" => Ok(EventDetails::SmartSyncNotOptOutDetails(SmartSyncNotOptOutDetails::internal_deserialize(map)?)),
                    "smart_sync_opt_out_details" => Ok(EventDetails::SmartSyncOptOutDetails(SmartSyncOptOutDetails::internal_deserialize(map)?)),
                    "sso_change_policy_details" => Ok(EventDetails::SsoChangePolicyDetails(SsoChangePolicyDetails::internal_deserialize(map)?)),
                    "team_extensions_policy_changed_details" => Ok(EventDetails::TeamExtensionsPolicyChangedDetails(TeamExtensionsPolicyChangedDetails::internal_deserialize(map)?)),
                    "team_selective_sync_policy_changed_details" => Ok(EventDetails::TeamSelectiveSyncPolicyChangedDetails(TeamSelectiveSyncPolicyChangedDetails::internal_deserialize(map)?)),
                    "team_sharing_whitelist_subjects_changed_details" => Ok(EventDetails::TeamSharingWhitelistSubjectsChangedDetails(TeamSharingWhitelistSubjectsChangedDetails::internal_deserialize(map)?)),
                    "tfa_add_exception_details" => Ok(EventDetails::TfaAddExceptionDetails(TfaAddExceptionDetails::internal_deserialize(map)?)),
                    "tfa_change_policy_details" => Ok(EventDetails::TfaChangePolicyDetails(TfaChangePolicyDetails::internal_deserialize(map)?)),
                    "tfa_remove_exception_details" => Ok(EventDetails::TfaRemoveExceptionDetails(TfaRemoveExceptionDetails::internal_deserialize(map)?)),
                    "two_account_change_policy_details" => Ok(EventDetails::TwoAccountChangePolicyDetails(TwoAccountChangePolicyDetails::internal_deserialize(map)?)),
                    "viewer_info_policy_changed_details" => Ok(EventDetails::ViewerInfoPolicyChangedDetails(ViewerInfoPolicyChangedDetails::internal_deserialize(map)?)),
                    "watermarking_policy_changed_details" => Ok(EventDetails::WatermarkingPolicyChangedDetails(WatermarkingPolicyChangedDetails::internal_deserialize(map)?)),
                    "web_sessions_change_active_session_limit_details" => Ok(EventDetails::WebSessionsChangeActiveSessionLimitDetails(WebSessionsChangeActiveSessionLimitDetails::internal_deserialize(map)?)),
                    "web_sessions_change_fixed_length_policy_details" => Ok(EventDetails::WebSessionsChangeFixedLengthPolicyDetails(WebSessionsChangeFixedLengthPolicyDetails::internal_deserialize(map)?)),
                    "web_sessions_change_idle_length_policy_details" => Ok(EventDetails::WebSessionsChangeIdleLengthPolicyDetails(WebSessionsChangeIdleLengthPolicyDetails::internal_deserialize(map)?)),
                    "team_merge_from_details" => Ok(EventDetails::TeamMergeFromDetails(TeamMergeFromDetails::internal_deserialize(map)?)),
                    "team_merge_to_details" => Ok(EventDetails::TeamMergeToDetails(TeamMergeToDetails::internal_deserialize(map)?)),
                    "team_profile_add_logo_details" => Ok(EventDetails::TeamProfileAddLogoDetails(TeamProfileAddLogoDetails::internal_deserialize(map)?)),
                    "team_profile_change_default_language_details" => Ok(EventDetails::TeamProfileChangeDefaultLanguageDetails(TeamProfileChangeDefaultLanguageDetails::internal_deserialize(map)?)),
                    "team_profile_change_logo_details" => Ok(EventDetails::TeamProfileChangeLogoDetails(TeamProfileChangeLogoDetails::internal_deserialize(map)?)),
                    "team_profile_change_name_details" => Ok(EventDetails::TeamProfileChangeNameDetails(TeamProfileChangeNameDetails::internal_deserialize(map)?)),
                    "team_profile_remove_logo_details" => Ok(EventDetails::TeamProfileRemoveLogoDetails(TeamProfileRemoveLogoDetails::internal_deserialize(map)?)),
                    "tfa_add_backup_phone_details" => Ok(EventDetails::TfaAddBackupPhoneDetails(TfaAddBackupPhoneDetails::internal_deserialize(map)?)),
                    "tfa_add_security_key_details" => Ok(EventDetails::TfaAddSecurityKeyDetails(TfaAddSecurityKeyDetails::internal_deserialize(map)?)),
                    "tfa_change_backup_phone_details" => Ok(EventDetails::TfaChangeBackupPhoneDetails(TfaChangeBackupPhoneDetails::internal_deserialize(map)?)),
                    "tfa_change_status_details" => Ok(EventDetails::TfaChangeStatusDetails(TfaChangeStatusDetails::internal_deserialize(map)?)),
                    "tfa_remove_backup_phone_details" => Ok(EventDetails::TfaRemoveBackupPhoneDetails(TfaRemoveBackupPhoneDetails::internal_deserialize(map)?)),
                    "tfa_remove_security_key_details" => Ok(EventDetails::TfaRemoveSecurityKeyDetails(TfaRemoveSecurityKeyDetails::internal_deserialize(map)?)),
                    "tfa_reset_details" => Ok(EventDetails::TfaResetDetails(TfaResetDetails::internal_deserialize(map)?)),
                    "changed_enterprise_admin_role_details" => Ok(EventDetails::ChangedEnterpriseAdminRoleDetails(ChangedEnterpriseAdminRoleDetails::internal_deserialize(map)?)),
                    "changed_enterprise_connected_team_status_details" => Ok(EventDetails::ChangedEnterpriseConnectedTeamStatusDetails(ChangedEnterpriseConnectedTeamStatusDetails::internal_deserialize(map)?)),
                    "ended_enterprise_admin_session_details" => Ok(EventDetails::EndedEnterpriseAdminSessionDetails(EndedEnterpriseAdminSessionDetails::internal_deserialize(map)?)),
                    "ended_enterprise_admin_session_deprecated_details" => Ok(EventDetails::EndedEnterpriseAdminSessionDeprecatedDetails(EndedEnterpriseAdminSessionDeprecatedDetails::internal_deserialize(map)?)),
                    "enterprise_settings_locking_details" => Ok(EventDetails::EnterpriseSettingsLockingDetails(EnterpriseSettingsLockingDetails::internal_deserialize(map)?)),
                    "guest_admin_change_status_details" => Ok(EventDetails::GuestAdminChangeStatusDetails(GuestAdminChangeStatusDetails::internal_deserialize(map)?)),
                    "started_enterprise_admin_session_details" => Ok(EventDetails::StartedEnterpriseAdminSessionDetails(StartedEnterpriseAdminSessionDetails::internal_deserialize(map)?)),
                    "team_merge_request_accepted_details" => Ok(EventDetails::TeamMergeRequestAcceptedDetails(TeamMergeRequestAcceptedDetails::internal_deserialize(map)?)),
                    "team_merge_request_accepted_shown_to_primary_team_details" => Ok(EventDetails::TeamMergeRequestAcceptedShownToPrimaryTeamDetails(TeamMergeRequestAcceptedShownToPrimaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_accepted_shown_to_secondary_team_details" => Ok(EventDetails::TeamMergeRequestAcceptedShownToSecondaryTeamDetails(TeamMergeRequestAcceptedShownToSecondaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_auto_canceled_details" => Ok(EventDetails::TeamMergeRequestAutoCanceledDetails(TeamMergeRequestAutoCanceledDetails::internal_deserialize(map)?)),
                    "team_merge_request_canceled_details" => Ok(EventDetails::TeamMergeRequestCanceledDetails(TeamMergeRequestCanceledDetails::internal_deserialize(map)?)),
                    "team_merge_request_canceled_shown_to_primary_team_details" => Ok(EventDetails::TeamMergeRequestCanceledShownToPrimaryTeamDetails(TeamMergeRequestCanceledShownToPrimaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_canceled_shown_to_secondary_team_details" => Ok(EventDetails::TeamMergeRequestCanceledShownToSecondaryTeamDetails(TeamMergeRequestCanceledShownToSecondaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_expired_details" => Ok(EventDetails::TeamMergeRequestExpiredDetails(TeamMergeRequestExpiredDetails::internal_deserialize(map)?)),
                    "team_merge_request_expired_shown_to_primary_team_details" => Ok(EventDetails::TeamMergeRequestExpiredShownToPrimaryTeamDetails(TeamMergeRequestExpiredShownToPrimaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_expired_shown_to_secondary_team_details" => Ok(EventDetails::TeamMergeRequestExpiredShownToSecondaryTeamDetails(TeamMergeRequestExpiredShownToSecondaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_rejected_shown_to_primary_team_details" => Ok(EventDetails::TeamMergeRequestRejectedShownToPrimaryTeamDetails(TeamMergeRequestRejectedShownToPrimaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_rejected_shown_to_secondary_team_details" => Ok(EventDetails::TeamMergeRequestRejectedShownToSecondaryTeamDetails(TeamMergeRequestRejectedShownToSecondaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_reminder_details" => Ok(EventDetails::TeamMergeRequestReminderDetails(TeamMergeRequestReminderDetails::internal_deserialize(map)?)),
                    "team_merge_request_reminder_shown_to_primary_team_details" => Ok(EventDetails::TeamMergeRequestReminderShownToPrimaryTeamDetails(TeamMergeRequestReminderShownToPrimaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_reminder_shown_to_secondary_team_details" => Ok(EventDetails::TeamMergeRequestReminderShownToSecondaryTeamDetails(TeamMergeRequestReminderShownToSecondaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_revoked_details" => Ok(EventDetails::TeamMergeRequestRevokedDetails(TeamMergeRequestRevokedDetails::internal_deserialize(map)?)),
                    "team_merge_request_sent_shown_to_primary_team_details" => Ok(EventDetails::TeamMergeRequestSentShownToPrimaryTeamDetails(TeamMergeRequestSentShownToPrimaryTeamDetails::internal_deserialize(map)?)),
                    "team_merge_request_sent_shown_to_secondary_team_details" => Ok(EventDetails::TeamMergeRequestSentShownToSecondaryTeamDetails(TeamMergeRequestSentShownToSecondaryTeamDetails::internal_deserialize(map)?)),
                    "missing_details" => Ok(EventDetails::MissingDetails(MissingDetails::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventDetails::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["app_link_team_details",
                                    "app_link_user_details",
                                    "app_unlink_team_details",
                                    "app_unlink_user_details",
                                    "integration_connected_details",
                                    "integration_disconnected_details",
                                    "file_add_comment_details",
                                    "file_change_comment_subscription_details",
                                    "file_delete_comment_details",
                                    "file_edit_comment_details",
                                    "file_like_comment_details",
                                    "file_resolve_comment_details",
                                    "file_unlike_comment_details",
                                    "file_unresolve_comment_details",
                                    "device_change_ip_desktop_details",
                                    "device_change_ip_mobile_details",
                                    "device_change_ip_web_details",
                                    "device_delete_on_unlink_fail_details",
                                    "device_delete_on_unlink_success_details",
                                    "device_link_fail_details",
                                    "device_link_success_details",
                                    "device_management_disabled_details",
                                    "device_management_enabled_details",
                                    "device_unlink_details",
                                    "emm_refresh_auth_token_details",
                                    "account_capture_change_availability_details",
                                    "account_capture_migrate_account_details",
                                    "account_capture_notification_emails_sent_details",
                                    "account_capture_relinquish_account_details",
                                    "disabled_domain_invites_details",
                                    "domain_invites_approve_request_to_join_team_details",
                                    "domain_invites_decline_request_to_join_team_details",
                                    "domain_invites_email_existing_users_details",
                                    "domain_invites_request_to_join_team_details",
                                    "domain_invites_set_invite_new_user_pref_to_no_details",
                                    "domain_invites_set_invite_new_user_pref_to_yes_details",
                                    "domain_verification_add_domain_fail_details",
                                    "domain_verification_add_domain_success_details",
                                    "domain_verification_remove_domain_details",
                                    "enabled_domain_invites_details",
                                    "create_folder_details",
                                    "file_add_details",
                                    "file_copy_details",
                                    "file_delete_details",
                                    "file_download_details",
                                    "file_edit_details",
                                    "file_get_copy_reference_details",
                                    "file_locking_lock_status_changed_details",
                                    "file_move_details",
                                    "file_permanently_delete_details",
                                    "file_preview_details",
                                    "file_rename_details",
                                    "file_restore_details",
                                    "file_revert_details",
                                    "file_rollback_changes_details",
                                    "file_save_copy_reference_details",
                                    "folder_overview_description_changed_details",
                                    "folder_overview_item_pinned_details",
                                    "folder_overview_item_unpinned_details",
                                    "rewind_folder_details",
                                    "file_request_change_details",
                                    "file_request_close_details",
                                    "file_request_create_details",
                                    "file_request_delete_details",
                                    "file_request_receive_file_details",
                                    "group_add_external_id_details",
                                    "group_add_member_details",
                                    "group_change_external_id_details",
                                    "group_change_management_type_details",
                                    "group_change_member_role_details",
                                    "group_create_details",
                                    "group_delete_details",
                                    "group_description_updated_details",
                                    "group_join_policy_updated_details",
                                    "group_moved_details",
                                    "group_remove_external_id_details",
                                    "group_remove_member_details",
                                    "group_rename_details",
                                    "legal_holds_activate_a_hold_details",
                                    "legal_holds_add_members_details",
                                    "legal_holds_change_hold_details_details",
                                    "legal_holds_change_hold_name_details",
                                    "legal_holds_export_a_hold_details",
                                    "legal_holds_export_cancelled_details",
                                    "legal_holds_export_downloaded_details",
                                    "legal_holds_export_removed_details",
                                    "legal_holds_release_a_hold_details",
                                    "legal_holds_remove_members_details",
                                    "legal_holds_report_a_hold_details",
                                    "account_lock_or_unlocked_details",
                                    "emm_error_details",
                                    "guest_admin_signed_in_via_trusted_teams_details",
                                    "guest_admin_signed_out_via_trusted_teams_details",
                                    "login_fail_details",
                                    "login_success_details",
                                    "logout_details",
                                    "reseller_support_session_end_details",
                                    "reseller_support_session_start_details",
                                    "sign_in_as_session_end_details",
                                    "sign_in_as_session_start_details",
                                    "sso_error_details",
                                    "create_team_invite_link_details",
                                    "delete_team_invite_link_details",
                                    "member_add_external_id_details",
                                    "member_add_name_details",
                                    "member_change_admin_role_details",
                                    "member_change_email_details",
                                    "member_change_external_id_details",
                                    "member_change_membership_type_details",
                                    "member_change_name_details",
                                    "member_change_status_details",
                                    "member_delete_manual_contacts_details",
                                    "member_delete_profile_photo_details",
                                    "member_permanently_delete_account_contents_details",
                                    "member_remove_external_id_details",
                                    "member_set_profile_photo_details",
                                    "member_space_limits_add_custom_quota_details",
                                    "member_space_limits_change_custom_quota_details",
                                    "member_space_limits_change_status_details",
                                    "member_space_limits_remove_custom_quota_details",
                                    "member_suggest_details",
                                    "member_transfer_account_contents_details",
                                    "pending_secondary_email_added_details",
                                    "secondary_email_deleted_details",
                                    "secondary_email_verified_details",
                                    "secondary_mails_policy_changed_details",
                                    "binder_add_page_details",
                                    "binder_add_section_details",
                                    "binder_remove_page_details",
                                    "binder_remove_section_details",
                                    "binder_rename_page_details",
                                    "binder_rename_section_details",
                                    "binder_reorder_page_details",
                                    "binder_reorder_section_details",
                                    "paper_content_add_member_details",
                                    "paper_content_add_to_folder_details",
                                    "paper_content_archive_details",
                                    "paper_content_create_details",
                                    "paper_content_permanently_delete_details",
                                    "paper_content_remove_from_folder_details",
                                    "paper_content_remove_member_details",
                                    "paper_content_rename_details",
                                    "paper_content_restore_details",
                                    "paper_doc_add_comment_details",
                                    "paper_doc_change_member_role_details",
                                    "paper_doc_change_sharing_policy_details",
                                    "paper_doc_change_subscription_details",
                                    "paper_doc_deleted_details",
                                    "paper_doc_delete_comment_details",
                                    "paper_doc_download_details",
                                    "paper_doc_edit_details",
                                    "paper_doc_edit_comment_details",
                                    "paper_doc_followed_details",
                                    "paper_doc_mention_details",
                                    "paper_doc_ownership_changed_details",
                                    "paper_doc_request_access_details",
                                    "paper_doc_resolve_comment_details",
                                    "paper_doc_revert_details",
                                    "paper_doc_slack_share_details",
                                    "paper_doc_team_invite_details",
                                    "paper_doc_trashed_details",
                                    "paper_doc_unresolve_comment_details",
                                    "paper_doc_untrashed_details",
                                    "paper_doc_view_details",
                                    "paper_external_view_allow_details",
                                    "paper_external_view_default_team_details",
                                    "paper_external_view_forbid_details",
                                    "paper_folder_change_subscription_details",
                                    "paper_folder_deleted_details",
                                    "paper_folder_followed_details",
                                    "paper_folder_team_invite_details",
                                    "paper_published_link_change_permission_details",
                                    "paper_published_link_create_details",
                                    "paper_published_link_disabled_details",
                                    "paper_published_link_view_details",
                                    "password_change_details",
                                    "password_reset_details",
                                    "password_reset_all_details",
                                    "emm_create_exceptions_report_details",
                                    "emm_create_usage_report_details",
                                    "export_members_report_details",
                                    "export_members_report_fail_details",
                                    "no_expiration_link_gen_create_report_details",
                                    "no_expiration_link_gen_report_failed_details",
                                    "no_password_link_gen_create_report_details",
                                    "no_password_link_gen_report_failed_details",
                                    "no_password_link_view_create_report_details",
                                    "no_password_link_view_report_failed_details",
                                    "outdated_link_view_create_report_details",
                                    "outdated_link_view_report_failed_details",
                                    "paper_admin_export_start_details",
                                    "smart_sync_create_admin_privilege_report_details",
                                    "team_activity_create_report_details",
                                    "team_activity_create_report_fail_details",
                                    "collection_share_details",
                                    "file_transfers_file_add_details",
                                    "file_transfers_transfer_delete_details",
                                    "file_transfers_transfer_download_details",
                                    "file_transfers_transfer_send_details",
                                    "file_transfers_transfer_view_details",
                                    "note_acl_invite_only_details",
                                    "note_acl_link_details",
                                    "note_acl_team_link_details",
                                    "note_shared_details",
                                    "note_share_receive_details",
                                    "open_note_shared_details",
                                    "sf_add_group_details",
                                    "sf_allow_non_members_to_view_shared_links_details",
                                    "sf_external_invite_warn_details",
                                    "sf_fb_invite_details",
                                    "sf_fb_invite_change_role_details",
                                    "sf_fb_uninvite_details",
                                    "sf_invite_group_details",
                                    "sf_team_grant_access_details",
                                    "sf_team_invite_details",
                                    "sf_team_invite_change_role_details",
                                    "sf_team_join_details",
                                    "sf_team_join_from_oob_link_details",
                                    "sf_team_uninvite_details",
                                    "shared_content_add_invitees_details",
                                    "shared_content_add_link_expiry_details",
                                    "shared_content_add_link_password_details",
                                    "shared_content_add_member_details",
                                    "shared_content_change_downloads_policy_details",
                                    "shared_content_change_invitee_role_details",
                                    "shared_content_change_link_audience_details",
                                    "shared_content_change_link_expiry_details",
                                    "shared_content_change_link_password_details",
                                    "shared_content_change_member_role_details",
                                    "shared_content_change_viewer_info_policy_details",
                                    "shared_content_claim_invitation_details",
                                    "shared_content_copy_details",
                                    "shared_content_download_details",
                                    "shared_content_relinquish_membership_details",
                                    "shared_content_remove_invitees_details",
                                    "shared_content_remove_link_expiry_details",
                                    "shared_content_remove_link_password_details",
                                    "shared_content_remove_member_details",
                                    "shared_content_request_access_details",
                                    "shared_content_restore_invitees_details",
                                    "shared_content_restore_member_details",
                                    "shared_content_unshare_details",
                                    "shared_content_view_details",
                                    "shared_folder_change_link_policy_details",
                                    "shared_folder_change_members_inheritance_policy_details",
                                    "shared_folder_change_members_management_policy_details",
                                    "shared_folder_change_members_policy_details",
                                    "shared_folder_create_details",
                                    "shared_folder_decline_invitation_details",
                                    "shared_folder_mount_details",
                                    "shared_folder_nest_details",
                                    "shared_folder_transfer_ownership_details",
                                    "shared_folder_unmount_details",
                                    "shared_link_add_expiry_details",
                                    "shared_link_change_expiry_details",
                                    "shared_link_change_visibility_details",
                                    "shared_link_copy_details",
                                    "shared_link_create_details",
                                    "shared_link_disable_details",
                                    "shared_link_download_details",
                                    "shared_link_remove_expiry_details",
                                    "shared_link_settings_add_expiration_details",
                                    "shared_link_settings_add_password_details",
                                    "shared_link_settings_allow_download_disabled_details",
                                    "shared_link_settings_allow_download_enabled_details",
                                    "shared_link_settings_change_audience_details",
                                    "shared_link_settings_change_expiration_details",
                                    "shared_link_settings_change_password_details",
                                    "shared_link_settings_remove_expiration_details",
                                    "shared_link_settings_remove_password_details",
                                    "shared_link_share_details",
                                    "shared_link_view_details",
                                    "shared_note_opened_details",
                                    "shmodel_group_share_details",
                                    "showcase_access_granted_details",
                                    "showcase_add_member_details",
                                    "showcase_archived_details",
                                    "showcase_created_details",
                                    "showcase_delete_comment_details",
                                    "showcase_edited_details",
                                    "showcase_edit_comment_details",
                                    "showcase_file_added_details",
                                    "showcase_file_download_details",
                                    "showcase_file_removed_details",
                                    "showcase_file_view_details",
                                    "showcase_permanently_deleted_details",
                                    "showcase_post_comment_details",
                                    "showcase_remove_member_details",
                                    "showcase_renamed_details",
                                    "showcase_request_access_details",
                                    "showcase_resolve_comment_details",
                                    "showcase_restored_details",
                                    "showcase_trashed_details",
                                    "showcase_trashed_deprecated_details",
                                    "showcase_unresolve_comment_details",
                                    "showcase_untrashed_details",
                                    "showcase_untrashed_deprecated_details",
                                    "showcase_view_details",
                                    "sso_add_cert_details",
                                    "sso_add_login_url_details",
                                    "sso_add_logout_url_details",
                                    "sso_change_cert_details",
                                    "sso_change_login_url_details",
                                    "sso_change_logout_url_details",
                                    "sso_change_saml_identity_mode_details",
                                    "sso_remove_cert_details",
                                    "sso_remove_login_url_details",
                                    "sso_remove_logout_url_details",
                                    "team_folder_change_status_details",
                                    "team_folder_create_details",
                                    "team_folder_downgrade_details",
                                    "team_folder_permanently_delete_details",
                                    "team_folder_rename_details",
                                    "team_selective_sync_settings_changed_details",
                                    "account_capture_change_policy_details",
                                    "allow_download_disabled_details",
                                    "allow_download_enabled_details",
                                    "camera_uploads_policy_changed_details",
                                    "data_placement_restriction_change_policy_details",
                                    "data_placement_restriction_satisfy_policy_details",
                                    "device_approvals_add_exception_details",
                                    "device_approvals_change_desktop_policy_details",
                                    "device_approvals_change_mobile_policy_details",
                                    "device_approvals_change_overage_action_details",
                                    "device_approvals_change_unlink_action_details",
                                    "device_approvals_remove_exception_details",
                                    "directory_restrictions_add_members_details",
                                    "directory_restrictions_remove_members_details",
                                    "emm_add_exception_details",
                                    "emm_change_policy_details",
                                    "emm_remove_exception_details",
                                    "extended_version_history_change_policy_details",
                                    "file_comments_change_policy_details",
                                    "file_locking_policy_changed_details",
                                    "file_requests_change_policy_details",
                                    "file_requests_emails_enabled_details",
                                    "file_requests_emails_restricted_to_team_only_details",
                                    "file_transfers_policy_changed_details",
                                    "google_sso_change_policy_details",
                                    "group_user_management_change_policy_details",
                                    "integration_policy_changed_details",
                                    "member_requests_change_policy_details",
                                    "member_send_invite_policy_changed_details",
                                    "member_space_limits_add_exception_details",
                                    "member_space_limits_change_caps_type_policy_details",
                                    "member_space_limits_change_policy_details",
                                    "member_space_limits_remove_exception_details",
                                    "member_suggestions_change_policy_details",
                                    "microsoft_office_addin_change_policy_details",
                                    "network_control_change_policy_details",
                                    "paper_change_deployment_policy_details",
                                    "paper_change_member_link_policy_details",
                                    "paper_change_member_policy_details",
                                    "paper_change_policy_details",
                                    "paper_default_folder_policy_changed_details",
                                    "paper_desktop_policy_changed_details",
                                    "paper_enabled_users_group_addition_details",
                                    "paper_enabled_users_group_removal_details",
                                    "password_strength_requirements_change_policy_details",
                                    "permanent_delete_change_policy_details",
                                    "reseller_support_change_policy_details",
                                    "rewind_policy_changed_details",
                                    "sharing_change_folder_join_policy_details",
                                    "sharing_change_link_policy_details",
                                    "sharing_change_member_policy_details",
                                    "showcase_change_download_policy_details",
                                    "showcase_change_enabled_policy_details",
                                    "showcase_change_external_sharing_policy_details",
                                    "smarter_smart_sync_policy_changed_details",
                                    "smart_sync_change_policy_details",
                                    "smart_sync_not_opt_out_details",
                                    "smart_sync_opt_out_details",
                                    "sso_change_policy_details",
                                    "team_extensions_policy_changed_details",
                                    "team_selective_sync_policy_changed_details",
                                    "team_sharing_whitelist_subjects_changed_details",
                                    "tfa_add_exception_details",
                                    "tfa_change_policy_details",
                                    "tfa_remove_exception_details",
                                    "two_account_change_policy_details",
                                    "viewer_info_policy_changed_details",
                                    "watermarking_policy_changed_details",
                                    "web_sessions_change_active_session_limit_details",
                                    "web_sessions_change_fixed_length_policy_details",
                                    "web_sessions_change_idle_length_policy_details",
                                    "team_merge_from_details",
                                    "team_merge_to_details",
                                    "team_profile_add_logo_details",
                                    "team_profile_change_default_language_details",
                                    "team_profile_change_logo_details",
                                    "team_profile_change_name_details",
                                    "team_profile_remove_logo_details",
                                    "tfa_add_backup_phone_details",
                                    "tfa_add_security_key_details",
                                    "tfa_change_backup_phone_details",
                                    "tfa_change_status_details",
                                    "tfa_remove_backup_phone_details",
                                    "tfa_remove_security_key_details",
                                    "tfa_reset_details",
                                    "changed_enterprise_admin_role_details",
                                    "changed_enterprise_connected_team_status_details",
                                    "ended_enterprise_admin_session_details",
                                    "ended_enterprise_admin_session_deprecated_details",
                                    "enterprise_settings_locking_details",
                                    "guest_admin_change_status_details",
                                    "started_enterprise_admin_session_details",
                                    "team_merge_request_accepted_details",
                                    "team_merge_request_accepted_shown_to_primary_team_details",
                                    "team_merge_request_accepted_shown_to_secondary_team_details",
                                    "team_merge_request_auto_canceled_details",
                                    "team_merge_request_canceled_details",
                                    "team_merge_request_canceled_shown_to_primary_team_details",
                                    "team_merge_request_canceled_shown_to_secondary_team_details",
                                    "team_merge_request_expired_details",
                                    "team_merge_request_expired_shown_to_primary_team_details",
                                    "team_merge_request_expired_shown_to_secondary_team_details",
                                    "team_merge_request_rejected_shown_to_primary_team_details",
                                    "team_merge_request_rejected_shown_to_secondary_team_details",
                                    "team_merge_request_reminder_details",
                                    "team_merge_request_reminder_shown_to_primary_team_details",
                                    "team_merge_request_reminder_shown_to_secondary_team_details",
                                    "team_merge_request_revoked_details",
                                    "team_merge_request_sent_shown_to_primary_team_details",
                                    "team_merge_request_sent_shown_to_secondary_team_details",
                                    "missing_details",
                                    "other"];
        deserializer.deserialize_struct("EventDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EventDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EventDetails::AppLinkTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_link_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppLinkUserDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_link_user_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppUnlinkTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_unlink_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AppUnlinkUserDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "app_unlink_user_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::IntegrationConnectedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "integration_connected_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::IntegrationDisconnectedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "integration_disconnected_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileAddCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_add_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileChangeCommentSubscriptionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_change_comment_subscription_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileDeleteCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_delete_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileEditCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_edit_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileLikeCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_like_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileResolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_resolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileUnlikeCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_unlike_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileUnresolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_unresolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceChangeIpDesktopDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_change_ip_desktop_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceChangeIpMobileDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_change_ip_mobile_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceChangeIpWebDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_change_ip_web_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceDeleteOnUnlinkFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "device_delete_on_unlink_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceDeleteOnUnlinkSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_delete_on_unlink_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceLinkFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_link_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceLinkSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "device_link_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceManagementDisabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "device_management_disabled_details")?;
                s.end()
            }
            EventDetails::DeviceManagementEnabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "device_management_enabled_details")?;
                s.end()
            }
            EventDetails::DeviceUnlinkDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "device_unlink_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmRefreshAuthTokenDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_refresh_auth_token_details")?;
                s.end()
            }
            EventDetails::AccountCaptureChangeAvailabilityDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "account_capture_change_availability_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureMigrateAccountDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "account_capture_migrate_account_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureNotificationEmailsSentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "account_capture_notification_emails_sent_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureRelinquishAccountDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "account_capture_relinquish_account_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DisabledDomainInvitesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "disabled_domain_invites_details")?;
                s.end()
            }
            EventDetails::DomainInvitesApproveRequestToJoinTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_approve_request_to_join_team_details")?;
                s.end()
            }
            EventDetails::DomainInvitesDeclineRequestToJoinTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_decline_request_to_join_team_details")?;
                s.end()
            }
            EventDetails::DomainInvitesEmailExistingUsersDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_invites_email_existing_users_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DomainInvitesRequestToJoinTeamDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_request_to_join_team_details")?;
                s.end()
            }
            EventDetails::DomainInvitesSetInviteNewUserPrefToNoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_no_details")?;
                s.end()
            }
            EventDetails::DomainInvitesSetInviteNewUserPrefToYesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_yes_details")?;
                s.end()
            }
            EventDetails::DomainVerificationAddDomainFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_verification_add_domain_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DomainVerificationAddDomainSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "domain_verification_add_domain_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DomainVerificationRemoveDomainDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "domain_verification_remove_domain_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EnabledDomainInvitesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "enabled_domain_invites_details")?;
                s.end()
            }
            EventDetails::CreateFolderDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "create_folder_details")?;
                s.end()
            }
            EventDetails::FileAddDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_add_details")?;
                s.end()
            }
            EventDetails::FileCopyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_copy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileDeleteDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_delete_details")?;
                s.end()
            }
            EventDetails::FileDownloadDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_download_details")?;
                s.end()
            }
            EventDetails::FileEditDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_edit_details")?;
                s.end()
            }
            EventDetails::FileGetCopyReferenceDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_get_copy_reference_details")?;
                s.end()
            }
            EventDetails::FileLockingLockStatusChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_locking_lock_status_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileMoveDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_move_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FilePermanentlyDeleteDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_permanently_delete_details")?;
                s.end()
            }
            EventDetails::FilePreviewDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_preview_details")?;
                s.end()
            }
            EventDetails::FileRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRestoreDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_restore_details")?;
                s.end()
            }
            EventDetails::FileRevertDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_revert_details")?;
                s.end()
            }
            EventDetails::FileRollbackChangesDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_rollback_changes_details")?;
                s.end()
            }
            EventDetails::FileSaveCopyReferenceDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_save_copy_reference_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FolderOverviewDescriptionChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "folder_overview_description_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FolderOverviewItemPinnedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "folder_overview_item_pinned_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FolderOverviewItemUnpinnedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "folder_overview_item_unpinned_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::RewindFolderDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "rewind_folder_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestChangeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "file_request_change_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestCloseDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_request_close_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_request_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestDeleteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_request_delete_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestReceiveFileDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "file_request_receive_file_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupAddExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_add_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupChangeExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_change_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupChangeManagementTypeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_change_management_type_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupChangeMemberRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_change_member_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupDeleteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_delete_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupDescriptionUpdatedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "group_description_updated_details")?;
                s.end()
            }
            EventDetails::GroupJoinPolicyUpdatedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_join_policy_updated_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupMovedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "group_moved_details")?;
                s.end()
            }
            EventDetails::GroupRemoveExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "group_remove_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupRemoveMemberDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "group_remove_member_details")?;
                s.end()
            }
            EventDetails::GroupRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsActivateAHoldDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "legal_holds_activate_a_hold_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsAddMembersDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "legal_holds_add_members_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsChangeHoldDetailsDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "legal_holds_change_hold_details_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsChangeHoldNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "legal_holds_change_hold_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsExportAHoldDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "legal_holds_export_a_hold_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsExportCancelledDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "legal_holds_export_cancelled_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsExportDownloadedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 6)?;
                s.serialize_field(".tag", "legal_holds_export_downloaded_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsExportRemovedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "legal_holds_export_removed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsReleaseAHoldDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "legal_holds_release_a_hold_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsRemoveMembersDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "legal_holds_remove_members_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LegalHoldsReportAHoldDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "legal_holds_report_a_hold_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountLockOrUnlockedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "account_lock_or_unlocked_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmErrorDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "emm_error_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GuestAdminSignedInViaTrustedTeamsDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "guest_admin_signed_in_via_trusted_teams_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GuestAdminSignedOutViaTrustedTeamsDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "guest_admin_signed_out_via_trusted_teams_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LoginFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "login_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LoginSuccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "login_success_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::LogoutDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "logout_details")?;
                s.end()
            }
            EventDetails::ResellerSupportSessionEndDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "reseller_support_session_end_details")?;
                s.end()
            }
            EventDetails::ResellerSupportSessionStartDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "reseller_support_session_start_details")?;
                s.end()
            }
            EventDetails::SignInAsSessionEndDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "sign_in_as_session_end_details")?;
                s.end()
            }
            EventDetails::SignInAsSessionStartDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "sign_in_as_session_start_details")?;
                s.end()
            }
            EventDetails::SsoErrorDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_error_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::CreateTeamInviteLinkDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "create_team_invite_link_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeleteTeamInviteLinkDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "delete_team_invite_link_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberAddExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "member_add_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberAddNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "member_add_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeAdminRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_admin_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeEmailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_email_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeMembershipTypeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_membership_type_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_change_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "member_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberDeleteManualContactsDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_delete_manual_contacts_details")?;
                s.end()
            }
            EventDetails::MemberDeleteProfilePhotoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_delete_profile_photo_details")?;
                s.end()
            }
            EventDetails::MemberPermanentlyDeleteAccountContentsDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_permanently_delete_account_contents_details")?;
                s.end()
            }
            EventDetails::MemberRemoveExternalIdDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "member_remove_external_id_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSetProfilePhotoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_set_profile_photo_details")?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsAddCustomQuotaDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "member_space_limits_add_custom_quota_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangeCustomQuotaDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_custom_quota_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsRemoveCustomQuotaDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_space_limits_remove_custom_quota_details")?;
                s.end()
            }
            EventDetails::MemberSuggestDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "member_suggest_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberTransferAccountContentsDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_transfer_account_contents_details")?;
                s.end()
            }
            EventDetails::PendingSecondaryEmailAddedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "pending_secondary_email_added_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SecondaryEmailDeletedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "secondary_email_deleted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SecondaryEmailVerifiedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "secondary_email_verified_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SecondaryMailsPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "secondary_mails_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::BinderAddPageDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "binder_add_page_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::BinderAddSectionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "binder_add_section_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::BinderRemovePageDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "binder_remove_page_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::BinderRemoveSectionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "binder_remove_section_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::BinderRenamePageDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "binder_rename_page_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::BinderRenameSectionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "binder_rename_section_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::BinderReorderPageDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "binder_reorder_page_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::BinderReorderSectionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "binder_reorder_section_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentAddToFolderDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_content_add_to_folder_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentArchiveDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_archive_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentPermanentlyDeleteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_permanently_delete_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRemoveFromFolderDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_content_remove_from_folder_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRemoveMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_remove_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperContentRestoreDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_content_restore_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocAddCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_add_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocChangeMemberRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_change_member_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocChangeSharingPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_doc_change_sharing_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocChangeSubscriptionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_doc_change_subscription_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocDeletedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_deleted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocDeleteCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_delete_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocEditDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_edit_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocEditCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_edit_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocFollowedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_followed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocMentionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_mention_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocOwnershipChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_doc_ownership_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocRequestAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_request_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocResolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_resolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocRevertDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_revert_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocSlackShareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_slack_share_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocTeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocTrashedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_trashed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocUnresolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_doc_unresolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocUntrashedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_untrashed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDocViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_doc_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperExternalViewAllowDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_external_view_allow_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperExternalViewDefaultTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_external_view_default_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperExternalViewForbidDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_external_view_forbid_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderChangeSubscriptionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_folder_change_subscription_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderDeletedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_folder_deleted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderFollowedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_folder_followed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperFolderTeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_folder_team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperPublishedLinkChangePermissionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "paper_published_link_change_permission_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperPublishedLinkCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_published_link_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperPublishedLinkDisabledDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_published_link_disabled_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperPublishedLinkViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_published_link_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PasswordChangeDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_change_details")?;
                s.end()
            }
            EventDetails::PasswordResetDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_reset_details")?;
                s.end()
            }
            EventDetails::PasswordResetAllDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "password_reset_all_details")?;
                s.end()
            }
            EventDetails::EmmCreateExceptionsReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_create_exceptions_report_details")?;
                s.end()
            }
            EventDetails::EmmCreateUsageReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_create_usage_report_details")?;
                s.end()
            }
            EventDetails::ExportMembersReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "export_members_report_details")?;
                s.end()
            }
            EventDetails::ExportMembersReportFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "export_members_report_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NoExpirationLinkGenCreateReportDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "no_expiration_link_gen_create_report_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NoExpirationLinkGenReportFailedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "no_expiration_link_gen_report_failed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NoPasswordLinkGenCreateReportDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "no_password_link_gen_create_report_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NoPasswordLinkGenReportFailedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "no_password_link_gen_report_failed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NoPasswordLinkViewCreateReportDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "no_password_link_view_create_report_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NoPasswordLinkViewReportFailedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "no_password_link_view_report_failed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::OutdatedLinkViewCreateReportDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "outdated_link_view_create_report_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::OutdatedLinkViewReportFailedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "outdated_link_view_report_failed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperAdminExportStartDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_admin_export_start_details")?;
                s.end()
            }
            EventDetails::SmartSyncCreateAdminPrivilegeReportDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "smart_sync_create_admin_privilege_report_details")?;
                s.end()
            }
            EventDetails::TeamActivityCreateReportDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_activity_create_report_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamActivityCreateReportFailDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_activity_create_report_fail_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::CollectionShareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "collection_share_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileTransfersFileAddDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_transfers_file_add_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileTransfersTransferDeleteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_transfers_transfer_delete_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileTransfersTransferDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_transfers_transfer_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileTransfersTransferSendDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_transfers_transfer_send_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileTransfersTransferViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "file_transfers_transfer_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NoteAclInviteOnlyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_acl_invite_only_details")?;
                s.end()
            }
            EventDetails::NoteAclLinkDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_acl_link_details")?;
                s.end()
            }
            EventDetails::NoteAclTeamLinkDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_acl_team_link_details")?;
                s.end()
            }
            EventDetails::NoteSharedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_shared_details")?;
                s.end()
            }
            EventDetails::NoteShareReceiveDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "note_share_receive_details")?;
                s.end()
            }
            EventDetails::OpenNoteSharedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "open_note_shared_details")?;
                s.end()
            }
            EventDetails::SfAddGroupDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_add_group_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfAllowNonMembersToViewSharedLinksDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "sf_allow_non_members_to_view_shared_links_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfExternalInviteWarnDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_external_invite_warn_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfFbInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "sf_fb_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfFbInviteChangeRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_fb_invite_change_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfFbUninviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_fb_uninvite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfInviteGroupDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sf_invite_group_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamGrantAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_grant_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamInviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "sf_team_invite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamInviteChangeRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_team_invite_change_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamJoinDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_join_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamJoinFromOobLinkDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "sf_team_join_from_oob_link_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SfTeamUninviteDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sf_team_uninvite_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddInviteesDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_add_invitees_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddLinkExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_add_link_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentAddLinkPasswordDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_add_link_password_details")?;
                s.end()
            }
            EventDetails::SharedContentAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeDownloadsPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_downloads_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeInviteeRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_change_invitee_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeLinkAudienceDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_link_audience_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeLinkExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_link_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeLinkPasswordDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_change_link_password_details")?;
                s.end()
            }
            EventDetails::SharedContentChangeMemberRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_member_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentChangeViewerInfoPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_change_viewer_info_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentClaimInvitationDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_claim_invitation_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentCopyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_content_copy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRelinquishMembershipDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_relinquish_membership_details")?;
                s.end()
            }
            EventDetails::SharedContentRemoveInviteesDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_remove_invitees_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRemoveLinkExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_remove_link_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRemoveLinkPasswordDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_remove_link_password_details")?;
                s.end()
            }
            EventDetails::SharedContentRemoveMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_remove_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRequestAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_request_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRestoreInviteesDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_content_restore_invitees_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentRestoreMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_content_restore_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedContentUnshareDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_content_unshare_details")?;
                s.end()
            }
            EventDetails::SharedContentViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_content_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeLinkPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_change_link_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeMembersInheritancePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_change_members_inheritance_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeMembersManagementPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_change_members_management_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderChangeMembersPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_change_members_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_folder_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderDeclineInvitationDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_folder_decline_invitation_details")?;
                s.end()
            }
            EventDetails::SharedFolderMountDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_folder_mount_details")?;
                s.end()
            }
            EventDetails::SharedFolderNestDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_folder_nest_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderTransferOwnershipDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_folder_transfer_ownership_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedFolderUnmountDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_folder_unmount_details")?;
                s.end()
            }
            EventDetails::SharedLinkAddExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_add_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkChangeExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_change_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkChangeVisibilityDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_change_visibility_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkCopyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_copy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkCreateDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_create_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkDisableDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_disable_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkRemoveExpiryDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_remove_expiry_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkSettingsAddExpirationDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_link_settings_add_expiration_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkSettingsAddPasswordDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_settings_add_password_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkSettingsAllowDownloadDisabledDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_settings_allow_download_disabled_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkSettingsAllowDownloadEnabledDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_settings_allow_download_enabled_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkSettingsChangeAudienceDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_link_settings_change_audience_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkSettingsChangeExpirationDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "shared_link_settings_change_expiration_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkSettingsChangePasswordDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_settings_change_password_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkSettingsRemoveExpirationDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "shared_link_settings_remove_expiration_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkSettingsRemovePasswordDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_settings_remove_password_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkShareDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "shared_link_share_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedLinkViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "shared_link_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharedNoteOpenedDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shared_note_opened_details")?;
                s.end()
            }
            EventDetails::ShmodelGroupShareDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "shmodel_group_share_details")?;
                s.end()
            }
            EventDetails::ShowcaseAccessGrantedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_access_granted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseAddMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_add_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseArchivedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_archived_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseCreatedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_created_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseDeleteCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "showcase_delete_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseEditedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_edited_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseEditCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "showcase_edit_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseFileAddedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_file_added_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseFileDownloadDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "showcase_file_download_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseFileRemovedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_file_removed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseFileViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_file_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcasePermanentlyDeletedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_permanently_deleted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcasePostCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "showcase_post_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseRemoveMemberDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_remove_member_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseRenamedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_renamed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseRequestAccessDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_request_access_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseResolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "showcase_resolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseRestoredDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_restored_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseTrashedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_trashed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseTrashedDeprecatedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_trashed_deprecated_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseUnresolveCommentDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "showcase_unresolve_comment_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseUntrashedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_untrashed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseUntrashedDeprecatedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_untrashed_deprecated_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseViewDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "showcase_view_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoAddCertDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_add_cert_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoAddLoginUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_add_login_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoAddLogoutUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_add_logout_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeCertDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_cert_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeLoginUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_login_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeLogoutUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_logout_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangeSamlIdentityModeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_saml_identity_mode_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoRemoveCertDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "sso_remove_cert_details")?;
                s.end()
            }
            EventDetails::SsoRemoveLoginUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_remove_login_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoRemoveLogoutUrlDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "sso_remove_logout_url_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamFolderChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_folder_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamFolderCreateDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_folder_create_details")?;
                s.end()
            }
            EventDetails::TeamFolderDowngradeDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_folder_downgrade_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamFolderPermanentlyDeleteDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_folder_permanently_delete_details")?;
                s.end()
            }
            EventDetails::TeamFolderRenameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_folder_rename_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamSelectiveSyncSettingsChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_selective_sync_settings_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AccountCaptureChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "account_capture_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::AllowDownloadDisabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "allow_download_disabled_details")?;
                s.end()
            }
            EventDetails::AllowDownloadEnabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "allow_download_enabled_details")?;
                s.end()
            }
            EventDetails::CameraUploadsPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "camera_uploads_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DataPlacementRestrictionChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "data_placement_restriction_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DataPlacementRestrictionSatisfyPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "data_placement_restriction_satisfy_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsAddExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "device_approvals_add_exception_details")?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeDesktopPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_desktop_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeMobilePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_mobile_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeOverageActionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_overage_action_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsChangeUnlinkActionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "device_approvals_change_unlink_action_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::DeviceApprovalsRemoveExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "device_approvals_remove_exception_details")?;
                s.end()
            }
            EventDetails::DirectoryRestrictionsAddMembersDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "directory_restrictions_add_members_details")?;
                s.end()
            }
            EventDetails::DirectoryRestrictionsRemoveMembersDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "directory_restrictions_remove_members_details")?;
                s.end()
            }
            EventDetails::EmmAddExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_add_exception_details")?;
                s.end()
            }
            EventDetails::EmmChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "emm_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EmmRemoveExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "emm_remove_exception_details")?;
                s.end()
            }
            EventDetails::ExtendedVersionHistoryChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "extended_version_history_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileCommentsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_comments_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileLockingPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_locking_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_requests_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::FileRequestsEmailsEnabledDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_requests_emails_enabled_details")?;
                s.end()
            }
            EventDetails::FileRequestsEmailsRestrictedToTeamOnlyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "file_requests_emails_restricted_to_team_only_details")?;
                s.end()
            }
            EventDetails::FileTransfersPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "file_transfers_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GoogleSsoChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "google_sso_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GroupUserManagementChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "group_user_management_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::IntegrationPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "integration_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberRequestsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_requests_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSendInvitePolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_send_invite_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsAddExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_space_limits_add_exception_details")?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangeCapsTypePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_caps_type_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_space_limits_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MemberSpaceLimitsRemoveExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "member_space_limits_remove_exception_details")?;
                s.end()
            }
            EventDetails::MemberSuggestionsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "member_suggestions_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MicrosoftOfficeAddinChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "microsoft_office_addin_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::NetworkControlChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "network_control_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangeDeploymentPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_change_deployment_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangeMemberLinkPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "paper_change_member_link_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangeMemberPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_change_member_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDefaultFolderPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_default_folder_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperDesktopPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "paper_desktop_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PaperEnabledUsersGroupAdditionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_enabled_users_group_addition_details")?;
                s.end()
            }
            EventDetails::PaperEnabledUsersGroupRemovalDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "paper_enabled_users_group_removal_details")?;
                s.end()
            }
            EventDetails::PasswordStrengthRequirementsChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "password_strength_requirements_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::PermanentDeleteChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "permanent_delete_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ResellerSupportChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "reseller_support_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::RewindPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "rewind_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharingChangeFolderJoinPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sharing_change_folder_join_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharingChangeLinkPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sharing_change_link_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SharingChangeMemberPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sharing_change_member_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseChangeDownloadPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "showcase_change_download_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseChangeEnabledPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "showcase_change_enabled_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ShowcaseChangeExternalSharingPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "showcase_change_external_sharing_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmarterSmartSyncPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smarter_smart_sync_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmartSyncChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smart_sync_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmartSyncNotOptOutDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smart_sync_not_opt_out_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SmartSyncOptOutDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "smart_sync_opt_out_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::SsoChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "sso_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamExtensionsPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_extensions_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamSelectiveSyncPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_selective_sync_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamSharingWhitelistSubjectsChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_sharing_whitelist_subjects_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TfaAddExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_add_exception_details")?;
                s.end()
            }
            EventDetails::TfaChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "tfa_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TfaRemoveExceptionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_remove_exception_details")?;
                s.end()
            }
            EventDetails::TwoAccountChangePolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "two_account_change_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ViewerInfoPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "viewer_info_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::WatermarkingPolicyChangedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "watermarking_policy_changed_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::WebSessionsChangeActiveSessionLimitDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "web_sessions_change_active_session_limit_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::WebSessionsChangeFixedLengthPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "web_sessions_change_fixed_length_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::WebSessionsChangeIdleLengthPolicyDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "web_sessions_change_idle_length_policy_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeFromDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_from_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeToDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_to_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamProfileAddLogoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_profile_add_logo_details")?;
                s.end()
            }
            EventDetails::TeamProfileChangeDefaultLanguageDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_profile_change_default_language_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamProfileChangeLogoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_profile_change_logo_details")?;
                s.end()
            }
            EventDetails::TeamProfileChangeNameDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_profile_change_name_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamProfileRemoveLogoDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "team_profile_remove_logo_details")?;
                s.end()
            }
            EventDetails::TfaAddBackupPhoneDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_add_backup_phone_details")?;
                s.end()
            }
            EventDetails::TfaAddSecurityKeyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_add_security_key_details")?;
                s.end()
            }
            EventDetails::TfaChangeBackupPhoneDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_change_backup_phone_details")?;
                s.end()
            }
            EventDetails::TfaChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "tfa_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TfaRemoveBackupPhoneDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_remove_backup_phone_details")?;
                s.end()
            }
            EventDetails::TfaRemoveSecurityKeyDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_remove_security_key_details")?;
                s.end()
            }
            EventDetails::TfaResetDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "tfa_reset_details")?;
                s.end()
            }
            EventDetails::ChangedEnterpriseAdminRoleDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 4)?;
                s.serialize_field(".tag", "changed_enterprise_admin_role_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::ChangedEnterpriseConnectedTeamStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "changed_enterprise_connected_team_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EndedEnterpriseAdminSessionDetails(_) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 1)?;
                s.serialize_field(".tag", "ended_enterprise_admin_session_details")?;
                s.end()
            }
            EventDetails::EndedEnterpriseAdminSessionDeprecatedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "ended_enterprise_admin_session_deprecated_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::EnterpriseSettingsLockingDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 5)?;
                s.serialize_field(".tag", "enterprise_settings_locking_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::GuestAdminChangeStatusDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 7)?;
                s.serialize_field(".tag", "guest_admin_change_status_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::StartedEnterpriseAdminSessionDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "started_enterprise_admin_session_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestAcceptedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_accepted_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestAcceptedShownToPrimaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_merge_request_accepted_shown_to_primary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestAcceptedShownToSecondaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_merge_request_accepted_shown_to_secondary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestAutoCanceledDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_auto_canceled_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestCanceledDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_canceled_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestCanceledShownToPrimaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_merge_request_canceled_shown_to_primary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestCanceledShownToSecondaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_merge_request_canceled_shown_to_secondary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestExpiredDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_expired_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestExpiredShownToPrimaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_merge_request_expired_shown_to_primary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestExpiredShownToSecondaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_expired_shown_to_secondary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestRejectedShownToPrimaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_merge_request_rejected_shown_to_primary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestRejectedShownToSecondaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_rejected_shown_to_secondary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestReminderDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_reminder_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestReminderShownToPrimaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_merge_request_reminder_shown_to_primary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestReminderShownToSecondaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_reminder_shown_to_secondary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestRevokedDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_revoked_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestSentShownToPrimaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 3)?;
                s.serialize_field(".tag", "team_merge_request_sent_shown_to_primary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::TeamMergeRequestSentShownToSecondaryTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "team_merge_request_sent_shown_to_secondary_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::MissingDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventDetails", 2)?;
                s.serialize_field(".tag", "missing_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The type of the event.
#[derive(Debug)]
pub enum EventType {
    /// (apps) Linked app for team
    AppLinkTeam(AppLinkTeamType),
    /// (apps) Linked app for member
    AppLinkUser(AppLinkUserType),
    /// (apps) Unlinked app for team
    AppUnlinkTeam(AppUnlinkTeamType),
    /// (apps) Unlinked app for member
    AppUnlinkUser(AppUnlinkUserType),
    /// (apps) Connected integration for member
    IntegrationConnected(IntegrationConnectedType),
    /// (apps) Disconnected integration for member
    IntegrationDisconnected(IntegrationDisconnectedType),
    /// (comments) Added file comment
    FileAddComment(FileAddCommentType),
    /// (comments) Subscribed to or unsubscribed from comment notifications for file
    FileChangeCommentSubscription(FileChangeCommentSubscriptionType),
    /// (comments) Deleted file comment
    FileDeleteComment(FileDeleteCommentType),
    /// (comments) Edited file comment
    FileEditComment(FileEditCommentType),
    /// (comments) Liked file comment (deprecated, no longer logged)
    FileLikeComment(FileLikeCommentType),
    /// (comments) Resolved file comment
    FileResolveComment(FileResolveCommentType),
    /// (comments) Unliked file comment (deprecated, no longer logged)
    FileUnlikeComment(FileUnlikeCommentType),
    /// (comments) Unresolved file comment
    FileUnresolveComment(FileUnresolveCommentType),
    /// (devices) Changed IP address associated with active desktop session
    DeviceChangeIpDesktop(DeviceChangeIpDesktopType),
    /// (devices) Changed IP address associated with active mobile session
    DeviceChangeIpMobile(DeviceChangeIpMobileType),
    /// (devices) Changed IP address associated with active web session
    DeviceChangeIpWeb(DeviceChangeIpWebType),
    /// (devices) Failed to delete all files from unlinked device
    DeviceDeleteOnUnlinkFail(DeviceDeleteOnUnlinkFailType),
    /// (devices) Deleted all files from unlinked device
    DeviceDeleteOnUnlinkSuccess(DeviceDeleteOnUnlinkSuccessType),
    /// (devices) Failed to link device
    DeviceLinkFail(DeviceLinkFailType),
    /// (devices) Linked device
    DeviceLinkSuccess(DeviceLinkSuccessType),
    /// (devices) Disabled device management (deprecated, no longer logged)
    DeviceManagementDisabled(DeviceManagementDisabledType),
    /// (devices) Enabled device management (deprecated, no longer logged)
    DeviceManagementEnabled(DeviceManagementEnabledType),
    /// (devices) Disconnected device
    DeviceUnlink(DeviceUnlinkType),
    /// (devices) Refreshed auth token used for setting up EMM
    EmmRefreshAuthToken(EmmRefreshAuthTokenType),
    /// (domains) Granted/revoked option to enable account capture on team domains
    AccountCaptureChangeAvailability(AccountCaptureChangeAvailabilityType),
    /// (domains) Account-captured user migrated account to team
    AccountCaptureMigrateAccount(AccountCaptureMigrateAccountType),
    /// (domains) Sent account capture email to all unmanaged members
    AccountCaptureNotificationEmailsSent(AccountCaptureNotificationEmailsSentType),
    /// (domains) Account-captured user changed account email to personal email
    AccountCaptureRelinquishAccount(AccountCaptureRelinquishAccountType),
    /// (domains) Disabled domain invites (deprecated, no longer logged)
    DisabledDomainInvites(DisabledDomainInvitesType),
    /// (domains) Approved user's request to join team
    DomainInvitesApproveRequestToJoinTeam(DomainInvitesApproveRequestToJoinTeamType),
    /// (domains) Declined user's request to join team
    DomainInvitesDeclineRequestToJoinTeam(DomainInvitesDeclineRequestToJoinTeamType),
    /// (domains) Sent domain invites to existing domain accounts (deprecated, no longer logged)
    DomainInvitesEmailExistingUsers(DomainInvitesEmailExistingUsersType),
    /// (domains) Requested to join team
    DomainInvitesRequestToJoinTeam(DomainInvitesRequestToJoinTeamType),
    /// (domains) Disabled "Automatically invite new users" (deprecated, no longer logged)
    DomainInvitesSetInviteNewUserPrefToNo(DomainInvitesSetInviteNewUserPrefToNoType),
    /// (domains) Enabled "Automatically invite new users" (deprecated, no longer logged)
    DomainInvitesSetInviteNewUserPrefToYes(DomainInvitesSetInviteNewUserPrefToYesType),
    /// (domains) Failed to verify team domain
    DomainVerificationAddDomainFail(DomainVerificationAddDomainFailType),
    /// (domains) Verified team domain
    DomainVerificationAddDomainSuccess(DomainVerificationAddDomainSuccessType),
    /// (domains) Removed domain from list of verified team domains
    DomainVerificationRemoveDomain(DomainVerificationRemoveDomainType),
    /// (domains) Enabled domain invites (deprecated, no longer logged)
    EnabledDomainInvites(EnabledDomainInvitesType),
    /// (file_operations) Created folders (deprecated, no longer logged)
    CreateFolder(CreateFolderType),
    /// (file_operations) Added files and/or folders
    FileAdd(FileAddType),
    /// (file_operations) Copied files and/or folders
    FileCopy(FileCopyType),
    /// (file_operations) Deleted files and/or folders
    FileDelete(FileDeleteType),
    /// (file_operations) Downloaded files and/or folders
    FileDownload(FileDownloadType),
    /// (file_operations) Edited files
    FileEdit(FileEditType),
    /// (file_operations) Created copy reference to file/folder
    FileGetCopyReference(FileGetCopyReferenceType),
    /// (file_operations) Locked/unlocked editing for a file
    FileLockingLockStatusChanged(FileLockingLockStatusChangedType),
    /// (file_operations) Moved files and/or folders
    FileMove(FileMoveType),
    /// (file_operations) Permanently deleted files and/or folders
    FilePermanentlyDelete(FilePermanentlyDeleteType),
    /// (file_operations) Previewed files and/or folders
    FilePreview(FilePreviewType),
    /// (file_operations) Renamed files and/or folders
    FileRename(FileRenameType),
    /// (file_operations) Restored deleted files and/or folders
    FileRestore(FileRestoreType),
    /// (file_operations) Reverted files to previous version
    FileRevert(FileRevertType),
    /// (file_operations) Rolled back file actions
    FileRollbackChanges(FileRollbackChangesType),
    /// (file_operations) Saved file/folder using copy reference
    FileSaveCopyReference(FileSaveCopyReferenceType),
    /// (file_operations) Updated folder overview
    FolderOverviewDescriptionChanged(FolderOverviewDescriptionChangedType),
    /// (file_operations) Pinned item to folder overview
    FolderOverviewItemPinned(FolderOverviewItemPinnedType),
    /// (file_operations) Unpinned item from folder overview
    FolderOverviewItemUnpinned(FolderOverviewItemUnpinnedType),
    /// (file_operations) Rewound a folder
    RewindFolder(RewindFolderType),
    /// (file_requests) Changed file request
    FileRequestChange(FileRequestChangeType),
    /// (file_requests) Closed file request
    FileRequestClose(FileRequestCloseType),
    /// (file_requests) Created file request
    FileRequestCreate(FileRequestCreateType),
    /// (file_requests) Delete file request
    FileRequestDelete(FileRequestDeleteType),
    /// (file_requests) Received files for file request
    FileRequestReceiveFile(FileRequestReceiveFileType),
    /// (groups) Added external ID for group
    GroupAddExternalId(GroupAddExternalIdType),
    /// (groups) Added team members to group
    GroupAddMember(GroupAddMemberType),
    /// (groups) Changed external ID for group
    GroupChangeExternalId(GroupChangeExternalIdType),
    /// (groups) Changed group management type
    GroupChangeManagementType(GroupChangeManagementTypeType),
    /// (groups) Changed manager permissions of group member
    GroupChangeMemberRole(GroupChangeMemberRoleType),
    /// (groups) Created group
    GroupCreate(GroupCreateType),
    /// (groups) Deleted group
    GroupDelete(GroupDeleteType),
    /// (groups) Updated group (deprecated, no longer logged)
    GroupDescriptionUpdated(GroupDescriptionUpdatedType),
    /// (groups) Updated group join policy (deprecated, no longer logged)
    GroupJoinPolicyUpdated(GroupJoinPolicyUpdatedType),
    /// (groups) Moved group (deprecated, no longer logged)
    GroupMoved(GroupMovedType),
    /// (groups) Removed external ID for group
    GroupRemoveExternalId(GroupRemoveExternalIdType),
    /// (groups) Removed team members from group
    GroupRemoveMember(GroupRemoveMemberType),
    /// (groups) Renamed group
    GroupRename(GroupRenameType),
    /// (legal_holds) Activated a hold
    LegalHoldsActivateAHold(LegalHoldsActivateAHoldType),
    /// (legal_holds) Added members to a hold
    LegalHoldsAddMembers(LegalHoldsAddMembersType),
    /// (legal_holds) Edited details for a hold
    LegalHoldsChangeHoldDetails(LegalHoldsChangeHoldDetailsType),
    /// (legal_holds) Renamed a hold
    LegalHoldsChangeHoldName(LegalHoldsChangeHoldNameType),
    /// (legal_holds) Exported hold
    LegalHoldsExportAHold(LegalHoldsExportAHoldType),
    /// (legal_holds) Canceled export for a hold
    LegalHoldsExportCancelled(LegalHoldsExportCancelledType),
    /// (legal_holds) Downloaded export for a hold
    LegalHoldsExportDownloaded(LegalHoldsExportDownloadedType),
    /// (legal_holds) Removed export for a hold
    LegalHoldsExportRemoved(LegalHoldsExportRemovedType),
    /// (legal_holds) Released a hold
    LegalHoldsReleaseAHold(LegalHoldsReleaseAHoldType),
    /// (legal_holds) Removed members from a hold
    LegalHoldsRemoveMembers(LegalHoldsRemoveMembersType),
    /// (legal_holds) Created a summary report for a hold
    LegalHoldsReportAHold(LegalHoldsReportAHoldType),
    /// (logins) Unlocked/locked account after failed sign in attempts
    AccountLockOrUnlocked(AccountLockOrUnlockedType),
    /// (logins) Failed to sign in via EMM (deprecated, replaced by 'Failed to sign in')
    EmmError(EmmErrorType),
    /// (logins) Started trusted team admin session
    GuestAdminSignedInViaTrustedTeams(GuestAdminSignedInViaTrustedTeamsType),
    /// (logins) Ended trusted team admin session
    GuestAdminSignedOutViaTrustedTeams(GuestAdminSignedOutViaTrustedTeamsType),
    /// (logins) Failed to sign in
    LoginFail(LoginFailType),
    /// (logins) Signed in
    LoginSuccess(LoginSuccessType),
    /// (logins) Signed out
    Logout(LogoutType),
    /// (logins) Ended reseller support session
    ResellerSupportSessionEnd(ResellerSupportSessionEndType),
    /// (logins) Started reseller support session
    ResellerSupportSessionStart(ResellerSupportSessionStartType),
    /// (logins) Ended admin sign-in-as session
    SignInAsSessionEnd(SignInAsSessionEndType),
    /// (logins) Started admin sign-in-as session
    SignInAsSessionStart(SignInAsSessionStartType),
    /// (logins) Failed to sign in via SSO (deprecated, replaced by 'Failed to sign in')
    SsoError(SsoErrorType),
    /// (members) Created team invite link
    CreateTeamInviteLink(CreateTeamInviteLinkType),
    /// (members) Deleted team invite link
    DeleteTeamInviteLink(DeleteTeamInviteLinkType),
    /// (members) Added an external ID for team member
    MemberAddExternalId(MemberAddExternalIdType),
    /// (members) Added team member name
    MemberAddName(MemberAddNameType),
    /// (members) Changed team member admin role
    MemberChangeAdminRole(MemberChangeAdminRoleType),
    /// (members) Changed team member email
    MemberChangeEmail(MemberChangeEmailType),
    /// (members) Changed the external ID for team member
    MemberChangeExternalId(MemberChangeExternalIdType),
    /// (members) Changed membership type (limited/full) of member (deprecated, no longer logged)
    MemberChangeMembershipType(MemberChangeMembershipTypeType),
    /// (members) Changed team member name
    MemberChangeName(MemberChangeNameType),
    /// (members) Changed member status (invited, joined, suspended, etc.)
    MemberChangeStatus(MemberChangeStatusType),
    /// (members) Cleared manually added contacts
    MemberDeleteManualContacts(MemberDeleteManualContactsType),
    /// (members) Deleted team member profile photo
    MemberDeleteProfilePhoto(MemberDeleteProfilePhotoType),
    /// (members) Permanently deleted contents of deleted team member account
    MemberPermanentlyDeleteAccountContents(MemberPermanentlyDeleteAccountContentsType),
    /// (members) Removed the external ID for team member
    MemberRemoveExternalId(MemberRemoveExternalIdType),
    /// (members) Set team member profile photo
    MemberSetProfilePhoto(MemberSetProfilePhotoType),
    /// (members) Set custom member space limit
    MemberSpaceLimitsAddCustomQuota(MemberSpaceLimitsAddCustomQuotaType),
    /// (members) Changed custom member space limit
    MemberSpaceLimitsChangeCustomQuota(MemberSpaceLimitsChangeCustomQuotaType),
    /// (members) Changed space limit status
    MemberSpaceLimitsChangeStatus(MemberSpaceLimitsChangeStatusType),
    /// (members) Removed custom member space limit
    MemberSpaceLimitsRemoveCustomQuota(MemberSpaceLimitsRemoveCustomQuotaType),
    /// (members) Suggested person to add to team
    MemberSuggest(MemberSuggestType),
    /// (members) Transferred contents of deleted member account to another member
    MemberTransferAccountContents(MemberTransferAccountContentsType),
    /// (members) Added pending secondary email
    PendingSecondaryEmailAdded(PendingSecondaryEmailAddedType),
    /// (members) Deleted secondary email
    SecondaryEmailDeleted(SecondaryEmailDeletedType),
    /// (members) Verified secondary email
    SecondaryEmailVerified(SecondaryEmailVerifiedType),
    /// (members) Secondary mails policy changed
    SecondaryMailsPolicyChanged(SecondaryMailsPolicyChangedType),
    /// (paper) Added Binder page (deprecated, replaced by 'Edited files')
    BinderAddPage(BinderAddPageType),
    /// (paper) Added Binder section (deprecated, replaced by 'Edited files')
    BinderAddSection(BinderAddSectionType),
    /// (paper) Removed Binder page (deprecated, replaced by 'Edited files')
    BinderRemovePage(BinderRemovePageType),
    /// (paper) Removed Binder section (deprecated, replaced by 'Edited files')
    BinderRemoveSection(BinderRemoveSectionType),
    /// (paper) Renamed Binder page (deprecated, replaced by 'Edited files')
    BinderRenamePage(BinderRenamePageType),
    /// (paper) Renamed Binder section (deprecated, replaced by 'Edited files')
    BinderRenameSection(BinderRenameSectionType),
    /// (paper) Reordered Binder page (deprecated, replaced by 'Edited files')
    BinderReorderPage(BinderReorderPageType),
    /// (paper) Reordered Binder section (deprecated, replaced by 'Edited files')
    BinderReorderSection(BinderReorderSectionType),
    /// (paper) Added users and/or groups to Paper doc/folder
    PaperContentAddMember(PaperContentAddMemberType),
    /// (paper) Added Paper doc/folder to folder
    PaperContentAddToFolder(PaperContentAddToFolderType),
    /// (paper) Archived Paper doc/folder
    PaperContentArchive(PaperContentArchiveType),
    /// (paper) Created Paper doc/folder
    PaperContentCreate(PaperContentCreateType),
    /// (paper) Permanently deleted Paper doc/folder
    PaperContentPermanentlyDelete(PaperContentPermanentlyDeleteType),
    /// (paper) Removed Paper doc/folder from folder
    PaperContentRemoveFromFolder(PaperContentRemoveFromFolderType),
    /// (paper) Removed users and/or groups from Paper doc/folder
    PaperContentRemoveMember(PaperContentRemoveMemberType),
    /// (paper) Renamed Paper doc/folder
    PaperContentRename(PaperContentRenameType),
    /// (paper) Restored archived Paper doc/folder
    PaperContentRestore(PaperContentRestoreType),
    /// (paper) Added Paper doc comment
    PaperDocAddComment(PaperDocAddCommentType),
    /// (paper) Changed member permissions for Paper doc
    PaperDocChangeMemberRole(PaperDocChangeMemberRoleType),
    /// (paper) Changed sharing setting for Paper doc
    PaperDocChangeSharingPolicy(PaperDocChangeSharingPolicyType),
    /// (paper) Followed/unfollowed Paper doc
    PaperDocChangeSubscription(PaperDocChangeSubscriptionType),
    /// (paper) Archived Paper doc (deprecated, no longer logged)
    PaperDocDeleted(PaperDocDeletedType),
    /// (paper) Deleted Paper doc comment
    PaperDocDeleteComment(PaperDocDeleteCommentType),
    /// (paper) Downloaded Paper doc in specific format
    PaperDocDownload(PaperDocDownloadType),
    /// (paper) Edited Paper doc
    PaperDocEdit(PaperDocEditType),
    /// (paper) Edited Paper doc comment
    PaperDocEditComment(PaperDocEditCommentType),
    /// (paper) Followed Paper doc (deprecated, replaced by 'Followed/unfollowed Paper doc')
    PaperDocFollowed(PaperDocFollowedType),
    /// (paper) Mentioned user in Paper doc
    PaperDocMention(PaperDocMentionType),
    /// (paper) Transferred ownership of Paper doc
    PaperDocOwnershipChanged(PaperDocOwnershipChangedType),
    /// (paper) Requested access to Paper doc
    PaperDocRequestAccess(PaperDocRequestAccessType),
    /// (paper) Resolved Paper doc comment
    PaperDocResolveComment(PaperDocResolveCommentType),
    /// (paper) Restored Paper doc to previous version
    PaperDocRevert(PaperDocRevertType),
    /// (paper) Shared Paper doc via Slack
    PaperDocSlackShare(PaperDocSlackShareType),
    /// (paper) Shared Paper doc with users and/or groups (deprecated, no longer logged)
    PaperDocTeamInvite(PaperDocTeamInviteType),
    /// (paper) Deleted Paper doc
    PaperDocTrashed(PaperDocTrashedType),
    /// (paper) Unresolved Paper doc comment
    PaperDocUnresolveComment(PaperDocUnresolveCommentType),
    /// (paper) Restored Paper doc
    PaperDocUntrashed(PaperDocUntrashedType),
    /// (paper) Viewed Paper doc
    PaperDocView(PaperDocViewType),
    /// (paper) Changed Paper external sharing setting to anyone (deprecated, no longer logged)
    PaperExternalViewAllow(PaperExternalViewAllowType),
    /// (paper) Changed Paper external sharing setting to default team (deprecated, no longer
    /// logged)
    PaperExternalViewDefaultTeam(PaperExternalViewDefaultTeamType),
    /// (paper) Changed Paper external sharing setting to team-only (deprecated, no longer logged)
    PaperExternalViewForbid(PaperExternalViewForbidType),
    /// (paper) Followed/unfollowed Paper folder
    PaperFolderChangeSubscription(PaperFolderChangeSubscriptionType),
    /// (paper) Archived Paper folder (deprecated, no longer logged)
    PaperFolderDeleted(PaperFolderDeletedType),
    /// (paper) Followed Paper folder (deprecated, replaced by 'Followed/unfollowed Paper folder')
    PaperFolderFollowed(PaperFolderFollowedType),
    /// (paper) Shared Paper folder with users and/or groups (deprecated, no longer logged)
    PaperFolderTeamInvite(PaperFolderTeamInviteType),
    /// (paper) Changed permissions for published doc
    PaperPublishedLinkChangePermission(PaperPublishedLinkChangePermissionType),
    /// (paper) Published doc
    PaperPublishedLinkCreate(PaperPublishedLinkCreateType),
    /// (paper) Unpublished doc
    PaperPublishedLinkDisabled(PaperPublishedLinkDisabledType),
    /// (paper) Viewed published doc
    PaperPublishedLinkView(PaperPublishedLinkViewType),
    /// (passwords) Changed password
    PasswordChange(PasswordChangeType),
    /// (passwords) Reset password
    PasswordReset(PasswordResetType),
    /// (passwords) Reset all team member passwords
    PasswordResetAll(PasswordResetAllType),
    /// (reports) Created EMM-excluded users report
    EmmCreateExceptionsReport(EmmCreateExceptionsReportType),
    /// (reports) Created EMM mobile app usage report
    EmmCreateUsageReport(EmmCreateUsageReportType),
    /// (reports) Created member data report
    ExportMembersReport(ExportMembersReportType),
    /// (reports) Failed to create members data report
    ExportMembersReportFail(ExportMembersReportFailType),
    /// (reports) Report created: Links created with no expiration
    NoExpirationLinkGenCreateReport(NoExpirationLinkGenCreateReportType),
    /// (reports) Couldn't create report: Links created with no expiration
    NoExpirationLinkGenReportFailed(NoExpirationLinkGenReportFailedType),
    /// (reports) Report created: Links created without passwords
    NoPasswordLinkGenCreateReport(NoPasswordLinkGenCreateReportType),
    /// (reports) Couldn't create report: Links created without passwords
    NoPasswordLinkGenReportFailed(NoPasswordLinkGenReportFailedType),
    /// (reports) Report created: Views of links without passwords
    NoPasswordLinkViewCreateReport(NoPasswordLinkViewCreateReportType),
    /// (reports) Couldn't create report: Views of links without passwords
    NoPasswordLinkViewReportFailed(NoPasswordLinkViewReportFailedType),
    /// (reports) Report created: Views of old links
    OutdatedLinkViewCreateReport(OutdatedLinkViewCreateReportType),
    /// (reports) Couldn't create report: Views of old links
    OutdatedLinkViewReportFailed(OutdatedLinkViewReportFailedType),
    /// (reports) Exported all team Paper docs
    PaperAdminExportStart(PaperAdminExportStartType),
    /// (reports) Created Smart Sync non-admin devices report
    SmartSyncCreateAdminPrivilegeReport(SmartSyncCreateAdminPrivilegeReportType),
    /// (reports) Created team activity report
    TeamActivityCreateReport(TeamActivityCreateReportType),
    /// (reports) Couldn't generate team activity report
    TeamActivityCreateReportFail(TeamActivityCreateReportFailType),
    /// (sharing) Shared album
    CollectionShare(CollectionShareType),
    /// (sharing) Transfer files added
    FileTransfersFileAdd(FileTransfersFileAddType),
    /// (sharing) Deleted transfer
    FileTransfersTransferDelete(FileTransfersTransferDeleteType),
    /// (sharing) Transfer downloaded
    FileTransfersTransferDownload(FileTransfersTransferDownloadType),
    /// (sharing) Sent transfer
    FileTransfersTransferSend(FileTransfersTransferSendType),
    /// (sharing) Viewed transfer
    FileTransfersTransferView(FileTransfersTransferViewType),
    /// (sharing) Changed Paper doc to invite-only (deprecated, no longer logged)
    NoteAclInviteOnly(NoteAclInviteOnlyType),
    /// (sharing) Changed Paper doc to link-accessible (deprecated, no longer logged)
    NoteAclLink(NoteAclLinkType),
    /// (sharing) Changed Paper doc to link-accessible for team (deprecated, no longer logged)
    NoteAclTeamLink(NoteAclTeamLinkType),
    /// (sharing) Shared Paper doc (deprecated, no longer logged)
    NoteShared(NoteSharedType),
    /// (sharing) Shared received Paper doc (deprecated, no longer logged)
    NoteShareReceive(NoteShareReceiveType),
    /// (sharing) Opened shared Paper doc (deprecated, no longer logged)
    OpenNoteShared(OpenNoteSharedType),
    /// (sharing) Added team to shared folder (deprecated, no longer logged)
    SfAddGroup(SfAddGroupType),
    /// (sharing) Allowed non-collaborators to view links to files in shared folder (deprecated, no
    /// longer logged)
    SfAllowNonMembersToViewSharedLinks(SfAllowNonMembersToViewSharedLinksType),
    /// (sharing) Set team members to see warning before sharing folders outside team (deprecated,
    /// no longer logged)
    SfExternalInviteWarn(SfExternalInviteWarnType),
    /// (sharing) Invited Facebook users to shared folder (deprecated, no longer logged)
    SfFbInvite(SfFbInviteType),
    /// (sharing) Changed Facebook user's role in shared folder (deprecated, no longer logged)
    SfFbInviteChangeRole(SfFbInviteChangeRoleType),
    /// (sharing) Uninvited Facebook user from shared folder (deprecated, no longer logged)
    SfFbUninvite(SfFbUninviteType),
    /// (sharing) Invited group to shared folder (deprecated, no longer logged)
    SfInviteGroup(SfInviteGroupType),
    /// (sharing) Granted access to shared folder (deprecated, no longer logged)
    SfTeamGrantAccess(SfTeamGrantAccessType),
    /// (sharing) Invited team members to shared folder (deprecated, replaced by 'Invited user to
    /// Dropbox and added them to shared file/folder')
    SfTeamInvite(SfTeamInviteType),
    /// (sharing) Changed team member's role in shared folder (deprecated, no longer logged)
    SfTeamInviteChangeRole(SfTeamInviteChangeRoleType),
    /// (sharing) Joined team member's shared folder (deprecated, no longer logged)
    SfTeamJoin(SfTeamJoinType),
    /// (sharing) Joined team member's shared folder from link (deprecated, no longer logged)
    SfTeamJoinFromOobLink(SfTeamJoinFromOobLinkType),
    /// (sharing) Unshared folder with team member (deprecated, replaced by 'Removed invitee from
    /// shared file/folder before invite was accepted')
    SfTeamUninvite(SfTeamUninviteType),
    /// (sharing) Invited user to Dropbox and added them to shared file/folder
    SharedContentAddInvitees(SharedContentAddInviteesType),
    /// (sharing) Added expiration date to link for shared file/folder (deprecated, no longer
    /// logged)
    SharedContentAddLinkExpiry(SharedContentAddLinkExpiryType),
    /// (sharing) Added password to link for shared file/folder (deprecated, no longer logged)
    SharedContentAddLinkPassword(SharedContentAddLinkPasswordType),
    /// (sharing) Added users and/or groups to shared file/folder
    SharedContentAddMember(SharedContentAddMemberType),
    /// (sharing) Changed whether members can download shared file/folder (deprecated, no longer
    /// logged)
    SharedContentChangeDownloadsPolicy(SharedContentChangeDownloadsPolicyType),
    /// (sharing) Changed access type of invitee to shared file/folder before invite was accepted
    SharedContentChangeInviteeRole(SharedContentChangeInviteeRoleType),
    /// (sharing) Changed link audience of shared file/folder (deprecated, no longer logged)
    SharedContentChangeLinkAudience(SharedContentChangeLinkAudienceType),
    /// (sharing) Changed link expiration of shared file/folder (deprecated, no longer logged)
    SharedContentChangeLinkExpiry(SharedContentChangeLinkExpiryType),
    /// (sharing) Changed link password of shared file/folder (deprecated, no longer logged)
    SharedContentChangeLinkPassword(SharedContentChangeLinkPasswordType),
    /// (sharing) Changed access type of shared file/folder member
    SharedContentChangeMemberRole(SharedContentChangeMemberRoleType),
    /// (sharing) Changed whether members can see who viewed shared file/folder
    SharedContentChangeViewerInfoPolicy(SharedContentChangeViewerInfoPolicyType),
    /// (sharing) Acquired membership of shared file/folder by accepting invite
    SharedContentClaimInvitation(SharedContentClaimInvitationType),
    /// (sharing) Copied shared file/folder to own Dropbox
    SharedContentCopy(SharedContentCopyType),
    /// (sharing) Downloaded shared file/folder
    SharedContentDownload(SharedContentDownloadType),
    /// (sharing) Left shared file/folder
    SharedContentRelinquishMembership(SharedContentRelinquishMembershipType),
    /// (sharing) Removed invitee from shared file/folder before invite was accepted
    SharedContentRemoveInvitees(SharedContentRemoveInviteesType),
    /// (sharing) Removed link expiration date of shared file/folder (deprecated, no longer logged)
    SharedContentRemoveLinkExpiry(SharedContentRemoveLinkExpiryType),
    /// (sharing) Removed link password of shared file/folder (deprecated, no longer logged)
    SharedContentRemoveLinkPassword(SharedContentRemoveLinkPasswordType),
    /// (sharing) Removed user/group from shared file/folder
    SharedContentRemoveMember(SharedContentRemoveMemberType),
    /// (sharing) Requested access to shared file/folder
    SharedContentRequestAccess(SharedContentRequestAccessType),
    /// (sharing) Restored shared file/folder invitees
    SharedContentRestoreInvitees(SharedContentRestoreInviteesType),
    /// (sharing) Restored users and/or groups to membership of shared file/folder
    SharedContentRestoreMember(SharedContentRestoreMemberType),
    /// (sharing) Unshared file/folder by clearing membership
    SharedContentUnshare(SharedContentUnshareType),
    /// (sharing) Previewed shared file/folder
    SharedContentView(SharedContentViewType),
    /// (sharing) Changed who can access shared folder via link
    SharedFolderChangeLinkPolicy(SharedFolderChangeLinkPolicyType),
    /// (sharing) Changed whether shared folder inherits members from parent folder
    SharedFolderChangeMembersInheritancePolicy(SharedFolderChangeMembersInheritancePolicyType),
    /// (sharing) Changed who can add/remove members of shared folder
    SharedFolderChangeMembersManagementPolicy(SharedFolderChangeMembersManagementPolicyType),
    /// (sharing) Changed who can become member of shared folder
    SharedFolderChangeMembersPolicy(SharedFolderChangeMembersPolicyType),
    /// (sharing) Created shared folder
    SharedFolderCreate(SharedFolderCreateType),
    /// (sharing) Declined team member's invite to shared folder
    SharedFolderDeclineInvitation(SharedFolderDeclineInvitationType),
    /// (sharing) Added shared folder to own Dropbox
    SharedFolderMount(SharedFolderMountType),
    /// (sharing) Changed parent of shared folder
    SharedFolderNest(SharedFolderNestType),
    /// (sharing) Transferred ownership of shared folder to another member
    SharedFolderTransferOwnership(SharedFolderTransferOwnershipType),
    /// (sharing) Deleted shared folder from Dropbox
    SharedFolderUnmount(SharedFolderUnmountType),
    /// (sharing) Added shared link expiration date
    SharedLinkAddExpiry(SharedLinkAddExpiryType),
    /// (sharing) Changed shared link expiration date
    SharedLinkChangeExpiry(SharedLinkChangeExpiryType),
    /// (sharing) Changed visibility of shared link
    SharedLinkChangeVisibility(SharedLinkChangeVisibilityType),
    /// (sharing) Added file/folder to Dropbox from shared link
    SharedLinkCopy(SharedLinkCopyType),
    /// (sharing) Created shared link
    SharedLinkCreate(SharedLinkCreateType),
    /// (sharing) Removed shared link
    SharedLinkDisable(SharedLinkDisableType),
    /// (sharing) Downloaded file/folder from shared link
    SharedLinkDownload(SharedLinkDownloadType),
    /// (sharing) Removed shared link expiration date
    SharedLinkRemoveExpiry(SharedLinkRemoveExpiryType),
    /// (sharing) Added an expiration date to the shared link
    SharedLinkSettingsAddExpiration(SharedLinkSettingsAddExpirationType),
    /// (sharing) Added a password to the shared link
    SharedLinkSettingsAddPassword(SharedLinkSettingsAddPasswordType),
    /// (sharing) Disabled downloads
    SharedLinkSettingsAllowDownloadDisabled(SharedLinkSettingsAllowDownloadDisabledType),
    /// (sharing) Enabled downloads
    SharedLinkSettingsAllowDownloadEnabled(SharedLinkSettingsAllowDownloadEnabledType),
    /// (sharing) Changed the audience of the shared link
    SharedLinkSettingsChangeAudience(SharedLinkSettingsChangeAudienceType),
    /// (sharing) Changed the expiration date of the shared link
    SharedLinkSettingsChangeExpiration(SharedLinkSettingsChangeExpirationType),
    /// (sharing) Changed the password of the shared link
    SharedLinkSettingsChangePassword(SharedLinkSettingsChangePasswordType),
    /// (sharing) Removed the expiration date from the shared link
    SharedLinkSettingsRemoveExpiration(SharedLinkSettingsRemoveExpirationType),
    /// (sharing) Removed the password from the shared link
    SharedLinkSettingsRemovePassword(SharedLinkSettingsRemovePasswordType),
    /// (sharing) Added members as audience of shared link
    SharedLinkShare(SharedLinkShareType),
    /// (sharing) Opened shared link
    SharedLinkView(SharedLinkViewType),
    /// (sharing) Opened shared Paper doc (deprecated, no longer logged)
    SharedNoteOpened(SharedNoteOpenedType),
    /// (sharing) Shared link with group (deprecated, no longer logged)
    ShmodelGroupShare(ShmodelGroupShareType),
    /// (showcase) Granted access to showcase
    ShowcaseAccessGranted(ShowcaseAccessGrantedType),
    /// (showcase) Added member to showcase
    ShowcaseAddMember(ShowcaseAddMemberType),
    /// (showcase) Archived showcase
    ShowcaseArchived(ShowcaseArchivedType),
    /// (showcase) Created showcase
    ShowcaseCreated(ShowcaseCreatedType),
    /// (showcase) Deleted showcase comment
    ShowcaseDeleteComment(ShowcaseDeleteCommentType),
    /// (showcase) Edited showcase
    ShowcaseEdited(ShowcaseEditedType),
    /// (showcase) Edited showcase comment
    ShowcaseEditComment(ShowcaseEditCommentType),
    /// (showcase) Added file to showcase
    ShowcaseFileAdded(ShowcaseFileAddedType),
    /// (showcase) Downloaded file from showcase
    ShowcaseFileDownload(ShowcaseFileDownloadType),
    /// (showcase) Removed file from showcase
    ShowcaseFileRemoved(ShowcaseFileRemovedType),
    /// (showcase) Viewed file in showcase
    ShowcaseFileView(ShowcaseFileViewType),
    /// (showcase) Permanently deleted showcase
    ShowcasePermanentlyDeleted(ShowcasePermanentlyDeletedType),
    /// (showcase) Added showcase comment
    ShowcasePostComment(ShowcasePostCommentType),
    /// (showcase) Removed member from showcase
    ShowcaseRemoveMember(ShowcaseRemoveMemberType),
    /// (showcase) Renamed showcase
    ShowcaseRenamed(ShowcaseRenamedType),
    /// (showcase) Requested access to showcase
    ShowcaseRequestAccess(ShowcaseRequestAccessType),
    /// (showcase) Resolved showcase comment
    ShowcaseResolveComment(ShowcaseResolveCommentType),
    /// (showcase) Unarchived showcase
    ShowcaseRestored(ShowcaseRestoredType),
    /// (showcase) Deleted showcase
    ShowcaseTrashed(ShowcaseTrashedType),
    /// (showcase) Deleted showcase (old version) (deprecated, replaced by 'Deleted showcase')
    ShowcaseTrashedDeprecated(ShowcaseTrashedDeprecatedType),
    /// (showcase) Unresolved showcase comment
    ShowcaseUnresolveComment(ShowcaseUnresolveCommentType),
    /// (showcase) Restored showcase
    ShowcaseUntrashed(ShowcaseUntrashedType),
    /// (showcase) Restored showcase (old version) (deprecated, replaced by 'Restored showcase')
    ShowcaseUntrashedDeprecated(ShowcaseUntrashedDeprecatedType),
    /// (showcase) Viewed showcase
    ShowcaseView(ShowcaseViewType),
    /// (sso) Added X.509 certificate for SSO
    SsoAddCert(SsoAddCertType),
    /// (sso) Added sign-in URL for SSO
    SsoAddLoginUrl(SsoAddLoginUrlType),
    /// (sso) Added sign-out URL for SSO
    SsoAddLogoutUrl(SsoAddLogoutUrlType),
    /// (sso) Changed X.509 certificate for SSO
    SsoChangeCert(SsoChangeCertType),
    /// (sso) Changed sign-in URL for SSO
    SsoChangeLoginUrl(SsoChangeLoginUrlType),
    /// (sso) Changed sign-out URL for SSO
    SsoChangeLogoutUrl(SsoChangeLogoutUrlType),
    /// (sso) Changed SAML identity mode for SSO
    SsoChangeSamlIdentityMode(SsoChangeSamlIdentityModeType),
    /// (sso) Removed X.509 certificate for SSO
    SsoRemoveCert(SsoRemoveCertType),
    /// (sso) Removed sign-in URL for SSO
    SsoRemoveLoginUrl(SsoRemoveLoginUrlType),
    /// (sso) Removed sign-out URL for SSO
    SsoRemoveLogoutUrl(SsoRemoveLogoutUrlType),
    /// (team_folders) Changed archival status of team folder
    TeamFolderChangeStatus(TeamFolderChangeStatusType),
    /// (team_folders) Created team folder in active status
    TeamFolderCreate(TeamFolderCreateType),
    /// (team_folders) Downgraded team folder to regular shared folder
    TeamFolderDowngrade(TeamFolderDowngradeType),
    /// (team_folders) Permanently deleted archived team folder
    TeamFolderPermanentlyDelete(TeamFolderPermanentlyDeleteType),
    /// (team_folders) Renamed active/archived team folder
    TeamFolderRename(TeamFolderRenameType),
    /// (team_folders) Changed sync default
    TeamSelectiveSyncSettingsChanged(TeamSelectiveSyncSettingsChangedType),
    /// (team_policies) Changed account capture setting on team domain
    AccountCaptureChangePolicy(AccountCaptureChangePolicyType),
    /// (team_policies) Disabled downloads (deprecated, no longer logged)
    AllowDownloadDisabled(AllowDownloadDisabledType),
    /// (team_policies) Enabled downloads (deprecated, no longer logged)
    AllowDownloadEnabled(AllowDownloadEnabledType),
    /// (team_policies) Changed camera uploads setting for team
    CameraUploadsPolicyChanged(CameraUploadsPolicyChangedType),
    /// (team_policies) Set restrictions on data center locations where team data resides
    DataPlacementRestrictionChangePolicy(DataPlacementRestrictionChangePolicyType),
    /// (team_policies) Completed restrictions on data center locations where team data resides
    DataPlacementRestrictionSatisfyPolicy(DataPlacementRestrictionSatisfyPolicyType),
    /// (team_policies) Added members to device approvals exception list
    DeviceApprovalsAddException(DeviceApprovalsAddExceptionType),
    /// (team_policies) Set/removed limit on number of computers member can link to team Dropbox
    /// account
    DeviceApprovalsChangeDesktopPolicy(DeviceApprovalsChangeDesktopPolicyType),
    /// (team_policies) Set/removed limit on number of mobile devices member can link to team
    /// Dropbox account
    DeviceApprovalsChangeMobilePolicy(DeviceApprovalsChangeMobilePolicyType),
    /// (team_policies) Changed device approvals setting when member is over limit
    DeviceApprovalsChangeOverageAction(DeviceApprovalsChangeOverageActionType),
    /// (team_policies) Changed device approvals setting when member unlinks approved device
    DeviceApprovalsChangeUnlinkAction(DeviceApprovalsChangeUnlinkActionType),
    /// (team_policies) Removed members from device approvals exception list
    DeviceApprovalsRemoveException(DeviceApprovalsRemoveExceptionType),
    /// (team_policies) Added members to directory restrictions list
    DirectoryRestrictionsAddMembers(DirectoryRestrictionsAddMembersType),
    /// (team_policies) Removed members from directory restrictions list
    DirectoryRestrictionsRemoveMembers(DirectoryRestrictionsRemoveMembersType),
    /// (team_policies) Added members to EMM exception list
    EmmAddException(EmmAddExceptionType),
    /// (team_policies) Enabled/disabled enterprise mobility management for members
    EmmChangePolicy(EmmChangePolicyType),
    /// (team_policies) Removed members from EMM exception list
    EmmRemoveException(EmmRemoveExceptionType),
    /// (team_policies) Accepted/opted out of extended version history
    ExtendedVersionHistoryChangePolicy(ExtendedVersionHistoryChangePolicyType),
    /// (team_policies) Enabled/disabled commenting on team files
    FileCommentsChangePolicy(FileCommentsChangePolicyType),
    /// (team_policies) Changed file locking policy for team
    FileLockingPolicyChanged(FileLockingPolicyChangedType),
    /// (team_policies) Enabled/disabled file requests
    FileRequestsChangePolicy(FileRequestsChangePolicyType),
    /// (team_policies) Enabled file request emails for everyone (deprecated, no longer logged)
    FileRequestsEmailsEnabled(FileRequestsEmailsEnabledType),
    /// (team_policies) Enabled file request emails for team (deprecated, no longer logged)
    FileRequestsEmailsRestrictedToTeamOnly(FileRequestsEmailsRestrictedToTeamOnlyType),
    /// (team_policies) Changed file transfers policy for team
    FileTransfersPolicyChanged(FileTransfersPolicyChangedType),
    /// (team_policies) Enabled/disabled Google single sign-on for team
    GoogleSsoChangePolicy(GoogleSsoChangePolicyType),
    /// (team_policies) Changed who can create groups
    GroupUserManagementChangePolicy(GroupUserManagementChangePolicyType),
    /// (team_policies) Changed integration policy for team
    IntegrationPolicyChanged(IntegrationPolicyChangedType),
    /// (team_policies) Changed whether users can find team when not invited
    MemberRequestsChangePolicy(MemberRequestsChangePolicyType),
    /// (team_policies) Changed member send invite policy for team
    MemberSendInvitePolicyChanged(MemberSendInvitePolicyChangedType),
    /// (team_policies) Added members to member space limit exception list
    MemberSpaceLimitsAddException(MemberSpaceLimitsAddExceptionType),
    /// (team_policies) Changed member space limit type for team
    MemberSpaceLimitsChangeCapsTypePolicy(MemberSpaceLimitsChangeCapsTypePolicyType),
    /// (team_policies) Changed team default member space limit
    MemberSpaceLimitsChangePolicy(MemberSpaceLimitsChangePolicyType),
    /// (team_policies) Removed members from member space limit exception list
    MemberSpaceLimitsRemoveException(MemberSpaceLimitsRemoveExceptionType),
    /// (team_policies) Enabled/disabled option for team members to suggest people to add to team
    MemberSuggestionsChangePolicy(MemberSuggestionsChangePolicyType),
    /// (team_policies) Enabled/disabled Microsoft Office add-in
    MicrosoftOfficeAddinChangePolicy(MicrosoftOfficeAddinChangePolicyType),
    /// (team_policies) Enabled/disabled network control
    NetworkControlChangePolicy(NetworkControlChangePolicyType),
    /// (team_policies) Changed whether Dropbox Paper, when enabled, is deployed to all members or
    /// to specific members
    PaperChangeDeploymentPolicy(PaperChangeDeploymentPolicyType),
    /// (team_policies) Changed whether non-members can view Paper docs with link (deprecated, no
    /// longer logged)
    PaperChangeMemberLinkPolicy(PaperChangeMemberLinkPolicyType),
    /// (team_policies) Changed whether members can share Paper docs outside team, and if docs are
    /// accessible only by team members or anyone by default
    PaperChangeMemberPolicy(PaperChangeMemberPolicyType),
    /// (team_policies) Enabled/disabled Dropbox Paper for team
    PaperChangePolicy(PaperChangePolicyType),
    /// (team_policies) Changed Paper Default Folder Policy setting for team
    PaperDefaultFolderPolicyChanged(PaperDefaultFolderPolicyChangedType),
    /// (team_policies) Enabled/disabled Paper Desktop for team
    PaperDesktopPolicyChanged(PaperDesktopPolicyChangedType),
    /// (team_policies) Added users to Paper-enabled users list
    PaperEnabledUsersGroupAddition(PaperEnabledUsersGroupAdditionType),
    /// (team_policies) Removed users from Paper-enabled users list
    PaperEnabledUsersGroupRemoval(PaperEnabledUsersGroupRemovalType),
    /// (team_policies) Changed team password strength requirements
    PasswordStrengthRequirementsChangePolicy(PasswordStrengthRequirementsChangePolicyType),
    /// (team_policies) Enabled/disabled ability of team members to permanently delete content
    PermanentDeleteChangePolicy(PermanentDeleteChangePolicyType),
    /// (team_policies) Enabled/disabled reseller support
    ResellerSupportChangePolicy(ResellerSupportChangePolicyType),
    /// (team_policies) Changed Rewind policy for team
    RewindPolicyChanged(RewindPolicyChangedType),
    /// (team_policies) Changed whether team members can join shared folders owned outside team
    SharingChangeFolderJoinPolicy(SharingChangeFolderJoinPolicyType),
    /// (team_policies) Changed whether members can share links outside team, and if links are
    /// accessible only by team members or anyone by default
    SharingChangeLinkPolicy(SharingChangeLinkPolicyType),
    /// (team_policies) Changed whether members can share files/folders outside team
    SharingChangeMemberPolicy(SharingChangeMemberPolicyType),
    /// (team_policies) Enabled/disabled downloading files from Dropbox Showcase for team
    ShowcaseChangeDownloadPolicy(ShowcaseChangeDownloadPolicyType),
    /// (team_policies) Enabled/disabled Dropbox Showcase for team
    ShowcaseChangeEnabledPolicy(ShowcaseChangeEnabledPolicyType),
    /// (team_policies) Enabled/disabled sharing Dropbox Showcase externally for team
    ShowcaseChangeExternalSharingPolicy(ShowcaseChangeExternalSharingPolicyType),
    /// (team_policies) Changed automatic Smart Sync setting for team
    SmarterSmartSyncPolicyChanged(SmarterSmartSyncPolicyChangedType),
    /// (team_policies) Changed default Smart Sync setting for team members
    SmartSyncChangePolicy(SmartSyncChangePolicyType),
    /// (team_policies) Opted team into Smart Sync
    SmartSyncNotOptOut(SmartSyncNotOptOutType),
    /// (team_policies) Opted team out of Smart Sync
    SmartSyncOptOut(SmartSyncOptOutType),
    /// (team_policies) Changed single sign-on setting for team
    SsoChangePolicy(SsoChangePolicyType),
    /// (team_policies) Changed App Integrations setting for team
    TeamExtensionsPolicyChanged(TeamExtensionsPolicyChangedType),
    /// (team_policies) Enabled/disabled Team Selective Sync for team
    TeamSelectiveSyncPolicyChanged(TeamSelectiveSyncPolicyChangedType),
    /// (team_policies) Edited the approved list for sharing externally
    TeamSharingWhitelistSubjectsChanged(TeamSharingWhitelistSubjectsChangedType),
    /// (team_policies) Added members to two factor authentication exception list
    TfaAddException(TfaAddExceptionType),
    /// (team_policies) Changed two-step verification setting for team
    TfaChangePolicy(TfaChangePolicyType),
    /// (team_policies) Removed members from two factor authentication exception list
    TfaRemoveException(TfaRemoveExceptionType),
    /// (team_policies) Enabled/disabled option for members to link personal Dropbox account and
    /// team account to same computer
    TwoAccountChangePolicy(TwoAccountChangePolicyType),
    /// (team_policies) Changed team policy for viewer info
    ViewerInfoPolicyChanged(ViewerInfoPolicyChangedType),
    /// (team_policies) Changed watermarking policy for team
    WatermarkingPolicyChanged(WatermarkingPolicyChangedType),
    /// (team_policies) Changed limit on active sessions per member
    WebSessionsChangeActiveSessionLimit(WebSessionsChangeActiveSessionLimitType),
    /// (team_policies) Changed how long members can stay signed in to Dropbox.com
    WebSessionsChangeFixedLengthPolicy(WebSessionsChangeFixedLengthPolicyType),
    /// (team_policies) Changed how long team members can be idle while signed in to Dropbox.com
    WebSessionsChangeIdleLengthPolicy(WebSessionsChangeIdleLengthPolicyType),
    /// (team_profile) Merged another team into this team
    TeamMergeFrom(TeamMergeFromType),
    /// (team_profile) Merged this team into another team
    TeamMergeTo(TeamMergeToType),
    /// (team_profile) Added team logo to display on shared link headers
    TeamProfileAddLogo(TeamProfileAddLogoType),
    /// (team_profile) Changed default language for team
    TeamProfileChangeDefaultLanguage(TeamProfileChangeDefaultLanguageType),
    /// (team_profile) Changed team logo displayed on shared link headers
    TeamProfileChangeLogo(TeamProfileChangeLogoType),
    /// (team_profile) Changed team name
    TeamProfileChangeName(TeamProfileChangeNameType),
    /// (team_profile) Removed team logo displayed on shared link headers
    TeamProfileRemoveLogo(TeamProfileRemoveLogoType),
    /// (tfa) Added backup phone for two-step verification
    TfaAddBackupPhone(TfaAddBackupPhoneType),
    /// (tfa) Added security key for two-step verification
    TfaAddSecurityKey(TfaAddSecurityKeyType),
    /// (tfa) Changed backup phone for two-step verification
    TfaChangeBackupPhone(TfaChangeBackupPhoneType),
    /// (tfa) Enabled/disabled/changed two-step verification setting
    TfaChangeStatus(TfaChangeStatusType),
    /// (tfa) Removed backup phone for two-step verification
    TfaRemoveBackupPhone(TfaRemoveBackupPhoneType),
    /// (tfa) Removed security key for two-step verification
    TfaRemoveSecurityKey(TfaRemoveSecurityKeyType),
    /// (tfa) Reset two-step verification for team member
    TfaReset(TfaResetType),
    /// (trusted_teams) Changed enterprise admin role
    ChangedEnterpriseAdminRole(ChangedEnterpriseAdminRoleType),
    /// (trusted_teams) Changed enterprise-connected team status
    ChangedEnterpriseConnectedTeamStatus(ChangedEnterpriseConnectedTeamStatusType),
    /// (trusted_teams) Ended enterprise admin session
    EndedEnterpriseAdminSession(EndedEnterpriseAdminSessionType),
    /// (trusted_teams) Ended enterprise admin session (deprecated, replaced by 'Ended enterprise
    /// admin session')
    EndedEnterpriseAdminSessionDeprecated(EndedEnterpriseAdminSessionDeprecatedType),
    /// (trusted_teams) Changed who can update a setting
    EnterpriseSettingsLocking(EnterpriseSettingsLockingType),
    /// (trusted_teams) Changed guest team admin status
    GuestAdminChangeStatus(GuestAdminChangeStatusType),
    /// (trusted_teams) Started enterprise admin session
    StartedEnterpriseAdminSession(StartedEnterpriseAdminSessionType),
    /// (trusted_teams) Accepted a team merge request
    TeamMergeRequestAccepted(TeamMergeRequestAcceptedType),
    /// (trusted_teams) Accepted a team merge request (deprecated, replaced by 'Accepted a team
    /// merge request')
    TeamMergeRequestAcceptedShownToPrimaryTeam(TeamMergeRequestAcceptedShownToPrimaryTeamType),
    /// (trusted_teams) Accepted a team merge request (deprecated, replaced by 'Accepted a team
    /// merge request')
    TeamMergeRequestAcceptedShownToSecondaryTeam(TeamMergeRequestAcceptedShownToSecondaryTeamType),
    /// (trusted_teams) Automatically canceled team merge request
    TeamMergeRequestAutoCanceled(TeamMergeRequestAutoCanceledType),
    /// (trusted_teams) Canceled a team merge request
    TeamMergeRequestCanceled(TeamMergeRequestCanceledType),
    /// (trusted_teams) Canceled a team merge request (deprecated, replaced by 'Canceled a team
    /// merge request')
    TeamMergeRequestCanceledShownToPrimaryTeam(TeamMergeRequestCanceledShownToPrimaryTeamType),
    /// (trusted_teams) Canceled a team merge request (deprecated, replaced by 'Canceled a team
    /// merge request')
    TeamMergeRequestCanceledShownToSecondaryTeam(TeamMergeRequestCanceledShownToSecondaryTeamType),
    /// (trusted_teams) Team merge request expired
    TeamMergeRequestExpired(TeamMergeRequestExpiredType),
    /// (trusted_teams) Team merge request expired (deprecated, replaced by 'Team merge request
    /// expired')
    TeamMergeRequestExpiredShownToPrimaryTeam(TeamMergeRequestExpiredShownToPrimaryTeamType),
    /// (trusted_teams) Team merge request expired (deprecated, replaced by 'Team merge request
    /// expired')
    TeamMergeRequestExpiredShownToSecondaryTeam(TeamMergeRequestExpiredShownToSecondaryTeamType),
    /// (trusted_teams) Rejected a team merge request (deprecated, no longer logged)
    TeamMergeRequestRejectedShownToPrimaryTeam(TeamMergeRequestRejectedShownToPrimaryTeamType),
    /// (trusted_teams) Rejected a team merge request (deprecated, no longer logged)
    TeamMergeRequestRejectedShownToSecondaryTeam(TeamMergeRequestRejectedShownToSecondaryTeamType),
    /// (trusted_teams) Sent a team merge request reminder
    TeamMergeRequestReminder(TeamMergeRequestReminderType),
    /// (trusted_teams) Sent a team merge request reminder (deprecated, replaced by 'Sent a team
    /// merge request reminder')
    TeamMergeRequestReminderShownToPrimaryTeam(TeamMergeRequestReminderShownToPrimaryTeamType),
    /// (trusted_teams) Sent a team merge request reminder (deprecated, replaced by 'Sent a team
    /// merge request reminder')
    TeamMergeRequestReminderShownToSecondaryTeam(TeamMergeRequestReminderShownToSecondaryTeamType),
    /// (trusted_teams) Canceled the team merge
    TeamMergeRequestRevoked(TeamMergeRequestRevokedType),
    /// (trusted_teams) Requested to merge their Dropbox team into yours
    TeamMergeRequestSentShownToPrimaryTeam(TeamMergeRequestSentShownToPrimaryTeamType),
    /// (trusted_teams) Requested to merge your team into another Dropbox team
    TeamMergeRequestSentShownToSecondaryTeam(TeamMergeRequestSentShownToSecondaryTeamType),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EventType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EventType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EventType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "app_link_team" => Ok(EventType::AppLinkTeam(AppLinkTeamType::internal_deserialize(map)?)),
                    "app_link_user" => Ok(EventType::AppLinkUser(AppLinkUserType::internal_deserialize(map)?)),
                    "app_unlink_team" => Ok(EventType::AppUnlinkTeam(AppUnlinkTeamType::internal_deserialize(map)?)),
                    "app_unlink_user" => Ok(EventType::AppUnlinkUser(AppUnlinkUserType::internal_deserialize(map)?)),
                    "integration_connected" => Ok(EventType::IntegrationConnected(IntegrationConnectedType::internal_deserialize(map)?)),
                    "integration_disconnected" => Ok(EventType::IntegrationDisconnected(IntegrationDisconnectedType::internal_deserialize(map)?)),
                    "file_add_comment" => Ok(EventType::FileAddComment(FileAddCommentType::internal_deserialize(map)?)),
                    "file_change_comment_subscription" => Ok(EventType::FileChangeCommentSubscription(FileChangeCommentSubscriptionType::internal_deserialize(map)?)),
                    "file_delete_comment" => Ok(EventType::FileDeleteComment(FileDeleteCommentType::internal_deserialize(map)?)),
                    "file_edit_comment" => Ok(EventType::FileEditComment(FileEditCommentType::internal_deserialize(map)?)),
                    "file_like_comment" => Ok(EventType::FileLikeComment(FileLikeCommentType::internal_deserialize(map)?)),
                    "file_resolve_comment" => Ok(EventType::FileResolveComment(FileResolveCommentType::internal_deserialize(map)?)),
                    "file_unlike_comment" => Ok(EventType::FileUnlikeComment(FileUnlikeCommentType::internal_deserialize(map)?)),
                    "file_unresolve_comment" => Ok(EventType::FileUnresolveComment(FileUnresolveCommentType::internal_deserialize(map)?)),
                    "device_change_ip_desktop" => Ok(EventType::DeviceChangeIpDesktop(DeviceChangeIpDesktopType::internal_deserialize(map)?)),
                    "device_change_ip_mobile" => Ok(EventType::DeviceChangeIpMobile(DeviceChangeIpMobileType::internal_deserialize(map)?)),
                    "device_change_ip_web" => Ok(EventType::DeviceChangeIpWeb(DeviceChangeIpWebType::internal_deserialize(map)?)),
                    "device_delete_on_unlink_fail" => Ok(EventType::DeviceDeleteOnUnlinkFail(DeviceDeleteOnUnlinkFailType::internal_deserialize(map)?)),
                    "device_delete_on_unlink_success" => Ok(EventType::DeviceDeleteOnUnlinkSuccess(DeviceDeleteOnUnlinkSuccessType::internal_deserialize(map)?)),
                    "device_link_fail" => Ok(EventType::DeviceLinkFail(DeviceLinkFailType::internal_deserialize(map)?)),
                    "device_link_success" => Ok(EventType::DeviceLinkSuccess(DeviceLinkSuccessType::internal_deserialize(map)?)),
                    "device_management_disabled" => Ok(EventType::DeviceManagementDisabled(DeviceManagementDisabledType::internal_deserialize(map)?)),
                    "device_management_enabled" => Ok(EventType::DeviceManagementEnabled(DeviceManagementEnabledType::internal_deserialize(map)?)),
                    "device_unlink" => Ok(EventType::DeviceUnlink(DeviceUnlinkType::internal_deserialize(map)?)),
                    "emm_refresh_auth_token" => Ok(EventType::EmmRefreshAuthToken(EmmRefreshAuthTokenType::internal_deserialize(map)?)),
                    "account_capture_change_availability" => Ok(EventType::AccountCaptureChangeAvailability(AccountCaptureChangeAvailabilityType::internal_deserialize(map)?)),
                    "account_capture_migrate_account" => Ok(EventType::AccountCaptureMigrateAccount(AccountCaptureMigrateAccountType::internal_deserialize(map)?)),
                    "account_capture_notification_emails_sent" => Ok(EventType::AccountCaptureNotificationEmailsSent(AccountCaptureNotificationEmailsSentType::internal_deserialize(map)?)),
                    "account_capture_relinquish_account" => Ok(EventType::AccountCaptureRelinquishAccount(AccountCaptureRelinquishAccountType::internal_deserialize(map)?)),
                    "disabled_domain_invites" => Ok(EventType::DisabledDomainInvites(DisabledDomainInvitesType::internal_deserialize(map)?)),
                    "domain_invites_approve_request_to_join_team" => Ok(EventType::DomainInvitesApproveRequestToJoinTeam(DomainInvitesApproveRequestToJoinTeamType::internal_deserialize(map)?)),
                    "domain_invites_decline_request_to_join_team" => Ok(EventType::DomainInvitesDeclineRequestToJoinTeam(DomainInvitesDeclineRequestToJoinTeamType::internal_deserialize(map)?)),
                    "domain_invites_email_existing_users" => Ok(EventType::DomainInvitesEmailExistingUsers(DomainInvitesEmailExistingUsersType::internal_deserialize(map)?)),
                    "domain_invites_request_to_join_team" => Ok(EventType::DomainInvitesRequestToJoinTeam(DomainInvitesRequestToJoinTeamType::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_no" => Ok(EventType::DomainInvitesSetInviteNewUserPrefToNo(DomainInvitesSetInviteNewUserPrefToNoType::internal_deserialize(map)?)),
                    "domain_invites_set_invite_new_user_pref_to_yes" => Ok(EventType::DomainInvitesSetInviteNewUserPrefToYes(DomainInvitesSetInviteNewUserPrefToYesType::internal_deserialize(map)?)),
                    "domain_verification_add_domain_fail" => Ok(EventType::DomainVerificationAddDomainFail(DomainVerificationAddDomainFailType::internal_deserialize(map)?)),
                    "domain_verification_add_domain_success" => Ok(EventType::DomainVerificationAddDomainSuccess(DomainVerificationAddDomainSuccessType::internal_deserialize(map)?)),
                    "domain_verification_remove_domain" => Ok(EventType::DomainVerificationRemoveDomain(DomainVerificationRemoveDomainType::internal_deserialize(map)?)),
                    "enabled_domain_invites" => Ok(EventType::EnabledDomainInvites(EnabledDomainInvitesType::internal_deserialize(map)?)),
                    "create_folder" => Ok(EventType::CreateFolder(CreateFolderType::internal_deserialize(map)?)),
                    "file_add" => Ok(EventType::FileAdd(FileAddType::internal_deserialize(map)?)),
                    "file_copy" => Ok(EventType::FileCopy(FileCopyType::internal_deserialize(map)?)),
                    "file_delete" => Ok(EventType::FileDelete(FileDeleteType::internal_deserialize(map)?)),
                    "file_download" => Ok(EventType::FileDownload(FileDownloadType::internal_deserialize(map)?)),
                    "file_edit" => Ok(EventType::FileEdit(FileEditType::internal_deserialize(map)?)),
                    "file_get_copy_reference" => Ok(EventType::FileGetCopyReference(FileGetCopyReferenceType::internal_deserialize(map)?)),
                    "file_locking_lock_status_changed" => Ok(EventType::FileLockingLockStatusChanged(FileLockingLockStatusChangedType::internal_deserialize(map)?)),
                    "file_move" => Ok(EventType::FileMove(FileMoveType::internal_deserialize(map)?)),
                    "file_permanently_delete" => Ok(EventType::FilePermanentlyDelete(FilePermanentlyDeleteType::internal_deserialize(map)?)),
                    "file_preview" => Ok(EventType::FilePreview(FilePreviewType::internal_deserialize(map)?)),
                    "file_rename" => Ok(EventType::FileRename(FileRenameType::internal_deserialize(map)?)),
                    "file_restore" => Ok(EventType::FileRestore(FileRestoreType::internal_deserialize(map)?)),
                    "file_revert" => Ok(EventType::FileRevert(FileRevertType::internal_deserialize(map)?)),
                    "file_rollback_changes" => Ok(EventType::FileRollbackChanges(FileRollbackChangesType::internal_deserialize(map)?)),
                    "file_save_copy_reference" => Ok(EventType::FileSaveCopyReference(FileSaveCopyReferenceType::internal_deserialize(map)?)),
                    "folder_overview_description_changed" => Ok(EventType::FolderOverviewDescriptionChanged(FolderOverviewDescriptionChangedType::internal_deserialize(map)?)),
                    "folder_overview_item_pinned" => Ok(EventType::FolderOverviewItemPinned(FolderOverviewItemPinnedType::internal_deserialize(map)?)),
                    "folder_overview_item_unpinned" => Ok(EventType::FolderOverviewItemUnpinned(FolderOverviewItemUnpinnedType::internal_deserialize(map)?)),
                    "rewind_folder" => Ok(EventType::RewindFolder(RewindFolderType::internal_deserialize(map)?)),
                    "file_request_change" => Ok(EventType::FileRequestChange(FileRequestChangeType::internal_deserialize(map)?)),
                    "file_request_close" => Ok(EventType::FileRequestClose(FileRequestCloseType::internal_deserialize(map)?)),
                    "file_request_create" => Ok(EventType::FileRequestCreate(FileRequestCreateType::internal_deserialize(map)?)),
                    "file_request_delete" => Ok(EventType::FileRequestDelete(FileRequestDeleteType::internal_deserialize(map)?)),
                    "file_request_receive_file" => Ok(EventType::FileRequestReceiveFile(FileRequestReceiveFileType::internal_deserialize(map)?)),
                    "group_add_external_id" => Ok(EventType::GroupAddExternalId(GroupAddExternalIdType::internal_deserialize(map)?)),
                    "group_add_member" => Ok(EventType::GroupAddMember(GroupAddMemberType::internal_deserialize(map)?)),
                    "group_change_external_id" => Ok(EventType::GroupChangeExternalId(GroupChangeExternalIdType::internal_deserialize(map)?)),
                    "group_change_management_type" => Ok(EventType::GroupChangeManagementType(GroupChangeManagementTypeType::internal_deserialize(map)?)),
                    "group_change_member_role" => Ok(EventType::GroupChangeMemberRole(GroupChangeMemberRoleType::internal_deserialize(map)?)),
                    "group_create" => Ok(EventType::GroupCreate(GroupCreateType::internal_deserialize(map)?)),
                    "group_delete" => Ok(EventType::GroupDelete(GroupDeleteType::internal_deserialize(map)?)),
                    "group_description_updated" => Ok(EventType::GroupDescriptionUpdated(GroupDescriptionUpdatedType::internal_deserialize(map)?)),
                    "group_join_policy_updated" => Ok(EventType::GroupJoinPolicyUpdated(GroupJoinPolicyUpdatedType::internal_deserialize(map)?)),
                    "group_moved" => Ok(EventType::GroupMoved(GroupMovedType::internal_deserialize(map)?)),
                    "group_remove_external_id" => Ok(EventType::GroupRemoveExternalId(GroupRemoveExternalIdType::internal_deserialize(map)?)),
                    "group_remove_member" => Ok(EventType::GroupRemoveMember(GroupRemoveMemberType::internal_deserialize(map)?)),
                    "group_rename" => Ok(EventType::GroupRename(GroupRenameType::internal_deserialize(map)?)),
                    "legal_holds_activate_a_hold" => Ok(EventType::LegalHoldsActivateAHold(LegalHoldsActivateAHoldType::internal_deserialize(map)?)),
                    "legal_holds_add_members" => Ok(EventType::LegalHoldsAddMembers(LegalHoldsAddMembersType::internal_deserialize(map)?)),
                    "legal_holds_change_hold_details" => Ok(EventType::LegalHoldsChangeHoldDetails(LegalHoldsChangeHoldDetailsType::internal_deserialize(map)?)),
                    "legal_holds_change_hold_name" => Ok(EventType::LegalHoldsChangeHoldName(LegalHoldsChangeHoldNameType::internal_deserialize(map)?)),
                    "legal_holds_export_a_hold" => Ok(EventType::LegalHoldsExportAHold(LegalHoldsExportAHoldType::internal_deserialize(map)?)),
                    "legal_holds_export_cancelled" => Ok(EventType::LegalHoldsExportCancelled(LegalHoldsExportCancelledType::internal_deserialize(map)?)),
                    "legal_holds_export_downloaded" => Ok(EventType::LegalHoldsExportDownloaded(LegalHoldsExportDownloadedType::internal_deserialize(map)?)),
                    "legal_holds_export_removed" => Ok(EventType::LegalHoldsExportRemoved(LegalHoldsExportRemovedType::internal_deserialize(map)?)),
                    "legal_holds_release_a_hold" => Ok(EventType::LegalHoldsReleaseAHold(LegalHoldsReleaseAHoldType::internal_deserialize(map)?)),
                    "legal_holds_remove_members" => Ok(EventType::LegalHoldsRemoveMembers(LegalHoldsRemoveMembersType::internal_deserialize(map)?)),
                    "legal_holds_report_a_hold" => Ok(EventType::LegalHoldsReportAHold(LegalHoldsReportAHoldType::internal_deserialize(map)?)),
                    "account_lock_or_unlocked" => Ok(EventType::AccountLockOrUnlocked(AccountLockOrUnlockedType::internal_deserialize(map)?)),
                    "emm_error" => Ok(EventType::EmmError(EmmErrorType::internal_deserialize(map)?)),
                    "guest_admin_signed_in_via_trusted_teams" => Ok(EventType::GuestAdminSignedInViaTrustedTeams(GuestAdminSignedInViaTrustedTeamsType::internal_deserialize(map)?)),
                    "guest_admin_signed_out_via_trusted_teams" => Ok(EventType::GuestAdminSignedOutViaTrustedTeams(GuestAdminSignedOutViaTrustedTeamsType::internal_deserialize(map)?)),
                    "login_fail" => Ok(EventType::LoginFail(LoginFailType::internal_deserialize(map)?)),
                    "login_success" => Ok(EventType::LoginSuccess(LoginSuccessType::internal_deserialize(map)?)),
                    "logout" => Ok(EventType::Logout(LogoutType::internal_deserialize(map)?)),
                    "reseller_support_session_end" => Ok(EventType::ResellerSupportSessionEnd(ResellerSupportSessionEndType::internal_deserialize(map)?)),
                    "reseller_support_session_start" => Ok(EventType::ResellerSupportSessionStart(ResellerSupportSessionStartType::internal_deserialize(map)?)),
                    "sign_in_as_session_end" => Ok(EventType::SignInAsSessionEnd(SignInAsSessionEndType::internal_deserialize(map)?)),
                    "sign_in_as_session_start" => Ok(EventType::SignInAsSessionStart(SignInAsSessionStartType::internal_deserialize(map)?)),
                    "sso_error" => Ok(EventType::SsoError(SsoErrorType::internal_deserialize(map)?)),
                    "create_team_invite_link" => Ok(EventType::CreateTeamInviteLink(CreateTeamInviteLinkType::internal_deserialize(map)?)),
                    "delete_team_invite_link" => Ok(EventType::DeleteTeamInviteLink(DeleteTeamInviteLinkType::internal_deserialize(map)?)),
                    "member_add_external_id" => Ok(EventType::MemberAddExternalId(MemberAddExternalIdType::internal_deserialize(map)?)),
                    "member_add_name" => Ok(EventType::MemberAddName(MemberAddNameType::internal_deserialize(map)?)),
                    "member_change_admin_role" => Ok(EventType::MemberChangeAdminRole(MemberChangeAdminRoleType::internal_deserialize(map)?)),
                    "member_change_email" => Ok(EventType::MemberChangeEmail(MemberChangeEmailType::internal_deserialize(map)?)),
                    "member_change_external_id" => Ok(EventType::MemberChangeExternalId(MemberChangeExternalIdType::internal_deserialize(map)?)),
                    "member_change_membership_type" => Ok(EventType::MemberChangeMembershipType(MemberChangeMembershipTypeType::internal_deserialize(map)?)),
                    "member_change_name" => Ok(EventType::MemberChangeName(MemberChangeNameType::internal_deserialize(map)?)),
                    "member_change_status" => Ok(EventType::MemberChangeStatus(MemberChangeStatusType::internal_deserialize(map)?)),
                    "member_delete_manual_contacts" => Ok(EventType::MemberDeleteManualContacts(MemberDeleteManualContactsType::internal_deserialize(map)?)),
                    "member_delete_profile_photo" => Ok(EventType::MemberDeleteProfilePhoto(MemberDeleteProfilePhotoType::internal_deserialize(map)?)),
                    "member_permanently_delete_account_contents" => Ok(EventType::MemberPermanentlyDeleteAccountContents(MemberPermanentlyDeleteAccountContentsType::internal_deserialize(map)?)),
                    "member_remove_external_id" => Ok(EventType::MemberRemoveExternalId(MemberRemoveExternalIdType::internal_deserialize(map)?)),
                    "member_set_profile_photo" => Ok(EventType::MemberSetProfilePhoto(MemberSetProfilePhotoType::internal_deserialize(map)?)),
                    "member_space_limits_add_custom_quota" => Ok(EventType::MemberSpaceLimitsAddCustomQuota(MemberSpaceLimitsAddCustomQuotaType::internal_deserialize(map)?)),
                    "member_space_limits_change_custom_quota" => Ok(EventType::MemberSpaceLimitsChangeCustomQuota(MemberSpaceLimitsChangeCustomQuotaType::internal_deserialize(map)?)),
                    "member_space_limits_change_status" => Ok(EventType::MemberSpaceLimitsChangeStatus(MemberSpaceLimitsChangeStatusType::internal_deserialize(map)?)),
                    "member_space_limits_remove_custom_quota" => Ok(EventType::MemberSpaceLimitsRemoveCustomQuota(MemberSpaceLimitsRemoveCustomQuotaType::internal_deserialize(map)?)),
                    "member_suggest" => Ok(EventType::MemberSuggest(MemberSuggestType::internal_deserialize(map)?)),
                    "member_transfer_account_contents" => Ok(EventType::MemberTransferAccountContents(MemberTransferAccountContentsType::internal_deserialize(map)?)),
                    "pending_secondary_email_added" => Ok(EventType::PendingSecondaryEmailAdded(PendingSecondaryEmailAddedType::internal_deserialize(map)?)),
                    "secondary_email_deleted" => Ok(EventType::SecondaryEmailDeleted(SecondaryEmailDeletedType::internal_deserialize(map)?)),
                    "secondary_email_verified" => Ok(EventType::SecondaryEmailVerified(SecondaryEmailVerifiedType::internal_deserialize(map)?)),
                    "secondary_mails_policy_changed" => Ok(EventType::SecondaryMailsPolicyChanged(SecondaryMailsPolicyChangedType::internal_deserialize(map)?)),
                    "binder_add_page" => Ok(EventType::BinderAddPage(BinderAddPageType::internal_deserialize(map)?)),
                    "binder_add_section" => Ok(EventType::BinderAddSection(BinderAddSectionType::internal_deserialize(map)?)),
                    "binder_remove_page" => Ok(EventType::BinderRemovePage(BinderRemovePageType::internal_deserialize(map)?)),
                    "binder_remove_section" => Ok(EventType::BinderRemoveSection(BinderRemoveSectionType::internal_deserialize(map)?)),
                    "binder_rename_page" => Ok(EventType::BinderRenamePage(BinderRenamePageType::internal_deserialize(map)?)),
                    "binder_rename_section" => Ok(EventType::BinderRenameSection(BinderRenameSectionType::internal_deserialize(map)?)),
                    "binder_reorder_page" => Ok(EventType::BinderReorderPage(BinderReorderPageType::internal_deserialize(map)?)),
                    "binder_reorder_section" => Ok(EventType::BinderReorderSection(BinderReorderSectionType::internal_deserialize(map)?)),
                    "paper_content_add_member" => Ok(EventType::PaperContentAddMember(PaperContentAddMemberType::internal_deserialize(map)?)),
                    "paper_content_add_to_folder" => Ok(EventType::PaperContentAddToFolder(PaperContentAddToFolderType::internal_deserialize(map)?)),
                    "paper_content_archive" => Ok(EventType::PaperContentArchive(PaperContentArchiveType::internal_deserialize(map)?)),
                    "paper_content_create" => Ok(EventType::PaperContentCreate(PaperContentCreateType::internal_deserialize(map)?)),
                    "paper_content_permanently_delete" => Ok(EventType::PaperContentPermanentlyDelete(PaperContentPermanentlyDeleteType::internal_deserialize(map)?)),
                    "paper_content_remove_from_folder" => Ok(EventType::PaperContentRemoveFromFolder(PaperContentRemoveFromFolderType::internal_deserialize(map)?)),
                    "paper_content_remove_member" => Ok(EventType::PaperContentRemoveMember(PaperContentRemoveMemberType::internal_deserialize(map)?)),
                    "paper_content_rename" => Ok(EventType::PaperContentRename(PaperContentRenameType::internal_deserialize(map)?)),
                    "paper_content_restore" => Ok(EventType::PaperContentRestore(PaperContentRestoreType::internal_deserialize(map)?)),
                    "paper_doc_add_comment" => Ok(EventType::PaperDocAddComment(PaperDocAddCommentType::internal_deserialize(map)?)),
                    "paper_doc_change_member_role" => Ok(EventType::PaperDocChangeMemberRole(PaperDocChangeMemberRoleType::internal_deserialize(map)?)),
                    "paper_doc_change_sharing_policy" => Ok(EventType::PaperDocChangeSharingPolicy(PaperDocChangeSharingPolicyType::internal_deserialize(map)?)),
                    "paper_doc_change_subscription" => Ok(EventType::PaperDocChangeSubscription(PaperDocChangeSubscriptionType::internal_deserialize(map)?)),
                    "paper_doc_deleted" => Ok(EventType::PaperDocDeleted(PaperDocDeletedType::internal_deserialize(map)?)),
                    "paper_doc_delete_comment" => Ok(EventType::PaperDocDeleteComment(PaperDocDeleteCommentType::internal_deserialize(map)?)),
                    "paper_doc_download" => Ok(EventType::PaperDocDownload(PaperDocDownloadType::internal_deserialize(map)?)),
                    "paper_doc_edit" => Ok(EventType::PaperDocEdit(PaperDocEditType::internal_deserialize(map)?)),
                    "paper_doc_edit_comment" => Ok(EventType::PaperDocEditComment(PaperDocEditCommentType::internal_deserialize(map)?)),
                    "paper_doc_followed" => Ok(EventType::PaperDocFollowed(PaperDocFollowedType::internal_deserialize(map)?)),
                    "paper_doc_mention" => Ok(EventType::PaperDocMention(PaperDocMentionType::internal_deserialize(map)?)),
                    "paper_doc_ownership_changed" => Ok(EventType::PaperDocOwnershipChanged(PaperDocOwnershipChangedType::internal_deserialize(map)?)),
                    "paper_doc_request_access" => Ok(EventType::PaperDocRequestAccess(PaperDocRequestAccessType::internal_deserialize(map)?)),
                    "paper_doc_resolve_comment" => Ok(EventType::PaperDocResolveComment(PaperDocResolveCommentType::internal_deserialize(map)?)),
                    "paper_doc_revert" => Ok(EventType::PaperDocRevert(PaperDocRevertType::internal_deserialize(map)?)),
                    "paper_doc_slack_share" => Ok(EventType::PaperDocSlackShare(PaperDocSlackShareType::internal_deserialize(map)?)),
                    "paper_doc_team_invite" => Ok(EventType::PaperDocTeamInvite(PaperDocTeamInviteType::internal_deserialize(map)?)),
                    "paper_doc_trashed" => Ok(EventType::PaperDocTrashed(PaperDocTrashedType::internal_deserialize(map)?)),
                    "paper_doc_unresolve_comment" => Ok(EventType::PaperDocUnresolveComment(PaperDocUnresolveCommentType::internal_deserialize(map)?)),
                    "paper_doc_untrashed" => Ok(EventType::PaperDocUntrashed(PaperDocUntrashedType::internal_deserialize(map)?)),
                    "paper_doc_view" => Ok(EventType::PaperDocView(PaperDocViewType::internal_deserialize(map)?)),
                    "paper_external_view_allow" => Ok(EventType::PaperExternalViewAllow(PaperExternalViewAllowType::internal_deserialize(map)?)),
                    "paper_external_view_default_team" => Ok(EventType::PaperExternalViewDefaultTeam(PaperExternalViewDefaultTeamType::internal_deserialize(map)?)),
                    "paper_external_view_forbid" => Ok(EventType::PaperExternalViewForbid(PaperExternalViewForbidType::internal_deserialize(map)?)),
                    "paper_folder_change_subscription" => Ok(EventType::PaperFolderChangeSubscription(PaperFolderChangeSubscriptionType::internal_deserialize(map)?)),
                    "paper_folder_deleted" => Ok(EventType::PaperFolderDeleted(PaperFolderDeletedType::internal_deserialize(map)?)),
                    "paper_folder_followed" => Ok(EventType::PaperFolderFollowed(PaperFolderFollowedType::internal_deserialize(map)?)),
                    "paper_folder_team_invite" => Ok(EventType::PaperFolderTeamInvite(PaperFolderTeamInviteType::internal_deserialize(map)?)),
                    "paper_published_link_change_permission" => Ok(EventType::PaperPublishedLinkChangePermission(PaperPublishedLinkChangePermissionType::internal_deserialize(map)?)),
                    "paper_published_link_create" => Ok(EventType::PaperPublishedLinkCreate(PaperPublishedLinkCreateType::internal_deserialize(map)?)),
                    "paper_published_link_disabled" => Ok(EventType::PaperPublishedLinkDisabled(PaperPublishedLinkDisabledType::internal_deserialize(map)?)),
                    "paper_published_link_view" => Ok(EventType::PaperPublishedLinkView(PaperPublishedLinkViewType::internal_deserialize(map)?)),
                    "password_change" => Ok(EventType::PasswordChange(PasswordChangeType::internal_deserialize(map)?)),
                    "password_reset" => Ok(EventType::PasswordReset(PasswordResetType::internal_deserialize(map)?)),
                    "password_reset_all" => Ok(EventType::PasswordResetAll(PasswordResetAllType::internal_deserialize(map)?)),
                    "emm_create_exceptions_report" => Ok(EventType::EmmCreateExceptionsReport(EmmCreateExceptionsReportType::internal_deserialize(map)?)),
                    "emm_create_usage_report" => Ok(EventType::EmmCreateUsageReport(EmmCreateUsageReportType::internal_deserialize(map)?)),
                    "export_members_report" => Ok(EventType::ExportMembersReport(ExportMembersReportType::internal_deserialize(map)?)),
                    "export_members_report_fail" => Ok(EventType::ExportMembersReportFail(ExportMembersReportFailType::internal_deserialize(map)?)),
                    "no_expiration_link_gen_create_report" => Ok(EventType::NoExpirationLinkGenCreateReport(NoExpirationLinkGenCreateReportType::internal_deserialize(map)?)),
                    "no_expiration_link_gen_report_failed" => Ok(EventType::NoExpirationLinkGenReportFailed(NoExpirationLinkGenReportFailedType::internal_deserialize(map)?)),
                    "no_password_link_gen_create_report" => Ok(EventType::NoPasswordLinkGenCreateReport(NoPasswordLinkGenCreateReportType::internal_deserialize(map)?)),
                    "no_password_link_gen_report_failed" => Ok(EventType::NoPasswordLinkGenReportFailed(NoPasswordLinkGenReportFailedType::internal_deserialize(map)?)),
                    "no_password_link_view_create_report" => Ok(EventType::NoPasswordLinkViewCreateReport(NoPasswordLinkViewCreateReportType::internal_deserialize(map)?)),
                    "no_password_link_view_report_failed" => Ok(EventType::NoPasswordLinkViewReportFailed(NoPasswordLinkViewReportFailedType::internal_deserialize(map)?)),
                    "outdated_link_view_create_report" => Ok(EventType::OutdatedLinkViewCreateReport(OutdatedLinkViewCreateReportType::internal_deserialize(map)?)),
                    "outdated_link_view_report_failed" => Ok(EventType::OutdatedLinkViewReportFailed(OutdatedLinkViewReportFailedType::internal_deserialize(map)?)),
                    "paper_admin_export_start" => Ok(EventType::PaperAdminExportStart(PaperAdminExportStartType::internal_deserialize(map)?)),
                    "smart_sync_create_admin_privilege_report" => Ok(EventType::SmartSyncCreateAdminPrivilegeReport(SmartSyncCreateAdminPrivilegeReportType::internal_deserialize(map)?)),
                    "team_activity_create_report" => Ok(EventType::TeamActivityCreateReport(TeamActivityCreateReportType::internal_deserialize(map)?)),
                    "team_activity_create_report_fail" => Ok(EventType::TeamActivityCreateReportFail(TeamActivityCreateReportFailType::internal_deserialize(map)?)),
                    "collection_share" => Ok(EventType::CollectionShare(CollectionShareType::internal_deserialize(map)?)),
                    "file_transfers_file_add" => Ok(EventType::FileTransfersFileAdd(FileTransfersFileAddType::internal_deserialize(map)?)),
                    "file_transfers_transfer_delete" => Ok(EventType::FileTransfersTransferDelete(FileTransfersTransferDeleteType::internal_deserialize(map)?)),
                    "file_transfers_transfer_download" => Ok(EventType::FileTransfersTransferDownload(FileTransfersTransferDownloadType::internal_deserialize(map)?)),
                    "file_transfers_transfer_send" => Ok(EventType::FileTransfersTransferSend(FileTransfersTransferSendType::internal_deserialize(map)?)),
                    "file_transfers_transfer_view" => Ok(EventType::FileTransfersTransferView(FileTransfersTransferViewType::internal_deserialize(map)?)),
                    "note_acl_invite_only" => Ok(EventType::NoteAclInviteOnly(NoteAclInviteOnlyType::internal_deserialize(map)?)),
                    "note_acl_link" => Ok(EventType::NoteAclLink(NoteAclLinkType::internal_deserialize(map)?)),
                    "note_acl_team_link" => Ok(EventType::NoteAclTeamLink(NoteAclTeamLinkType::internal_deserialize(map)?)),
                    "note_shared" => Ok(EventType::NoteShared(NoteSharedType::internal_deserialize(map)?)),
                    "note_share_receive" => Ok(EventType::NoteShareReceive(NoteShareReceiveType::internal_deserialize(map)?)),
                    "open_note_shared" => Ok(EventType::OpenNoteShared(OpenNoteSharedType::internal_deserialize(map)?)),
                    "sf_add_group" => Ok(EventType::SfAddGroup(SfAddGroupType::internal_deserialize(map)?)),
                    "sf_allow_non_members_to_view_shared_links" => Ok(EventType::SfAllowNonMembersToViewSharedLinks(SfAllowNonMembersToViewSharedLinksType::internal_deserialize(map)?)),
                    "sf_external_invite_warn" => Ok(EventType::SfExternalInviteWarn(SfExternalInviteWarnType::internal_deserialize(map)?)),
                    "sf_fb_invite" => Ok(EventType::SfFbInvite(SfFbInviteType::internal_deserialize(map)?)),
                    "sf_fb_invite_change_role" => Ok(EventType::SfFbInviteChangeRole(SfFbInviteChangeRoleType::internal_deserialize(map)?)),
                    "sf_fb_uninvite" => Ok(EventType::SfFbUninvite(SfFbUninviteType::internal_deserialize(map)?)),
                    "sf_invite_group" => Ok(EventType::SfInviteGroup(SfInviteGroupType::internal_deserialize(map)?)),
                    "sf_team_grant_access" => Ok(EventType::SfTeamGrantAccess(SfTeamGrantAccessType::internal_deserialize(map)?)),
                    "sf_team_invite" => Ok(EventType::SfTeamInvite(SfTeamInviteType::internal_deserialize(map)?)),
                    "sf_team_invite_change_role" => Ok(EventType::SfTeamInviteChangeRole(SfTeamInviteChangeRoleType::internal_deserialize(map)?)),
                    "sf_team_join" => Ok(EventType::SfTeamJoin(SfTeamJoinType::internal_deserialize(map)?)),
                    "sf_team_join_from_oob_link" => Ok(EventType::SfTeamJoinFromOobLink(SfTeamJoinFromOobLinkType::internal_deserialize(map)?)),
                    "sf_team_uninvite" => Ok(EventType::SfTeamUninvite(SfTeamUninviteType::internal_deserialize(map)?)),
                    "shared_content_add_invitees" => Ok(EventType::SharedContentAddInvitees(SharedContentAddInviteesType::internal_deserialize(map)?)),
                    "shared_content_add_link_expiry" => Ok(EventType::SharedContentAddLinkExpiry(SharedContentAddLinkExpiryType::internal_deserialize(map)?)),
                    "shared_content_add_link_password" => Ok(EventType::SharedContentAddLinkPassword(SharedContentAddLinkPasswordType::internal_deserialize(map)?)),
                    "shared_content_add_member" => Ok(EventType::SharedContentAddMember(SharedContentAddMemberType::internal_deserialize(map)?)),
                    "shared_content_change_downloads_policy" => Ok(EventType::SharedContentChangeDownloadsPolicy(SharedContentChangeDownloadsPolicyType::internal_deserialize(map)?)),
                    "shared_content_change_invitee_role" => Ok(EventType::SharedContentChangeInviteeRole(SharedContentChangeInviteeRoleType::internal_deserialize(map)?)),
                    "shared_content_change_link_audience" => Ok(EventType::SharedContentChangeLinkAudience(SharedContentChangeLinkAudienceType::internal_deserialize(map)?)),
                    "shared_content_change_link_expiry" => Ok(EventType::SharedContentChangeLinkExpiry(SharedContentChangeLinkExpiryType::internal_deserialize(map)?)),
                    "shared_content_change_link_password" => Ok(EventType::SharedContentChangeLinkPassword(SharedContentChangeLinkPasswordType::internal_deserialize(map)?)),
                    "shared_content_change_member_role" => Ok(EventType::SharedContentChangeMemberRole(SharedContentChangeMemberRoleType::internal_deserialize(map)?)),
                    "shared_content_change_viewer_info_policy" => Ok(EventType::SharedContentChangeViewerInfoPolicy(SharedContentChangeViewerInfoPolicyType::internal_deserialize(map)?)),
                    "shared_content_claim_invitation" => Ok(EventType::SharedContentClaimInvitation(SharedContentClaimInvitationType::internal_deserialize(map)?)),
                    "shared_content_copy" => Ok(EventType::SharedContentCopy(SharedContentCopyType::internal_deserialize(map)?)),
                    "shared_content_download" => Ok(EventType::SharedContentDownload(SharedContentDownloadType::internal_deserialize(map)?)),
                    "shared_content_relinquish_membership" => Ok(EventType::SharedContentRelinquishMembership(SharedContentRelinquishMembershipType::internal_deserialize(map)?)),
                    "shared_content_remove_invitees" => Ok(EventType::SharedContentRemoveInvitees(SharedContentRemoveInviteesType::internal_deserialize(map)?)),
                    "shared_content_remove_link_expiry" => Ok(EventType::SharedContentRemoveLinkExpiry(SharedContentRemoveLinkExpiryType::internal_deserialize(map)?)),
                    "shared_content_remove_link_password" => Ok(EventType::SharedContentRemoveLinkPassword(SharedContentRemoveLinkPasswordType::internal_deserialize(map)?)),
                    "shared_content_remove_member" => Ok(EventType::SharedContentRemoveMember(SharedContentRemoveMemberType::internal_deserialize(map)?)),
                    "shared_content_request_access" => Ok(EventType::SharedContentRequestAccess(SharedContentRequestAccessType::internal_deserialize(map)?)),
                    "shared_content_restore_invitees" => Ok(EventType::SharedContentRestoreInvitees(SharedContentRestoreInviteesType::internal_deserialize(map)?)),
                    "shared_content_restore_member" => Ok(EventType::SharedContentRestoreMember(SharedContentRestoreMemberType::internal_deserialize(map)?)),
                    "shared_content_unshare" => Ok(EventType::SharedContentUnshare(SharedContentUnshareType::internal_deserialize(map)?)),
                    "shared_content_view" => Ok(EventType::SharedContentView(SharedContentViewType::internal_deserialize(map)?)),
                    "shared_folder_change_link_policy" => Ok(EventType::SharedFolderChangeLinkPolicy(SharedFolderChangeLinkPolicyType::internal_deserialize(map)?)),
                    "shared_folder_change_members_inheritance_policy" => Ok(EventType::SharedFolderChangeMembersInheritancePolicy(SharedFolderChangeMembersInheritancePolicyType::internal_deserialize(map)?)),
                    "shared_folder_change_members_management_policy" => Ok(EventType::SharedFolderChangeMembersManagementPolicy(SharedFolderChangeMembersManagementPolicyType::internal_deserialize(map)?)),
                    "shared_folder_change_members_policy" => Ok(EventType::SharedFolderChangeMembersPolicy(SharedFolderChangeMembersPolicyType::internal_deserialize(map)?)),
                    "shared_folder_create" => Ok(EventType::SharedFolderCreate(SharedFolderCreateType::internal_deserialize(map)?)),
                    "shared_folder_decline_invitation" => Ok(EventType::SharedFolderDeclineInvitation(SharedFolderDeclineInvitationType::internal_deserialize(map)?)),
                    "shared_folder_mount" => Ok(EventType::SharedFolderMount(SharedFolderMountType::internal_deserialize(map)?)),
                    "shared_folder_nest" => Ok(EventType::SharedFolderNest(SharedFolderNestType::internal_deserialize(map)?)),
                    "shared_folder_transfer_ownership" => Ok(EventType::SharedFolderTransferOwnership(SharedFolderTransferOwnershipType::internal_deserialize(map)?)),
                    "shared_folder_unmount" => Ok(EventType::SharedFolderUnmount(SharedFolderUnmountType::internal_deserialize(map)?)),
                    "shared_link_add_expiry" => Ok(EventType::SharedLinkAddExpiry(SharedLinkAddExpiryType::internal_deserialize(map)?)),
                    "shared_link_change_expiry" => Ok(EventType::SharedLinkChangeExpiry(SharedLinkChangeExpiryType::internal_deserialize(map)?)),
                    "shared_link_change_visibility" => Ok(EventType::SharedLinkChangeVisibility(SharedLinkChangeVisibilityType::internal_deserialize(map)?)),
                    "shared_link_copy" => Ok(EventType::SharedLinkCopy(SharedLinkCopyType::internal_deserialize(map)?)),
                    "shared_link_create" => Ok(EventType::SharedLinkCreate(SharedLinkCreateType::internal_deserialize(map)?)),
                    "shared_link_disable" => Ok(EventType::SharedLinkDisable(SharedLinkDisableType::internal_deserialize(map)?)),
                    "shared_link_download" => Ok(EventType::SharedLinkDownload(SharedLinkDownloadType::internal_deserialize(map)?)),
                    "shared_link_remove_expiry" => Ok(EventType::SharedLinkRemoveExpiry(SharedLinkRemoveExpiryType::internal_deserialize(map)?)),
                    "shared_link_settings_add_expiration" => Ok(EventType::SharedLinkSettingsAddExpiration(SharedLinkSettingsAddExpirationType::internal_deserialize(map)?)),
                    "shared_link_settings_add_password" => Ok(EventType::SharedLinkSettingsAddPassword(SharedLinkSettingsAddPasswordType::internal_deserialize(map)?)),
                    "shared_link_settings_allow_download_disabled" => Ok(EventType::SharedLinkSettingsAllowDownloadDisabled(SharedLinkSettingsAllowDownloadDisabledType::internal_deserialize(map)?)),
                    "shared_link_settings_allow_download_enabled" => Ok(EventType::SharedLinkSettingsAllowDownloadEnabled(SharedLinkSettingsAllowDownloadEnabledType::internal_deserialize(map)?)),
                    "shared_link_settings_change_audience" => Ok(EventType::SharedLinkSettingsChangeAudience(SharedLinkSettingsChangeAudienceType::internal_deserialize(map)?)),
                    "shared_link_settings_change_expiration" => Ok(EventType::SharedLinkSettingsChangeExpiration(SharedLinkSettingsChangeExpirationType::internal_deserialize(map)?)),
                    "shared_link_settings_change_password" => Ok(EventType::SharedLinkSettingsChangePassword(SharedLinkSettingsChangePasswordType::internal_deserialize(map)?)),
                    "shared_link_settings_remove_expiration" => Ok(EventType::SharedLinkSettingsRemoveExpiration(SharedLinkSettingsRemoveExpirationType::internal_deserialize(map)?)),
                    "shared_link_settings_remove_password" => Ok(EventType::SharedLinkSettingsRemovePassword(SharedLinkSettingsRemovePasswordType::internal_deserialize(map)?)),
                    "shared_link_share" => Ok(EventType::SharedLinkShare(SharedLinkShareType::internal_deserialize(map)?)),
                    "shared_link_view" => Ok(EventType::SharedLinkView(SharedLinkViewType::internal_deserialize(map)?)),
                    "shared_note_opened" => Ok(EventType::SharedNoteOpened(SharedNoteOpenedType::internal_deserialize(map)?)),
                    "shmodel_group_share" => Ok(EventType::ShmodelGroupShare(ShmodelGroupShareType::internal_deserialize(map)?)),
                    "showcase_access_granted" => Ok(EventType::ShowcaseAccessGranted(ShowcaseAccessGrantedType::internal_deserialize(map)?)),
                    "showcase_add_member" => Ok(EventType::ShowcaseAddMember(ShowcaseAddMemberType::internal_deserialize(map)?)),
                    "showcase_archived" => Ok(EventType::ShowcaseArchived(ShowcaseArchivedType::internal_deserialize(map)?)),
                    "showcase_created" => Ok(EventType::ShowcaseCreated(ShowcaseCreatedType::internal_deserialize(map)?)),
                    "showcase_delete_comment" => Ok(EventType::ShowcaseDeleteComment(ShowcaseDeleteCommentType::internal_deserialize(map)?)),
                    "showcase_edited" => Ok(EventType::ShowcaseEdited(ShowcaseEditedType::internal_deserialize(map)?)),
                    "showcase_edit_comment" => Ok(EventType::ShowcaseEditComment(ShowcaseEditCommentType::internal_deserialize(map)?)),
                    "showcase_file_added" => Ok(EventType::ShowcaseFileAdded(ShowcaseFileAddedType::internal_deserialize(map)?)),
                    "showcase_file_download" => Ok(EventType::ShowcaseFileDownload(ShowcaseFileDownloadType::internal_deserialize(map)?)),
                    "showcase_file_removed" => Ok(EventType::ShowcaseFileRemoved(ShowcaseFileRemovedType::internal_deserialize(map)?)),
                    "showcase_file_view" => Ok(EventType::ShowcaseFileView(ShowcaseFileViewType::internal_deserialize(map)?)),
                    "showcase_permanently_deleted" => Ok(EventType::ShowcasePermanentlyDeleted(ShowcasePermanentlyDeletedType::internal_deserialize(map)?)),
                    "showcase_post_comment" => Ok(EventType::ShowcasePostComment(ShowcasePostCommentType::internal_deserialize(map)?)),
                    "showcase_remove_member" => Ok(EventType::ShowcaseRemoveMember(ShowcaseRemoveMemberType::internal_deserialize(map)?)),
                    "showcase_renamed" => Ok(EventType::ShowcaseRenamed(ShowcaseRenamedType::internal_deserialize(map)?)),
                    "showcase_request_access" => Ok(EventType::ShowcaseRequestAccess(ShowcaseRequestAccessType::internal_deserialize(map)?)),
                    "showcase_resolve_comment" => Ok(EventType::ShowcaseResolveComment(ShowcaseResolveCommentType::internal_deserialize(map)?)),
                    "showcase_restored" => Ok(EventType::ShowcaseRestored(ShowcaseRestoredType::internal_deserialize(map)?)),
                    "showcase_trashed" => Ok(EventType::ShowcaseTrashed(ShowcaseTrashedType::internal_deserialize(map)?)),
                    "showcase_trashed_deprecated" => Ok(EventType::ShowcaseTrashedDeprecated(ShowcaseTrashedDeprecatedType::internal_deserialize(map)?)),
                    "showcase_unresolve_comment" => Ok(EventType::ShowcaseUnresolveComment(ShowcaseUnresolveCommentType::internal_deserialize(map)?)),
                    "showcase_untrashed" => Ok(EventType::ShowcaseUntrashed(ShowcaseUntrashedType::internal_deserialize(map)?)),
                    "showcase_untrashed_deprecated" => Ok(EventType::ShowcaseUntrashedDeprecated(ShowcaseUntrashedDeprecatedType::internal_deserialize(map)?)),
                    "showcase_view" => Ok(EventType::ShowcaseView(ShowcaseViewType::internal_deserialize(map)?)),
                    "sso_add_cert" => Ok(EventType::SsoAddCert(SsoAddCertType::internal_deserialize(map)?)),
                    "sso_add_login_url" => Ok(EventType::SsoAddLoginUrl(SsoAddLoginUrlType::internal_deserialize(map)?)),
                    "sso_add_logout_url" => Ok(EventType::SsoAddLogoutUrl(SsoAddLogoutUrlType::internal_deserialize(map)?)),
                    "sso_change_cert" => Ok(EventType::SsoChangeCert(SsoChangeCertType::internal_deserialize(map)?)),
                    "sso_change_login_url" => Ok(EventType::SsoChangeLoginUrl(SsoChangeLoginUrlType::internal_deserialize(map)?)),
                    "sso_change_logout_url" => Ok(EventType::SsoChangeLogoutUrl(SsoChangeLogoutUrlType::internal_deserialize(map)?)),
                    "sso_change_saml_identity_mode" => Ok(EventType::SsoChangeSamlIdentityMode(SsoChangeSamlIdentityModeType::internal_deserialize(map)?)),
                    "sso_remove_cert" => Ok(EventType::SsoRemoveCert(SsoRemoveCertType::internal_deserialize(map)?)),
                    "sso_remove_login_url" => Ok(EventType::SsoRemoveLoginUrl(SsoRemoveLoginUrlType::internal_deserialize(map)?)),
                    "sso_remove_logout_url" => Ok(EventType::SsoRemoveLogoutUrl(SsoRemoveLogoutUrlType::internal_deserialize(map)?)),
                    "team_folder_change_status" => Ok(EventType::TeamFolderChangeStatus(TeamFolderChangeStatusType::internal_deserialize(map)?)),
                    "team_folder_create" => Ok(EventType::TeamFolderCreate(TeamFolderCreateType::internal_deserialize(map)?)),
                    "team_folder_downgrade" => Ok(EventType::TeamFolderDowngrade(TeamFolderDowngradeType::internal_deserialize(map)?)),
                    "team_folder_permanently_delete" => Ok(EventType::TeamFolderPermanentlyDelete(TeamFolderPermanentlyDeleteType::internal_deserialize(map)?)),
                    "team_folder_rename" => Ok(EventType::TeamFolderRename(TeamFolderRenameType::internal_deserialize(map)?)),
                    "team_selective_sync_settings_changed" => Ok(EventType::TeamSelectiveSyncSettingsChanged(TeamSelectiveSyncSettingsChangedType::internal_deserialize(map)?)),
                    "account_capture_change_policy" => Ok(EventType::AccountCaptureChangePolicy(AccountCaptureChangePolicyType::internal_deserialize(map)?)),
                    "allow_download_disabled" => Ok(EventType::AllowDownloadDisabled(AllowDownloadDisabledType::internal_deserialize(map)?)),
                    "allow_download_enabled" => Ok(EventType::AllowDownloadEnabled(AllowDownloadEnabledType::internal_deserialize(map)?)),
                    "camera_uploads_policy_changed" => Ok(EventType::CameraUploadsPolicyChanged(CameraUploadsPolicyChangedType::internal_deserialize(map)?)),
                    "data_placement_restriction_change_policy" => Ok(EventType::DataPlacementRestrictionChangePolicy(DataPlacementRestrictionChangePolicyType::internal_deserialize(map)?)),
                    "data_placement_restriction_satisfy_policy" => Ok(EventType::DataPlacementRestrictionSatisfyPolicy(DataPlacementRestrictionSatisfyPolicyType::internal_deserialize(map)?)),
                    "device_approvals_add_exception" => Ok(EventType::DeviceApprovalsAddException(DeviceApprovalsAddExceptionType::internal_deserialize(map)?)),
                    "device_approvals_change_desktop_policy" => Ok(EventType::DeviceApprovalsChangeDesktopPolicy(DeviceApprovalsChangeDesktopPolicyType::internal_deserialize(map)?)),
                    "device_approvals_change_mobile_policy" => Ok(EventType::DeviceApprovalsChangeMobilePolicy(DeviceApprovalsChangeMobilePolicyType::internal_deserialize(map)?)),
                    "device_approvals_change_overage_action" => Ok(EventType::DeviceApprovalsChangeOverageAction(DeviceApprovalsChangeOverageActionType::internal_deserialize(map)?)),
                    "device_approvals_change_unlink_action" => Ok(EventType::DeviceApprovalsChangeUnlinkAction(DeviceApprovalsChangeUnlinkActionType::internal_deserialize(map)?)),
                    "device_approvals_remove_exception" => Ok(EventType::DeviceApprovalsRemoveException(DeviceApprovalsRemoveExceptionType::internal_deserialize(map)?)),
                    "directory_restrictions_add_members" => Ok(EventType::DirectoryRestrictionsAddMembers(DirectoryRestrictionsAddMembersType::internal_deserialize(map)?)),
                    "directory_restrictions_remove_members" => Ok(EventType::DirectoryRestrictionsRemoveMembers(DirectoryRestrictionsRemoveMembersType::internal_deserialize(map)?)),
                    "emm_add_exception" => Ok(EventType::EmmAddException(EmmAddExceptionType::internal_deserialize(map)?)),
                    "emm_change_policy" => Ok(EventType::EmmChangePolicy(EmmChangePolicyType::internal_deserialize(map)?)),
                    "emm_remove_exception" => Ok(EventType::EmmRemoveException(EmmRemoveExceptionType::internal_deserialize(map)?)),
                    "extended_version_history_change_policy" => Ok(EventType::ExtendedVersionHistoryChangePolicy(ExtendedVersionHistoryChangePolicyType::internal_deserialize(map)?)),
                    "file_comments_change_policy" => Ok(EventType::FileCommentsChangePolicy(FileCommentsChangePolicyType::internal_deserialize(map)?)),
                    "file_locking_policy_changed" => Ok(EventType::FileLockingPolicyChanged(FileLockingPolicyChangedType::internal_deserialize(map)?)),
                    "file_requests_change_policy" => Ok(EventType::FileRequestsChangePolicy(FileRequestsChangePolicyType::internal_deserialize(map)?)),
                    "file_requests_emails_enabled" => Ok(EventType::FileRequestsEmailsEnabled(FileRequestsEmailsEnabledType::internal_deserialize(map)?)),
                    "file_requests_emails_restricted_to_team_only" => Ok(EventType::FileRequestsEmailsRestrictedToTeamOnly(FileRequestsEmailsRestrictedToTeamOnlyType::internal_deserialize(map)?)),
                    "file_transfers_policy_changed" => Ok(EventType::FileTransfersPolicyChanged(FileTransfersPolicyChangedType::internal_deserialize(map)?)),
                    "google_sso_change_policy" => Ok(EventType::GoogleSsoChangePolicy(GoogleSsoChangePolicyType::internal_deserialize(map)?)),
                    "group_user_management_change_policy" => Ok(EventType::GroupUserManagementChangePolicy(GroupUserManagementChangePolicyType::internal_deserialize(map)?)),
                    "integration_policy_changed" => Ok(EventType::IntegrationPolicyChanged(IntegrationPolicyChangedType::internal_deserialize(map)?)),
                    "member_requests_change_policy" => Ok(EventType::MemberRequestsChangePolicy(MemberRequestsChangePolicyType::internal_deserialize(map)?)),
                    "member_send_invite_policy_changed" => Ok(EventType::MemberSendInvitePolicyChanged(MemberSendInvitePolicyChangedType::internal_deserialize(map)?)),
                    "member_space_limits_add_exception" => Ok(EventType::MemberSpaceLimitsAddException(MemberSpaceLimitsAddExceptionType::internal_deserialize(map)?)),
                    "member_space_limits_change_caps_type_policy" => Ok(EventType::MemberSpaceLimitsChangeCapsTypePolicy(MemberSpaceLimitsChangeCapsTypePolicyType::internal_deserialize(map)?)),
                    "member_space_limits_change_policy" => Ok(EventType::MemberSpaceLimitsChangePolicy(MemberSpaceLimitsChangePolicyType::internal_deserialize(map)?)),
                    "member_space_limits_remove_exception" => Ok(EventType::MemberSpaceLimitsRemoveException(MemberSpaceLimitsRemoveExceptionType::internal_deserialize(map)?)),
                    "member_suggestions_change_policy" => Ok(EventType::MemberSuggestionsChangePolicy(MemberSuggestionsChangePolicyType::internal_deserialize(map)?)),
                    "microsoft_office_addin_change_policy" => Ok(EventType::MicrosoftOfficeAddinChangePolicy(MicrosoftOfficeAddinChangePolicyType::internal_deserialize(map)?)),
                    "network_control_change_policy" => Ok(EventType::NetworkControlChangePolicy(NetworkControlChangePolicyType::internal_deserialize(map)?)),
                    "paper_change_deployment_policy" => Ok(EventType::PaperChangeDeploymentPolicy(PaperChangeDeploymentPolicyType::internal_deserialize(map)?)),
                    "paper_change_member_link_policy" => Ok(EventType::PaperChangeMemberLinkPolicy(PaperChangeMemberLinkPolicyType::internal_deserialize(map)?)),
                    "paper_change_member_policy" => Ok(EventType::PaperChangeMemberPolicy(PaperChangeMemberPolicyType::internal_deserialize(map)?)),
                    "paper_change_policy" => Ok(EventType::PaperChangePolicy(PaperChangePolicyType::internal_deserialize(map)?)),
                    "paper_default_folder_policy_changed" => Ok(EventType::PaperDefaultFolderPolicyChanged(PaperDefaultFolderPolicyChangedType::internal_deserialize(map)?)),
                    "paper_desktop_policy_changed" => Ok(EventType::PaperDesktopPolicyChanged(PaperDesktopPolicyChangedType::internal_deserialize(map)?)),
                    "paper_enabled_users_group_addition" => Ok(EventType::PaperEnabledUsersGroupAddition(PaperEnabledUsersGroupAdditionType::internal_deserialize(map)?)),
                    "paper_enabled_users_group_removal" => Ok(EventType::PaperEnabledUsersGroupRemoval(PaperEnabledUsersGroupRemovalType::internal_deserialize(map)?)),
                    "password_strength_requirements_change_policy" => Ok(EventType::PasswordStrengthRequirementsChangePolicy(PasswordStrengthRequirementsChangePolicyType::internal_deserialize(map)?)),
                    "permanent_delete_change_policy" => Ok(EventType::PermanentDeleteChangePolicy(PermanentDeleteChangePolicyType::internal_deserialize(map)?)),
                    "reseller_support_change_policy" => Ok(EventType::ResellerSupportChangePolicy(ResellerSupportChangePolicyType::internal_deserialize(map)?)),
                    "rewind_policy_changed" => Ok(EventType::RewindPolicyChanged(RewindPolicyChangedType::internal_deserialize(map)?)),
                    "sharing_change_folder_join_policy" => Ok(EventType::SharingChangeFolderJoinPolicy(SharingChangeFolderJoinPolicyType::internal_deserialize(map)?)),
                    "sharing_change_link_policy" => Ok(EventType::SharingChangeLinkPolicy(SharingChangeLinkPolicyType::internal_deserialize(map)?)),
                    "sharing_change_member_policy" => Ok(EventType::SharingChangeMemberPolicy(SharingChangeMemberPolicyType::internal_deserialize(map)?)),
                    "showcase_change_download_policy" => Ok(EventType::ShowcaseChangeDownloadPolicy(ShowcaseChangeDownloadPolicyType::internal_deserialize(map)?)),
                    "showcase_change_enabled_policy" => Ok(EventType::ShowcaseChangeEnabledPolicy(ShowcaseChangeEnabledPolicyType::internal_deserialize(map)?)),
                    "showcase_change_external_sharing_policy" => Ok(EventType::ShowcaseChangeExternalSharingPolicy(ShowcaseChangeExternalSharingPolicyType::internal_deserialize(map)?)),
                    "smarter_smart_sync_policy_changed" => Ok(EventType::SmarterSmartSyncPolicyChanged(SmarterSmartSyncPolicyChangedType::internal_deserialize(map)?)),
                    "smart_sync_change_policy" => Ok(EventType::SmartSyncChangePolicy(SmartSyncChangePolicyType::internal_deserialize(map)?)),
                    "smart_sync_not_opt_out" => Ok(EventType::SmartSyncNotOptOut(SmartSyncNotOptOutType::internal_deserialize(map)?)),
                    "smart_sync_opt_out" => Ok(EventType::SmartSyncOptOut(SmartSyncOptOutType::internal_deserialize(map)?)),
                    "sso_change_policy" => Ok(EventType::SsoChangePolicy(SsoChangePolicyType::internal_deserialize(map)?)),
                    "team_extensions_policy_changed" => Ok(EventType::TeamExtensionsPolicyChanged(TeamExtensionsPolicyChangedType::internal_deserialize(map)?)),
                    "team_selective_sync_policy_changed" => Ok(EventType::TeamSelectiveSyncPolicyChanged(TeamSelectiveSyncPolicyChangedType::internal_deserialize(map)?)),
                    "team_sharing_whitelist_subjects_changed" => Ok(EventType::TeamSharingWhitelistSubjectsChanged(TeamSharingWhitelistSubjectsChangedType::internal_deserialize(map)?)),
                    "tfa_add_exception" => Ok(EventType::TfaAddException(TfaAddExceptionType::internal_deserialize(map)?)),
                    "tfa_change_policy" => Ok(EventType::TfaChangePolicy(TfaChangePolicyType::internal_deserialize(map)?)),
                    "tfa_remove_exception" => Ok(EventType::TfaRemoveException(TfaRemoveExceptionType::internal_deserialize(map)?)),
                    "two_account_change_policy" => Ok(EventType::TwoAccountChangePolicy(TwoAccountChangePolicyType::internal_deserialize(map)?)),
                    "viewer_info_policy_changed" => Ok(EventType::ViewerInfoPolicyChanged(ViewerInfoPolicyChangedType::internal_deserialize(map)?)),
                    "watermarking_policy_changed" => Ok(EventType::WatermarkingPolicyChanged(WatermarkingPolicyChangedType::internal_deserialize(map)?)),
                    "web_sessions_change_active_session_limit" => Ok(EventType::WebSessionsChangeActiveSessionLimit(WebSessionsChangeActiveSessionLimitType::internal_deserialize(map)?)),
                    "web_sessions_change_fixed_length_policy" => Ok(EventType::WebSessionsChangeFixedLengthPolicy(WebSessionsChangeFixedLengthPolicyType::internal_deserialize(map)?)),
                    "web_sessions_change_idle_length_policy" => Ok(EventType::WebSessionsChangeIdleLengthPolicy(WebSessionsChangeIdleLengthPolicyType::internal_deserialize(map)?)),
                    "team_merge_from" => Ok(EventType::TeamMergeFrom(TeamMergeFromType::internal_deserialize(map)?)),
                    "team_merge_to" => Ok(EventType::TeamMergeTo(TeamMergeToType::internal_deserialize(map)?)),
                    "team_profile_add_logo" => Ok(EventType::TeamProfileAddLogo(TeamProfileAddLogoType::internal_deserialize(map)?)),
                    "team_profile_change_default_language" => Ok(EventType::TeamProfileChangeDefaultLanguage(TeamProfileChangeDefaultLanguageType::internal_deserialize(map)?)),
                    "team_profile_change_logo" => Ok(EventType::TeamProfileChangeLogo(TeamProfileChangeLogoType::internal_deserialize(map)?)),
                    "team_profile_change_name" => Ok(EventType::TeamProfileChangeName(TeamProfileChangeNameType::internal_deserialize(map)?)),
                    "team_profile_remove_logo" => Ok(EventType::TeamProfileRemoveLogo(TeamProfileRemoveLogoType::internal_deserialize(map)?)),
                    "tfa_add_backup_phone" => Ok(EventType::TfaAddBackupPhone(TfaAddBackupPhoneType::internal_deserialize(map)?)),
                    "tfa_add_security_key" => Ok(EventType::TfaAddSecurityKey(TfaAddSecurityKeyType::internal_deserialize(map)?)),
                    "tfa_change_backup_phone" => Ok(EventType::TfaChangeBackupPhone(TfaChangeBackupPhoneType::internal_deserialize(map)?)),
                    "tfa_change_status" => Ok(EventType::TfaChangeStatus(TfaChangeStatusType::internal_deserialize(map)?)),
                    "tfa_remove_backup_phone" => Ok(EventType::TfaRemoveBackupPhone(TfaRemoveBackupPhoneType::internal_deserialize(map)?)),
                    "tfa_remove_security_key" => Ok(EventType::TfaRemoveSecurityKey(TfaRemoveSecurityKeyType::internal_deserialize(map)?)),
                    "tfa_reset" => Ok(EventType::TfaReset(TfaResetType::internal_deserialize(map)?)),
                    "changed_enterprise_admin_role" => Ok(EventType::ChangedEnterpriseAdminRole(ChangedEnterpriseAdminRoleType::internal_deserialize(map)?)),
                    "changed_enterprise_connected_team_status" => Ok(EventType::ChangedEnterpriseConnectedTeamStatus(ChangedEnterpriseConnectedTeamStatusType::internal_deserialize(map)?)),
                    "ended_enterprise_admin_session" => Ok(EventType::EndedEnterpriseAdminSession(EndedEnterpriseAdminSessionType::internal_deserialize(map)?)),
                    "ended_enterprise_admin_session_deprecated" => Ok(EventType::EndedEnterpriseAdminSessionDeprecated(EndedEnterpriseAdminSessionDeprecatedType::internal_deserialize(map)?)),
                    "enterprise_settings_locking" => Ok(EventType::EnterpriseSettingsLocking(EnterpriseSettingsLockingType::internal_deserialize(map)?)),
                    "guest_admin_change_status" => Ok(EventType::GuestAdminChangeStatus(GuestAdminChangeStatusType::internal_deserialize(map)?)),
                    "started_enterprise_admin_session" => Ok(EventType::StartedEnterpriseAdminSession(StartedEnterpriseAdminSessionType::internal_deserialize(map)?)),
                    "team_merge_request_accepted" => Ok(EventType::TeamMergeRequestAccepted(TeamMergeRequestAcceptedType::internal_deserialize(map)?)),
                    "team_merge_request_accepted_shown_to_primary_team" => Ok(EventType::TeamMergeRequestAcceptedShownToPrimaryTeam(TeamMergeRequestAcceptedShownToPrimaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_accepted_shown_to_secondary_team" => Ok(EventType::TeamMergeRequestAcceptedShownToSecondaryTeam(TeamMergeRequestAcceptedShownToSecondaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_auto_canceled" => Ok(EventType::TeamMergeRequestAutoCanceled(TeamMergeRequestAutoCanceledType::internal_deserialize(map)?)),
                    "team_merge_request_canceled" => Ok(EventType::TeamMergeRequestCanceled(TeamMergeRequestCanceledType::internal_deserialize(map)?)),
                    "team_merge_request_canceled_shown_to_primary_team" => Ok(EventType::TeamMergeRequestCanceledShownToPrimaryTeam(TeamMergeRequestCanceledShownToPrimaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_canceled_shown_to_secondary_team" => Ok(EventType::TeamMergeRequestCanceledShownToSecondaryTeam(TeamMergeRequestCanceledShownToSecondaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_expired" => Ok(EventType::TeamMergeRequestExpired(TeamMergeRequestExpiredType::internal_deserialize(map)?)),
                    "team_merge_request_expired_shown_to_primary_team" => Ok(EventType::TeamMergeRequestExpiredShownToPrimaryTeam(TeamMergeRequestExpiredShownToPrimaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_expired_shown_to_secondary_team" => Ok(EventType::TeamMergeRequestExpiredShownToSecondaryTeam(TeamMergeRequestExpiredShownToSecondaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_rejected_shown_to_primary_team" => Ok(EventType::TeamMergeRequestRejectedShownToPrimaryTeam(TeamMergeRequestRejectedShownToPrimaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_rejected_shown_to_secondary_team" => Ok(EventType::TeamMergeRequestRejectedShownToSecondaryTeam(TeamMergeRequestRejectedShownToSecondaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_reminder" => Ok(EventType::TeamMergeRequestReminder(TeamMergeRequestReminderType::internal_deserialize(map)?)),
                    "team_merge_request_reminder_shown_to_primary_team" => Ok(EventType::TeamMergeRequestReminderShownToPrimaryTeam(TeamMergeRequestReminderShownToPrimaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_reminder_shown_to_secondary_team" => Ok(EventType::TeamMergeRequestReminderShownToSecondaryTeam(TeamMergeRequestReminderShownToSecondaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_revoked" => Ok(EventType::TeamMergeRequestRevoked(TeamMergeRequestRevokedType::internal_deserialize(map)?)),
                    "team_merge_request_sent_shown_to_primary_team" => Ok(EventType::TeamMergeRequestSentShownToPrimaryTeam(TeamMergeRequestSentShownToPrimaryTeamType::internal_deserialize(map)?)),
                    "team_merge_request_sent_shown_to_secondary_team" => Ok(EventType::TeamMergeRequestSentShownToSecondaryTeam(TeamMergeRequestSentShownToSecondaryTeamType::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(EventType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["app_link_team",
                                    "app_link_user",
                                    "app_unlink_team",
                                    "app_unlink_user",
                                    "integration_connected",
                                    "integration_disconnected",
                                    "file_add_comment",
                                    "file_change_comment_subscription",
                                    "file_delete_comment",
                                    "file_edit_comment",
                                    "file_like_comment",
                                    "file_resolve_comment",
                                    "file_unlike_comment",
                                    "file_unresolve_comment",
                                    "device_change_ip_desktop",
                                    "device_change_ip_mobile",
                                    "device_change_ip_web",
                                    "device_delete_on_unlink_fail",
                                    "device_delete_on_unlink_success",
                                    "device_link_fail",
                                    "device_link_success",
                                    "device_management_disabled",
                                    "device_management_enabled",
                                    "device_unlink",
                                    "emm_refresh_auth_token",
                                    "account_capture_change_availability",
                                    "account_capture_migrate_account",
                                    "account_capture_notification_emails_sent",
                                    "account_capture_relinquish_account",
                                    "disabled_domain_invites",
                                    "domain_invites_approve_request_to_join_team",
                                    "domain_invites_decline_request_to_join_team",
                                    "domain_invites_email_existing_users",
                                    "domain_invites_request_to_join_team",
                                    "domain_invites_set_invite_new_user_pref_to_no",
                                    "domain_invites_set_invite_new_user_pref_to_yes",
                                    "domain_verification_add_domain_fail",
                                    "domain_verification_add_domain_success",
                                    "domain_verification_remove_domain",
                                    "enabled_domain_invites",
                                    "create_folder",
                                    "file_add",
                                    "file_copy",
                                    "file_delete",
                                    "file_download",
                                    "file_edit",
                                    "file_get_copy_reference",
                                    "file_locking_lock_status_changed",
                                    "file_move",
                                    "file_permanently_delete",
                                    "file_preview",
                                    "file_rename",
                                    "file_restore",
                                    "file_revert",
                                    "file_rollback_changes",
                                    "file_save_copy_reference",
                                    "folder_overview_description_changed",
                                    "folder_overview_item_pinned",
                                    "folder_overview_item_unpinned",
                                    "rewind_folder",
                                    "file_request_change",
                                    "file_request_close",
                                    "file_request_create",
                                    "file_request_delete",
                                    "file_request_receive_file",
                                    "group_add_external_id",
                                    "group_add_member",
                                    "group_change_external_id",
                                    "group_change_management_type",
                                    "group_change_member_role",
                                    "group_create",
                                    "group_delete",
                                    "group_description_updated",
                                    "group_join_policy_updated",
                                    "group_moved",
                                    "group_remove_external_id",
                                    "group_remove_member",
                                    "group_rename",
                                    "legal_holds_activate_a_hold",
                                    "legal_holds_add_members",
                                    "legal_holds_change_hold_details",
                                    "legal_holds_change_hold_name",
                                    "legal_holds_export_a_hold",
                                    "legal_holds_export_cancelled",
                                    "legal_holds_export_downloaded",
                                    "legal_holds_export_removed",
                                    "legal_holds_release_a_hold",
                                    "legal_holds_remove_members",
                                    "legal_holds_report_a_hold",
                                    "account_lock_or_unlocked",
                                    "emm_error",
                                    "guest_admin_signed_in_via_trusted_teams",
                                    "guest_admin_signed_out_via_trusted_teams",
                                    "login_fail",
                                    "login_success",
                                    "logout",
                                    "reseller_support_session_end",
                                    "reseller_support_session_start",
                                    "sign_in_as_session_end",
                                    "sign_in_as_session_start",
                                    "sso_error",
                                    "create_team_invite_link",
                                    "delete_team_invite_link",
                                    "member_add_external_id",
                                    "member_add_name",
                                    "member_change_admin_role",
                                    "member_change_email",
                                    "member_change_external_id",
                                    "member_change_membership_type",
                                    "member_change_name",
                                    "member_change_status",
                                    "member_delete_manual_contacts",
                                    "member_delete_profile_photo",
                                    "member_permanently_delete_account_contents",
                                    "member_remove_external_id",
                                    "member_set_profile_photo",
                                    "member_space_limits_add_custom_quota",
                                    "member_space_limits_change_custom_quota",
                                    "member_space_limits_change_status",
                                    "member_space_limits_remove_custom_quota",
                                    "member_suggest",
                                    "member_transfer_account_contents",
                                    "pending_secondary_email_added",
                                    "secondary_email_deleted",
                                    "secondary_email_verified",
                                    "secondary_mails_policy_changed",
                                    "binder_add_page",
                                    "binder_add_section",
                                    "binder_remove_page",
                                    "binder_remove_section",
                                    "binder_rename_page",
                                    "binder_rename_section",
                                    "binder_reorder_page",
                                    "binder_reorder_section",
                                    "paper_content_add_member",
                                    "paper_content_add_to_folder",
                                    "paper_content_archive",
                                    "paper_content_create",
                                    "paper_content_permanently_delete",
                                    "paper_content_remove_from_folder",
                                    "paper_content_remove_member",
                                    "paper_content_rename",
                                    "paper_content_restore",
                                    "paper_doc_add_comment",
                                    "paper_doc_change_member_role",
                                    "paper_doc_change_sharing_policy",
                                    "paper_doc_change_subscription",
                                    "paper_doc_deleted",
                                    "paper_doc_delete_comment",
                                    "paper_doc_download",
                                    "paper_doc_edit",
                                    "paper_doc_edit_comment",
                                    "paper_doc_followed",
                                    "paper_doc_mention",
                                    "paper_doc_ownership_changed",
                                    "paper_doc_request_access",
                                    "paper_doc_resolve_comment",
                                    "paper_doc_revert",
                                    "paper_doc_slack_share",
                                    "paper_doc_team_invite",
                                    "paper_doc_trashed",
                                    "paper_doc_unresolve_comment",
                                    "paper_doc_untrashed",
                                    "paper_doc_view",
                                    "paper_external_view_allow",
                                    "paper_external_view_default_team",
                                    "paper_external_view_forbid",
                                    "paper_folder_change_subscription",
                                    "paper_folder_deleted",
                                    "paper_folder_followed",
                                    "paper_folder_team_invite",
                                    "paper_published_link_change_permission",
                                    "paper_published_link_create",
                                    "paper_published_link_disabled",
                                    "paper_published_link_view",
                                    "password_change",
                                    "password_reset",
                                    "password_reset_all",
                                    "emm_create_exceptions_report",
                                    "emm_create_usage_report",
                                    "export_members_report",
                                    "export_members_report_fail",
                                    "no_expiration_link_gen_create_report",
                                    "no_expiration_link_gen_report_failed",
                                    "no_password_link_gen_create_report",
                                    "no_password_link_gen_report_failed",
                                    "no_password_link_view_create_report",
                                    "no_password_link_view_report_failed",
                                    "outdated_link_view_create_report",
                                    "outdated_link_view_report_failed",
                                    "paper_admin_export_start",
                                    "smart_sync_create_admin_privilege_report",
                                    "team_activity_create_report",
                                    "team_activity_create_report_fail",
                                    "collection_share",
                                    "file_transfers_file_add",
                                    "file_transfers_transfer_delete",
                                    "file_transfers_transfer_download",
                                    "file_transfers_transfer_send",
                                    "file_transfers_transfer_view",
                                    "note_acl_invite_only",
                                    "note_acl_link",
                                    "note_acl_team_link",
                                    "note_shared",
                                    "note_share_receive",
                                    "open_note_shared",
                                    "sf_add_group",
                                    "sf_allow_non_members_to_view_shared_links",
                                    "sf_external_invite_warn",
                                    "sf_fb_invite",
                                    "sf_fb_invite_change_role",
                                    "sf_fb_uninvite",
                                    "sf_invite_group",
                                    "sf_team_grant_access",
                                    "sf_team_invite",
                                    "sf_team_invite_change_role",
                                    "sf_team_join",
                                    "sf_team_join_from_oob_link",
                                    "sf_team_uninvite",
                                    "shared_content_add_invitees",
                                    "shared_content_add_link_expiry",
                                    "shared_content_add_link_password",
                                    "shared_content_add_member",
                                    "shared_content_change_downloads_policy",
                                    "shared_content_change_invitee_role",
                                    "shared_content_change_link_audience",
                                    "shared_content_change_link_expiry",
                                    "shared_content_change_link_password",
                                    "shared_content_change_member_role",
                                    "shared_content_change_viewer_info_policy",
                                    "shared_content_claim_invitation",
                                    "shared_content_copy",
                                    "shared_content_download",
                                    "shared_content_relinquish_membership",
                                    "shared_content_remove_invitees",
                                    "shared_content_remove_link_expiry",
                                    "shared_content_remove_link_password",
                                    "shared_content_remove_member",
                                    "shared_content_request_access",
                                    "shared_content_restore_invitees",
                                    "shared_content_restore_member",
                                    "shared_content_unshare",
                                    "shared_content_view",
                                    "shared_folder_change_link_policy",
                                    "shared_folder_change_members_inheritance_policy",
                                    "shared_folder_change_members_management_policy",
                                    "shared_folder_change_members_policy",
                                    "shared_folder_create",
                                    "shared_folder_decline_invitation",
                                    "shared_folder_mount",
                                    "shared_folder_nest",
                                    "shared_folder_transfer_ownership",
                                    "shared_folder_unmount",
                                    "shared_link_add_expiry",
                                    "shared_link_change_expiry",
                                    "shared_link_change_visibility",
                                    "shared_link_copy",
                                    "shared_link_create",
                                    "shared_link_disable",
                                    "shared_link_download",
                                    "shared_link_remove_expiry",
                                    "shared_link_settings_add_expiration",
                                    "shared_link_settings_add_password",
                                    "shared_link_settings_allow_download_disabled",
                                    "shared_link_settings_allow_download_enabled",
                                    "shared_link_settings_change_audience",
                                    "shared_link_settings_change_expiration",
                                    "shared_link_settings_change_password",
                                    "shared_link_settings_remove_expiration",
                                    "shared_link_settings_remove_password",
                                    "shared_link_share",
                                    "shared_link_view",
                                    "shared_note_opened",
                                    "shmodel_group_share",
                                    "showcase_access_granted",
                                    "showcase_add_member",
                                    "showcase_archived",
                                    "showcase_created",
                                    "showcase_delete_comment",
                                    "showcase_edited",
                                    "showcase_edit_comment",
                                    "showcase_file_added",
                                    "showcase_file_download",
                                    "showcase_file_removed",
                                    "showcase_file_view",
                                    "showcase_permanently_deleted",
                                    "showcase_post_comment",
                                    "showcase_remove_member",
                                    "showcase_renamed",
                                    "showcase_request_access",
                                    "showcase_resolve_comment",
                                    "showcase_restored",
                                    "showcase_trashed",
                                    "showcase_trashed_deprecated",
                                    "showcase_unresolve_comment",
                                    "showcase_untrashed",
                                    "showcase_untrashed_deprecated",
                                    "showcase_view",
                                    "sso_add_cert",
                                    "sso_add_login_url",
                                    "sso_add_logout_url",
                                    "sso_change_cert",
                                    "sso_change_login_url",
                                    "sso_change_logout_url",
                                    "sso_change_saml_identity_mode",
                                    "sso_remove_cert",
                                    "sso_remove_login_url",
                                    "sso_remove_logout_url",
                                    "team_folder_change_status",
                                    "team_folder_create",
                                    "team_folder_downgrade",
                                    "team_folder_permanently_delete",
                                    "team_folder_rename",
                                    "team_selective_sync_settings_changed",
                                    "account_capture_change_policy",
                                    "allow_download_disabled",
                                    "allow_download_enabled",
                                    "camera_uploads_policy_changed",
                                    "data_placement_restriction_change_policy",
                                    "data_placement_restriction_satisfy_policy",
                                    "device_approvals_add_exception",
                                    "device_approvals_change_desktop_policy",
                                    "device_approvals_change_mobile_policy",
                                    "device_approvals_change_overage_action",
                                    "device_approvals_change_unlink_action",
                                    "device_approvals_remove_exception",
                                    "directory_restrictions_add_members",
                                    "directory_restrictions_remove_members",
                                    "emm_add_exception",
                                    "emm_change_policy",
                                    "emm_remove_exception",
                                    "extended_version_history_change_policy",
                                    "file_comments_change_policy",
                                    "file_locking_policy_changed",
                                    "file_requests_change_policy",
                                    "file_requests_emails_enabled",
                                    "file_requests_emails_restricted_to_team_only",
                                    "file_transfers_policy_changed",
                                    "google_sso_change_policy",
                                    "group_user_management_change_policy",
                                    "integration_policy_changed",
                                    "member_requests_change_policy",
                                    "member_send_invite_policy_changed",
                                    "member_space_limits_add_exception",
                                    "member_space_limits_change_caps_type_policy",
                                    "member_space_limits_change_policy",
                                    "member_space_limits_remove_exception",
                                    "member_suggestions_change_policy",
                                    "microsoft_office_addin_change_policy",
                                    "network_control_change_policy",
                                    "paper_change_deployment_policy",
                                    "paper_change_member_link_policy",
                                    "paper_change_member_policy",
                                    "paper_change_policy",
                                    "paper_default_folder_policy_changed",
                                    "paper_desktop_policy_changed",
                                    "paper_enabled_users_group_addition",
                                    "paper_enabled_users_group_removal",
                                    "password_strength_requirements_change_policy",
                                    "permanent_delete_change_policy",
                                    "reseller_support_change_policy",
                                    "rewind_policy_changed",
                                    "sharing_change_folder_join_policy",
                                    "sharing_change_link_policy",
                                    "sharing_change_member_policy",
                                    "showcase_change_download_policy",
                                    "showcase_change_enabled_policy",
                                    "showcase_change_external_sharing_policy",
                                    "smarter_smart_sync_policy_changed",
                                    "smart_sync_change_policy",
                                    "smart_sync_not_opt_out",
                                    "smart_sync_opt_out",
                                    "sso_change_policy",
                                    "team_extensions_policy_changed",
                                    "team_selective_sync_policy_changed",
                                    "team_sharing_whitelist_subjects_changed",
                                    "tfa_add_exception",
                                    "tfa_change_policy",
                                    "tfa_remove_exception",
                                    "two_account_change_policy",
                                    "viewer_info_policy_changed",
                                    "watermarking_policy_changed",
                                    "web_sessions_change_active_session_limit",
                                    "web_sessions_change_fixed_length_policy",
                                    "web_sessions_change_idle_length_policy",
                                    "team_merge_from",
                                    "team_merge_to",
                                    "team_profile_add_logo",
                                    "team_profile_change_default_language",
                                    "team_profile_change_logo",
                                    "team_profile_change_name",
                                    "team_profile_remove_logo",
                                    "tfa_add_backup_phone",
                                    "tfa_add_security_key",
                                    "tfa_change_backup_phone",
                                    "tfa_change_status",
                                    "tfa_remove_backup_phone",
                                    "tfa_remove_security_key",
                                    "tfa_reset",
                                    "changed_enterprise_admin_role",
                                    "changed_enterprise_connected_team_status",
                                    "ended_enterprise_admin_session",
                                    "ended_enterprise_admin_session_deprecated",
                                    "enterprise_settings_locking",
                                    "guest_admin_change_status",
                                    "started_enterprise_admin_session",
                                    "team_merge_request_accepted",
                                    "team_merge_request_accepted_shown_to_primary_team",
                                    "team_merge_request_accepted_shown_to_secondary_team",
                                    "team_merge_request_auto_canceled",
                                    "team_merge_request_canceled",
                                    "team_merge_request_canceled_shown_to_primary_team",
                                    "team_merge_request_canceled_shown_to_secondary_team",
                                    "team_merge_request_expired",
                                    "team_merge_request_expired_shown_to_primary_team",
                                    "team_merge_request_expired_shown_to_secondary_team",
                                    "team_merge_request_rejected_shown_to_primary_team",
                                    "team_merge_request_rejected_shown_to_secondary_team",
                                    "team_merge_request_reminder",
                                    "team_merge_request_reminder_shown_to_primary_team",
                                    "team_merge_request_reminder_shown_to_secondary_team",
                                    "team_merge_request_revoked",
                                    "team_merge_request_sent_shown_to_primary_team",
                                    "team_merge_request_sent_shown_to_secondary_team",
                                    "other"];
        deserializer.deserialize_struct("EventType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EventType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EventType::AppLinkTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "app_link_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AppLinkUser(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "app_link_user")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AppUnlinkTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "app_unlink_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AppUnlinkUser(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "app_unlink_user")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::IntegrationConnected(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "integration_connected")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::IntegrationDisconnected(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "integration_disconnected")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileAddComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_add_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileChangeCommentSubscription(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_change_comment_subscription")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileDeleteComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_delete_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileEditComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_edit_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileLikeComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_like_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileResolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_resolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileUnlikeComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_unlike_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileUnresolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_unresolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceChangeIpDesktop(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_change_ip_desktop")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceChangeIpMobile(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_change_ip_mobile")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceChangeIpWeb(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_change_ip_web")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceDeleteOnUnlinkFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_delete_on_unlink_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceDeleteOnUnlinkSuccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_delete_on_unlink_success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceLinkFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_link_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceLinkSuccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_link_success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceManagementDisabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_management_disabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceManagementEnabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_management_enabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceUnlink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_unlink")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmRefreshAuthToken(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_refresh_auth_token")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureChangeAvailability(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_change_availability")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureMigrateAccount(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_migrate_account")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureNotificationEmailsSent(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_notification_emails_sent")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureRelinquishAccount(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_relinquish_account")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DisabledDomainInvites(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "disabled_domain_invites")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesApproveRequestToJoinTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_approve_request_to_join_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesDeclineRequestToJoinTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_decline_request_to_join_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesEmailExistingUsers(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_email_existing_users")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesRequestToJoinTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_request_to_join_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesSetInviteNewUserPrefToNo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_no")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainInvitesSetInviteNewUserPrefToYes(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_invites_set_invite_new_user_pref_to_yes")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainVerificationAddDomainFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_verification_add_domain_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainVerificationAddDomainSuccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_verification_add_domain_success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DomainVerificationRemoveDomain(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "domain_verification_remove_domain")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EnabledDomainInvites(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "enabled_domain_invites")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::CreateFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "create_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileAdd(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_add")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileCopy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_copy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileEdit(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_edit")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileGetCopyReference(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_get_copy_reference")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileLockingLockStatusChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_locking_lock_status_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileMove(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_move")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FilePermanentlyDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_permanently_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FilePreview(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_preview")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRename(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_rename")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRestore(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_restore")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRevert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_revert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRollbackChanges(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_rollback_changes")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileSaveCopyReference(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_save_copy_reference")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FolderOverviewDescriptionChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "folder_overview_description_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FolderOverviewItemPinned(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "folder_overview_item_pinned")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FolderOverviewItemUnpinned(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "folder_overview_item_unpinned")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::RewindFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "rewind_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestChange(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_request_change")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestClose(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_request_close")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_request_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_request_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestReceiveFile(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_request_receive_file")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupAddExternalId(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_add_external_id")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupAddMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_add_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupChangeExternalId(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_change_external_id")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupChangeManagementType(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_change_management_type")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupChangeMemberRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_change_member_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupDescriptionUpdated(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_description_updated")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupJoinPolicyUpdated(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_join_policy_updated")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupMoved(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_moved")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupRemoveExternalId(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_remove_external_id")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupRemoveMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_remove_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupRename(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_rename")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsActivateAHold(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_activate_a_hold")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsAddMembers(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_add_members")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsChangeHoldDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_change_hold_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsChangeHoldName(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_change_hold_name")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsExportAHold(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_export_a_hold")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsExportCancelled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_export_cancelled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsExportDownloaded(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_export_downloaded")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsExportRemoved(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_export_removed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsReleaseAHold(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_release_a_hold")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsRemoveMembers(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_remove_members")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LegalHoldsReportAHold(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "legal_holds_report_a_hold")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountLockOrUnlocked(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_lock_or_unlocked")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmError(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_error")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GuestAdminSignedInViaTrustedTeams(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "guest_admin_signed_in_via_trusted_teams")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GuestAdminSignedOutViaTrustedTeams(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "guest_admin_signed_out_via_trusted_teams")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LoginFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "login_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::LoginSuccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "login_success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::Logout(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "logout")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ResellerSupportSessionEnd(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "reseller_support_session_end")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ResellerSupportSessionStart(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "reseller_support_session_start")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SignInAsSessionEnd(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sign_in_as_session_end")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SignInAsSessionStart(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sign_in_as_session_start")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoError(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_error")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::CreateTeamInviteLink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "create_team_invite_link")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeleteTeamInviteLink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "delete_team_invite_link")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberAddExternalId(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_add_external_id")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberAddName(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_add_name")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeAdminRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_admin_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeEmail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_email")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeExternalId(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_external_id")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeMembershipType(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_membership_type")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeName(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_name")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberChangeStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_change_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberDeleteManualContacts(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_delete_manual_contacts")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberDeleteProfilePhoto(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_delete_profile_photo")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberPermanentlyDeleteAccountContents(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_permanently_delete_account_contents")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberRemoveExternalId(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_remove_external_id")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSetProfilePhoto(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_set_profile_photo")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsAddCustomQuota(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_add_custom_quota")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangeCustomQuota(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_change_custom_quota")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangeStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_change_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsRemoveCustomQuota(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_remove_custom_quota")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSuggest(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_suggest")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberTransferAccountContents(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_transfer_account_contents")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PendingSecondaryEmailAdded(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "pending_secondary_email_added")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SecondaryEmailDeleted(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "secondary_email_deleted")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SecondaryEmailVerified(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "secondary_email_verified")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SecondaryMailsPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "secondary_mails_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::BinderAddPage(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "binder_add_page")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::BinderAddSection(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "binder_add_section")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::BinderRemovePage(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "binder_remove_page")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::BinderRemoveSection(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "binder_remove_section")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::BinderRenamePage(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "binder_rename_page")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::BinderRenameSection(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "binder_rename_section")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::BinderReorderPage(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "binder_reorder_page")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::BinderReorderSection(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "binder_reorder_section")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentAddMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_add_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentAddToFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_add_to_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentArchive(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_archive")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentPermanentlyDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_permanently_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentRemoveFromFolder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_remove_from_folder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentRemoveMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_remove_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentRename(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_rename")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperContentRestore(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_content_restore")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocAddComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_add_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocChangeMemberRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_change_member_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocChangeSharingPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_change_sharing_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocChangeSubscription(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_change_subscription")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocDeleted(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_deleted")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocDeleteComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_delete_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocEdit(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_edit")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocEditComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_edit_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocFollowed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_followed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocMention(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_mention")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocOwnershipChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_ownership_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocRequestAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_request_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocResolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_resolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocRevert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_revert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocSlackShare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_slack_share")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocTeamInvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_team_invite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocTrashed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_trashed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocUnresolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_unresolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocUntrashed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_untrashed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDocView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_doc_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperExternalViewAllow(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_external_view_allow")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperExternalViewDefaultTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_external_view_default_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperExternalViewForbid(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_external_view_forbid")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperFolderChangeSubscription(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_folder_change_subscription")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperFolderDeleted(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_folder_deleted")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperFolderFollowed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_folder_followed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperFolderTeamInvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_folder_team_invite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperPublishedLinkChangePermission(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_published_link_change_permission")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperPublishedLinkCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_published_link_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperPublishedLinkDisabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_published_link_disabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperPublishedLinkView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_published_link_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PasswordChange(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "password_change")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PasswordReset(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "password_reset")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PasswordResetAll(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "password_reset_all")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmCreateExceptionsReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_create_exceptions_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmCreateUsageReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_create_usage_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ExportMembersReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "export_members_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ExportMembersReportFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "export_members_report_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoExpirationLinkGenCreateReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "no_expiration_link_gen_create_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoExpirationLinkGenReportFailed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "no_expiration_link_gen_report_failed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoPasswordLinkGenCreateReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "no_password_link_gen_create_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoPasswordLinkGenReportFailed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "no_password_link_gen_report_failed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoPasswordLinkViewCreateReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "no_password_link_view_create_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoPasswordLinkViewReportFailed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "no_password_link_view_report_failed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::OutdatedLinkViewCreateReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "outdated_link_view_create_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::OutdatedLinkViewReportFailed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "outdated_link_view_report_failed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperAdminExportStart(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_admin_export_start")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SmartSyncCreateAdminPrivilegeReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "smart_sync_create_admin_privilege_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamActivityCreateReport(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_activity_create_report")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamActivityCreateReportFail(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_activity_create_report_fail")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::CollectionShare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "collection_share")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileTransfersFileAdd(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_transfers_file_add")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileTransfersTransferDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_transfers_transfer_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileTransfersTransferDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_transfers_transfer_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileTransfersTransferSend(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_transfers_transfer_send")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileTransfersTransferView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_transfers_transfer_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteAclInviteOnly(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_acl_invite_only")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteAclLink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_acl_link")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteAclTeamLink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_acl_team_link")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteShared(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_shared")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NoteShareReceive(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "note_share_receive")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::OpenNoteShared(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "open_note_shared")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfAddGroup(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_add_group")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfAllowNonMembersToViewSharedLinks(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_allow_non_members_to_view_shared_links")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfExternalInviteWarn(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_external_invite_warn")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfFbInvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_fb_invite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfFbInviteChangeRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_fb_invite_change_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfFbUninvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_fb_uninvite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfInviteGroup(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_invite_group")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamGrantAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_grant_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamInvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_invite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamInviteChangeRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_invite_change_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamJoin(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_join")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamJoinFromOobLink(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_join_from_oob_link")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SfTeamUninvite(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sf_team_uninvite")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentAddInvitees(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_add_invitees")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentAddLinkExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_add_link_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentAddLinkPassword(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_add_link_password")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentAddMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_add_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeDownloadsPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_downloads_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeInviteeRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_invitee_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeLinkAudience(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_link_audience")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeLinkExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_link_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeLinkPassword(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_link_password")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeMemberRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_member_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentChangeViewerInfoPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_change_viewer_info_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentClaimInvitation(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_claim_invitation")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentCopy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_copy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRelinquishMembership(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_relinquish_membership")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRemoveInvitees(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_remove_invitees")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRemoveLinkExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_remove_link_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRemoveLinkPassword(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_remove_link_password")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRemoveMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_remove_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRequestAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_request_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRestoreInvitees(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_restore_invitees")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentRestoreMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_restore_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentUnshare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_unshare")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedContentView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_content_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderChangeLinkPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_change_link_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderChangeMembersInheritancePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_change_members_inheritance_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderChangeMembersManagementPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_change_members_management_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderChangeMembersPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_change_members_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderDeclineInvitation(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_decline_invitation")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderMount(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_mount")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderNest(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_nest")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderTransferOwnership(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_transfer_ownership")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedFolderUnmount(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_folder_unmount")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkAddExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_add_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkChangeExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_change_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkChangeVisibility(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_change_visibility")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkCopy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_copy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkDisable(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_disable")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkRemoveExpiry(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_remove_expiry")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkSettingsAddExpiration(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_settings_add_expiration")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkSettingsAddPassword(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_settings_add_password")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkSettingsAllowDownloadDisabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_settings_allow_download_disabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkSettingsAllowDownloadEnabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_settings_allow_download_enabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkSettingsChangeAudience(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_settings_change_audience")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkSettingsChangeExpiration(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_settings_change_expiration")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkSettingsChangePassword(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_settings_change_password")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkSettingsRemoveExpiration(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_settings_remove_expiration")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkSettingsRemovePassword(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_settings_remove_password")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkShare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_share")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedLinkView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_link_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharedNoteOpened(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shared_note_opened")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShmodelGroupShare(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "shmodel_group_share")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseAccessGranted(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_access_granted")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseAddMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_add_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseArchived(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_archived")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseCreated(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_created")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseDeleteComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_delete_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseEdited(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_edited")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseEditComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_edit_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseFileAdded(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_file_added")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseFileDownload(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_file_download")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseFileRemoved(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_file_removed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseFileView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_file_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcasePermanentlyDeleted(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_permanently_deleted")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcasePostComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_post_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseRemoveMember(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_remove_member")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseRenamed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_renamed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseRequestAccess(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_request_access")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseResolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_resolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseRestored(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_restored")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseTrashed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_trashed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseTrashedDeprecated(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_trashed_deprecated")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseUnresolveComment(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_unresolve_comment")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseUntrashed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_untrashed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseUntrashedDeprecated(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_untrashed_deprecated")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseView(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_view")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoAddCert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_add_cert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoAddLoginUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_add_login_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoAddLogoutUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_add_logout_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangeCert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_cert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangeLoginUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_login_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangeLogoutUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_logout_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangeSamlIdentityMode(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_saml_identity_mode")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoRemoveCert(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_remove_cert")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoRemoveLoginUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_remove_login_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoRemoveLogoutUrl(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_remove_logout_url")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderChangeStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_change_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderCreate(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_create")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderDowngrade(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_downgrade")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderPermanentlyDelete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_permanently_delete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamFolderRename(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_folder_rename")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamSelectiveSyncSettingsChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_selective_sync_settings_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AccountCaptureChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "account_capture_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AllowDownloadDisabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "allow_download_disabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::AllowDownloadEnabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "allow_download_enabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::CameraUploadsPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "camera_uploads_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DataPlacementRestrictionChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "data_placement_restriction_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DataPlacementRestrictionSatisfyPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "data_placement_restriction_satisfy_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsAddException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_add_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsChangeDesktopPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_change_desktop_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsChangeMobilePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_change_mobile_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsChangeOverageAction(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_change_overage_action")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsChangeUnlinkAction(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_change_unlink_action")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DeviceApprovalsRemoveException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "device_approvals_remove_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DirectoryRestrictionsAddMembers(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "directory_restrictions_add_members")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::DirectoryRestrictionsRemoveMembers(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "directory_restrictions_remove_members")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmAddException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_add_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EmmRemoveException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "emm_remove_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ExtendedVersionHistoryChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "extended_version_history_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileCommentsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_comments_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileLockingPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_locking_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_requests_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestsEmailsEnabled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_requests_emails_enabled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileRequestsEmailsRestrictedToTeamOnly(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_requests_emails_restricted_to_team_only")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::FileTransfersPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "file_transfers_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GoogleSsoChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "google_sso_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GroupUserManagementChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "group_user_management_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::IntegrationPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "integration_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberRequestsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_requests_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSendInvitePolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_send_invite_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsAddException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_add_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangeCapsTypePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_change_caps_type_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSpaceLimitsRemoveException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_space_limits_remove_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MemberSuggestionsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "member_suggestions_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::MicrosoftOfficeAddinChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "microsoft_office_addin_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::NetworkControlChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "network_control_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperChangeDeploymentPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_change_deployment_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperChangeMemberLinkPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_change_member_link_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperChangeMemberPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_change_member_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDefaultFolderPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_default_folder_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperDesktopPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_desktop_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperEnabledUsersGroupAddition(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_enabled_users_group_addition")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PaperEnabledUsersGroupRemoval(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "paper_enabled_users_group_removal")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PasswordStrengthRequirementsChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "password_strength_requirements_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::PermanentDeleteChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "permanent_delete_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ResellerSupportChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "reseller_support_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::RewindPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "rewind_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharingChangeFolderJoinPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sharing_change_folder_join_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharingChangeLinkPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sharing_change_link_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SharingChangeMemberPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sharing_change_member_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseChangeDownloadPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_change_download_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseChangeEnabledPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_change_enabled_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ShowcaseChangeExternalSharingPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "showcase_change_external_sharing_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SmarterSmartSyncPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "smarter_smart_sync_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SmartSyncChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "smart_sync_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SmartSyncNotOptOut(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "smart_sync_not_opt_out")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SmartSyncOptOut(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "smart_sync_opt_out")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::SsoChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "sso_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamExtensionsPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_extensions_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamSelectiveSyncPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_selective_sync_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamSharingWhitelistSubjectsChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_sharing_whitelist_subjects_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaAddException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_add_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaRemoveException(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_remove_exception")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TwoAccountChangePolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "two_account_change_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ViewerInfoPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "viewer_info_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::WatermarkingPolicyChanged(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "watermarking_policy_changed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::WebSessionsChangeActiveSessionLimit(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "web_sessions_change_active_session_limit")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::WebSessionsChangeFixedLengthPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "web_sessions_change_fixed_length_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::WebSessionsChangeIdleLengthPolicy(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "web_sessions_change_idle_length_policy")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeFrom(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_from")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeTo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_to")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileAddLogo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_add_logo")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileChangeDefaultLanguage(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_change_default_language")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileChangeLogo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_change_logo")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileChangeName(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_change_name")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamProfileRemoveLogo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_profile_remove_logo")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaAddBackupPhone(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_add_backup_phone")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaAddSecurityKey(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_add_security_key")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaChangeBackupPhone(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_change_backup_phone")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaChangeStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_change_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaRemoveBackupPhone(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_remove_backup_phone")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaRemoveSecurityKey(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_remove_security_key")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TfaReset(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "tfa_reset")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ChangedEnterpriseAdminRole(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "changed_enterprise_admin_role")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::ChangedEnterpriseConnectedTeamStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "changed_enterprise_connected_team_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EndedEnterpriseAdminSession(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "ended_enterprise_admin_session")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EndedEnterpriseAdminSessionDeprecated(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "ended_enterprise_admin_session_deprecated")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::EnterpriseSettingsLocking(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "enterprise_settings_locking")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::GuestAdminChangeStatus(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "guest_admin_change_status")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::StartedEnterpriseAdminSession(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "started_enterprise_admin_session")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestAccepted(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_accepted")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestAcceptedShownToPrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_accepted_shown_to_primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestAcceptedShownToSecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_accepted_shown_to_secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestAutoCanceled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_auto_canceled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestCanceled(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_canceled")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestCanceledShownToPrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_canceled_shown_to_primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestCanceledShownToSecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_canceled_shown_to_secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestExpired(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_expired")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestExpiredShownToPrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_expired_shown_to_primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestExpiredShownToSecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_expired_shown_to_secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestRejectedShownToPrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_rejected_shown_to_primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestRejectedShownToSecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_rejected_shown_to_secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestReminder(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_reminder")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestReminderShownToPrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_reminder_shown_to_primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestReminderShownToSecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_reminder_shown_to_secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestRevoked(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_revoked")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestSentShownToPrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_sent_shown_to_primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::TeamMergeRequestSentShownToSecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("EventType", 2)?;
                s.serialize_field(".tag", "team_merge_request_sent_shown_to_secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            EventType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Created member data report.
#[derive(Debug)]
pub struct ExportMembersReportDetails {
}

impl Default for ExportMembersReportDetails {
    fn default() -> Self {
        ExportMembersReportDetails {
        }
    }
}

const EXPORT_MEMBERS_REPORT_DETAILS_FIELDS: &[&str] = &[];
impl ExportMembersReportDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ExportMembersReportDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(ExportMembersReportDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExportMembersReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExportMembersReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ExportMembersReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExportMembersReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExportMembersReportDetails", EXPORT_MEMBERS_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExportMembersReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ExportMembersReportDetails", 0)?.end()
    }
}

/// Failed to create members data report.
#[derive(Debug)]
pub struct ExportMembersReportFailDetails {
    /// Failure reason.
    pub failure_reason: super::team::TeamReportFailureReason,
}

impl ExportMembersReportFailDetails {
    pub fn new(failure_reason: super::team::TeamReportFailureReason) -> Self {
        ExportMembersReportFailDetails {
            failure_reason,
        }
    }

}

const EXPORT_MEMBERS_REPORT_FAIL_DETAILS_FIELDS: &[&str] = &["failure_reason"];
impl ExportMembersReportFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ExportMembersReportFailDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ExportMembersReportFailDetails>, V::Error> {
        let mut field_failure_reason = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "failure_reason" => {
                    if field_failure_reason.is_some() {
                        return Err(::serde::de::Error::duplicate_field("failure_reason"));
                    }
                    field_failure_reason = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ExportMembersReportFailDetails {
            failure_reason: field_failure_reason.ok_or_else(|| ::serde::de::Error::missing_field("failure_reason"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("failure_reason", &self.failure_reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExportMembersReportFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExportMembersReportFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ExportMembersReportFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExportMembersReportFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExportMembersReportFailDetails", EXPORT_MEMBERS_REPORT_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExportMembersReportFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExportMembersReportFailDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ExportMembersReportFailType {
    pub description: String,
}

impl ExportMembersReportFailType {
    pub fn new(description: String) -> Self {
        ExportMembersReportFailType {
            description,
        }
    }

}

const EXPORT_MEMBERS_REPORT_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl ExportMembersReportFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ExportMembersReportFailType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ExportMembersReportFailType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ExportMembersReportFailType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExportMembersReportFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExportMembersReportFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ExportMembersReportFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExportMembersReportFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExportMembersReportFailType", EXPORT_MEMBERS_REPORT_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExportMembersReportFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExportMembersReportFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ExportMembersReportType {
    pub description: String,
}

impl ExportMembersReportType {
    pub fn new(description: String) -> Self {
        ExportMembersReportType {
            description,
        }
    }

}

const EXPORT_MEMBERS_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl ExportMembersReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ExportMembersReportType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ExportMembersReportType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ExportMembersReportType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExportMembersReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExportMembersReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ExportMembersReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExportMembersReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExportMembersReportType", EXPORT_MEMBERS_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExportMembersReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExportMembersReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Accepted/opted out of extended version history.
#[derive(Debug)]
pub struct ExtendedVersionHistoryChangePolicyDetails {
    /// New extended version history policy.
    pub new_value: ExtendedVersionHistoryPolicy,
    /// Previous extended version history policy. Might be missing due to historical data gap.
    pub previous_value: Option<ExtendedVersionHistoryPolicy>,
}

impl ExtendedVersionHistoryChangePolicyDetails {
    pub fn new(new_value: ExtendedVersionHistoryPolicy) -> Self {
        ExtendedVersionHistoryChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<ExtendedVersionHistoryPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const EXTENDED_VERSION_HISTORY_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl ExtendedVersionHistoryChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ExtendedVersionHistoryChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ExtendedVersionHistoryChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ExtendedVersionHistoryChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExtendedVersionHistoryChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExtendedVersionHistoryChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ExtendedVersionHistoryChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExtendedVersionHistoryChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExtendedVersionHistoryChangePolicyDetails", EXTENDED_VERSION_HISTORY_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExtendedVersionHistoryChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExtendedVersionHistoryChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ExtendedVersionHistoryChangePolicyType {
    pub description: String,
}

impl ExtendedVersionHistoryChangePolicyType {
    pub fn new(description: String) -> Self {
        ExtendedVersionHistoryChangePolicyType {
            description,
        }
    }

}

const EXTENDED_VERSION_HISTORY_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl ExtendedVersionHistoryChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ExtendedVersionHistoryChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ExtendedVersionHistoryChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ExtendedVersionHistoryChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExtendedVersionHistoryChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExtendedVersionHistoryChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ExtendedVersionHistoryChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExtendedVersionHistoryChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExtendedVersionHistoryChangePolicyType", EXTENDED_VERSION_HISTORY_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExtendedVersionHistoryChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExtendedVersionHistoryChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ExtendedVersionHistoryPolicy {
    ExplicitlyLimited,
    ExplicitlyUnlimited,
    ImplicitlyLimited,
    ImplicitlyUnlimited,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ExtendedVersionHistoryPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ExtendedVersionHistoryPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ExtendedVersionHistoryPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "explicitly_limited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ExtendedVersionHistoryPolicy::ExplicitlyLimited)
                    }
                    "explicitly_unlimited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ExtendedVersionHistoryPolicy::ExplicitlyUnlimited)
                    }
                    "implicitly_limited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ExtendedVersionHistoryPolicy::ImplicitlyLimited)
                    }
                    "implicitly_unlimited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ExtendedVersionHistoryPolicy::ImplicitlyUnlimited)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ExtendedVersionHistoryPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["explicitly_limited",
                                    "explicitly_unlimited",
                                    "implicitly_limited",
                                    "implicitly_unlimited",
                                    "other"];
        deserializer.deserialize_struct("ExtendedVersionHistoryPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ExtendedVersionHistoryPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ExtendedVersionHistoryPolicy::ExplicitlyLimited => {
                // unit
                let mut s = serializer.serialize_struct("ExtendedVersionHistoryPolicy", 1)?;
                s.serialize_field(".tag", "explicitly_limited")?;
                s.end()
            }
            ExtendedVersionHistoryPolicy::ExplicitlyUnlimited => {
                // unit
                let mut s = serializer.serialize_struct("ExtendedVersionHistoryPolicy", 1)?;
                s.serialize_field(".tag", "explicitly_unlimited")?;
                s.end()
            }
            ExtendedVersionHistoryPolicy::ImplicitlyLimited => {
                // unit
                let mut s = serializer.serialize_struct("ExtendedVersionHistoryPolicy", 1)?;
                s.serialize_field(".tag", "implicitly_limited")?;
                s.end()
            }
            ExtendedVersionHistoryPolicy::ImplicitlyUnlimited => {
                // unit
                let mut s = serializer.serialize_struct("ExtendedVersionHistoryPolicy", 1)?;
                s.serialize_field(".tag", "implicitly_unlimited")?;
                s.end()
            }
            ExtendedVersionHistoryPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// A user without a Dropbox account.
#[derive(Debug)]
pub struct ExternalUserLogInfo {
    /// An external user identifier.
    pub user_identifier: String,
    /// Identifier type.
    pub identifier_type: IdentifierType,
}

impl ExternalUserLogInfo {
    pub fn new(user_identifier: String, identifier_type: IdentifierType) -> Self {
        ExternalUserLogInfo {
            user_identifier,
            identifier_type,
        }
    }

}

const EXTERNAL_USER_LOG_INFO_FIELDS: &[&str] = &["user_identifier",
                                                 "identifier_type"];
impl ExternalUserLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ExternalUserLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ExternalUserLogInfo>, V::Error> {
        let mut field_user_identifier = None;
        let mut field_identifier_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "user_identifier" => {
                    if field_user_identifier.is_some() {
                        return Err(::serde::de::Error::duplicate_field("user_identifier"));
                    }
                    field_user_identifier = Some(map.next_value()?);
                }
                "identifier_type" => {
                    if field_identifier_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("identifier_type"));
                    }
                    field_identifier_type = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ExternalUserLogInfo {
            user_identifier: field_user_identifier.ok_or_else(|| ::serde::de::Error::missing_field("user_identifier"))?,
            identifier_type: field_identifier_type.ok_or_else(|| ::serde::de::Error::missing_field("identifier_type"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_identifier", &self.user_identifier)?;
        s.serialize_field("identifier_type", &self.identifier_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExternalUserLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExternalUserLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ExternalUserLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExternalUserLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExternalUserLogInfo", EXTERNAL_USER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExternalUserLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExternalUserLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Provides details about a failure
#[derive(Debug)]
pub struct FailureDetailsLogInfo {
    /// A user friendly explanation of the error. Might be missing due to historical data gap.
    pub user_friendly_message: Option<String>,
    /// A technical explanation of the error. This is relevant for some errors.
    pub technical_error_message: Option<String>,
}

impl Default for FailureDetailsLogInfo {
    fn default() -> Self {
        FailureDetailsLogInfo {
            user_friendly_message: None,
            technical_error_message: None,
        }
    }
}

const FAILURE_DETAILS_LOG_INFO_FIELDS: &[&str] = &["user_friendly_message",
                                                   "technical_error_message"];
impl FailureDetailsLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FailureDetailsLogInfo, V::Error> {
        let mut field_user_friendly_message = None;
        let mut field_technical_error_message = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "user_friendly_message" => {
                    if field_user_friendly_message.is_some() {
                        return Err(::serde::de::Error::duplicate_field("user_friendly_message"));
                    }
                    field_user_friendly_message = Some(map.next_value()?);
                }
                "technical_error_message" => {
                    if field_technical_error_message.is_some() {
                        return Err(::serde::de::Error::duplicate_field("technical_error_message"));
                    }
                    field_technical_error_message = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FailureDetailsLogInfo {
            user_friendly_message: field_user_friendly_message,
            technical_error_message: field_technical_error_message,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_friendly_message", &self.user_friendly_message)?;
        s.serialize_field("technical_error_message", &self.technical_error_message)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FailureDetailsLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FailureDetailsLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FailureDetailsLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FailureDetailsLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FailureDetailsLogInfo", FAILURE_DETAILS_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FailureDetailsLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FailureDetailsLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum FedAdminRole {
    NotEnterpriseAdmin,
    EnterpriseAdmin,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FedAdminRole {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FedAdminRole;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FedAdminRole structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "not_enterprise_admin" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedAdminRole::NotEnterpriseAdmin)
                    }
                    "enterprise_admin" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedAdminRole::EnterpriseAdmin)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedAdminRole::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["not_enterprise_admin",
                                    "enterprise_admin",
                                    "other"];
        deserializer.deserialize_struct("FedAdminRole", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FedAdminRole {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FedAdminRole::NotEnterpriseAdmin => {
                // unit
                let mut s = serializer.serialize_struct("FedAdminRole", 1)?;
                s.serialize_field(".tag", "not_enterprise_admin")?;
                s.end()
            }
            FedAdminRole::EnterpriseAdmin => {
                // unit
                let mut s = serializer.serialize_struct("FedAdminRole", 1)?;
                s.serialize_field(".tag", "enterprise_admin")?;
                s.end()
            }
            FedAdminRole::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// More details about the organization or team.
#[derive(Debug)]
pub enum FedExtraDetails {
    /// More details about the team.
    Team(TeamDetails),
    /// More details about the organization.
    Organization(OrganizationDetails),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FedExtraDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FedExtraDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FedExtraDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team" => Ok(FedExtraDetails::Team(TeamDetails::internal_deserialize(map)?)),
                    "organization" => Ok(FedExtraDetails::Organization(OrganizationDetails::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedExtraDetails::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["team",
                                    "organization",
                                    "other"];
        deserializer.deserialize_struct("FedExtraDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FedExtraDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FedExtraDetails::Team(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("FedExtraDetails", 2)?;
                s.serialize_field(".tag", "team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            FedExtraDetails::Organization(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("FedExtraDetails", 2)?;
                s.serialize_field(".tag", "organization")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            FedExtraDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum FedHandshakeAction {
    Invited,
    AcceptedInvite,
    RejectedInvite,
    CanceledInvite,
    RemovedTeam,
    InviteExpired,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FedHandshakeAction {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FedHandshakeAction;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FedHandshakeAction structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedHandshakeAction::Invited)
                    }
                    "accepted_invite" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedHandshakeAction::AcceptedInvite)
                    }
                    "rejected_invite" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedHandshakeAction::RejectedInvite)
                    }
                    "canceled_invite" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedHandshakeAction::CanceledInvite)
                    }
                    "removed_team" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedHandshakeAction::RemovedTeam)
                    }
                    "invite_expired" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedHandshakeAction::InviteExpired)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FedHandshakeAction::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["invited",
                                    "accepted_invite",
                                    "rejected_invite",
                                    "canceled_invite",
                                    "removed_team",
                                    "invite_expired",
                                    "other"];
        deserializer.deserialize_struct("FedHandshakeAction", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FedHandshakeAction {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FedHandshakeAction::Invited => {
                // unit
                let mut s = serializer.serialize_struct("FedHandshakeAction", 1)?;
                s.serialize_field(".tag", "invited")?;
                s.end()
            }
            FedHandshakeAction::AcceptedInvite => {
                // unit
                let mut s = serializer.serialize_struct("FedHandshakeAction", 1)?;
                s.serialize_field(".tag", "accepted_invite")?;
                s.end()
            }
            FedHandshakeAction::RejectedInvite => {
                // unit
                let mut s = serializer.serialize_struct("FedHandshakeAction", 1)?;
                s.serialize_field(".tag", "rejected_invite")?;
                s.end()
            }
            FedHandshakeAction::CanceledInvite => {
                // unit
                let mut s = serializer.serialize_struct("FedHandshakeAction", 1)?;
                s.serialize_field(".tag", "canceled_invite")?;
                s.end()
            }
            FedHandshakeAction::RemovedTeam => {
                // unit
                let mut s = serializer.serialize_struct("FedHandshakeAction", 1)?;
                s.serialize_field(".tag", "removed_team")?;
                s.end()
            }
            FedHandshakeAction::InviteExpired => {
                // unit
                let mut s = serializer.serialize_struct("FedHandshakeAction", 1)?;
                s.serialize_field(".tag", "invite_expired")?;
                s.end()
            }
            FedHandshakeAction::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Additional information about the organization or connected team
#[derive(Debug)]
pub enum FederationStatusChangeAdditionalInfo {
    /// The name of the team.
    ConnectedTeamName(ConnectedTeamName),
    /// The email to which the request was sent.
    NonTrustedTeamDetails(NonTrustedTeamDetails),
    /// The name of the organization.
    OrganizationName(OrganizationName),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FederationStatusChangeAdditionalInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FederationStatusChangeAdditionalInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FederationStatusChangeAdditionalInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "connected_team_name" => Ok(FederationStatusChangeAdditionalInfo::ConnectedTeamName(ConnectedTeamName::internal_deserialize(map)?)),
                    "non_trusted_team_details" => Ok(FederationStatusChangeAdditionalInfo::NonTrustedTeamDetails(NonTrustedTeamDetails::internal_deserialize(map)?)),
                    "organization_name" => Ok(FederationStatusChangeAdditionalInfo::OrganizationName(OrganizationName::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FederationStatusChangeAdditionalInfo::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["connected_team_name",
                                    "non_trusted_team_details",
                                    "organization_name",
                                    "other"];
        deserializer.deserialize_struct("FederationStatusChangeAdditionalInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FederationStatusChangeAdditionalInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FederationStatusChangeAdditionalInfo::ConnectedTeamName(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("FederationStatusChangeAdditionalInfo", 2)?;
                s.serialize_field(".tag", "connected_team_name")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            FederationStatusChangeAdditionalInfo::NonTrustedTeamDetails(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("FederationStatusChangeAdditionalInfo", 2)?;
                s.serialize_field(".tag", "non_trusted_team_details")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            FederationStatusChangeAdditionalInfo::OrganizationName(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("FederationStatusChangeAdditionalInfo", 2)?;
                s.serialize_field(".tag", "organization_name")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            FederationStatusChangeAdditionalInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added file comment.
#[derive(Debug)]
pub struct FileAddCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileAddCommentDetails {
    fn default() -> Self {
        FileAddCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_ADD_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileAddCommentDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileAddCommentDetails, V::Error> {
        let mut field_comment_text = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileAddCommentDetails {
            comment_text: field_comment_text,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileAddCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddCommentDetails", FILE_ADD_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileAddCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileAddCommentType {
    pub description: String,
}

impl FileAddCommentType {
    pub fn new(description: String) -> Self {
        FileAddCommentType {
            description,
        }
    }

}

const FILE_ADD_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileAddCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileAddCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileAddCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileAddCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileAddCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddCommentType", FILE_ADD_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileAddCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added files and/or folders.
#[derive(Debug)]
pub struct FileAddDetails {
}

impl Default for FileAddDetails {
    fn default() -> Self {
        FileAddDetails {
        }
    }
}

const FILE_ADD_DETAILS_FIELDS: &[&str] = &[];
impl FileAddDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileAddDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileAddDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileAddDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddDetails", FILE_ADD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileAddDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileAddType {
    pub description: String,
}

impl FileAddType {
    pub fn new(description: String) -> Self {
        FileAddType {
            description,
        }
    }

}

const FILE_ADD_TYPE_FIELDS: &[&str] = &["description"];
impl FileAddType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileAddType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileAddType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileAddType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileAddType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileAddType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileAddType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileAddType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileAddType", FILE_ADD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileAddType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileAddType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Subscribed to or unsubscribed from comment notifications for file.
#[derive(Debug)]
pub struct FileChangeCommentSubscriptionDetails {
    /// New file comment subscription.
    pub new_value: FileCommentNotificationPolicy,
    /// Previous file comment subscription. Might be missing due to historical data gap.
    pub previous_value: Option<FileCommentNotificationPolicy>,
}

impl FileChangeCommentSubscriptionDetails {
    pub fn new(new_value: FileCommentNotificationPolicy) -> Self {
        FileChangeCommentSubscriptionDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<FileCommentNotificationPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const FILE_CHANGE_COMMENT_SUBSCRIPTION_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                   "previous_value"];
impl FileChangeCommentSubscriptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileChangeCommentSubscriptionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileChangeCommentSubscriptionDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileChangeCommentSubscriptionDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileChangeCommentSubscriptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileChangeCommentSubscriptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileChangeCommentSubscriptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileChangeCommentSubscriptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileChangeCommentSubscriptionDetails", FILE_CHANGE_COMMENT_SUBSCRIPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileChangeCommentSubscriptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileChangeCommentSubscriptionDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileChangeCommentSubscriptionType {
    pub description: String,
}

impl FileChangeCommentSubscriptionType {
    pub fn new(description: String) -> Self {
        FileChangeCommentSubscriptionType {
            description,
        }
    }

}

const FILE_CHANGE_COMMENT_SUBSCRIPTION_TYPE_FIELDS: &[&str] = &["description"];
impl FileChangeCommentSubscriptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileChangeCommentSubscriptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileChangeCommentSubscriptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileChangeCommentSubscriptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileChangeCommentSubscriptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileChangeCommentSubscriptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileChangeCommentSubscriptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileChangeCommentSubscriptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileChangeCommentSubscriptionType", FILE_CHANGE_COMMENT_SUBSCRIPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileChangeCommentSubscriptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileChangeCommentSubscriptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enable or disable file comments notifications
#[derive(Debug)]
pub enum FileCommentNotificationPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentNotificationPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileCommentNotificationPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileCommentNotificationPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileCommentNotificationPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileCommentNotificationPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileCommentNotificationPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("FileCommentNotificationPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentNotificationPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileCommentNotificationPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentNotificationPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            FileCommentNotificationPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentNotificationPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            FileCommentNotificationPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Enabled/disabled commenting on team files.
#[derive(Debug)]
pub struct FileCommentsChangePolicyDetails {
    /// New commenting on team files policy.
    pub new_value: FileCommentsPolicy,
    /// Previous commenting on team files policy. Might be missing due to historical data gap.
    pub previous_value: Option<FileCommentsPolicy>,
}

impl FileCommentsChangePolicyDetails {
    pub fn new(new_value: FileCommentsPolicy) -> Self {
        FileCommentsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<FileCommentsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const FILE_COMMENTS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                              "previous_value"];
impl FileCommentsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileCommentsChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileCommentsChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileCommentsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCommentsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileCommentsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCommentsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCommentsChangePolicyDetails", FILE_COMMENTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCommentsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileCommentsChangePolicyType {
    pub description: String,
}

impl FileCommentsChangePolicyType {
    pub fn new(description: String) -> Self {
        FileCommentsChangePolicyType {
            description,
        }
    }

}

const FILE_COMMENTS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl FileCommentsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileCommentsChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileCommentsChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileCommentsChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCommentsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileCommentsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCommentsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCommentsChangePolicyType", FILE_COMMENTS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCommentsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File comments policy
#[derive(Debug)]
pub enum FileCommentsPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileCommentsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileCommentsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileCommentsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileCommentsPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileCommentsPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileCommentsPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("FileCommentsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileCommentsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileCommentsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            FileCommentsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("FileCommentsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            FileCommentsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Copied files and/or folders.
#[derive(Debug)]
pub struct FileCopyDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileCopyDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileCopyDetails {
            relocate_action_details,
        }
    }

}

const FILE_COPY_DETAILS_FIELDS: &[&str] = &["relocate_action_details"];
impl FileCopyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileCopyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileCopyDetails>, V::Error> {
        let mut field_relocate_action_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileCopyDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| ::serde::de::Error::missing_field("relocate_action_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCopyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCopyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileCopyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCopyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCopyDetails", FILE_COPY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCopyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCopyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileCopyType {
    pub description: String,
}

impl FileCopyType {
    pub fn new(description: String) -> Self {
        FileCopyType {
            description,
        }
    }

}

const FILE_COPY_TYPE_FIELDS: &[&str] = &["description"];
impl FileCopyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileCopyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileCopyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileCopyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileCopyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileCopyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileCopyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileCopyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileCopyType", FILE_COPY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileCopyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileCopyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted file comment.
#[derive(Debug)]
pub struct FileDeleteCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileDeleteCommentDetails {
    fn default() -> Self {
        FileDeleteCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_DELETE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileDeleteCommentDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileDeleteCommentDetails, V::Error> {
        let mut field_comment_text = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileDeleteCommentDetails {
            comment_text: field_comment_text,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDeleteCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDeleteCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileDeleteCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDeleteCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDeleteCommentDetails", FILE_DELETE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDeleteCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileDeleteCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileDeleteCommentType {
    pub description: String,
}

impl FileDeleteCommentType {
    pub fn new(description: String) -> Self {
        FileDeleteCommentType {
            description,
        }
    }

}

const FILE_DELETE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileDeleteCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileDeleteCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileDeleteCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileDeleteCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDeleteCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDeleteCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileDeleteCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDeleteCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDeleteCommentType", FILE_DELETE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDeleteCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileDeleteCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted files and/or folders.
#[derive(Debug)]
pub struct FileDeleteDetails {
}

impl Default for FileDeleteDetails {
    fn default() -> Self {
        FileDeleteDetails {
        }
    }
}

const FILE_DELETE_DETAILS_FIELDS: &[&str] = &[];
impl FileDeleteDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileDeleteDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileDeleteDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDeleteDetails", FILE_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileDeleteDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileDeleteType {
    pub description: String,
}

impl FileDeleteType {
    pub fn new(description: String) -> Self {
        FileDeleteType {
            description,
        }
    }

}

const FILE_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl FileDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileDeleteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileDeleteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileDeleteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDeleteType", FILE_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded files and/or folders.
#[derive(Debug)]
pub struct FileDownloadDetails {
}

impl Default for FileDownloadDetails {
    fn default() -> Self {
        FileDownloadDetails {
        }
    }
}

const FILE_DOWNLOAD_DETAILS_FIELDS: &[&str] = &[];
impl FileDownloadDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileDownloadDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileDownloadDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDownloadDetails", FILE_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileDownloadDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileDownloadType {
    pub description: String,
}

impl FileDownloadType {
    pub fn new(description: String) -> Self {
        FileDownloadType {
            description,
        }
    }

}

const FILE_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl FileDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileDownloadType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileDownloadType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileDownloadType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileDownloadType", FILE_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited file comment.
#[derive(Debug)]
pub struct FileEditCommentDetails {
    /// Previous comment text.
    pub previous_comment_text: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl FileEditCommentDetails {
    pub fn new(previous_comment_text: String) -> Self {
        FileEditCommentDetails {
            previous_comment_text,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const FILE_EDIT_COMMENT_DETAILS_FIELDS: &[&str] = &["previous_comment_text",
                                                    "comment_text"];
impl FileEditCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileEditCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileEditCommentDetails>, V::Error> {
        let mut field_previous_comment_text = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_comment_text" => {
                    if field_previous_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_comment_text"));
                    }
                    field_previous_comment_text = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileEditCommentDetails {
            previous_comment_text: field_previous_comment_text.ok_or_else(|| ::serde::de::Error::missing_field("previous_comment_text"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_comment_text", &self.previous_comment_text)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileEditCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileEditCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileEditCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileEditCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileEditCommentDetails", FILE_EDIT_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileEditCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileEditCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileEditCommentType {
    pub description: String,
}

impl FileEditCommentType {
    pub fn new(description: String) -> Self {
        FileEditCommentType {
            description,
        }
    }

}

const FILE_EDIT_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileEditCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileEditCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileEditCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileEditCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileEditCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileEditCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileEditCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileEditCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileEditCommentType", FILE_EDIT_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileEditCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileEditCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited files.
#[derive(Debug)]
pub struct FileEditDetails {
}

impl Default for FileEditDetails {
    fn default() -> Self {
        FileEditDetails {
        }
    }
}

const FILE_EDIT_DETAILS_FIELDS: &[&str] = &[];
impl FileEditDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileEditDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileEditDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileEditDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileEditDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileEditDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileEditDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileEditDetails", FILE_EDIT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileEditDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileEditDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileEditType {
    pub description: String,
}

impl FileEditType {
    pub fn new(description: String) -> Self {
        FileEditType {
            description,
        }
    }

}

const FILE_EDIT_TYPE_FIELDS: &[&str] = &["description"];
impl FileEditType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileEditType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileEditType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileEditType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileEditType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileEditType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileEditType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileEditType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileEditType", FILE_EDIT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileEditType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileEditType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created copy reference to file/folder.
#[derive(Debug)]
pub struct FileGetCopyReferenceDetails {
}

impl Default for FileGetCopyReferenceDetails {
    fn default() -> Self {
        FileGetCopyReferenceDetails {
        }
    }
}

const FILE_GET_COPY_REFERENCE_DETAILS_FIELDS: &[&str] = &[];
impl FileGetCopyReferenceDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileGetCopyReferenceDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileGetCopyReferenceDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileGetCopyReferenceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileGetCopyReferenceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileGetCopyReferenceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileGetCopyReferenceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileGetCopyReferenceDetails", FILE_GET_COPY_REFERENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileGetCopyReferenceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileGetCopyReferenceDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileGetCopyReferenceType {
    pub description: String,
}

impl FileGetCopyReferenceType {
    pub fn new(description: String) -> Self {
        FileGetCopyReferenceType {
            description,
        }
    }

}

const FILE_GET_COPY_REFERENCE_TYPE_FIELDS: &[&str] = &["description"];
impl FileGetCopyReferenceType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileGetCopyReferenceType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileGetCopyReferenceType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileGetCopyReferenceType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileGetCopyReferenceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileGetCopyReferenceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileGetCopyReferenceType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileGetCopyReferenceType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileGetCopyReferenceType", FILE_GET_COPY_REFERENCE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileGetCopyReferenceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileGetCopyReferenceType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Liked file comment.
#[derive(Debug)]
pub struct FileLikeCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileLikeCommentDetails {
    fn default() -> Self {
        FileLikeCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_LIKE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileLikeCommentDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileLikeCommentDetails, V::Error> {
        let mut field_comment_text = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileLikeCommentDetails {
            comment_text: field_comment_text,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLikeCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLikeCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileLikeCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLikeCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLikeCommentDetails", FILE_LIKE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLikeCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLikeCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileLikeCommentType {
    pub description: String,
}

impl FileLikeCommentType {
    pub fn new(description: String) -> Self {
        FileLikeCommentType {
            description,
        }
    }

}

const FILE_LIKE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileLikeCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileLikeCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileLikeCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileLikeCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLikeCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLikeCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileLikeCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLikeCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLikeCommentType", FILE_LIKE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLikeCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLikeCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Locked/unlocked editing for a file.
#[derive(Debug)]
pub struct FileLockingLockStatusChangedDetails {
    /// Previous lock status of the file.
    pub previous_value: LockStatus,
    /// New lock status of the file.
    pub new_value: LockStatus,
}

impl FileLockingLockStatusChangedDetails {
    pub fn new(previous_value: LockStatus, new_value: LockStatus) -> Self {
        FileLockingLockStatusChangedDetails {
            previous_value,
            new_value,
        }
    }

}

const FILE_LOCKING_LOCK_STATUS_CHANGED_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                   "new_value"];
impl FileLockingLockStatusChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileLockingLockStatusChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileLockingLockStatusChangedDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileLockingLockStatusChangedDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLockingLockStatusChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLockingLockStatusChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileLockingLockStatusChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLockingLockStatusChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLockingLockStatusChangedDetails", FILE_LOCKING_LOCK_STATUS_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLockingLockStatusChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLockingLockStatusChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileLockingLockStatusChangedType {
    pub description: String,
}

impl FileLockingLockStatusChangedType {
    pub fn new(description: String) -> Self {
        FileLockingLockStatusChangedType {
            description,
        }
    }

}

const FILE_LOCKING_LOCK_STATUS_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl FileLockingLockStatusChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileLockingLockStatusChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileLockingLockStatusChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileLockingLockStatusChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLockingLockStatusChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLockingLockStatusChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileLockingLockStatusChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLockingLockStatusChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLockingLockStatusChangedType", FILE_LOCKING_LOCK_STATUS_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLockingLockStatusChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLockingLockStatusChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed file locking policy for team.
#[derive(Debug)]
pub struct FileLockingPolicyChangedDetails {
    /// New file locking policy.
    pub new_value: super::team_policies::FileLockingPolicyState,
    /// Previous file locking policy.
    pub previous_value: super::team_policies::FileLockingPolicyState,
}

impl FileLockingPolicyChangedDetails {
    pub fn new(
        new_value: super::team_policies::FileLockingPolicyState,
        previous_value: super::team_policies::FileLockingPolicyState,
    ) -> Self {
        FileLockingPolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const FILE_LOCKING_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                              "previous_value"];
impl FileLockingPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileLockingPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileLockingPolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileLockingPolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLockingPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLockingPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileLockingPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLockingPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLockingPolicyChangedDetails", FILE_LOCKING_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLockingPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLockingPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileLockingPolicyChangedType {
    pub description: String,
}

impl FileLockingPolicyChangedType {
    pub fn new(description: String) -> Self {
        FileLockingPolicyChangedType {
            description,
        }
    }

}

const FILE_LOCKING_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl FileLockingPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileLockingPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileLockingPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileLockingPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLockingPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLockingPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileLockingPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLockingPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLockingPolicyChangedType", FILE_LOCKING_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLockingPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLockingPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File's logged information.
#[derive(Debug)]
pub struct FileLogInfo {
    /// Path relative to event context.
    pub path: PathLogInfo,
    /// Display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Unique ID. Might be missing due to historical data gap.
    pub file_id: Option<String>,
    /// File or folder size in bytes.
    pub file_size: Option<u64>,
}

impl FileLogInfo {
    pub fn new(path: PathLogInfo) -> Self {
        FileLogInfo {
            path,
            display_name: None,
            file_id: None,
            file_size: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_file_id(mut self, value: Option<String>) -> Self {
        self.file_id = value;
        self
    }

    pub fn with_file_size(mut self, value: Option<u64>) -> Self {
        self.file_size = value;
        self
    }

}

const FILE_LOG_INFO_FIELDS: &[&str] = &["path",
                                        "display_name",
                                        "file_id",
                                        "file_size"];
impl FileLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileLogInfo>, V::Error> {
        let mut field_path = None;
        let mut field_display_name = None;
        let mut field_file_id = None;
        let mut field_file_size = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(::serde::de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                "file_size" => {
                    if field_file_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_size"));
                    }
                    field_file_size = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileLogInfo {
            path: field_path.ok_or_else(|| ::serde::de::Error::missing_field("path"))?,
            display_name: field_display_name,
            file_id: field_file_id,
            file_size: field_file_size,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("file_id", &self.file_id)?;
        s.serialize_field("file_size", &self.file_size)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileLogInfo", FILE_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileLogInfo", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Moved files and/or folders.
#[derive(Debug)]
pub struct FileMoveDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileMoveDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileMoveDetails {
            relocate_action_details,
        }
    }

}

const FILE_MOVE_DETAILS_FIELDS: &[&str] = &["relocate_action_details"];
impl FileMoveDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileMoveDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileMoveDetails>, V::Error> {
        let mut field_relocate_action_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileMoveDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| ::serde::de::Error::missing_field("relocate_action_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileMoveDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileMoveDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileMoveDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileMoveDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileMoveDetails", FILE_MOVE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileMoveDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileMoveDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileMoveType {
    pub description: String,
}

impl FileMoveType {
    pub fn new(description: String) -> Self {
        FileMoveType {
            description,
        }
    }

}

const FILE_MOVE_TYPE_FIELDS: &[&str] = &["description"];
impl FileMoveType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileMoveType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileMoveType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileMoveType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileMoveType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileMoveType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileMoveType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileMoveType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileMoveType", FILE_MOVE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileMoveType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileMoveType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Generic information relevant both for files and folders
#[derive(Debug)]
pub struct FileOrFolderLogInfo {
    /// Path relative to event context.
    pub path: PathLogInfo,
    /// Display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Unique ID. Might be missing due to historical data gap.
    pub file_id: Option<String>,
    /// File or folder size in bytes.
    pub file_size: Option<u64>,
}

impl FileOrFolderLogInfo {
    pub fn new(path: PathLogInfo) -> Self {
        FileOrFolderLogInfo {
            path,
            display_name: None,
            file_id: None,
            file_size: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_file_id(mut self, value: Option<String>) -> Self {
        self.file_id = value;
        self
    }

    pub fn with_file_size(mut self, value: Option<u64>) -> Self {
        self.file_size = value;
        self
    }

}

const FILE_OR_FOLDER_LOG_INFO_FIELDS: &[&str] = &["path",
                                                  "display_name",
                                                  "file_id",
                                                  "file_size"];
impl FileOrFolderLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileOrFolderLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileOrFolderLogInfo>, V::Error> {
        let mut field_path = None;
        let mut field_display_name = None;
        let mut field_file_id = None;
        let mut field_file_size = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(::serde::de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                "file_size" => {
                    if field_file_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_size"));
                    }
                    field_file_size = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileOrFolderLogInfo {
            path: field_path.ok_or_else(|| ::serde::de::Error::missing_field("path"))?,
            display_name: field_display_name,
            file_id: field_file_id,
            file_size: field_file_size,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("file_id", &self.file_id)?;
        s.serialize_field("file_size", &self.file_size)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileOrFolderLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileOrFolderLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileOrFolderLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileOrFolderLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileOrFolderLogInfo", FILE_OR_FOLDER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileOrFolderLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileOrFolderLogInfo", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted files and/or folders.
#[derive(Debug)]
pub struct FilePermanentlyDeleteDetails {
}

impl Default for FilePermanentlyDeleteDetails {
    fn default() -> Self {
        FilePermanentlyDeleteDetails {
        }
    }
}

const FILE_PERMANENTLY_DELETE_DETAILS_FIELDS: &[&str] = &[];
impl FilePermanentlyDeleteDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FilePermanentlyDeleteDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FilePermanentlyDeleteDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePermanentlyDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePermanentlyDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FilePermanentlyDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePermanentlyDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePermanentlyDeleteDetails", FILE_PERMANENTLY_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePermanentlyDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FilePermanentlyDeleteDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FilePermanentlyDeleteType {
    pub description: String,
}

impl FilePermanentlyDeleteType {
    pub fn new(description: String) -> Self {
        FilePermanentlyDeleteType {
            description,
        }
    }

}

const FILE_PERMANENTLY_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl FilePermanentlyDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FilePermanentlyDeleteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FilePermanentlyDeleteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FilePermanentlyDeleteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePermanentlyDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePermanentlyDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FilePermanentlyDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePermanentlyDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePermanentlyDeleteType", FILE_PERMANENTLY_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePermanentlyDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FilePermanentlyDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Previewed files and/or folders.
#[derive(Debug)]
pub struct FilePreviewDetails {
}

impl Default for FilePreviewDetails {
    fn default() -> Self {
        FilePreviewDetails {
        }
    }
}

const FILE_PREVIEW_DETAILS_FIELDS: &[&str] = &[];
impl FilePreviewDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FilePreviewDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FilePreviewDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePreviewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePreviewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FilePreviewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePreviewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePreviewDetails", FILE_PREVIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePreviewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FilePreviewDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FilePreviewType {
    pub description: String,
}

impl FilePreviewType {
    pub fn new(description: String) -> Self {
        FilePreviewType {
            description,
        }
    }

}

const FILE_PREVIEW_TYPE_FIELDS: &[&str] = &["description"];
impl FilePreviewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FilePreviewType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FilePreviewType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FilePreviewType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FilePreviewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FilePreviewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FilePreviewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FilePreviewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FilePreviewType", FILE_PREVIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FilePreviewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FilePreviewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed files and/or folders.
#[derive(Debug)]
pub struct FileRenameDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileRenameDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileRenameDetails {
            relocate_action_details,
        }
    }

}

const FILE_RENAME_DETAILS_FIELDS: &[&str] = &["relocate_action_details"];
impl FileRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRenameDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRenameDetails>, V::Error> {
        let mut field_relocate_action_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRenameDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| ::serde::de::Error::missing_field("relocate_action_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRenameDetails", FILE_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRenameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRenameType {
    pub description: String,
}

impl FileRenameType {
    pub fn new(description: String) -> Self {
        FileRenameType {
            description,
        }
    }

}

const FILE_RENAME_TYPE_FIELDS: &[&str] = &["description"];
impl FileRenameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRenameType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRenameType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRenameType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRenameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRenameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRenameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRenameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRenameType", FILE_RENAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRenameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRenameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed file request.
#[derive(Debug)]
pub struct FileRequestChangeDetails {
    /// New file request details.
    pub new_details: FileRequestDetails,
    /// File request id. Might be missing due to historical data gap.
    pub file_request_id: Option<super::file_requests::FileRequestId>,
    /// Previous file request details. Might be missing due to historical data gap.
    pub previous_details: Option<FileRequestDetails>,
}

impl FileRequestChangeDetails {
    pub fn new(new_details: FileRequestDetails) -> Self {
        FileRequestChangeDetails {
            new_details,
            file_request_id: None,
            previous_details: None,
        }
    }

    pub fn with_file_request_id(
        mut self,
        value: Option<super::file_requests::FileRequestId>,
    ) -> Self {
        self.file_request_id = value;
        self
    }

    pub fn with_previous_details(mut self, value: Option<FileRequestDetails>) -> Self {
        self.previous_details = value;
        self
    }

}

const FILE_REQUEST_CHANGE_DETAILS_FIELDS: &[&str] = &["new_details",
                                                      "file_request_id",
                                                      "previous_details"];
impl FileRequestChangeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestChangeDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestChangeDetails>, V::Error> {
        let mut field_new_details = None;
        let mut field_file_request_id = None;
        let mut field_previous_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_details" => {
                    if field_new_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_details"));
                    }
                    field_new_details = Some(map.next_value()?);
                }
                "file_request_id" => {
                    if field_file_request_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_request_id"));
                    }
                    field_file_request_id = Some(map.next_value()?);
                }
                "previous_details" => {
                    if field_previous_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_details"));
                    }
                    field_previous_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestChangeDetails {
            new_details: field_new_details.ok_or_else(|| ::serde::de::Error::missing_field("new_details"))?,
            file_request_id: field_file_request_id,
            previous_details: field_previous_details,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_details", &self.new_details)?;
        s.serialize_field("file_request_id", &self.file_request_id)?;
        s.serialize_field("previous_details", &self.previous_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestChangeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestChangeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestChangeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestChangeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestChangeDetails", FILE_REQUEST_CHANGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestChangeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestChangeDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestChangeType {
    pub description: String,
}

impl FileRequestChangeType {
    pub fn new(description: String) -> Self {
        FileRequestChangeType {
            description,
        }
    }

}

const FILE_REQUEST_CHANGE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestChangeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestChangeType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestChangeType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestChangeType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestChangeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestChangeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestChangeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestChangeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestChangeType", FILE_REQUEST_CHANGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestChangeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestChangeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Closed file request.
#[derive(Debug)]
pub struct FileRequestCloseDetails {
    /// File request id. Might be missing due to historical data gap.
    pub file_request_id: Option<super::file_requests::FileRequestId>,
    /// Previous file request details. Might be missing due to historical data gap.
    pub previous_details: Option<FileRequestDetails>,
}

impl Default for FileRequestCloseDetails {
    fn default() -> Self {
        FileRequestCloseDetails {
            file_request_id: None,
            previous_details: None,
        }
    }
}

const FILE_REQUEST_CLOSE_DETAILS_FIELDS: &[&str] = &["file_request_id",
                                                     "previous_details"];
impl FileRequestCloseDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestCloseDetails, V::Error> {
        let mut field_file_request_id = None;
        let mut field_previous_details = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "file_request_id" => {
                    if field_file_request_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_request_id"));
                    }
                    field_file_request_id = Some(map.next_value()?);
                }
                "previous_details" => {
                    if field_previous_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_details"));
                    }
                    field_previous_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileRequestCloseDetails {
            file_request_id: field_file_request_id,
            previous_details: field_previous_details,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_request_id", &self.file_request_id)?;
        s.serialize_field("previous_details", &self.previous_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCloseDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCloseDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestCloseDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCloseDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCloseDetails", FILE_REQUEST_CLOSE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCloseDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCloseDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestCloseType {
    pub description: String,
}

impl FileRequestCloseType {
    pub fn new(description: String) -> Self {
        FileRequestCloseType {
            description,
        }
    }

}

const FILE_REQUEST_CLOSE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestCloseType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestCloseType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestCloseType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestCloseType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCloseType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCloseType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestCloseType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCloseType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCloseType", FILE_REQUEST_CLOSE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCloseType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCloseType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created file request.
#[derive(Debug)]
pub struct FileRequestCreateDetails {
    /// File request id. Might be missing due to historical data gap.
    pub file_request_id: Option<super::file_requests::FileRequestId>,
    /// File request details. Might be missing due to historical data gap.
    pub request_details: Option<FileRequestDetails>,
}

impl Default for FileRequestCreateDetails {
    fn default() -> Self {
        FileRequestCreateDetails {
            file_request_id: None,
            request_details: None,
        }
    }
}

const FILE_REQUEST_CREATE_DETAILS_FIELDS: &[&str] = &["file_request_id",
                                                      "request_details"];
impl FileRequestCreateDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestCreateDetails, V::Error> {
        let mut field_file_request_id = None;
        let mut field_request_details = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "file_request_id" => {
                    if field_file_request_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_request_id"));
                    }
                    field_file_request_id = Some(map.next_value()?);
                }
                "request_details" => {
                    if field_request_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("request_details"));
                    }
                    field_request_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileRequestCreateDetails {
            file_request_id: field_file_request_id,
            request_details: field_request_details,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_request_id", &self.file_request_id)?;
        s.serialize_field("request_details", &self.request_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCreateDetails", FILE_REQUEST_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCreateDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestCreateType {
    pub description: String,
}

impl FileRequestCreateType {
    pub fn new(description: String) -> Self {
        FileRequestCreateType {
            description,
        }
    }

}

const FILE_REQUEST_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestCreateType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestCreateType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestCreateType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestCreateType", FILE_REQUEST_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File request deadline
#[derive(Debug)]
pub struct FileRequestDeadline {
    /// The deadline for this file request. Might be missing due to historical data gap.
    pub deadline: Option<super::common::DropboxTimestamp>,
    /// If set, allow uploads after the deadline has passed. Might be missing due to historical data
    /// gap.
    pub allow_late_uploads: Option<String>,
}

impl Default for FileRequestDeadline {
    fn default() -> Self {
        FileRequestDeadline {
            deadline: None,
            allow_late_uploads: None,
        }
    }
}

const FILE_REQUEST_DEADLINE_FIELDS: &[&str] = &["deadline",
                                                "allow_late_uploads"];
impl FileRequestDeadline {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestDeadline, V::Error> {
        let mut field_deadline = None;
        let mut field_allow_late_uploads = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "deadline" => {
                    if field_deadline.is_some() {
                        return Err(::serde::de::Error::duplicate_field("deadline"));
                    }
                    field_deadline = Some(map.next_value()?);
                }
                "allow_late_uploads" => {
                    if field_allow_late_uploads.is_some() {
                        return Err(::serde::de::Error::duplicate_field("allow_late_uploads"));
                    }
                    field_allow_late_uploads = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileRequestDeadline {
            deadline: field_deadline,
            allow_late_uploads: field_allow_late_uploads,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("deadline", &self.deadline)?;
        s.serialize_field("allow_late_uploads", &self.allow_late_uploads)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestDeadline {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestDeadline;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestDeadline struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestDeadline::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestDeadline", FILE_REQUEST_DEADLINE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestDeadline {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestDeadline", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Delete file request.
#[derive(Debug)]
pub struct FileRequestDeleteDetails {
    /// File request id. Might be missing due to historical data gap.
    pub file_request_id: Option<super::file_requests::FileRequestId>,
    /// Previous file request details. Might be missing due to historical data gap.
    pub previous_details: Option<FileRequestDetails>,
}

impl Default for FileRequestDeleteDetails {
    fn default() -> Self {
        FileRequestDeleteDetails {
            file_request_id: None,
            previous_details: None,
        }
    }
}

const FILE_REQUEST_DELETE_DETAILS_FIELDS: &[&str] = &["file_request_id",
                                                      "previous_details"];
impl FileRequestDeleteDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestDeleteDetails, V::Error> {
        let mut field_file_request_id = None;
        let mut field_previous_details = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "file_request_id" => {
                    if field_file_request_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_request_id"));
                    }
                    field_file_request_id = Some(map.next_value()?);
                }
                "previous_details" => {
                    if field_previous_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_details"));
                    }
                    field_previous_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileRequestDeleteDetails {
            file_request_id: field_file_request_id,
            previous_details: field_previous_details,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_request_id", &self.file_request_id)?;
        s.serialize_field("previous_details", &self.previous_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestDeleteDetails", FILE_REQUEST_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestDeleteDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestDeleteType {
    pub description: String,
}

impl FileRequestDeleteType {
    pub fn new(description: String) -> Self {
        FileRequestDeleteType {
            description,
        }
    }

}

const FILE_REQUEST_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestDeleteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestDeleteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestDeleteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestDeleteType", FILE_REQUEST_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File request details
#[derive(Debug)]
pub struct FileRequestDetails {
    /// Asset position in the Assets list.
    pub asset_index: u64,
    /// File request deadline. Might be missing due to historical data gap.
    pub deadline: Option<FileRequestDeadline>,
}

impl FileRequestDetails {
    pub fn new(asset_index: u64) -> Self {
        FileRequestDetails {
            asset_index,
            deadline: None,
        }
    }

    pub fn with_deadline(mut self, value: Option<FileRequestDeadline>) -> Self {
        self.deadline = value;
        self
    }

}

const FILE_REQUEST_DETAILS_FIELDS: &[&str] = &["asset_index",
                                               "deadline"];
impl FileRequestDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestDetails>, V::Error> {
        let mut field_asset_index = None;
        let mut field_deadline = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "asset_index" => {
                    if field_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("asset_index"));
                    }
                    field_asset_index = Some(map.next_value()?);
                }
                "deadline" => {
                    if field_deadline.is_some() {
                        return Err(::serde::de::Error::duplicate_field("deadline"));
                    }
                    field_deadline = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestDetails {
            asset_index: field_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("asset_index"))?,
            deadline: field_deadline,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("asset_index", &self.asset_index)?;
        s.serialize_field("deadline", &self.deadline)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestDetails", FILE_REQUEST_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Received files for file request.
#[derive(Debug)]
pub struct FileRequestReceiveFileDetails {
    /// Submitted file names.
    pub submitted_file_names: Vec<String>,
    /// File request id. Might be missing due to historical data gap.
    pub file_request_id: Option<super::file_requests::FileRequestId>,
    /// File request details. Might be missing due to historical data gap.
    pub file_request_details: Option<FileRequestDetails>,
    /// The name as provided by the submitter. Might be missing due to historical data gap.
    pub submitter_name: Option<super::common::DisplayNameLegacy>,
    /// The email as provided by the submitter. Might be missing due to historical data gap.
    pub submitter_email: Option<EmailAddress>,
}

impl FileRequestReceiveFileDetails {
    pub fn new(submitted_file_names: Vec<String>) -> Self {
        FileRequestReceiveFileDetails {
            submitted_file_names,
            file_request_id: None,
            file_request_details: None,
            submitter_name: None,
            submitter_email: None,
        }
    }

    pub fn with_file_request_id(
        mut self,
        value: Option<super::file_requests::FileRequestId>,
    ) -> Self {
        self.file_request_id = value;
        self
    }

    pub fn with_file_request_details(mut self, value: Option<FileRequestDetails>) -> Self {
        self.file_request_details = value;
        self
    }

    pub fn with_submitter_name(mut self, value: Option<super::common::DisplayNameLegacy>) -> Self {
        self.submitter_name = value;
        self
    }

    pub fn with_submitter_email(mut self, value: Option<EmailAddress>) -> Self {
        self.submitter_email = value;
        self
    }

}

const FILE_REQUEST_RECEIVE_FILE_DETAILS_FIELDS: &[&str] = &["submitted_file_names",
                                                            "file_request_id",
                                                            "file_request_details",
                                                            "submitter_name",
                                                            "submitter_email"];
impl FileRequestReceiveFileDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestReceiveFileDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestReceiveFileDetails>, V::Error> {
        let mut field_submitted_file_names = None;
        let mut field_file_request_id = None;
        let mut field_file_request_details = None;
        let mut field_submitter_name = None;
        let mut field_submitter_email = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "submitted_file_names" => {
                    if field_submitted_file_names.is_some() {
                        return Err(::serde::de::Error::duplicate_field("submitted_file_names"));
                    }
                    field_submitted_file_names = Some(map.next_value()?);
                }
                "file_request_id" => {
                    if field_file_request_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_request_id"));
                    }
                    field_file_request_id = Some(map.next_value()?);
                }
                "file_request_details" => {
                    if field_file_request_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_request_details"));
                    }
                    field_file_request_details = Some(map.next_value()?);
                }
                "submitter_name" => {
                    if field_submitter_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("submitter_name"));
                    }
                    field_submitter_name = Some(map.next_value()?);
                }
                "submitter_email" => {
                    if field_submitter_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("submitter_email"));
                    }
                    field_submitter_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestReceiveFileDetails {
            submitted_file_names: field_submitted_file_names.ok_or_else(|| ::serde::de::Error::missing_field("submitted_file_names"))?,
            file_request_id: field_file_request_id,
            file_request_details: field_file_request_details,
            submitter_name: field_submitter_name,
            submitter_email: field_submitter_email,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("submitted_file_names", &self.submitted_file_names)?;
        s.serialize_field("file_request_id", &self.file_request_id)?;
        s.serialize_field("file_request_details", &self.file_request_details)?;
        s.serialize_field("submitter_name", &self.submitter_name)?;
        s.serialize_field("submitter_email", &self.submitter_email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestReceiveFileDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestReceiveFileDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestReceiveFileDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestReceiveFileDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestReceiveFileDetails", FILE_REQUEST_RECEIVE_FILE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestReceiveFileDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestReceiveFileDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestReceiveFileType {
    pub description: String,
}

impl FileRequestReceiveFileType {
    pub fn new(description: String) -> Self {
        FileRequestReceiveFileType {
            description,
        }
    }

}

const FILE_REQUEST_RECEIVE_FILE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestReceiveFileType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestReceiveFileType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestReceiveFileType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestReceiveFileType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestReceiveFileType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestReceiveFileType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestReceiveFileType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestReceiveFileType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestReceiveFileType", FILE_REQUEST_RECEIVE_FILE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestReceiveFileType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestReceiveFileType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled file requests.
#[derive(Debug)]
pub struct FileRequestsChangePolicyDetails {
    /// New file requests policy.
    pub new_value: FileRequestsPolicy,
    /// Previous file requests policy. Might be missing due to historical data gap.
    pub previous_value: Option<FileRequestsPolicy>,
}

impl FileRequestsChangePolicyDetails {
    pub fn new(new_value: FileRequestsPolicy) -> Self {
        FileRequestsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<FileRequestsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const FILE_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                              "previous_value"];
impl FileRequestsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestsChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestsChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsChangePolicyDetails", FILE_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileRequestsChangePolicyType {
    pub description: String,
}

impl FileRequestsChangePolicyType {
    pub fn new(description: String) -> Self {
        FileRequestsChangePolicyType {
            description,
        }
    }

}

const FILE_REQUESTS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestsChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestsChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestsChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsChangePolicyType", FILE_REQUESTS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled file request emails for everyone.
#[derive(Debug)]
pub struct FileRequestsEmailsEnabledDetails {
}

impl Default for FileRequestsEmailsEnabledDetails {
    fn default() -> Self {
        FileRequestsEmailsEnabledDetails {
        }
    }
}

const FILE_REQUESTS_EMAILS_ENABLED_DETAILS_FIELDS: &[&str] = &[];
impl FileRequestsEmailsEnabledDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestsEmailsEnabledDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileRequestsEmailsEnabledDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsEnabledDetails", FILE_REQUESTS_EMAILS_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRequestsEmailsEnabledDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRequestsEmailsEnabledType {
    pub description: String,
}

impl FileRequestsEmailsEnabledType {
    pub fn new(description: String) -> Self {
        FileRequestsEmailsEnabledType {
            description,
        }
    }

}

const FILE_REQUESTS_EMAILS_ENABLED_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestsEmailsEnabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestsEmailsEnabledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestsEmailsEnabledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestsEmailsEnabledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsEnabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsEnabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsEnabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsEnabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsEnabledType", FILE_REQUESTS_EMAILS_ENABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsEnabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestsEmailsEnabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled file request emails for team.
#[derive(Debug)]
pub struct FileRequestsEmailsRestrictedToTeamOnlyDetails {
}

impl Default for FileRequestsEmailsRestrictedToTeamOnlyDetails {
    fn default() -> Self {
        FileRequestsEmailsRestrictedToTeamOnlyDetails {
        }
    }
}

const FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_DETAILS_FIELDS: &[&str] = &[];
impl FileRequestsEmailsRestrictedToTeamOnlyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRequestsEmailsRestrictedToTeamOnlyDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileRequestsEmailsRestrictedToTeamOnlyDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsRestrictedToTeamOnlyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsRestrictedToTeamOnlyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsRestrictedToTeamOnlyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsRestrictedToTeamOnlyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsRestrictedToTeamOnlyDetails", FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsRestrictedToTeamOnlyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRequestsEmailsRestrictedToTeamOnlyDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRequestsEmailsRestrictedToTeamOnlyType {
    pub description: String,
}

impl FileRequestsEmailsRestrictedToTeamOnlyType {
    pub fn new(description: String) -> Self {
        FileRequestsEmailsRestrictedToTeamOnlyType {
            description,
        }
    }

}

const FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_TYPE_FIELDS: &[&str] = &["description"];
impl FileRequestsEmailsRestrictedToTeamOnlyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRequestsEmailsRestrictedToTeamOnlyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRequestsEmailsRestrictedToTeamOnlyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRequestsEmailsRestrictedToTeamOnlyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsEmailsRestrictedToTeamOnlyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRequestsEmailsRestrictedToTeamOnlyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestsEmailsRestrictedToTeamOnlyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRequestsEmailsRestrictedToTeamOnlyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRequestsEmailsRestrictedToTeamOnlyType", FILE_REQUESTS_EMAILS_RESTRICTED_TO_TEAM_ONLY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsEmailsRestrictedToTeamOnlyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRequestsEmailsRestrictedToTeamOnlyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File requests policy
#[derive(Debug)]
pub enum FileRequestsPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileRequestsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileRequestsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRequestsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileRequestsPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileRequestsPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileRequestsPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("FileRequestsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileRequestsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileRequestsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            FileRequestsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("FileRequestsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            FileRequestsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Resolved file comment.
#[derive(Debug)]
pub struct FileResolveCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileResolveCommentDetails {
    fn default() -> Self {
        FileResolveCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_RESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileResolveCommentDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileResolveCommentDetails, V::Error> {
        let mut field_comment_text = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileResolveCommentDetails {
            comment_text: field_comment_text,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileResolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileResolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileResolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileResolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileResolveCommentDetails", FILE_RESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileResolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileResolveCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileResolveCommentType {
    pub description: String,
}

impl FileResolveCommentType {
    pub fn new(description: String) -> Self {
        FileResolveCommentType {
            description,
        }
    }

}

const FILE_RESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileResolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileResolveCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileResolveCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileResolveCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileResolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileResolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileResolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileResolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileResolveCommentType", FILE_RESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileResolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileResolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored deleted files and/or folders.
#[derive(Debug)]
pub struct FileRestoreDetails {
}

impl Default for FileRestoreDetails {
    fn default() -> Self {
        FileRestoreDetails {
        }
    }
}

const FILE_RESTORE_DETAILS_FIELDS: &[&str] = &[];
impl FileRestoreDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRestoreDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileRestoreDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRestoreDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRestoreDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRestoreDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRestoreDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRestoreDetails", FILE_RESTORE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRestoreDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRestoreDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRestoreType {
    pub description: String,
}

impl FileRestoreType {
    pub fn new(description: String) -> Self {
        FileRestoreType {
            description,
        }
    }

}

const FILE_RESTORE_TYPE_FIELDS: &[&str] = &["description"];
impl FileRestoreType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRestoreType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRestoreType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRestoreType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRestoreType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRestoreType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRestoreType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRestoreType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRestoreType", FILE_RESTORE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRestoreType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRestoreType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reverted files to previous version.
#[derive(Debug)]
pub struct FileRevertDetails {
}

impl Default for FileRevertDetails {
    fn default() -> Self {
        FileRevertDetails {
        }
    }
}

const FILE_REVERT_DETAILS_FIELDS: &[&str] = &[];
impl FileRevertDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRevertDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileRevertDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRevertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRevertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRevertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRevertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRevertDetails", FILE_REVERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRevertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRevertDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRevertType {
    pub description: String,
}

impl FileRevertType {
    pub fn new(description: String) -> Self {
        FileRevertType {
            description,
        }
    }

}

const FILE_REVERT_TYPE_FIELDS: &[&str] = &["description"];
impl FileRevertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRevertType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRevertType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRevertType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRevertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRevertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRevertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRevertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRevertType", FILE_REVERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRevertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRevertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Rolled back file actions.
#[derive(Debug)]
pub struct FileRollbackChangesDetails {
}

impl Default for FileRollbackChangesDetails {
    fn default() -> Self {
        FileRollbackChangesDetails {
        }
    }
}

const FILE_ROLLBACK_CHANGES_DETAILS_FIELDS: &[&str] = &[];
impl FileRollbackChangesDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileRollbackChangesDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(FileRollbackChangesDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRollbackChangesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRollbackChangesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRollbackChangesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRollbackChangesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRollbackChangesDetails", FILE_ROLLBACK_CHANGES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRollbackChangesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("FileRollbackChangesDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct FileRollbackChangesType {
    pub description: String,
}

impl FileRollbackChangesType {
    pub fn new(description: String) -> Self {
        FileRollbackChangesType {
            description,
        }
    }

}

const FILE_ROLLBACK_CHANGES_TYPE_FIELDS: &[&str] = &["description"];
impl FileRollbackChangesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileRollbackChangesType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileRollbackChangesType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileRollbackChangesType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileRollbackChangesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileRollbackChangesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileRollbackChangesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileRollbackChangesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileRollbackChangesType", FILE_ROLLBACK_CHANGES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileRollbackChangesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileRollbackChangesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Saved file/folder using copy reference.
#[derive(Debug)]
pub struct FileSaveCopyReferenceDetails {
    /// Relocate action details.
    pub relocate_action_details: Vec<RelocateAssetReferencesLogInfo>,
}

impl FileSaveCopyReferenceDetails {
    pub fn new(relocate_action_details: Vec<RelocateAssetReferencesLogInfo>) -> Self {
        FileSaveCopyReferenceDetails {
            relocate_action_details,
        }
    }

}

const FILE_SAVE_COPY_REFERENCE_DETAILS_FIELDS: &[&str] = &["relocate_action_details"];
impl FileSaveCopyReferenceDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileSaveCopyReferenceDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileSaveCopyReferenceDetails>, V::Error> {
        let mut field_relocate_action_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "relocate_action_details" => {
                    if field_relocate_action_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("relocate_action_details"));
                    }
                    field_relocate_action_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileSaveCopyReferenceDetails {
            relocate_action_details: field_relocate_action_details.ok_or_else(|| ::serde::de::Error::missing_field("relocate_action_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("relocate_action_details", &self.relocate_action_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileSaveCopyReferenceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileSaveCopyReferenceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileSaveCopyReferenceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileSaveCopyReferenceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileSaveCopyReferenceDetails", FILE_SAVE_COPY_REFERENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileSaveCopyReferenceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileSaveCopyReferenceDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileSaveCopyReferenceType {
    pub description: String,
}

impl FileSaveCopyReferenceType {
    pub fn new(description: String) -> Self {
        FileSaveCopyReferenceType {
            description,
        }
    }

}

const FILE_SAVE_COPY_REFERENCE_TYPE_FIELDS: &[&str] = &["description"];
impl FileSaveCopyReferenceType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileSaveCopyReferenceType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileSaveCopyReferenceType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileSaveCopyReferenceType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileSaveCopyReferenceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileSaveCopyReferenceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileSaveCopyReferenceType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileSaveCopyReferenceType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileSaveCopyReferenceType", FILE_SAVE_COPY_REFERENCE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileSaveCopyReferenceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileSaveCopyReferenceType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Transfer files added.
#[derive(Debug)]
pub struct FileTransfersFileAddDetails {
    /// Transfer id.
    pub file_transfer_id: String,
}

impl FileTransfersFileAddDetails {
    pub fn new(file_transfer_id: String) -> Self {
        FileTransfersFileAddDetails {
            file_transfer_id,
        }
    }

}

const FILE_TRANSFERS_FILE_ADD_DETAILS_FIELDS: &[&str] = &["file_transfer_id"];
impl FileTransfersFileAddDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersFileAddDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersFileAddDetails>, V::Error> {
        let mut field_file_transfer_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "file_transfer_id" => {
                    if field_file_transfer_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_transfer_id"));
                    }
                    field_file_transfer_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersFileAddDetails {
            file_transfer_id: field_file_transfer_id.ok_or_else(|| ::serde::de::Error::missing_field("file_transfer_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_transfer_id", &self.file_transfer_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersFileAddDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersFileAddDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersFileAddDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersFileAddDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersFileAddDetails", FILE_TRANSFERS_FILE_ADD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersFileAddDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersFileAddDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileTransfersFileAddType {
    pub description: String,
}

impl FileTransfersFileAddType {
    pub fn new(description: String) -> Self {
        FileTransfersFileAddType {
            description,
        }
    }

}

const FILE_TRANSFERS_FILE_ADD_TYPE_FIELDS: &[&str] = &["description"];
impl FileTransfersFileAddType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersFileAddType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersFileAddType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersFileAddType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersFileAddType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersFileAddType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersFileAddType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersFileAddType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersFileAddType", FILE_TRANSFERS_FILE_ADD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersFileAddType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersFileAddType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// File transfers policy
#[derive(Debug)]
pub enum FileTransfersPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FileTransfersPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileTransfersPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileTransfersPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(FileTransfersPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("FileTransfersPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FileTransfersPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("FileTransfersPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            FileTransfersPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("FileTransfersPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            FileTransfersPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed file transfers policy for team.
#[derive(Debug)]
pub struct FileTransfersPolicyChangedDetails {
    /// New file transfers policy.
    pub new_value: FileTransfersPolicy,
    /// Previous file transfers policy.
    pub previous_value: FileTransfersPolicy,
}

impl FileTransfersPolicyChangedDetails {
    pub fn new(new_value: FileTransfersPolicy, previous_value: FileTransfersPolicy) -> Self {
        FileTransfersPolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const FILE_TRANSFERS_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl FileTransfersPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersPolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersPolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersPolicyChangedDetails", FILE_TRANSFERS_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileTransfersPolicyChangedType {
    pub description: String,
}

impl FileTransfersPolicyChangedType {
    pub fn new(description: String) -> Self {
        FileTransfersPolicyChangedType {
            description,
        }
    }

}

const FILE_TRANSFERS_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl FileTransfersPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersPolicyChangedType", FILE_TRANSFERS_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted transfer.
#[derive(Debug)]
pub struct FileTransfersTransferDeleteDetails {
    /// Transfer id.
    pub file_transfer_id: String,
}

impl FileTransfersTransferDeleteDetails {
    pub fn new(file_transfer_id: String) -> Self {
        FileTransfersTransferDeleteDetails {
            file_transfer_id,
        }
    }

}

const FILE_TRANSFERS_TRANSFER_DELETE_DETAILS_FIELDS: &[&str] = &["file_transfer_id"];
impl FileTransfersTransferDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersTransferDeleteDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersTransferDeleteDetails>, V::Error> {
        let mut field_file_transfer_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "file_transfer_id" => {
                    if field_file_transfer_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_transfer_id"));
                    }
                    field_file_transfer_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersTransferDeleteDetails {
            file_transfer_id: field_file_transfer_id.ok_or_else(|| ::serde::de::Error::missing_field("file_transfer_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_transfer_id", &self.file_transfer_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersTransferDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersTransferDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersTransferDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersTransferDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersTransferDeleteDetails", FILE_TRANSFERS_TRANSFER_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersTransferDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersTransferDeleteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileTransfersTransferDeleteType {
    pub description: String,
}

impl FileTransfersTransferDeleteType {
    pub fn new(description: String) -> Self {
        FileTransfersTransferDeleteType {
            description,
        }
    }

}

const FILE_TRANSFERS_TRANSFER_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl FileTransfersTransferDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersTransferDeleteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersTransferDeleteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersTransferDeleteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersTransferDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersTransferDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersTransferDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersTransferDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersTransferDeleteType", FILE_TRANSFERS_TRANSFER_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersTransferDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersTransferDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Transfer downloaded.
#[derive(Debug)]
pub struct FileTransfersTransferDownloadDetails {
    /// Transfer id.
    pub file_transfer_id: String,
}

impl FileTransfersTransferDownloadDetails {
    pub fn new(file_transfer_id: String) -> Self {
        FileTransfersTransferDownloadDetails {
            file_transfer_id,
        }
    }

}

const FILE_TRANSFERS_TRANSFER_DOWNLOAD_DETAILS_FIELDS: &[&str] = &["file_transfer_id"];
impl FileTransfersTransferDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersTransferDownloadDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersTransferDownloadDetails>, V::Error> {
        let mut field_file_transfer_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "file_transfer_id" => {
                    if field_file_transfer_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_transfer_id"));
                    }
                    field_file_transfer_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersTransferDownloadDetails {
            file_transfer_id: field_file_transfer_id.ok_or_else(|| ::serde::de::Error::missing_field("file_transfer_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_transfer_id", &self.file_transfer_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersTransferDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersTransferDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersTransferDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersTransferDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersTransferDownloadDetails", FILE_TRANSFERS_TRANSFER_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersTransferDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersTransferDownloadDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileTransfersTransferDownloadType {
    pub description: String,
}

impl FileTransfersTransferDownloadType {
    pub fn new(description: String) -> Self {
        FileTransfersTransferDownloadType {
            description,
        }
    }

}

const FILE_TRANSFERS_TRANSFER_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl FileTransfersTransferDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersTransferDownloadType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersTransferDownloadType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersTransferDownloadType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersTransferDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersTransferDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersTransferDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersTransferDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersTransferDownloadType", FILE_TRANSFERS_TRANSFER_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersTransferDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersTransferDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sent transfer.
#[derive(Debug)]
pub struct FileTransfersTransferSendDetails {
    /// Transfer id.
    pub file_transfer_id: String,
}

impl FileTransfersTransferSendDetails {
    pub fn new(file_transfer_id: String) -> Self {
        FileTransfersTransferSendDetails {
            file_transfer_id,
        }
    }

}

const FILE_TRANSFERS_TRANSFER_SEND_DETAILS_FIELDS: &[&str] = &["file_transfer_id"];
impl FileTransfersTransferSendDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersTransferSendDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersTransferSendDetails>, V::Error> {
        let mut field_file_transfer_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "file_transfer_id" => {
                    if field_file_transfer_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_transfer_id"));
                    }
                    field_file_transfer_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersTransferSendDetails {
            file_transfer_id: field_file_transfer_id.ok_or_else(|| ::serde::de::Error::missing_field("file_transfer_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_transfer_id", &self.file_transfer_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersTransferSendDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersTransferSendDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersTransferSendDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersTransferSendDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersTransferSendDetails", FILE_TRANSFERS_TRANSFER_SEND_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersTransferSendDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersTransferSendDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileTransfersTransferSendType {
    pub description: String,
}

impl FileTransfersTransferSendType {
    pub fn new(description: String) -> Self {
        FileTransfersTransferSendType {
            description,
        }
    }

}

const FILE_TRANSFERS_TRANSFER_SEND_TYPE_FIELDS: &[&str] = &["description"];
impl FileTransfersTransferSendType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersTransferSendType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersTransferSendType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersTransferSendType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersTransferSendType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersTransferSendType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersTransferSendType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersTransferSendType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersTransferSendType", FILE_TRANSFERS_TRANSFER_SEND_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersTransferSendType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersTransferSendType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Viewed transfer.
#[derive(Debug)]
pub struct FileTransfersTransferViewDetails {
    /// Transfer id.
    pub file_transfer_id: String,
}

impl FileTransfersTransferViewDetails {
    pub fn new(file_transfer_id: String) -> Self {
        FileTransfersTransferViewDetails {
            file_transfer_id,
        }
    }

}

const FILE_TRANSFERS_TRANSFER_VIEW_DETAILS_FIELDS: &[&str] = &["file_transfer_id"];
impl FileTransfersTransferViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersTransferViewDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersTransferViewDetails>, V::Error> {
        let mut field_file_transfer_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "file_transfer_id" => {
                    if field_file_transfer_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_transfer_id"));
                    }
                    field_file_transfer_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersTransferViewDetails {
            file_transfer_id: field_file_transfer_id.ok_or_else(|| ::serde::de::Error::missing_field("file_transfer_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_transfer_id", &self.file_transfer_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersTransferViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersTransferViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersTransferViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersTransferViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersTransferViewDetails", FILE_TRANSFERS_TRANSFER_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersTransferViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersTransferViewDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileTransfersTransferViewType {
    pub description: String,
}

impl FileTransfersTransferViewType {
    pub fn new(description: String) -> Self {
        FileTransfersTransferViewType {
            description,
        }
    }

}

const FILE_TRANSFERS_TRANSFER_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl FileTransfersTransferViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileTransfersTransferViewType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileTransfersTransferViewType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileTransfersTransferViewType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileTransfersTransferViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileTransfersTransferViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileTransfersTransferViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileTransfersTransferViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileTransfersTransferViewType", FILE_TRANSFERS_TRANSFER_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileTransfersTransferViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileTransfersTransferViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unliked file comment.
#[derive(Debug)]
pub struct FileUnlikeCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileUnlikeCommentDetails {
    fn default() -> Self {
        FileUnlikeCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_UNLIKE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileUnlikeCommentDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileUnlikeCommentDetails, V::Error> {
        let mut field_comment_text = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileUnlikeCommentDetails {
            comment_text: field_comment_text,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileUnlikeCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileUnlikeCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileUnlikeCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileUnlikeCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileUnlikeCommentDetails", FILE_UNLIKE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileUnlikeCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileUnlikeCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileUnlikeCommentType {
    pub description: String,
}

impl FileUnlikeCommentType {
    pub fn new(description: String) -> Self {
        FileUnlikeCommentType {
            description,
        }
    }

}

const FILE_UNLIKE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileUnlikeCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileUnlikeCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileUnlikeCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileUnlikeCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileUnlikeCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileUnlikeCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileUnlikeCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileUnlikeCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileUnlikeCommentType", FILE_UNLIKE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileUnlikeCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileUnlikeCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unresolved file comment.
#[derive(Debug)]
pub struct FileUnresolveCommentDetails {
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl Default for FileUnresolveCommentDetails {
    fn default() -> Self {
        FileUnresolveCommentDetails {
            comment_text: None,
        }
    }
}

const FILE_UNRESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["comment_text"];
impl FileUnresolveCommentDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<FileUnresolveCommentDetails, V::Error> {
        let mut field_comment_text = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = FileUnresolveCommentDetails {
            comment_text: field_comment_text,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileUnresolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileUnresolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileUnresolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileUnresolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileUnresolveCommentDetails", FILE_UNRESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileUnresolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileUnresolveCommentDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FileUnresolveCommentType {
    pub description: String,
}

impl FileUnresolveCommentType {
    pub fn new(description: String) -> Self {
        FileUnresolveCommentType {
            description,
        }
    }

}

const FILE_UNRESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl FileUnresolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FileUnresolveCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FileUnresolveCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FileUnresolveCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FileUnresolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FileUnresolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FileUnresolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FileUnresolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FileUnresolveCommentType", FILE_UNRESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FileUnresolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FileUnresolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Folder's logged information.
#[derive(Debug)]
pub struct FolderLogInfo {
    /// Path relative to event context.
    pub path: PathLogInfo,
    /// Display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Unique ID. Might be missing due to historical data gap.
    pub file_id: Option<String>,
    /// File or folder size in bytes.
    pub file_size: Option<u64>,
    /// Number of files within the folder.
    pub file_count: Option<u64>,
}

impl FolderLogInfo {
    pub fn new(path: PathLogInfo) -> Self {
        FolderLogInfo {
            path,
            display_name: None,
            file_id: None,
            file_size: None,
            file_count: None,
        }
    }

    pub fn with_display_name(mut self, value: Option<String>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_file_id(mut self, value: Option<String>) -> Self {
        self.file_id = value;
        self
    }

    pub fn with_file_size(mut self, value: Option<u64>) -> Self {
        self.file_size = value;
        self
    }

    pub fn with_file_count(mut self, value: Option<u64>) -> Self {
        self.file_count = value;
        self
    }

}

const FOLDER_LOG_INFO_FIELDS: &[&str] = &["path",
                                          "display_name",
                                          "file_id",
                                          "file_size",
                                          "file_count"];
impl FolderLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FolderLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FolderLogInfo>, V::Error> {
        let mut field_path = None;
        let mut field_display_name = None;
        let mut field_file_id = None;
        let mut field_file_size = None;
        let mut field_file_count = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "path" => {
                    if field_path.is_some() {
                        return Err(::serde::de::Error::duplicate_field("path"));
                    }
                    field_path = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                "file_size" => {
                    if field_file_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_size"));
                    }
                    field_file_size = Some(map.next_value()?);
                }
                "file_count" => {
                    if field_file_count.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_count"));
                    }
                    field_file_count = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FolderLogInfo {
            path: field_path.ok_or_else(|| ::serde::de::Error::missing_field("path"))?,
            display_name: field_display_name,
            file_id: field_file_id,
            file_size: field_file_size,
            file_count: field_file_count,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("path", &self.path)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("file_id", &self.file_id)?;
        s.serialize_field("file_size", &self.file_size)?;
        s.serialize_field("file_count", &self.file_count)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FolderLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderLogInfo", FOLDER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderLogInfo", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Updated folder overview.
#[derive(Debug)]
pub struct FolderOverviewDescriptionChangedDetails {
    /// Folder Overview location position in the Assets list.
    pub folder_overview_location_asset: u64,
}

impl FolderOverviewDescriptionChangedDetails {
    pub fn new(folder_overview_location_asset: u64) -> Self {
        FolderOverviewDescriptionChangedDetails {
            folder_overview_location_asset,
        }
    }

}

const FOLDER_OVERVIEW_DESCRIPTION_CHANGED_DETAILS_FIELDS: &[&str] = &["folder_overview_location_asset"];
impl FolderOverviewDescriptionChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FolderOverviewDescriptionChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FolderOverviewDescriptionChangedDetails>, V::Error> {
        let mut field_folder_overview_location_asset = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "folder_overview_location_asset" => {
                    if field_folder_overview_location_asset.is_some() {
                        return Err(::serde::de::Error::duplicate_field("folder_overview_location_asset"));
                    }
                    field_folder_overview_location_asset = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FolderOverviewDescriptionChangedDetails {
            folder_overview_location_asset: field_folder_overview_location_asset.ok_or_else(|| ::serde::de::Error::missing_field("folder_overview_location_asset"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("folder_overview_location_asset", &self.folder_overview_location_asset)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderOverviewDescriptionChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderOverviewDescriptionChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FolderOverviewDescriptionChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderOverviewDescriptionChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderOverviewDescriptionChangedDetails", FOLDER_OVERVIEW_DESCRIPTION_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderOverviewDescriptionChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderOverviewDescriptionChangedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FolderOverviewDescriptionChangedType {
    pub description: String,
}

impl FolderOverviewDescriptionChangedType {
    pub fn new(description: String) -> Self {
        FolderOverviewDescriptionChangedType {
            description,
        }
    }

}

const FOLDER_OVERVIEW_DESCRIPTION_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl FolderOverviewDescriptionChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FolderOverviewDescriptionChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FolderOverviewDescriptionChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FolderOverviewDescriptionChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderOverviewDescriptionChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderOverviewDescriptionChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FolderOverviewDescriptionChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderOverviewDescriptionChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderOverviewDescriptionChangedType", FOLDER_OVERVIEW_DESCRIPTION_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderOverviewDescriptionChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderOverviewDescriptionChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Pinned item to folder overview.
#[derive(Debug)]
pub struct FolderOverviewItemPinnedDetails {
    /// Folder Overview location position in the Assets list.
    pub folder_overview_location_asset: u64,
    /// Pinned items positions in the Assets list.
    pub pinned_items_asset_indices: Vec<u64>,
}

impl FolderOverviewItemPinnedDetails {
    pub fn new(folder_overview_location_asset: u64, pinned_items_asset_indices: Vec<u64>) -> Self {
        FolderOverviewItemPinnedDetails {
            folder_overview_location_asset,
            pinned_items_asset_indices,
        }
    }

}

const FOLDER_OVERVIEW_ITEM_PINNED_DETAILS_FIELDS: &[&str] = &["folder_overview_location_asset",
                                                              "pinned_items_asset_indices"];
impl FolderOverviewItemPinnedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FolderOverviewItemPinnedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FolderOverviewItemPinnedDetails>, V::Error> {
        let mut field_folder_overview_location_asset = None;
        let mut field_pinned_items_asset_indices = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "folder_overview_location_asset" => {
                    if field_folder_overview_location_asset.is_some() {
                        return Err(::serde::de::Error::duplicate_field("folder_overview_location_asset"));
                    }
                    field_folder_overview_location_asset = Some(map.next_value()?);
                }
                "pinned_items_asset_indices" => {
                    if field_pinned_items_asset_indices.is_some() {
                        return Err(::serde::de::Error::duplicate_field("pinned_items_asset_indices"));
                    }
                    field_pinned_items_asset_indices = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FolderOverviewItemPinnedDetails {
            folder_overview_location_asset: field_folder_overview_location_asset.ok_or_else(|| ::serde::de::Error::missing_field("folder_overview_location_asset"))?,
            pinned_items_asset_indices: field_pinned_items_asset_indices.ok_or_else(|| ::serde::de::Error::missing_field("pinned_items_asset_indices"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("folder_overview_location_asset", &self.folder_overview_location_asset)?;
        s.serialize_field("pinned_items_asset_indices", &self.pinned_items_asset_indices)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderOverviewItemPinnedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderOverviewItemPinnedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FolderOverviewItemPinnedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderOverviewItemPinnedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderOverviewItemPinnedDetails", FOLDER_OVERVIEW_ITEM_PINNED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderOverviewItemPinnedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderOverviewItemPinnedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FolderOverviewItemPinnedType {
    pub description: String,
}

impl FolderOverviewItemPinnedType {
    pub fn new(description: String) -> Self {
        FolderOverviewItemPinnedType {
            description,
        }
    }

}

const FOLDER_OVERVIEW_ITEM_PINNED_TYPE_FIELDS: &[&str] = &["description"];
impl FolderOverviewItemPinnedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FolderOverviewItemPinnedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FolderOverviewItemPinnedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FolderOverviewItemPinnedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderOverviewItemPinnedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderOverviewItemPinnedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FolderOverviewItemPinnedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderOverviewItemPinnedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderOverviewItemPinnedType", FOLDER_OVERVIEW_ITEM_PINNED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderOverviewItemPinnedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderOverviewItemPinnedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unpinned item from folder overview.
#[derive(Debug)]
pub struct FolderOverviewItemUnpinnedDetails {
    /// Folder Overview location position in the Assets list.
    pub folder_overview_location_asset: u64,
    /// Pinned items positions in the Assets list.
    pub pinned_items_asset_indices: Vec<u64>,
}

impl FolderOverviewItemUnpinnedDetails {
    pub fn new(folder_overview_location_asset: u64, pinned_items_asset_indices: Vec<u64>) -> Self {
        FolderOverviewItemUnpinnedDetails {
            folder_overview_location_asset,
            pinned_items_asset_indices,
        }
    }

}

const FOLDER_OVERVIEW_ITEM_UNPINNED_DETAILS_FIELDS: &[&str] = &["folder_overview_location_asset",
                                                                "pinned_items_asset_indices"];
impl FolderOverviewItemUnpinnedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FolderOverviewItemUnpinnedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FolderOverviewItemUnpinnedDetails>, V::Error> {
        let mut field_folder_overview_location_asset = None;
        let mut field_pinned_items_asset_indices = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "folder_overview_location_asset" => {
                    if field_folder_overview_location_asset.is_some() {
                        return Err(::serde::de::Error::duplicate_field("folder_overview_location_asset"));
                    }
                    field_folder_overview_location_asset = Some(map.next_value()?);
                }
                "pinned_items_asset_indices" => {
                    if field_pinned_items_asset_indices.is_some() {
                        return Err(::serde::de::Error::duplicate_field("pinned_items_asset_indices"));
                    }
                    field_pinned_items_asset_indices = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FolderOverviewItemUnpinnedDetails {
            folder_overview_location_asset: field_folder_overview_location_asset.ok_or_else(|| ::serde::de::Error::missing_field("folder_overview_location_asset"))?,
            pinned_items_asset_indices: field_pinned_items_asset_indices.ok_or_else(|| ::serde::de::Error::missing_field("pinned_items_asset_indices"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("folder_overview_location_asset", &self.folder_overview_location_asset)?;
        s.serialize_field("pinned_items_asset_indices", &self.pinned_items_asset_indices)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderOverviewItemUnpinnedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderOverviewItemUnpinnedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FolderOverviewItemUnpinnedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderOverviewItemUnpinnedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderOverviewItemUnpinnedDetails", FOLDER_OVERVIEW_ITEM_UNPINNED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderOverviewItemUnpinnedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderOverviewItemUnpinnedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct FolderOverviewItemUnpinnedType {
    pub description: String,
}

impl FolderOverviewItemUnpinnedType {
    pub fn new(description: String) -> Self {
        FolderOverviewItemUnpinnedType {
            description,
        }
    }

}

const FOLDER_OVERVIEW_ITEM_UNPINNED_TYPE_FIELDS: &[&str] = &["description"];
impl FolderOverviewItemUnpinnedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FolderOverviewItemUnpinnedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FolderOverviewItemUnpinnedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FolderOverviewItemUnpinnedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FolderOverviewItemUnpinnedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FolderOverviewItemUnpinnedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a FolderOverviewItemUnpinnedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FolderOverviewItemUnpinnedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FolderOverviewItemUnpinnedType", FOLDER_OVERVIEW_ITEM_UNPINNED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FolderOverviewItemUnpinnedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FolderOverviewItemUnpinnedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Geographic location details.
#[derive(Debug)]
pub struct GeoLocationLogInfo {
    /// IP address.
    pub ip_address: IpAddress,
    /// City name.
    pub city: Option<String>,
    /// Region name.
    pub region: Option<String>,
    /// Country code.
    pub country: Option<String>,
}

impl GeoLocationLogInfo {
    pub fn new(ip_address: IpAddress) -> Self {
        GeoLocationLogInfo {
            ip_address,
            city: None,
            region: None,
            country: None,
        }
    }

    pub fn with_city(mut self, value: Option<String>) -> Self {
        self.city = value;
        self
    }

    pub fn with_region(mut self, value: Option<String>) -> Self {
        self.region = value;
        self
    }

    pub fn with_country(mut self, value: Option<String>) -> Self {
        self.country = value;
        self
    }

}

const GEO_LOCATION_LOG_INFO_FIELDS: &[&str] = &["ip_address",
                                                "city",
                                                "region",
                                                "country"];
impl GeoLocationLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GeoLocationLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GeoLocationLogInfo>, V::Error> {
        let mut field_ip_address = None;
        let mut field_city = None;
        let mut field_region = None;
        let mut field_country = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(::serde::de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "city" => {
                    if field_city.is_some() {
                        return Err(::serde::de::Error::duplicate_field("city"));
                    }
                    field_city = Some(map.next_value()?);
                }
                "region" => {
                    if field_region.is_some() {
                        return Err(::serde::de::Error::duplicate_field("region"));
                    }
                    field_region = Some(map.next_value()?);
                }
                "country" => {
                    if field_country.is_some() {
                        return Err(::serde::de::Error::duplicate_field("country"));
                    }
                    field_country = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GeoLocationLogInfo {
            ip_address: field_ip_address.ok_or_else(|| ::serde::de::Error::missing_field("ip_address"))?,
            city: field_city,
            region: field_region,
            country: field_country,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("city", &self.city)?;
        s.serialize_field("region", &self.region)?;
        s.serialize_field("country", &self.country)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GeoLocationLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GeoLocationLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GeoLocationLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GeoLocationLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GeoLocationLogInfo", GEO_LOCATION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GeoLocationLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GeoLocationLogInfo", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetTeamEventsArg {
    /// The maximal number of results to return per call. Note that some calls may not return
    /// `limit` number of events, and may even return no events, even with `has_more` set to true.
    /// In this case, callers should fetch again using
    /// [`get_events_continue()`](get_events_continue).
    pub limit: u32,
    /// Filter the events by account ID. Return ony events with this account_id as either Actor,
    /// Context, or Participants.
    pub account_id: Option<super::users_common::AccountId>,
    /// Filter by time range.
    pub time: Option<super::team_common::TimeRange>,
    /// Filter the returned events to a single category.
    pub category: Option<EventCategory>,
}

impl Default for GetTeamEventsArg {
    fn default() -> Self {
        GetTeamEventsArg {
            limit: 1000,
            account_id: None,
            time: None,
            category: None,
        }
    }
}

const GET_TEAM_EVENTS_ARG_FIELDS: &[&str] = &["limit",
                                              "account_id",
                                              "time",
                                              "category"];
impl GetTeamEventsArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GetTeamEventsArg, V::Error> {
        let mut field_limit = None;
        let mut field_account_id = None;
        let mut field_time = None;
        let mut field_category = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "time" => {
                    if field_time.is_some() {
                        return Err(::serde::de::Error::duplicate_field("time"));
                    }
                    field_time = Some(map.next_value()?);
                }
                "category" => {
                    if field_category.is_some() {
                        return Err(::serde::de::Error::duplicate_field("category"));
                    }
                    field_category = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = GetTeamEventsArg {
            limit: field_limit.unwrap_or(1000),
            account_id: field_account_id,
            time: field_time,
            category: field_category,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)?;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("time", &self.time)?;
        s.serialize_field("category", &self.category)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetTeamEventsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetTeamEventsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetTeamEventsArg", GET_TEAM_EVENTS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetTeamEventsArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetTeamEventsContinueArg {
    /// Indicates from what point to get the next set of events.
    pub cursor: String,
}

impl GetTeamEventsContinueArg {
    pub fn new(cursor: String) -> Self {
        GetTeamEventsContinueArg {
            cursor,
        }
    }

}

const GET_TEAM_EVENTS_CONTINUE_ARG_FIELDS: &[&str] = &["cursor"];
impl GetTeamEventsContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GetTeamEventsContinueArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GetTeamEventsContinueArg>, V::Error> {
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GetTeamEventsContinueArg {
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetTeamEventsContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetTeamEventsContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetTeamEventsContinueArg", GET_TEAM_EVENTS_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetTeamEventsContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Errors that can be raised when calling [`get_events_continue()`](get_events_continue).
#[derive(Debug)]
pub enum GetTeamEventsContinueError {
    /// Bad cursor.
    BadCursor,
    /// Cursors are intended to be used quickly. Individual cursor values are normally valid for
    /// days, but in rare cases may be reset sooner. Cursor reset errors should be handled by
    /// fetching a new cursor from [`get_events()`](get_events). The associated value is the
    /// approximate timestamp of the most recent event returned by the cursor. This should be used
    /// as a resumption point when calling [`get_events()`](get_events) to obtain a new cursor.
    Reset(super::common::DropboxTimestamp),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetTeamEventsContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "bad_cursor" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GetTeamEventsContinueError::BadCursor)
                    }
                    "reset" => {
                        match map.next_key()? {
                            Some("reset") => Ok(GetTeamEventsContinueError::Reset(map.next_value()?)),
                            None => Err(de::Error::missing_field("reset")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GetTeamEventsContinueError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["bad_cursor",
                                    "reset",
                                    "other"];
        deserializer.deserialize_struct("GetTeamEventsContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetTeamEventsContinueError::BadCursor => {
                // unit
                let mut s = serializer.serialize_struct("GetTeamEventsContinueError", 1)?;
                s.serialize_field(".tag", "bad_cursor")?;
                s.end()
            }
            GetTeamEventsContinueError::Reset(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GetTeamEventsContinueError", 2)?;
                s.serialize_field(".tag", "reset")?;
                s.serialize_field("reset", x)?;
                s.end()
            }
            GetTeamEventsContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetTeamEventsContinueError {
    fn description(&self) -> &str {
        "GetTeamEventsContinueError"
    }
}

impl ::std::fmt::Display for GetTeamEventsContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Errors that can be raised when calling [`get_events()`](get_events).
#[derive(Debug)]
pub enum GetTeamEventsError {
    /// No user found matching the provided account_id.
    AccountIdNotFound,
    /// Invalid time range.
    InvalidTimeRange,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetTeamEventsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "account_id_not_found" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GetTeamEventsError::AccountIdNotFound)
                    }
                    "invalid_time_range" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GetTeamEventsError::InvalidTimeRange)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GetTeamEventsError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["account_id_not_found",
                                    "invalid_time_range",
                                    "other"];
        deserializer.deserialize_struct("GetTeamEventsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetTeamEventsError::AccountIdNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GetTeamEventsError", 1)?;
                s.serialize_field(".tag", "account_id_not_found")?;
                s.end()
            }
            GetTeamEventsError::InvalidTimeRange => {
                // unit
                let mut s = serializer.serialize_struct("GetTeamEventsError", 1)?;
                s.serialize_field(".tag", "invalid_time_range")?;
                s.end()
            }
            GetTeamEventsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GetTeamEventsError {
    fn description(&self) -> &str {
        "GetTeamEventsError"
    }
}

impl ::std::fmt::Display for GetTeamEventsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GetTeamEventsResult {
    /// List of events. Note that events are not guaranteed to be sorted by their timestamp value.
    pub events: Vec<TeamEvent>,
    /// Pass the cursor into [`get_events_continue()`](get_events_continue) to obtain additional
    /// events. The value of `cursor` may change for each response from
    /// [`get_events_continue()`](get_events_continue), regardless of the value of `has_more`; older
    /// cursor strings may expire. Thus, callers should ensure that they update their cursor based
    /// on the latest value of `cursor` after each call, and poll regularly if they wish to poll for
    /// new events. Callers should handle reset exceptions for expired cursors.
    pub cursor: String,
    /// Is true if there may be additional events that have not been returned yet. An additional
    /// call to [`get_events_continue()`](get_events_continue) can retrieve them. Note that
    /// `has_more` may be `true`, even if `events` is empty.
    pub has_more: bool,
}

impl GetTeamEventsResult {
    pub fn new(events: Vec<TeamEvent>, cursor: String, has_more: bool) -> Self {
        GetTeamEventsResult {
            events,
            cursor,
            has_more,
        }
    }

}

const GET_TEAM_EVENTS_RESULT_FIELDS: &[&str] = &["events",
                                                 "cursor",
                                                 "has_more"];
impl GetTeamEventsResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GetTeamEventsResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GetTeamEventsResult>, V::Error> {
        let mut field_events = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "events" => {
                    if field_events.is_some() {
                        return Err(::serde::de::Error::duplicate_field("events"));
                    }
                    field_events = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(::serde::de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GetTeamEventsResult {
            events: field_events.ok_or_else(|| ::serde::de::Error::missing_field("events"))?,
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
            has_more: field_has_more.ok_or_else(|| ::serde::de::Error::missing_field("has_more"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("events", &self.events)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetTeamEventsResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetTeamEventsResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GetTeamEventsResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetTeamEventsResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetTeamEventsResult", GET_TEAM_EVENTS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetTeamEventsResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetTeamEventsResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled Google single sign-on for team.
#[derive(Debug)]
pub struct GoogleSsoChangePolicyDetails {
    /// New Google single sign-on policy.
    pub new_value: GoogleSsoPolicy,
    /// Previous Google single sign-on policy. Might be missing due to historical data gap.
    pub previous_value: Option<GoogleSsoPolicy>,
}

impl GoogleSsoChangePolicyDetails {
    pub fn new(new_value: GoogleSsoPolicy) -> Self {
        GoogleSsoChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<GoogleSsoPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const GOOGLE_SSO_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl GoogleSsoChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GoogleSsoChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GoogleSsoChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GoogleSsoChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GoogleSsoChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GoogleSsoChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GoogleSsoChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GoogleSsoChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GoogleSsoChangePolicyDetails", GOOGLE_SSO_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GoogleSsoChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GoogleSsoChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GoogleSsoChangePolicyType {
    pub description: String,
}

impl GoogleSsoChangePolicyType {
    pub fn new(description: String) -> Self {
        GoogleSsoChangePolicyType {
            description,
        }
    }

}

const GOOGLE_SSO_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl GoogleSsoChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GoogleSsoChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GoogleSsoChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GoogleSsoChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GoogleSsoChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GoogleSsoChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GoogleSsoChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GoogleSsoChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GoogleSsoChangePolicyType", GOOGLE_SSO_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GoogleSsoChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GoogleSsoChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Google SSO policy
#[derive(Debug)]
pub enum GoogleSsoPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GoogleSsoPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GoogleSsoPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GoogleSsoPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GoogleSsoPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GoogleSsoPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GoogleSsoPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("GoogleSsoPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GoogleSsoPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GoogleSsoPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("GoogleSsoPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            GoogleSsoPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("GoogleSsoPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            GoogleSsoPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added external ID for group.
#[derive(Debug)]
pub struct GroupAddExternalIdDetails {
    /// Current external id.
    pub new_value: super::team_common::GroupExternalId,
}

impl GroupAddExternalIdDetails {
    pub fn new(new_value: super::team_common::GroupExternalId) -> Self {
        GroupAddExternalIdDetails {
            new_value,
        }
    }

}

const GROUP_ADD_EXTERNAL_ID_DETAILS_FIELDS: &[&str] = &["new_value"];
impl GroupAddExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupAddExternalIdDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupAddExternalIdDetails>, V::Error> {
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupAddExternalIdDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupAddExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddExternalIdDetails", GROUP_ADD_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddExternalIdDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupAddExternalIdType {
    pub description: String,
}

impl GroupAddExternalIdType {
    pub fn new(description: String) -> Self {
        GroupAddExternalIdType {
            description,
        }
    }

}

const GROUP_ADD_EXTERNAL_ID_TYPE_FIELDS: &[&str] = &["description"];
impl GroupAddExternalIdType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupAddExternalIdType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupAddExternalIdType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupAddExternalIdType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddExternalIdType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddExternalIdType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupAddExternalIdType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddExternalIdType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddExternalIdType", GROUP_ADD_EXTERNAL_ID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddExternalIdType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddExternalIdType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added team members to group.
#[derive(Debug)]
pub struct GroupAddMemberDetails {
    /// Is group owner.
    pub is_group_owner: bool,
}

impl GroupAddMemberDetails {
    pub fn new(is_group_owner: bool) -> Self {
        GroupAddMemberDetails {
            is_group_owner,
        }
    }

}

const GROUP_ADD_MEMBER_DETAILS_FIELDS: &[&str] = &["is_group_owner"];
impl GroupAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupAddMemberDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupAddMemberDetails>, V::Error> {
        let mut field_is_group_owner = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "is_group_owner" => {
                    if field_is_group_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_group_owner"));
                    }
                    field_is_group_owner = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupAddMemberDetails {
            is_group_owner: field_is_group_owner.ok_or_else(|| ::serde::de::Error::missing_field("is_group_owner"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_group_owner", &self.is_group_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddMemberDetails", GROUP_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupAddMemberType {
    pub description: String,
}

impl GroupAddMemberType {
    pub fn new(description: String) -> Self {
        GroupAddMemberType {
            description,
        }
    }

}

const GROUP_ADD_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl GroupAddMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupAddMemberType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupAddMemberType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupAddMemberType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAddMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupAddMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupAddMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupAddMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupAddMemberType", GROUP_ADD_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAddMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupAddMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed external ID for group.
#[derive(Debug)]
pub struct GroupChangeExternalIdDetails {
    /// Current external id.
    pub new_value: super::team_common::GroupExternalId,
    /// Old external id.
    pub previous_value: super::team_common::GroupExternalId,
}

impl GroupChangeExternalIdDetails {
    pub fn new(
        new_value: super::team_common::GroupExternalId,
        previous_value: super::team_common::GroupExternalId,
    ) -> Self {
        GroupChangeExternalIdDetails {
            new_value,
            previous_value,
        }
    }

}

const GROUP_CHANGE_EXTERNAL_ID_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl GroupChangeExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupChangeExternalIdDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupChangeExternalIdDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupChangeExternalIdDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupChangeExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeExternalIdDetails", GROUP_CHANGE_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeExternalIdDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupChangeExternalIdType {
    pub description: String,
}

impl GroupChangeExternalIdType {
    pub fn new(description: String) -> Self {
        GroupChangeExternalIdType {
            description,
        }
    }

}

const GROUP_CHANGE_EXTERNAL_ID_TYPE_FIELDS: &[&str] = &["description"];
impl GroupChangeExternalIdType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupChangeExternalIdType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupChangeExternalIdType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupChangeExternalIdType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeExternalIdType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeExternalIdType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupChangeExternalIdType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeExternalIdType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeExternalIdType", GROUP_CHANGE_EXTERNAL_ID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeExternalIdType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeExternalIdType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed group management type.
#[derive(Debug)]
pub struct GroupChangeManagementTypeDetails {
    /// New group management type.
    pub new_value: super::team_common::GroupManagementType,
    /// Previous group management type. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_common::GroupManagementType>,
}

impl GroupChangeManagementTypeDetails {
    pub fn new(new_value: super::team_common::GroupManagementType) -> Self {
        GroupChangeManagementTypeDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_common::GroupManagementType>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const GROUP_CHANGE_MANAGEMENT_TYPE_DETAILS_FIELDS: &[&str] = &["new_value",
                                                               "previous_value"];
impl GroupChangeManagementTypeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupChangeManagementTypeDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupChangeManagementTypeDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupChangeManagementTypeDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeManagementTypeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeManagementTypeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupChangeManagementTypeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeManagementTypeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeManagementTypeDetails", GROUP_CHANGE_MANAGEMENT_TYPE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeManagementTypeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeManagementTypeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupChangeManagementTypeType {
    pub description: String,
}

impl GroupChangeManagementTypeType {
    pub fn new(description: String) -> Self {
        GroupChangeManagementTypeType {
            description,
        }
    }

}

const GROUP_CHANGE_MANAGEMENT_TYPE_TYPE_FIELDS: &[&str] = &["description"];
impl GroupChangeManagementTypeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupChangeManagementTypeType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupChangeManagementTypeType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupChangeManagementTypeType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeManagementTypeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeManagementTypeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupChangeManagementTypeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeManagementTypeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeManagementTypeType", GROUP_CHANGE_MANAGEMENT_TYPE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeManagementTypeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeManagementTypeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed manager permissions of group member.
#[derive(Debug)]
pub struct GroupChangeMemberRoleDetails {
    /// Is group owner.
    pub is_group_owner: bool,
}

impl GroupChangeMemberRoleDetails {
    pub fn new(is_group_owner: bool) -> Self {
        GroupChangeMemberRoleDetails {
            is_group_owner,
        }
    }

}

const GROUP_CHANGE_MEMBER_ROLE_DETAILS_FIELDS: &[&str] = &["is_group_owner"];
impl GroupChangeMemberRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupChangeMemberRoleDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupChangeMemberRoleDetails>, V::Error> {
        let mut field_is_group_owner = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "is_group_owner" => {
                    if field_is_group_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_group_owner"));
                    }
                    field_is_group_owner = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupChangeMemberRoleDetails {
            is_group_owner: field_is_group_owner.ok_or_else(|| ::serde::de::Error::missing_field("is_group_owner"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_group_owner", &self.is_group_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeMemberRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeMemberRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupChangeMemberRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeMemberRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeMemberRoleDetails", GROUP_CHANGE_MEMBER_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeMemberRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeMemberRoleDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupChangeMemberRoleType {
    pub description: String,
}

impl GroupChangeMemberRoleType {
    pub fn new(description: String) -> Self {
        GroupChangeMemberRoleType {
            description,
        }
    }

}

const GROUP_CHANGE_MEMBER_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl GroupChangeMemberRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupChangeMemberRoleType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupChangeMemberRoleType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupChangeMemberRoleType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupChangeMemberRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupChangeMemberRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupChangeMemberRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupChangeMemberRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupChangeMemberRoleType", GROUP_CHANGE_MEMBER_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupChangeMemberRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupChangeMemberRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created group.
#[derive(Debug)]
pub struct GroupCreateDetails {
    /// Is company managed group. Might be missing due to historical data gap.
    pub is_company_managed: Option<bool>,
    /// Group join policy.
    pub join_policy: Option<GroupJoinPolicy>,
}

impl Default for GroupCreateDetails {
    fn default() -> Self {
        GroupCreateDetails {
            is_company_managed: None,
            join_policy: None,
        }
    }
}

const GROUP_CREATE_DETAILS_FIELDS: &[&str] = &["is_company_managed",
                                               "join_policy"];
impl GroupCreateDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupCreateDetails, V::Error> {
        let mut field_is_company_managed = None;
        let mut field_join_policy = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "is_company_managed" => {
                    if field_is_company_managed.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_company_managed"));
                    }
                    field_is_company_managed = Some(map.next_value()?);
                }
                "join_policy" => {
                    if field_join_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("join_policy"));
                    }
                    field_join_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = GroupCreateDetails {
            is_company_managed: field_is_company_managed,
            join_policy: field_join_policy,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_company_managed", &self.is_company_managed)?;
        s.serialize_field("join_policy", &self.join_policy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupCreateDetails", GROUP_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupCreateDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupCreateType {
    pub description: String,
}

impl GroupCreateType {
    pub fn new(description: String) -> Self {
        GroupCreateType {
            description,
        }
    }

}

const GROUP_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl GroupCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupCreateType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupCreateType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupCreateType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupCreateType", GROUP_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted group.
#[derive(Debug)]
pub struct GroupDeleteDetails {
    /// Is company managed group. Might be missing due to historical data gap.
    pub is_company_managed: Option<bool>,
}

impl Default for GroupDeleteDetails {
    fn default() -> Self {
        GroupDeleteDetails {
            is_company_managed: None,
        }
    }
}

const GROUP_DELETE_DETAILS_FIELDS: &[&str] = &["is_company_managed"];
impl GroupDeleteDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupDeleteDetails, V::Error> {
        let mut field_is_company_managed = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "is_company_managed" => {
                    if field_is_company_managed.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_company_managed"));
                    }
                    field_is_company_managed = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = GroupDeleteDetails {
            is_company_managed: field_is_company_managed,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_company_managed", &self.is_company_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupDeleteDetails", GROUP_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupDeleteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupDeleteType {
    pub description: String,
}

impl GroupDeleteType {
    pub fn new(description: String) -> Self {
        GroupDeleteType {
            description,
        }
    }

}

const GROUP_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl GroupDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupDeleteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupDeleteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupDeleteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupDeleteType", GROUP_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Updated group.
#[derive(Debug)]
pub struct GroupDescriptionUpdatedDetails {
}

impl Default for GroupDescriptionUpdatedDetails {
    fn default() -> Self {
        GroupDescriptionUpdatedDetails {
        }
    }
}

const GROUP_DESCRIPTION_UPDATED_DETAILS_FIELDS: &[&str] = &[];
impl GroupDescriptionUpdatedDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupDescriptionUpdatedDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(GroupDescriptionUpdatedDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupDescriptionUpdatedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupDescriptionUpdatedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupDescriptionUpdatedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupDescriptionUpdatedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupDescriptionUpdatedDetails", GROUP_DESCRIPTION_UPDATED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupDescriptionUpdatedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("GroupDescriptionUpdatedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct GroupDescriptionUpdatedType {
    pub description: String,
}

impl GroupDescriptionUpdatedType {
    pub fn new(description: String) -> Self {
        GroupDescriptionUpdatedType {
            description,
        }
    }

}

const GROUP_DESCRIPTION_UPDATED_TYPE_FIELDS: &[&str] = &["description"];
impl GroupDescriptionUpdatedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupDescriptionUpdatedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupDescriptionUpdatedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupDescriptionUpdatedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupDescriptionUpdatedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupDescriptionUpdatedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupDescriptionUpdatedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupDescriptionUpdatedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupDescriptionUpdatedType", GROUP_DESCRIPTION_UPDATED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupDescriptionUpdatedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupDescriptionUpdatedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupJoinPolicy {
    Open,
    RequestToJoin,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupJoinPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupJoinPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupJoinPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "open" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GroupJoinPolicy::Open)
                    }
                    "request_to_join" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GroupJoinPolicy::RequestToJoin)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GroupJoinPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["open",
                                    "request_to_join",
                                    "other"];
        deserializer.deserialize_struct("GroupJoinPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupJoinPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupJoinPolicy::Open => {
                // unit
                let mut s = serializer.serialize_struct("GroupJoinPolicy", 1)?;
                s.serialize_field(".tag", "open")?;
                s.end()
            }
            GroupJoinPolicy::RequestToJoin => {
                // unit
                let mut s = serializer.serialize_struct("GroupJoinPolicy", 1)?;
                s.serialize_field(".tag", "request_to_join")?;
                s.end()
            }
            GroupJoinPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Updated group join policy.
#[derive(Debug)]
pub struct GroupJoinPolicyUpdatedDetails {
    /// Is company managed group. Might be missing due to historical data gap.
    pub is_company_managed: Option<bool>,
    /// Group join policy.
    pub join_policy: Option<GroupJoinPolicy>,
}

impl Default for GroupJoinPolicyUpdatedDetails {
    fn default() -> Self {
        GroupJoinPolicyUpdatedDetails {
            is_company_managed: None,
            join_policy: None,
        }
    }
}

const GROUP_JOIN_POLICY_UPDATED_DETAILS_FIELDS: &[&str] = &["is_company_managed",
                                                            "join_policy"];
impl GroupJoinPolicyUpdatedDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupJoinPolicyUpdatedDetails, V::Error> {
        let mut field_is_company_managed = None;
        let mut field_join_policy = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "is_company_managed" => {
                    if field_is_company_managed.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_company_managed"));
                    }
                    field_is_company_managed = Some(map.next_value()?);
                }
                "join_policy" => {
                    if field_join_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("join_policy"));
                    }
                    field_join_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = GroupJoinPolicyUpdatedDetails {
            is_company_managed: field_is_company_managed,
            join_policy: field_join_policy,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_company_managed", &self.is_company_managed)?;
        s.serialize_field("join_policy", &self.join_policy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupJoinPolicyUpdatedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupJoinPolicyUpdatedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupJoinPolicyUpdatedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupJoinPolicyUpdatedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupJoinPolicyUpdatedDetails", GROUP_JOIN_POLICY_UPDATED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupJoinPolicyUpdatedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupJoinPolicyUpdatedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupJoinPolicyUpdatedType {
    pub description: String,
}

impl GroupJoinPolicyUpdatedType {
    pub fn new(description: String) -> Self {
        GroupJoinPolicyUpdatedType {
            description,
        }
    }

}

const GROUP_JOIN_POLICY_UPDATED_TYPE_FIELDS: &[&str] = &["description"];
impl GroupJoinPolicyUpdatedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupJoinPolicyUpdatedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupJoinPolicyUpdatedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupJoinPolicyUpdatedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupJoinPolicyUpdatedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupJoinPolicyUpdatedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupJoinPolicyUpdatedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupJoinPolicyUpdatedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupJoinPolicyUpdatedType", GROUP_JOIN_POLICY_UPDATED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupJoinPolicyUpdatedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupJoinPolicyUpdatedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Group's logged information.
#[derive(Debug)]
pub struct GroupLogInfo {
    /// The name of this group.
    pub display_name: String,
    /// The unique id of this group. Might be missing due to historical data gap.
    pub group_id: Option<super::team_common::GroupId>,
    /// External group ID. Might be missing due to historical data gap.
    pub external_id: Option<super::team_common::GroupExternalId>,
}

impl GroupLogInfo {
    pub fn new(display_name: String) -> Self {
        GroupLogInfo {
            display_name,
            group_id: None,
            external_id: None,
        }
    }

    pub fn with_group_id(mut self, value: Option<super::team_common::GroupId>) -> Self {
        self.group_id = value;
        self
    }

    pub fn with_external_id(mut self, value: Option<super::team_common::GroupExternalId>) -> Self {
        self.external_id = value;
        self
    }

}

const GROUP_LOG_INFO_FIELDS: &[&str] = &["display_name",
                                         "group_id",
                                         "external_id"];
impl GroupLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupLogInfo>, V::Error> {
        let mut field_display_name = None;
        let mut field_group_id = None;
        let mut field_external_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "group_id" => {
                    if field_group_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("group_id"));
                    }
                    field_group_id = Some(map.next_value()?);
                }
                "external_id" => {
                    if field_external_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("external_id"));
                    }
                    field_external_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupLogInfo {
            display_name: field_display_name.ok_or_else(|| ::serde::de::Error::missing_field("display_name"))?,
            group_id: field_group_id,
            external_id: field_external_id,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("group_id", &self.group_id)?;
        s.serialize_field("external_id", &self.external_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupLogInfo", GROUP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Moved group.
#[derive(Debug)]
pub struct GroupMovedDetails {
}

impl Default for GroupMovedDetails {
    fn default() -> Self {
        GroupMovedDetails {
        }
    }
}

const GROUP_MOVED_DETAILS_FIELDS: &[&str] = &[];
impl GroupMovedDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupMovedDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(GroupMovedDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMovedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMovedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupMovedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMovedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMovedDetails", GROUP_MOVED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMovedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("GroupMovedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct GroupMovedType {
    pub description: String,
}

impl GroupMovedType {
    pub fn new(description: String) -> Self {
        GroupMovedType {
            description,
        }
    }

}

const GROUP_MOVED_TYPE_FIELDS: &[&str] = &["description"];
impl GroupMovedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupMovedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupMovedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupMovedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMovedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMovedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupMovedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMovedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMovedType", GROUP_MOVED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMovedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMovedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed external ID for group.
#[derive(Debug)]
pub struct GroupRemoveExternalIdDetails {
    /// Old external id.
    pub previous_value: super::team_common::GroupExternalId,
}

impl GroupRemoveExternalIdDetails {
    pub fn new(previous_value: super::team_common::GroupExternalId) -> Self {
        GroupRemoveExternalIdDetails {
            previous_value,
        }
    }

}

const GROUP_REMOVE_EXTERNAL_ID_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl GroupRemoveExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupRemoveExternalIdDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupRemoveExternalIdDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupRemoveExternalIdDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveExternalIdDetails", GROUP_REMOVE_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRemoveExternalIdDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupRemoveExternalIdType {
    pub description: String,
}

impl GroupRemoveExternalIdType {
    pub fn new(description: String) -> Self {
        GroupRemoveExternalIdType {
            description,
        }
    }

}

const GROUP_REMOVE_EXTERNAL_ID_TYPE_FIELDS: &[&str] = &["description"];
impl GroupRemoveExternalIdType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupRemoveExternalIdType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupRemoveExternalIdType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupRemoveExternalIdType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveExternalIdType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveExternalIdType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveExternalIdType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveExternalIdType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveExternalIdType", GROUP_REMOVE_EXTERNAL_ID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveExternalIdType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRemoveExternalIdType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed team members from group.
#[derive(Debug)]
pub struct GroupRemoveMemberDetails {
}

impl Default for GroupRemoveMemberDetails {
    fn default() -> Self {
        GroupRemoveMemberDetails {
        }
    }
}

const GROUP_REMOVE_MEMBER_DETAILS_FIELDS: &[&str] = &[];
impl GroupRemoveMemberDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupRemoveMemberDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(GroupRemoveMemberDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveMemberDetails", GROUP_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("GroupRemoveMemberDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct GroupRemoveMemberType {
    pub description: String,
}

impl GroupRemoveMemberType {
    pub fn new(description: String) -> Self {
        GroupRemoveMemberType {
            description,
        }
    }

}

const GROUP_REMOVE_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl GroupRemoveMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupRemoveMemberType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupRemoveMemberType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupRemoveMemberType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRemoveMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRemoveMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupRemoveMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRemoveMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRemoveMemberType", GROUP_REMOVE_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRemoveMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRemoveMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed group.
#[derive(Debug)]
pub struct GroupRenameDetails {
    /// Previous display name.
    pub previous_value: String,
    /// New display name.
    pub new_value: String,
}

impl GroupRenameDetails {
    pub fn new(previous_value: String, new_value: String) -> Self {
        GroupRenameDetails {
            previous_value,
            new_value,
        }
    }

}

const GROUP_RENAME_DETAILS_FIELDS: &[&str] = &["previous_value",
                                               "new_value"];
impl GroupRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupRenameDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupRenameDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupRenameDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRenameDetails", GROUP_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRenameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupRenameType {
    pub description: String,
}

impl GroupRenameType {
    pub fn new(description: String) -> Self {
        GroupRenameType {
            description,
        }
    }

}

const GROUP_RENAME_TYPE_FIELDS: &[&str] = &["description"];
impl GroupRenameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupRenameType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupRenameType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupRenameType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupRenameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupRenameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupRenameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupRenameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupRenameType", GROUP_RENAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupRenameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupRenameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can create groups.
#[derive(Debug)]
pub struct GroupUserManagementChangePolicyDetails {
    /// New group users management policy.
    pub new_value: super::team_policies::GroupCreation,
    /// Previous group users management policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::GroupCreation>,
}

impl GroupUserManagementChangePolicyDetails {
    pub fn new(new_value: super::team_policies::GroupCreation) -> Self {
        GroupUserManagementChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_policies::GroupCreation>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const GROUP_USER_MANAGEMENT_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                      "previous_value"];
impl GroupUserManagementChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupUserManagementChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupUserManagementChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupUserManagementChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupUserManagementChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupUserManagementChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupUserManagementChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupUserManagementChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupUserManagementChangePolicyDetails", GROUP_USER_MANAGEMENT_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupUserManagementChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupUserManagementChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupUserManagementChangePolicyType {
    pub description: String,
}

impl GroupUserManagementChangePolicyType {
    pub fn new(description: String) -> Self {
        GroupUserManagementChangePolicyType {
            description,
        }
    }

}

const GROUP_USER_MANAGEMENT_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl GroupUserManagementChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupUserManagementChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupUserManagementChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupUserManagementChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupUserManagementChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupUserManagementChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GroupUserManagementChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupUserManagementChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupUserManagementChangePolicyType", GROUP_USER_MANAGEMENT_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupUserManagementChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupUserManagementChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed guest team admin status.
#[derive(Debug)]
pub struct GuestAdminChangeStatusDetails {
    /// True for guest, false for host.
    pub is_guest: bool,
    /// Previous request state.
    pub previous_value: TrustedTeamsRequestState,
    /// New request state.
    pub new_value: TrustedTeamsRequestState,
    /// Action details.
    pub action_details: TrustedTeamsRequestAction,
    /// The name of the guest team.
    pub guest_team_name: Option<String>,
    /// The name of the host team.
    pub host_team_name: Option<String>,
}

impl GuestAdminChangeStatusDetails {
    pub fn new(
        is_guest: bool,
        previous_value: TrustedTeamsRequestState,
        new_value: TrustedTeamsRequestState,
        action_details: TrustedTeamsRequestAction,
    ) -> Self {
        GuestAdminChangeStatusDetails {
            is_guest,
            previous_value,
            new_value,
            action_details,
            guest_team_name: None,
            host_team_name: None,
        }
    }

    pub fn with_guest_team_name(mut self, value: Option<String>) -> Self {
        self.guest_team_name = value;
        self
    }

    pub fn with_host_team_name(mut self, value: Option<String>) -> Self {
        self.host_team_name = value;
        self
    }

}

const GUEST_ADMIN_CHANGE_STATUS_DETAILS_FIELDS: &[&str] = &["is_guest",
                                                            "previous_value",
                                                            "new_value",
                                                            "action_details",
                                                            "guest_team_name",
                                                            "host_team_name"];
impl GuestAdminChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GuestAdminChangeStatusDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GuestAdminChangeStatusDetails>, V::Error> {
        let mut field_is_guest = None;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut field_action_details = None;
        let mut field_guest_team_name = None;
        let mut field_host_team_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "is_guest" => {
                    if field_is_guest.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_guest"));
                    }
                    field_is_guest = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "action_details" => {
                    if field_action_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("action_details"));
                    }
                    field_action_details = Some(map.next_value()?);
                }
                "guest_team_name" => {
                    if field_guest_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("guest_team_name"));
                    }
                    field_guest_team_name = Some(map.next_value()?);
                }
                "host_team_name" => {
                    if field_host_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("host_team_name"));
                    }
                    field_host_team_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GuestAdminChangeStatusDetails {
            is_guest: field_is_guest.ok_or_else(|| ::serde::de::Error::missing_field("is_guest"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            action_details: field_action_details.ok_or_else(|| ::serde::de::Error::missing_field("action_details"))?,
            guest_team_name: field_guest_team_name,
            host_team_name: field_host_team_name,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_guest", &self.is_guest)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("action_details", &self.action_details)?;
        s.serialize_field("guest_team_name", &self.guest_team_name)?;
        s.serialize_field("host_team_name", &self.host_team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GuestAdminChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GuestAdminChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GuestAdminChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GuestAdminChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GuestAdminChangeStatusDetails", GUEST_ADMIN_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GuestAdminChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GuestAdminChangeStatusDetails", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GuestAdminChangeStatusType {
    pub description: String,
}

impl GuestAdminChangeStatusType {
    pub fn new(description: String) -> Self {
        GuestAdminChangeStatusType {
            description,
        }
    }

}

const GUEST_ADMIN_CHANGE_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl GuestAdminChangeStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GuestAdminChangeStatusType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GuestAdminChangeStatusType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GuestAdminChangeStatusType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GuestAdminChangeStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GuestAdminChangeStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GuestAdminChangeStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GuestAdminChangeStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GuestAdminChangeStatusType", GUEST_ADMIN_CHANGE_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GuestAdminChangeStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GuestAdminChangeStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Started trusted team admin session.
#[derive(Debug)]
pub struct GuestAdminSignedInViaTrustedTeamsDetails {
    /// Host team name.
    pub team_name: Option<String>,
    /// Trusted team name.
    pub trusted_team_name: Option<String>,
}

impl Default for GuestAdminSignedInViaTrustedTeamsDetails {
    fn default() -> Self {
        GuestAdminSignedInViaTrustedTeamsDetails {
            team_name: None,
            trusted_team_name: None,
        }
    }
}

const GUEST_ADMIN_SIGNED_IN_VIA_TRUSTED_TEAMS_DETAILS_FIELDS: &[&str] = &["team_name",
                                                                          "trusted_team_name"];
impl GuestAdminSignedInViaTrustedTeamsDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GuestAdminSignedInViaTrustedTeamsDetails, V::Error> {
        let mut field_team_name = None;
        let mut field_trusted_team_name = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                "trusted_team_name" => {
                    if field_trusted_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("trusted_team_name"));
                    }
                    field_trusted_team_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = GuestAdminSignedInViaTrustedTeamsDetails {
            team_name: field_team_name,
            trusted_team_name: field_trusted_team_name,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_name", &self.team_name)?;
        s.serialize_field("trusted_team_name", &self.trusted_team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GuestAdminSignedInViaTrustedTeamsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GuestAdminSignedInViaTrustedTeamsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GuestAdminSignedInViaTrustedTeamsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GuestAdminSignedInViaTrustedTeamsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GuestAdminSignedInViaTrustedTeamsDetails", GUEST_ADMIN_SIGNED_IN_VIA_TRUSTED_TEAMS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GuestAdminSignedInViaTrustedTeamsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GuestAdminSignedInViaTrustedTeamsDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GuestAdminSignedInViaTrustedTeamsType {
    pub description: String,
}

impl GuestAdminSignedInViaTrustedTeamsType {
    pub fn new(description: String) -> Self {
        GuestAdminSignedInViaTrustedTeamsType {
            description,
        }
    }

}

const GUEST_ADMIN_SIGNED_IN_VIA_TRUSTED_TEAMS_TYPE_FIELDS: &[&str] = &["description"];
impl GuestAdminSignedInViaTrustedTeamsType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GuestAdminSignedInViaTrustedTeamsType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GuestAdminSignedInViaTrustedTeamsType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GuestAdminSignedInViaTrustedTeamsType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GuestAdminSignedInViaTrustedTeamsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GuestAdminSignedInViaTrustedTeamsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GuestAdminSignedInViaTrustedTeamsType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GuestAdminSignedInViaTrustedTeamsType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GuestAdminSignedInViaTrustedTeamsType", GUEST_ADMIN_SIGNED_IN_VIA_TRUSTED_TEAMS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GuestAdminSignedInViaTrustedTeamsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GuestAdminSignedInViaTrustedTeamsType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Ended trusted team admin session.
#[derive(Debug)]
pub struct GuestAdminSignedOutViaTrustedTeamsDetails {
    /// Host team name.
    pub team_name: Option<String>,
    /// Trusted team name.
    pub trusted_team_name: Option<String>,
}

impl Default for GuestAdminSignedOutViaTrustedTeamsDetails {
    fn default() -> Self {
        GuestAdminSignedOutViaTrustedTeamsDetails {
            team_name: None,
            trusted_team_name: None,
        }
    }
}

const GUEST_ADMIN_SIGNED_OUT_VIA_TRUSTED_TEAMS_DETAILS_FIELDS: &[&str] = &["team_name",
                                                                           "trusted_team_name"];
impl GuestAdminSignedOutViaTrustedTeamsDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GuestAdminSignedOutViaTrustedTeamsDetails, V::Error> {
        let mut field_team_name = None;
        let mut field_trusted_team_name = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                "trusted_team_name" => {
                    if field_trusted_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("trusted_team_name"));
                    }
                    field_trusted_team_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = GuestAdminSignedOutViaTrustedTeamsDetails {
            team_name: field_team_name,
            trusted_team_name: field_trusted_team_name,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_name", &self.team_name)?;
        s.serialize_field("trusted_team_name", &self.trusted_team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GuestAdminSignedOutViaTrustedTeamsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GuestAdminSignedOutViaTrustedTeamsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GuestAdminSignedOutViaTrustedTeamsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GuestAdminSignedOutViaTrustedTeamsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GuestAdminSignedOutViaTrustedTeamsDetails", GUEST_ADMIN_SIGNED_OUT_VIA_TRUSTED_TEAMS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GuestAdminSignedOutViaTrustedTeamsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GuestAdminSignedOutViaTrustedTeamsDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GuestAdminSignedOutViaTrustedTeamsType {
    pub description: String,
}

impl GuestAdminSignedOutViaTrustedTeamsType {
    pub fn new(description: String) -> Self {
        GuestAdminSignedOutViaTrustedTeamsType {
            description,
        }
    }

}

const GUEST_ADMIN_SIGNED_OUT_VIA_TRUSTED_TEAMS_TYPE_FIELDS: &[&str] = &["description"];
impl GuestAdminSignedOutViaTrustedTeamsType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GuestAdminSignedOutViaTrustedTeamsType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GuestAdminSignedOutViaTrustedTeamsType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GuestAdminSignedOutViaTrustedTeamsType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GuestAdminSignedOutViaTrustedTeamsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GuestAdminSignedOutViaTrustedTeamsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GuestAdminSignedOutViaTrustedTeamsType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GuestAdminSignedOutViaTrustedTeamsType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GuestAdminSignedOutViaTrustedTeamsType", GUEST_ADMIN_SIGNED_OUT_VIA_TRUSTED_TEAMS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GuestAdminSignedOutViaTrustedTeamsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GuestAdminSignedOutViaTrustedTeamsType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum IdentifierType {
    Email,
    FacebookProfileName,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for IdentifierType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = IdentifierType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a IdentifierType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "email" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(IdentifierType::Email)
                    }
                    "facebook_profile_name" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(IdentifierType::FacebookProfileName)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(IdentifierType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["email",
                                    "facebook_profile_name",
                                    "other"];
        deserializer.deserialize_struct("IdentifierType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for IdentifierType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            IdentifierType::Email => {
                // unit
                let mut s = serializer.serialize_struct("IdentifierType", 1)?;
                s.serialize_field(".tag", "email")?;
                s.end()
            }
            IdentifierType::FacebookProfileName => {
                // unit
                let mut s = serializer.serialize_struct("IdentifierType", 1)?;
                s.serialize_field(".tag", "facebook_profile_name")?;
                s.end()
            }
            IdentifierType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Connected integration for member.
#[derive(Debug)]
pub struct IntegrationConnectedDetails {
    /// Name of the third-party integration.
    pub integration_name: String,
}

impl IntegrationConnectedDetails {
    pub fn new(integration_name: String) -> Self {
        IntegrationConnectedDetails {
            integration_name,
        }
    }

}

const INTEGRATION_CONNECTED_DETAILS_FIELDS: &[&str] = &["integration_name"];
impl IntegrationConnectedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<IntegrationConnectedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<IntegrationConnectedDetails>, V::Error> {
        let mut field_integration_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "integration_name" => {
                    if field_integration_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("integration_name"));
                    }
                    field_integration_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = IntegrationConnectedDetails {
            integration_name: field_integration_name.ok_or_else(|| ::serde::de::Error::missing_field("integration_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("integration_name", &self.integration_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for IntegrationConnectedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = IntegrationConnectedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a IntegrationConnectedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                IntegrationConnectedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("IntegrationConnectedDetails", INTEGRATION_CONNECTED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for IntegrationConnectedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("IntegrationConnectedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct IntegrationConnectedType {
    pub description: String,
}

impl IntegrationConnectedType {
    pub fn new(description: String) -> Self {
        IntegrationConnectedType {
            description,
        }
    }

}

const INTEGRATION_CONNECTED_TYPE_FIELDS: &[&str] = &["description"];
impl IntegrationConnectedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<IntegrationConnectedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<IntegrationConnectedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = IntegrationConnectedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for IntegrationConnectedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = IntegrationConnectedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a IntegrationConnectedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                IntegrationConnectedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("IntegrationConnectedType", INTEGRATION_CONNECTED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for IntegrationConnectedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("IntegrationConnectedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Disconnected integration for member.
#[derive(Debug)]
pub struct IntegrationDisconnectedDetails {
    /// Name of the third-party integration.
    pub integration_name: String,
}

impl IntegrationDisconnectedDetails {
    pub fn new(integration_name: String) -> Self {
        IntegrationDisconnectedDetails {
            integration_name,
        }
    }

}

const INTEGRATION_DISCONNECTED_DETAILS_FIELDS: &[&str] = &["integration_name"];
impl IntegrationDisconnectedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<IntegrationDisconnectedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<IntegrationDisconnectedDetails>, V::Error> {
        let mut field_integration_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "integration_name" => {
                    if field_integration_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("integration_name"));
                    }
                    field_integration_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = IntegrationDisconnectedDetails {
            integration_name: field_integration_name.ok_or_else(|| ::serde::de::Error::missing_field("integration_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("integration_name", &self.integration_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for IntegrationDisconnectedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = IntegrationDisconnectedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a IntegrationDisconnectedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                IntegrationDisconnectedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("IntegrationDisconnectedDetails", INTEGRATION_DISCONNECTED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for IntegrationDisconnectedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("IntegrationDisconnectedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct IntegrationDisconnectedType {
    pub description: String,
}

impl IntegrationDisconnectedType {
    pub fn new(description: String) -> Self {
        IntegrationDisconnectedType {
            description,
        }
    }

}

const INTEGRATION_DISCONNECTED_TYPE_FIELDS: &[&str] = &["description"];
impl IntegrationDisconnectedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<IntegrationDisconnectedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<IntegrationDisconnectedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = IntegrationDisconnectedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for IntegrationDisconnectedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = IntegrationDisconnectedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a IntegrationDisconnectedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                IntegrationDisconnectedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("IntegrationDisconnectedType", INTEGRATION_DISCONNECTED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for IntegrationDisconnectedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("IntegrationDisconnectedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling whether a service integration is enabled for the team.
#[derive(Debug)]
pub enum IntegrationPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for IntegrationPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = IntegrationPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a IntegrationPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(IntegrationPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(IntegrationPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(IntegrationPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("IntegrationPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for IntegrationPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            IntegrationPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("IntegrationPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            IntegrationPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("IntegrationPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            IntegrationPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed integration policy for team.
#[derive(Debug)]
pub struct IntegrationPolicyChangedDetails {
    /// Name of the third-party integration.
    pub integration_name: String,
    /// New integration policy.
    pub new_value: IntegrationPolicy,
    /// Previous integration policy.
    pub previous_value: IntegrationPolicy,
}

impl IntegrationPolicyChangedDetails {
    pub fn new(
        integration_name: String,
        new_value: IntegrationPolicy,
        previous_value: IntegrationPolicy,
    ) -> Self {
        IntegrationPolicyChangedDetails {
            integration_name,
            new_value,
            previous_value,
        }
    }

}

const INTEGRATION_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["integration_name",
                                                             "new_value",
                                                             "previous_value"];
impl IntegrationPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<IntegrationPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<IntegrationPolicyChangedDetails>, V::Error> {
        let mut field_integration_name = None;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "integration_name" => {
                    if field_integration_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("integration_name"));
                    }
                    field_integration_name = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = IntegrationPolicyChangedDetails {
            integration_name: field_integration_name.ok_or_else(|| ::serde::de::Error::missing_field("integration_name"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("integration_name", &self.integration_name)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for IntegrationPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = IntegrationPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a IntegrationPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                IntegrationPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("IntegrationPolicyChangedDetails", INTEGRATION_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for IntegrationPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("IntegrationPolicyChangedDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct IntegrationPolicyChangedType {
    pub description: String,
}

impl IntegrationPolicyChangedType {
    pub fn new(description: String) -> Self {
        IntegrationPolicyChangedType {
            description,
        }
    }

}

const INTEGRATION_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl IntegrationPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<IntegrationPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<IntegrationPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = IntegrationPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for IntegrationPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = IntegrationPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a IntegrationPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                IntegrationPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("IntegrationPolicyChangedType", INTEGRATION_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for IntegrationPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("IntegrationPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum InviteMethod {
    InviteLink,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for InviteMethod {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = InviteMethod;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a InviteMethod structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invite_link" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(InviteMethod::InviteLink)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(InviteMethod::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["invite_link",
                                    "other"];
        deserializer.deserialize_struct("InviteMethod", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for InviteMethod {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            InviteMethod::InviteLink => {
                // unit
                let mut s = serializer.serialize_struct("InviteMethod", 1)?;
                s.serialize_field(".tag", "invite_link")?;
                s.end()
            }
            InviteMethod::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Additional information relevant when a new member joins the team.
#[derive(Debug)]
pub struct JoinTeamDetails {
    /// Linked applications. (Deprecated) Please use has_linked_apps boolean field instead.
    pub linked_apps: Vec<UserLinkedAppLogInfo>,
    /// Linked devices. (Deprecated) Please use has_linked_devices boolean field instead.
    pub linked_devices: Vec<LinkedDeviceLogInfo>,
    /// Linked shared folders. (Deprecated) Please use has_linked_shared_folders boolean field
    /// instead.
    pub linked_shared_folders: Vec<FolderLogInfo>,
    /// True if the linked_apps list was truncated to the maximum supported length (50).
    pub was_linked_apps_truncated: Option<bool>,
    /// True if the linked_devices list was truncated to the maximum supported length (50).
    pub was_linked_devices_truncated: Option<bool>,
    /// True if the linked_shared_folders list was truncated to the maximum supported length (50).
    pub was_linked_shared_folders_truncated: Option<bool>,
    /// True if the user had linked apps at event time.
    pub has_linked_apps: Option<bool>,
    /// True if the user had linked apps at event time.
    pub has_linked_devices: Option<bool>,
    /// True if the user had linked shared folders at event time.
    pub has_linked_shared_folders: Option<bool>,
}

impl JoinTeamDetails {
    pub fn new(
        linked_apps: Vec<UserLinkedAppLogInfo>,
        linked_devices: Vec<LinkedDeviceLogInfo>,
        linked_shared_folders: Vec<FolderLogInfo>,
    ) -> Self {
        JoinTeamDetails {
            linked_apps,
            linked_devices,
            linked_shared_folders,
            was_linked_apps_truncated: None,
            was_linked_devices_truncated: None,
            was_linked_shared_folders_truncated: None,
            has_linked_apps: None,
            has_linked_devices: None,
            has_linked_shared_folders: None,
        }
    }

    pub fn with_was_linked_apps_truncated(mut self, value: Option<bool>) -> Self {
        self.was_linked_apps_truncated = value;
        self
    }

    pub fn with_was_linked_devices_truncated(mut self, value: Option<bool>) -> Self {
        self.was_linked_devices_truncated = value;
        self
    }

    pub fn with_was_linked_shared_folders_truncated(mut self, value: Option<bool>) -> Self {
        self.was_linked_shared_folders_truncated = value;
        self
    }

    pub fn with_has_linked_apps(mut self, value: Option<bool>) -> Self {
        self.has_linked_apps = value;
        self
    }

    pub fn with_has_linked_devices(mut self, value: Option<bool>) -> Self {
        self.has_linked_devices = value;
        self
    }

    pub fn with_has_linked_shared_folders(mut self, value: Option<bool>) -> Self {
        self.has_linked_shared_folders = value;
        self
    }

}

const JOIN_TEAM_DETAILS_FIELDS: &[&str] = &["linked_apps",
                                            "linked_devices",
                                            "linked_shared_folders",
                                            "was_linked_apps_truncated",
                                            "was_linked_devices_truncated",
                                            "was_linked_shared_folders_truncated",
                                            "has_linked_apps",
                                            "has_linked_devices",
                                            "has_linked_shared_folders"];
impl JoinTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<JoinTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<JoinTeamDetails>, V::Error> {
        let mut field_linked_apps = None;
        let mut field_linked_devices = None;
        let mut field_linked_shared_folders = None;
        let mut field_was_linked_apps_truncated = None;
        let mut field_was_linked_devices_truncated = None;
        let mut field_was_linked_shared_folders_truncated = None;
        let mut field_has_linked_apps = None;
        let mut field_has_linked_devices = None;
        let mut field_has_linked_shared_folders = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "linked_apps" => {
                    if field_linked_apps.is_some() {
                        return Err(::serde::de::Error::duplicate_field("linked_apps"));
                    }
                    field_linked_apps = Some(map.next_value()?);
                }
                "linked_devices" => {
                    if field_linked_devices.is_some() {
                        return Err(::serde::de::Error::duplicate_field("linked_devices"));
                    }
                    field_linked_devices = Some(map.next_value()?);
                }
                "linked_shared_folders" => {
                    if field_linked_shared_folders.is_some() {
                        return Err(::serde::de::Error::duplicate_field("linked_shared_folders"));
                    }
                    field_linked_shared_folders = Some(map.next_value()?);
                }
                "was_linked_apps_truncated" => {
                    if field_was_linked_apps_truncated.is_some() {
                        return Err(::serde::de::Error::duplicate_field("was_linked_apps_truncated"));
                    }
                    field_was_linked_apps_truncated = Some(map.next_value()?);
                }
                "was_linked_devices_truncated" => {
                    if field_was_linked_devices_truncated.is_some() {
                        return Err(::serde::de::Error::duplicate_field("was_linked_devices_truncated"));
                    }
                    field_was_linked_devices_truncated = Some(map.next_value()?);
                }
                "was_linked_shared_folders_truncated" => {
                    if field_was_linked_shared_folders_truncated.is_some() {
                        return Err(::serde::de::Error::duplicate_field("was_linked_shared_folders_truncated"));
                    }
                    field_was_linked_shared_folders_truncated = Some(map.next_value()?);
                }
                "has_linked_apps" => {
                    if field_has_linked_apps.is_some() {
                        return Err(::serde::de::Error::duplicate_field("has_linked_apps"));
                    }
                    field_has_linked_apps = Some(map.next_value()?);
                }
                "has_linked_devices" => {
                    if field_has_linked_devices.is_some() {
                        return Err(::serde::de::Error::duplicate_field("has_linked_devices"));
                    }
                    field_has_linked_devices = Some(map.next_value()?);
                }
                "has_linked_shared_folders" => {
                    if field_has_linked_shared_folders.is_some() {
                        return Err(::serde::de::Error::duplicate_field("has_linked_shared_folders"));
                    }
                    field_has_linked_shared_folders = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = JoinTeamDetails {
            linked_apps: field_linked_apps.ok_or_else(|| ::serde::de::Error::missing_field("linked_apps"))?,
            linked_devices: field_linked_devices.ok_or_else(|| ::serde::de::Error::missing_field("linked_devices"))?,
            linked_shared_folders: field_linked_shared_folders.ok_or_else(|| ::serde::de::Error::missing_field("linked_shared_folders"))?,
            was_linked_apps_truncated: field_was_linked_apps_truncated,
            was_linked_devices_truncated: field_was_linked_devices_truncated,
            was_linked_shared_folders_truncated: field_was_linked_shared_folders_truncated,
            has_linked_apps: field_has_linked_apps,
            has_linked_devices: field_has_linked_devices,
            has_linked_shared_folders: field_has_linked_shared_folders,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("linked_apps", &self.linked_apps)?;
        s.serialize_field("linked_devices", &self.linked_devices)?;
        s.serialize_field("linked_shared_folders", &self.linked_shared_folders)?;
        s.serialize_field("was_linked_apps_truncated", &self.was_linked_apps_truncated)?;
        s.serialize_field("was_linked_devices_truncated", &self.was_linked_devices_truncated)?;
        s.serialize_field("was_linked_shared_folders_truncated", &self.was_linked_shared_folders_truncated)?;
        s.serialize_field("has_linked_apps", &self.has_linked_apps)?;
        s.serialize_field("has_linked_devices", &self.has_linked_devices)?;
        s.serialize_field("has_linked_shared_folders", &self.has_linked_shared_folders)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for JoinTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = JoinTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a JoinTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                JoinTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("JoinTeamDetails", JOIN_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for JoinTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("JoinTeamDetails", 9)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information on sessions, in legacy format
#[derive(Debug)]
pub struct LegacyDeviceSessionLogInfo {
    /// The IP address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub ip_address: Option<IpAddress>,
    /// The time this session was created. Might be missing due to historical data gap.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session. Might be missing due to historical data
    /// gap.
    pub updated: Option<super::common::DropboxTimestamp>,
    /// Session unique id. Might be missing due to historical data gap.
    pub session_info: Option<SessionLogInfo>,
    /// The device name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
    /// Is device managed by emm. Might be missing due to historical data gap.
    pub is_emm_managed: Option<bool>,
    /// Information on the hosting platform. Might be missing due to historical data gap.
    pub platform: Option<String>,
    /// The mac address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub mac_address: Option<IpAddress>,
    /// The hosting OS version. Might be missing due to historical data gap.
    pub os_version: Option<String>,
    /// Information on the hosting device type. Might be missing due to historical data gap.
    pub device_type: Option<String>,
    /// The Dropbox client version. Might be missing due to historical data gap.
    pub client_version: Option<String>,
    /// Alternative unique device session id, instead of session id field. Might be missing due to
    /// historical data gap.
    pub legacy_uniq_id: Option<String>,
}

impl Default for LegacyDeviceSessionLogInfo {
    fn default() -> Self {
        LegacyDeviceSessionLogInfo {
            ip_address: None,
            created: None,
            updated: None,
            session_info: None,
            display_name: None,
            is_emm_managed: None,
            platform: None,
            mac_address: None,
            os_version: None,
            device_type: None,
            client_version: None,
            legacy_uniq_id: None,
        }
    }
}

const LEGACY_DEVICE_SESSION_LOG_INFO_FIELDS: &[&str] = &["ip_address",
                                                         "created",
                                                         "updated",
                                                         "session_info",
                                                         "display_name",
                                                         "is_emm_managed",
                                                         "platform",
                                                         "mac_address",
                                                         "os_version",
                                                         "device_type",
                                                         "client_version",
                                                         "legacy_uniq_id"];
impl LegacyDeviceSessionLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LegacyDeviceSessionLogInfo, V::Error> {
        let mut field_ip_address = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut field_session_info = None;
        let mut field_display_name = None;
        let mut field_is_emm_managed = None;
        let mut field_platform = None;
        let mut field_mac_address = None;
        let mut field_os_version = None;
        let mut field_device_type = None;
        let mut field_client_version = None;
        let mut field_legacy_uniq_id = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(::serde::de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(::serde::de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(::serde::de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                "session_info" => {
                    if field_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_info"));
                    }
                    field_session_info = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "is_emm_managed" => {
                    if field_is_emm_managed.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_emm_managed"));
                    }
                    field_is_emm_managed = Some(map.next_value()?);
                }
                "platform" => {
                    if field_platform.is_some() {
                        return Err(::serde::de::Error::duplicate_field("platform"));
                    }
                    field_platform = Some(map.next_value()?);
                }
                "mac_address" => {
                    if field_mac_address.is_some() {
                        return Err(::serde::de::Error::duplicate_field("mac_address"));
                    }
                    field_mac_address = Some(map.next_value()?);
                }
                "os_version" => {
                    if field_os_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("os_version"));
                    }
                    field_os_version = Some(map.next_value()?);
                }
                "device_type" => {
                    if field_device_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("device_type"));
                    }
                    field_device_type = Some(map.next_value()?);
                }
                "client_version" => {
                    if field_client_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("client_version"));
                    }
                    field_client_version = Some(map.next_value()?);
                }
                "legacy_uniq_id" => {
                    if field_legacy_uniq_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legacy_uniq_id"));
                    }
                    field_legacy_uniq_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = LegacyDeviceSessionLogInfo {
            ip_address: field_ip_address,
            created: field_created,
            updated: field_updated,
            session_info: field_session_info,
            display_name: field_display_name,
            is_emm_managed: field_is_emm_managed,
            platform: field_platform,
            mac_address: field_mac_address,
            os_version: field_os_version,
            device_type: field_device_type,
            client_version: field_client_version,
            legacy_uniq_id: field_legacy_uniq_id,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)?;
        s.serialize_field("session_info", &self.session_info)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("is_emm_managed", &self.is_emm_managed)?;
        s.serialize_field("platform", &self.platform)?;
        s.serialize_field("mac_address", &self.mac_address)?;
        s.serialize_field("os_version", &self.os_version)?;
        s.serialize_field("device_type", &self.device_type)?;
        s.serialize_field("client_version", &self.client_version)?;
        s.serialize_field("legacy_uniq_id", &self.legacy_uniq_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegacyDeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegacyDeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegacyDeviceSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegacyDeviceSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegacyDeviceSessionLogInfo", LEGACY_DEVICE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegacyDeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegacyDeviceSessionLogInfo", 12)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Activated a hold.
#[derive(Debug)]
pub struct LegalHoldsActivateAHoldDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
    /// Hold start date.
    pub start_date: super::common::DropboxTimestamp,
    /// Hold end date.
    pub end_date: Option<super::common::DropboxTimestamp>,
}

impl LegalHoldsActivateAHoldDetails {
    pub fn new(
        legal_hold_id: String,
        name: String,
        start_date: super::common::DropboxTimestamp,
    ) -> Self {
        LegalHoldsActivateAHoldDetails {
            legal_hold_id,
            name,
            start_date,
            end_date: None,
        }
    }

    pub fn with_end_date(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.end_date = value;
        self
    }

}

const LEGAL_HOLDS_ACTIVATE_A_HOLD_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                              "name",
                                                              "start_date",
                                                              "end_date"];
impl LegalHoldsActivateAHoldDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsActivateAHoldDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsActivateAHoldDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut field_start_date = None;
        let mut field_end_date = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "end_date" => {
                    if field_end_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("end_date"));
                    }
                    field_end_date = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsActivateAHoldDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            start_date: field_start_date.ok_or_else(|| ::serde::de::Error::missing_field("start_date"))?,
            end_date: field_end_date,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("end_date", &self.end_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsActivateAHoldDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsActivateAHoldDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsActivateAHoldDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsActivateAHoldDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsActivateAHoldDetails", LEGAL_HOLDS_ACTIVATE_A_HOLD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsActivateAHoldDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsActivateAHoldDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsActivateAHoldType {
    pub description: String,
}

impl LegalHoldsActivateAHoldType {
    pub fn new(description: String) -> Self {
        LegalHoldsActivateAHoldType {
            description,
        }
    }

}

const LEGAL_HOLDS_ACTIVATE_A_HOLD_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsActivateAHoldType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsActivateAHoldType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsActivateAHoldType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsActivateAHoldType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsActivateAHoldType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsActivateAHoldType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsActivateAHoldType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsActivateAHoldType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsActivateAHoldType", LEGAL_HOLDS_ACTIVATE_A_HOLD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsActivateAHoldType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsActivateAHoldType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added members to a hold.
#[derive(Debug)]
pub struct LegalHoldsAddMembersDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
}

impl LegalHoldsAddMembersDetails {
    pub fn new(legal_hold_id: String, name: String) -> Self {
        LegalHoldsAddMembersDetails {
            legal_hold_id,
            name,
        }
    }

}

const LEGAL_HOLDS_ADD_MEMBERS_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                          "name"];
impl LegalHoldsAddMembersDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsAddMembersDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsAddMembersDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsAddMembersDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsAddMembersDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsAddMembersDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsAddMembersDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsAddMembersDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsAddMembersDetails", LEGAL_HOLDS_ADD_MEMBERS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsAddMembersDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsAddMembersDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsAddMembersType {
    pub description: String,
}

impl LegalHoldsAddMembersType {
    pub fn new(description: String) -> Self {
        LegalHoldsAddMembersType {
            description,
        }
    }

}

const LEGAL_HOLDS_ADD_MEMBERS_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsAddMembersType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsAddMembersType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsAddMembersType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsAddMembersType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsAddMembersType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsAddMembersType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsAddMembersType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsAddMembersType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsAddMembersType", LEGAL_HOLDS_ADD_MEMBERS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsAddMembersType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsAddMembersType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited details for a hold.
#[derive(Debug)]
pub struct LegalHoldsChangeHoldDetailsDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
    /// Previous details.
    pub previous_value: String,
    /// New details.
    pub new_value: String,
}

impl LegalHoldsChangeHoldDetailsDetails {
    pub fn new(
        legal_hold_id: String,
        name: String,
        previous_value: String,
        new_value: String,
    ) -> Self {
        LegalHoldsChangeHoldDetailsDetails {
            legal_hold_id,
            name,
            previous_value,
            new_value,
        }
    }

}

const LEGAL_HOLDS_CHANGE_HOLD_DETAILS_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                                  "name",
                                                                  "previous_value",
                                                                  "new_value"];
impl LegalHoldsChangeHoldDetailsDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsChangeHoldDetailsDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsChangeHoldDetailsDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsChangeHoldDetailsDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsChangeHoldDetailsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsChangeHoldDetailsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsChangeHoldDetailsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsChangeHoldDetailsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsChangeHoldDetailsDetails", LEGAL_HOLDS_CHANGE_HOLD_DETAILS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsChangeHoldDetailsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsChangeHoldDetailsDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsChangeHoldDetailsType {
    pub description: String,
}

impl LegalHoldsChangeHoldDetailsType {
    pub fn new(description: String) -> Self {
        LegalHoldsChangeHoldDetailsType {
            description,
        }
    }

}

const LEGAL_HOLDS_CHANGE_HOLD_DETAILS_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsChangeHoldDetailsType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsChangeHoldDetailsType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsChangeHoldDetailsType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsChangeHoldDetailsType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsChangeHoldDetailsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsChangeHoldDetailsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsChangeHoldDetailsType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsChangeHoldDetailsType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsChangeHoldDetailsType", LEGAL_HOLDS_CHANGE_HOLD_DETAILS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsChangeHoldDetailsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsChangeHoldDetailsType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed a hold.
#[derive(Debug)]
pub struct LegalHoldsChangeHoldNameDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Previous Name.
    pub previous_value: String,
    /// New Name.
    pub new_value: String,
}

impl LegalHoldsChangeHoldNameDetails {
    pub fn new(legal_hold_id: String, previous_value: String, new_value: String) -> Self {
        LegalHoldsChangeHoldNameDetails {
            legal_hold_id,
            previous_value,
            new_value,
        }
    }

}

const LEGAL_HOLDS_CHANGE_HOLD_NAME_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                               "previous_value",
                                                               "new_value"];
impl LegalHoldsChangeHoldNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsChangeHoldNameDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsChangeHoldNameDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsChangeHoldNameDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsChangeHoldNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsChangeHoldNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsChangeHoldNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsChangeHoldNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsChangeHoldNameDetails", LEGAL_HOLDS_CHANGE_HOLD_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsChangeHoldNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsChangeHoldNameDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsChangeHoldNameType {
    pub description: String,
}

impl LegalHoldsChangeHoldNameType {
    pub fn new(description: String) -> Self {
        LegalHoldsChangeHoldNameType {
            description,
        }
    }

}

const LEGAL_HOLDS_CHANGE_HOLD_NAME_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsChangeHoldNameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsChangeHoldNameType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsChangeHoldNameType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsChangeHoldNameType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsChangeHoldNameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsChangeHoldNameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsChangeHoldNameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsChangeHoldNameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsChangeHoldNameType", LEGAL_HOLDS_CHANGE_HOLD_NAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsChangeHoldNameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsChangeHoldNameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Exported hold.
#[derive(Debug)]
pub struct LegalHoldsExportAHoldDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
    /// Export name.
    pub export_name: Option<String>,
}

impl LegalHoldsExportAHoldDetails {
    pub fn new(legal_hold_id: String, name: String) -> Self {
        LegalHoldsExportAHoldDetails {
            legal_hold_id,
            name,
            export_name: None,
        }
    }

    pub fn with_export_name(mut self, value: Option<String>) -> Self {
        self.export_name = value;
        self
    }

}

const LEGAL_HOLDS_EXPORT_A_HOLD_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                            "name",
                                                            "export_name"];
impl LegalHoldsExportAHoldDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsExportAHoldDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsExportAHoldDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut field_export_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "export_name" => {
                    if field_export_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("export_name"));
                    }
                    field_export_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsExportAHoldDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            export_name: field_export_name,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("export_name", &self.export_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsExportAHoldDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsExportAHoldDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsExportAHoldDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsExportAHoldDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsExportAHoldDetails", LEGAL_HOLDS_EXPORT_A_HOLD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsExportAHoldDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsExportAHoldDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsExportAHoldType {
    pub description: String,
}

impl LegalHoldsExportAHoldType {
    pub fn new(description: String) -> Self {
        LegalHoldsExportAHoldType {
            description,
        }
    }

}

const LEGAL_HOLDS_EXPORT_A_HOLD_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsExportAHoldType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsExportAHoldType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsExportAHoldType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsExportAHoldType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsExportAHoldType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsExportAHoldType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsExportAHoldType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsExportAHoldType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsExportAHoldType", LEGAL_HOLDS_EXPORT_A_HOLD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsExportAHoldType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsExportAHoldType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Canceled export for a hold.
#[derive(Debug)]
pub struct LegalHoldsExportCancelledDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
    /// Export name.
    pub export_name: String,
}

impl LegalHoldsExportCancelledDetails {
    pub fn new(legal_hold_id: String, name: String, export_name: String) -> Self {
        LegalHoldsExportCancelledDetails {
            legal_hold_id,
            name,
            export_name,
        }
    }

}

const LEGAL_HOLDS_EXPORT_CANCELLED_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                               "name",
                                                               "export_name"];
impl LegalHoldsExportCancelledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsExportCancelledDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsExportCancelledDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut field_export_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "export_name" => {
                    if field_export_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("export_name"));
                    }
                    field_export_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsExportCancelledDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            export_name: field_export_name.ok_or_else(|| ::serde::de::Error::missing_field("export_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("export_name", &self.export_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsExportCancelledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsExportCancelledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsExportCancelledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsExportCancelledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsExportCancelledDetails", LEGAL_HOLDS_EXPORT_CANCELLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsExportCancelledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsExportCancelledDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsExportCancelledType {
    pub description: String,
}

impl LegalHoldsExportCancelledType {
    pub fn new(description: String) -> Self {
        LegalHoldsExportCancelledType {
            description,
        }
    }

}

const LEGAL_HOLDS_EXPORT_CANCELLED_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsExportCancelledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsExportCancelledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsExportCancelledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsExportCancelledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsExportCancelledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsExportCancelledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsExportCancelledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsExportCancelledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsExportCancelledType", LEGAL_HOLDS_EXPORT_CANCELLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsExportCancelledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsExportCancelledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded export for a hold.
#[derive(Debug)]
pub struct LegalHoldsExportDownloadedDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
    /// Export name.
    pub export_name: String,
    /// Part.
    pub part: Option<String>,
    /// Filename.
    pub file_name: Option<String>,
}

impl LegalHoldsExportDownloadedDetails {
    pub fn new(legal_hold_id: String, name: String, export_name: String) -> Self {
        LegalHoldsExportDownloadedDetails {
            legal_hold_id,
            name,
            export_name,
            part: None,
            file_name: None,
        }
    }

    pub fn with_part(mut self, value: Option<String>) -> Self {
        self.part = value;
        self
    }

    pub fn with_file_name(mut self, value: Option<String>) -> Self {
        self.file_name = value;
        self
    }

}

const LEGAL_HOLDS_EXPORT_DOWNLOADED_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                                "name",
                                                                "export_name",
                                                                "part",
                                                                "file_name"];
impl LegalHoldsExportDownloadedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsExportDownloadedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsExportDownloadedDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut field_export_name = None;
        let mut field_part = None;
        let mut field_file_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "export_name" => {
                    if field_export_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("export_name"));
                    }
                    field_export_name = Some(map.next_value()?);
                }
                "part" => {
                    if field_part.is_some() {
                        return Err(::serde::de::Error::duplicate_field("part"));
                    }
                    field_part = Some(map.next_value()?);
                }
                "file_name" => {
                    if field_file_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_name"));
                    }
                    field_file_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsExportDownloadedDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            export_name: field_export_name.ok_or_else(|| ::serde::de::Error::missing_field("export_name"))?,
            part: field_part,
            file_name: field_file_name,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("export_name", &self.export_name)?;
        s.serialize_field("part", &self.part)?;
        s.serialize_field("file_name", &self.file_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsExportDownloadedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsExportDownloadedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsExportDownloadedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsExportDownloadedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsExportDownloadedDetails", LEGAL_HOLDS_EXPORT_DOWNLOADED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsExportDownloadedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsExportDownloadedDetails", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsExportDownloadedType {
    pub description: String,
}

impl LegalHoldsExportDownloadedType {
    pub fn new(description: String) -> Self {
        LegalHoldsExportDownloadedType {
            description,
        }
    }

}

const LEGAL_HOLDS_EXPORT_DOWNLOADED_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsExportDownloadedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsExportDownloadedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsExportDownloadedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsExportDownloadedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsExportDownloadedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsExportDownloadedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsExportDownloadedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsExportDownloadedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsExportDownloadedType", LEGAL_HOLDS_EXPORT_DOWNLOADED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsExportDownloadedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsExportDownloadedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed export for a hold.
#[derive(Debug)]
pub struct LegalHoldsExportRemovedDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
    /// Export name.
    pub export_name: String,
}

impl LegalHoldsExportRemovedDetails {
    pub fn new(legal_hold_id: String, name: String, export_name: String) -> Self {
        LegalHoldsExportRemovedDetails {
            legal_hold_id,
            name,
            export_name,
        }
    }

}

const LEGAL_HOLDS_EXPORT_REMOVED_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                             "name",
                                                             "export_name"];
impl LegalHoldsExportRemovedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsExportRemovedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsExportRemovedDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut field_export_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "export_name" => {
                    if field_export_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("export_name"));
                    }
                    field_export_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsExportRemovedDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            export_name: field_export_name.ok_or_else(|| ::serde::de::Error::missing_field("export_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("export_name", &self.export_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsExportRemovedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsExportRemovedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsExportRemovedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsExportRemovedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsExportRemovedDetails", LEGAL_HOLDS_EXPORT_REMOVED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsExportRemovedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsExportRemovedDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsExportRemovedType {
    pub description: String,
}

impl LegalHoldsExportRemovedType {
    pub fn new(description: String) -> Self {
        LegalHoldsExportRemovedType {
            description,
        }
    }

}

const LEGAL_HOLDS_EXPORT_REMOVED_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsExportRemovedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsExportRemovedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsExportRemovedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsExportRemovedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsExportRemovedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsExportRemovedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsExportRemovedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsExportRemovedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsExportRemovedType", LEGAL_HOLDS_EXPORT_REMOVED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsExportRemovedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsExportRemovedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Released a hold.
#[derive(Debug)]
pub struct LegalHoldsReleaseAHoldDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
}

impl LegalHoldsReleaseAHoldDetails {
    pub fn new(legal_hold_id: String, name: String) -> Self {
        LegalHoldsReleaseAHoldDetails {
            legal_hold_id,
            name,
        }
    }

}

const LEGAL_HOLDS_RELEASE_A_HOLD_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                             "name"];
impl LegalHoldsReleaseAHoldDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsReleaseAHoldDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsReleaseAHoldDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsReleaseAHoldDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsReleaseAHoldDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsReleaseAHoldDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsReleaseAHoldDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsReleaseAHoldDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsReleaseAHoldDetails", LEGAL_HOLDS_RELEASE_A_HOLD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsReleaseAHoldDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsReleaseAHoldDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsReleaseAHoldType {
    pub description: String,
}

impl LegalHoldsReleaseAHoldType {
    pub fn new(description: String) -> Self {
        LegalHoldsReleaseAHoldType {
            description,
        }
    }

}

const LEGAL_HOLDS_RELEASE_A_HOLD_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsReleaseAHoldType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsReleaseAHoldType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsReleaseAHoldType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsReleaseAHoldType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsReleaseAHoldType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsReleaseAHoldType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsReleaseAHoldType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsReleaseAHoldType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsReleaseAHoldType", LEGAL_HOLDS_RELEASE_A_HOLD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsReleaseAHoldType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsReleaseAHoldType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed members from a hold.
#[derive(Debug)]
pub struct LegalHoldsRemoveMembersDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
}

impl LegalHoldsRemoveMembersDetails {
    pub fn new(legal_hold_id: String, name: String) -> Self {
        LegalHoldsRemoveMembersDetails {
            legal_hold_id,
            name,
        }
    }

}

const LEGAL_HOLDS_REMOVE_MEMBERS_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                             "name"];
impl LegalHoldsRemoveMembersDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsRemoveMembersDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsRemoveMembersDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsRemoveMembersDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsRemoveMembersDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsRemoveMembersDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsRemoveMembersDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsRemoveMembersDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsRemoveMembersDetails", LEGAL_HOLDS_REMOVE_MEMBERS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsRemoveMembersDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsRemoveMembersDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsRemoveMembersType {
    pub description: String,
}

impl LegalHoldsRemoveMembersType {
    pub fn new(description: String) -> Self {
        LegalHoldsRemoveMembersType {
            description,
        }
    }

}

const LEGAL_HOLDS_REMOVE_MEMBERS_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsRemoveMembersType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsRemoveMembersType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsRemoveMembersType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsRemoveMembersType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsRemoveMembersType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsRemoveMembersType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsRemoveMembersType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsRemoveMembersType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsRemoveMembersType", LEGAL_HOLDS_REMOVE_MEMBERS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsRemoveMembersType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsRemoveMembersType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created a summary report for a hold.
#[derive(Debug)]
pub struct LegalHoldsReportAHoldDetails {
    /// Hold ID.
    pub legal_hold_id: String,
    /// Hold name.
    pub name: String,
}

impl LegalHoldsReportAHoldDetails {
    pub fn new(legal_hold_id: String, name: String) -> Self {
        LegalHoldsReportAHoldDetails {
            legal_hold_id,
            name,
        }
    }

}

const LEGAL_HOLDS_REPORT_A_HOLD_DETAILS_FIELDS: &[&str] = &["legal_hold_id",
                                                            "name"];
impl LegalHoldsReportAHoldDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsReportAHoldDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsReportAHoldDetails>, V::Error> {
        let mut field_legal_hold_id = None;
        let mut field_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "legal_hold_id" => {
                    if field_legal_hold_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("legal_hold_id"));
                    }
                    field_legal_hold_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsReportAHoldDetails {
            legal_hold_id: field_legal_hold_id.ok_or_else(|| ::serde::de::Error::missing_field("legal_hold_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("legal_hold_id", &self.legal_hold_id)?;
        s.serialize_field("name", &self.name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsReportAHoldDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsReportAHoldDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsReportAHoldDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsReportAHoldDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsReportAHoldDetails", LEGAL_HOLDS_REPORT_A_HOLD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsReportAHoldDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsReportAHoldDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LegalHoldsReportAHoldType {
    pub description: String,
}

impl LegalHoldsReportAHoldType {
    pub fn new(description: String) -> Self {
        LegalHoldsReportAHoldType {
            description,
        }
    }

}

const LEGAL_HOLDS_REPORT_A_HOLD_TYPE_FIELDS: &[&str] = &["description"];
impl LegalHoldsReportAHoldType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LegalHoldsReportAHoldType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LegalHoldsReportAHoldType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LegalHoldsReportAHoldType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LegalHoldsReportAHoldType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LegalHoldsReportAHoldType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LegalHoldsReportAHoldType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LegalHoldsReportAHoldType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LegalHoldsReportAHoldType", LEGAL_HOLDS_REPORT_A_HOLD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LegalHoldsReportAHoldType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LegalHoldsReportAHoldType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The device sessions that user is linked to.
#[derive(Debug)]
pub enum LinkedDeviceLogInfo {
    /// mobile device session's details.
    MobileDeviceSession(MobileDeviceSessionLogInfo),
    /// desktop device session's details.
    DesktopDeviceSession(DesktopDeviceSessionLogInfo),
    /// web device session's details.
    WebDeviceSession(WebDeviceSessionLogInfo),
    /// legacy device session's details.
    LegacyDeviceSession(LegacyDeviceSessionLogInfo),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LinkedDeviceLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LinkedDeviceLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LinkedDeviceLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "mobile_device_session" => Ok(LinkedDeviceLogInfo::MobileDeviceSession(MobileDeviceSessionLogInfo::internal_deserialize(map)?)),
                    "desktop_device_session" => Ok(LinkedDeviceLogInfo::DesktopDeviceSession(DesktopDeviceSessionLogInfo::internal_deserialize(map)?)),
                    "web_device_session" => Ok(LinkedDeviceLogInfo::WebDeviceSession(WebDeviceSessionLogInfo::internal_deserialize(map)?)),
                    "legacy_device_session" => Ok(LinkedDeviceLogInfo::LegacyDeviceSession(LegacyDeviceSessionLogInfo::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LinkedDeviceLogInfo::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["mobile_device_session",
                                    "desktop_device_session",
                                    "web_device_session",
                                    "legacy_device_session",
                                    "other"];
        deserializer.deserialize_struct("LinkedDeviceLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LinkedDeviceLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LinkedDeviceLogInfo::MobileDeviceSession(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("LinkedDeviceLogInfo", 10)?;
                s.serialize_field(".tag", "mobile_device_session")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            LinkedDeviceLogInfo::DesktopDeviceSession(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("LinkedDeviceLogInfo", 10)?;
                s.serialize_field(".tag", "desktop_device_session")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            LinkedDeviceLogInfo::WebDeviceSession(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("LinkedDeviceLogInfo", 8)?;
                s.serialize_field(".tag", "web_device_session")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            LinkedDeviceLogInfo::LegacyDeviceSession(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("LinkedDeviceLogInfo", 13)?;
                s.serialize_field(".tag", "legacy_device_session")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            LinkedDeviceLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// File lock status
#[derive(Debug)]
pub enum LockStatus {
    Locked,
    Unlocked,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LockStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LockStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LockStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "locked" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LockStatus::Locked)
                    }
                    "unlocked" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LockStatus::Unlocked)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LockStatus::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["locked",
                                    "unlocked",
                                    "other"];
        deserializer.deserialize_struct("LockStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LockStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LockStatus::Locked => {
                // unit
                let mut s = serializer.serialize_struct("LockStatus", 1)?;
                s.serialize_field(".tag", "locked")?;
                s.end()
            }
            LockStatus::Unlocked => {
                // unit
                let mut s = serializer.serialize_struct("LockStatus", 1)?;
                s.serialize_field(".tag", "unlocked")?;
                s.end()
            }
            LockStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Failed to sign in.
#[derive(Debug)]
pub struct LoginFailDetails {
    /// Login method.
    pub login_method: LoginMethod,
    /// Error details.
    pub error_details: FailureDetailsLogInfo,
    /// Tells if the login device is EMM managed. Might be missing due to historical data gap.
    pub is_emm_managed: Option<bool>,
}

impl LoginFailDetails {
    pub fn new(login_method: LoginMethod, error_details: FailureDetailsLogInfo) -> Self {
        LoginFailDetails {
            login_method,
            error_details,
            is_emm_managed: None,
        }
    }

    pub fn with_is_emm_managed(mut self, value: Option<bool>) -> Self {
        self.is_emm_managed = value;
        self
    }

}

const LOGIN_FAIL_DETAILS_FIELDS: &[&str] = &["login_method",
                                             "error_details",
                                             "is_emm_managed"];
impl LoginFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LoginFailDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LoginFailDetails>, V::Error> {
        let mut field_login_method = None;
        let mut field_error_details = None;
        let mut field_is_emm_managed = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "login_method" => {
                    if field_login_method.is_some() {
                        return Err(::serde::de::Error::duplicate_field("login_method"));
                    }
                    field_login_method = Some(map.next_value()?);
                }
                "error_details" => {
                    if field_error_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("error_details"));
                    }
                    field_error_details = Some(map.next_value()?);
                }
                "is_emm_managed" => {
                    if field_is_emm_managed.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_emm_managed"));
                    }
                    field_is_emm_managed = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LoginFailDetails {
            login_method: field_login_method.ok_or_else(|| ::serde::de::Error::missing_field("login_method"))?,
            error_details: field_error_details.ok_or_else(|| ::serde::de::Error::missing_field("error_details"))?,
            is_emm_managed: field_is_emm_managed,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("login_method", &self.login_method)?;
        s.serialize_field("error_details", &self.error_details)?;
        s.serialize_field("is_emm_managed", &self.is_emm_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LoginFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LoginFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LoginFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LoginFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LoginFailDetails", LOGIN_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LoginFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LoginFailDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LoginFailType {
    pub description: String,
}

impl LoginFailType {
    pub fn new(description: String) -> Self {
        LoginFailType {
            description,
        }
    }

}

const LOGIN_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl LoginFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LoginFailType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LoginFailType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LoginFailType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LoginFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LoginFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LoginFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LoginFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LoginFailType", LOGIN_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LoginFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LoginFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum LoginMethod {
    Password,
    TwoFactorAuthentication,
    Saml,
    GoogleOauth,
    WebSession,
    QrCode,
    AppleOauth,
    FirstPartyTokenExchange,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LoginMethod {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LoginMethod;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LoginMethod structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "password" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LoginMethod::Password)
                    }
                    "two_factor_authentication" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LoginMethod::TwoFactorAuthentication)
                    }
                    "saml" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LoginMethod::Saml)
                    }
                    "google_oauth" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LoginMethod::GoogleOauth)
                    }
                    "web_session" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LoginMethod::WebSession)
                    }
                    "qr_code" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LoginMethod::QrCode)
                    }
                    "apple_oauth" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LoginMethod::AppleOauth)
                    }
                    "first_party_token_exchange" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LoginMethod::FirstPartyTokenExchange)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LoginMethod::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["password",
                                    "two_factor_authentication",
                                    "saml",
                                    "google_oauth",
                                    "web_session",
                                    "qr_code",
                                    "apple_oauth",
                                    "first_party_token_exchange",
                                    "other"];
        deserializer.deserialize_struct("LoginMethod", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LoginMethod {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LoginMethod::Password => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "password")?;
                s.end()
            }
            LoginMethod::TwoFactorAuthentication => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "two_factor_authentication")?;
                s.end()
            }
            LoginMethod::Saml => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "saml")?;
                s.end()
            }
            LoginMethod::GoogleOauth => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "google_oauth")?;
                s.end()
            }
            LoginMethod::WebSession => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "web_session")?;
                s.end()
            }
            LoginMethod::QrCode => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "qr_code")?;
                s.end()
            }
            LoginMethod::AppleOauth => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "apple_oauth")?;
                s.end()
            }
            LoginMethod::FirstPartyTokenExchange => {
                // unit
                let mut s = serializer.serialize_struct("LoginMethod", 1)?;
                s.serialize_field(".tag", "first_party_token_exchange")?;
                s.end()
            }
            LoginMethod::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Signed in.
#[derive(Debug)]
pub struct LoginSuccessDetails {
    /// Login method.
    pub login_method: LoginMethod,
    /// Tells if the login device is EMM managed. Might be missing due to historical data gap.
    pub is_emm_managed: Option<bool>,
}

impl LoginSuccessDetails {
    pub fn new(login_method: LoginMethod) -> Self {
        LoginSuccessDetails {
            login_method,
            is_emm_managed: None,
        }
    }

    pub fn with_is_emm_managed(mut self, value: Option<bool>) -> Self {
        self.is_emm_managed = value;
        self
    }

}

const LOGIN_SUCCESS_DETAILS_FIELDS: &[&str] = &["login_method",
                                                "is_emm_managed"];
impl LoginSuccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LoginSuccessDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LoginSuccessDetails>, V::Error> {
        let mut field_login_method = None;
        let mut field_is_emm_managed = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "login_method" => {
                    if field_login_method.is_some() {
                        return Err(::serde::de::Error::duplicate_field("login_method"));
                    }
                    field_login_method = Some(map.next_value()?);
                }
                "is_emm_managed" => {
                    if field_is_emm_managed.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_emm_managed"));
                    }
                    field_is_emm_managed = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LoginSuccessDetails {
            login_method: field_login_method.ok_or_else(|| ::serde::de::Error::missing_field("login_method"))?,
            is_emm_managed: field_is_emm_managed,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("login_method", &self.login_method)?;
        s.serialize_field("is_emm_managed", &self.is_emm_managed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LoginSuccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LoginSuccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LoginSuccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LoginSuccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LoginSuccessDetails", LOGIN_SUCCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LoginSuccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LoginSuccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LoginSuccessType {
    pub description: String,
}

impl LoginSuccessType {
    pub fn new(description: String) -> Self {
        LoginSuccessType {
            description,
        }
    }

}

const LOGIN_SUCCESS_TYPE_FIELDS: &[&str] = &["description"];
impl LoginSuccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LoginSuccessType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LoginSuccessType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LoginSuccessType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LoginSuccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LoginSuccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LoginSuccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LoginSuccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LoginSuccessType", LOGIN_SUCCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LoginSuccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LoginSuccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Signed out.
#[derive(Debug)]
pub struct LogoutDetails {
}

impl Default for LogoutDetails {
    fn default() -> Self {
        LogoutDetails {
        }
    }
}

const LOGOUT_DETAILS_FIELDS: &[&str] = &[];
impl LogoutDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LogoutDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(LogoutDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LogoutDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LogoutDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LogoutDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LogoutDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LogoutDetails", LOGOUT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LogoutDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("LogoutDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct LogoutType {
    pub description: String,
}

impl LogoutType {
    pub fn new(description: String) -> Self {
        LogoutType {
            description,
        }
    }

}

const LOGOUT_TYPE_FIELDS: &[&str] = &["description"];
impl LogoutType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<LogoutType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<LogoutType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = LogoutType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LogoutType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LogoutType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LogoutType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LogoutType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LogoutType", LOGOUT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LogoutType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LogoutType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added an external ID for team member.
#[derive(Debug)]
pub struct MemberAddExternalIdDetails {
    /// Current external id.
    pub new_value: super::team_common::MemberExternalId,
}

impl MemberAddExternalIdDetails {
    pub fn new(new_value: super::team_common::MemberExternalId) -> Self {
        MemberAddExternalIdDetails {
            new_value,
        }
    }

}

const MEMBER_ADD_EXTERNAL_ID_DETAILS_FIELDS: &[&str] = &["new_value"];
impl MemberAddExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberAddExternalIdDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberAddExternalIdDetails>, V::Error> {
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberAddExternalIdDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAddExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAddExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberAddExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAddExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAddExternalIdDetails", MEMBER_ADD_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAddExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAddExternalIdDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberAddExternalIdType {
    pub description: String,
}

impl MemberAddExternalIdType {
    pub fn new(description: String) -> Self {
        MemberAddExternalIdType {
            description,
        }
    }

}

const MEMBER_ADD_EXTERNAL_ID_TYPE_FIELDS: &[&str] = &["description"];
impl MemberAddExternalIdType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberAddExternalIdType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberAddExternalIdType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberAddExternalIdType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAddExternalIdType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAddExternalIdType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberAddExternalIdType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAddExternalIdType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAddExternalIdType", MEMBER_ADD_EXTERNAL_ID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAddExternalIdType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAddExternalIdType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added team member name.
#[derive(Debug)]
pub struct MemberAddNameDetails {
    /// New user's name.
    pub new_value: UserNameLogInfo,
}

impl MemberAddNameDetails {
    pub fn new(new_value: UserNameLogInfo) -> Self {
        MemberAddNameDetails {
            new_value,
        }
    }

}

const MEMBER_ADD_NAME_DETAILS_FIELDS: &[&str] = &["new_value"];
impl MemberAddNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberAddNameDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberAddNameDetails>, V::Error> {
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberAddNameDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAddNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAddNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberAddNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAddNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAddNameDetails", MEMBER_ADD_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAddNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAddNameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberAddNameType {
    pub description: String,
}

impl MemberAddNameType {
    pub fn new(description: String) -> Self {
        MemberAddNameType {
            description,
        }
    }

}

const MEMBER_ADD_NAME_TYPE_FIELDS: &[&str] = &["description"];
impl MemberAddNameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberAddNameType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberAddNameType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberAddNameType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAddNameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAddNameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberAddNameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAddNameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAddNameType", MEMBER_ADD_NAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAddNameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAddNameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team member admin role.
#[derive(Debug)]
pub struct MemberChangeAdminRoleDetails {
    /// New admin role. This field is relevant when the admin role is changed or whenthe user role
    /// changes from no admin rights to with admin rights.
    pub new_value: Option<AdminRole>,
    /// Previous admin role. This field is relevant when the admin role is changed or when the admin
    /// role is removed.
    pub previous_value: Option<AdminRole>,
}

impl Default for MemberChangeAdminRoleDetails {
    fn default() -> Self {
        MemberChangeAdminRoleDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const MEMBER_CHANGE_ADMIN_ROLE_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl MemberChangeAdminRoleDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberChangeAdminRoleDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = MemberChangeAdminRoleDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeAdminRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeAdminRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeAdminRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeAdminRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeAdminRoleDetails", MEMBER_CHANGE_ADMIN_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeAdminRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeAdminRoleDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeAdminRoleType {
    pub description: String,
}

impl MemberChangeAdminRoleType {
    pub fn new(description: String) -> Self {
        MemberChangeAdminRoleType {
            description,
        }
    }

}

const MEMBER_CHANGE_ADMIN_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeAdminRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeAdminRoleType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeAdminRoleType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeAdminRoleType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeAdminRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeAdminRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeAdminRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeAdminRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeAdminRoleType", MEMBER_CHANGE_ADMIN_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeAdminRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeAdminRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team member email.
#[derive(Debug)]
pub struct MemberChangeEmailDetails {
    /// New email.
    pub new_value: EmailAddress,
    /// Previous email. Might be missing due to historical data gap.
    pub previous_value: Option<EmailAddress>,
}

impl MemberChangeEmailDetails {
    pub fn new(new_value: EmailAddress) -> Self {
        MemberChangeEmailDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<EmailAddress>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_CHANGE_EMAIL_DETAILS_FIELDS: &[&str] = &["new_value",
                                                      "previous_value"];
impl MemberChangeEmailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeEmailDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeEmailDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeEmailDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeEmailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeEmailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeEmailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeEmailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeEmailDetails", MEMBER_CHANGE_EMAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeEmailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeEmailDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeEmailType {
    pub description: String,
}

impl MemberChangeEmailType {
    pub fn new(description: String) -> Self {
        MemberChangeEmailType {
            description,
        }
    }

}

const MEMBER_CHANGE_EMAIL_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeEmailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeEmailType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeEmailType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeEmailType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeEmailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeEmailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeEmailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeEmailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeEmailType", MEMBER_CHANGE_EMAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeEmailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeEmailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the external ID for team member.
#[derive(Debug)]
pub struct MemberChangeExternalIdDetails {
    /// Current external id.
    pub new_value: super::team_common::MemberExternalId,
    /// Old external id.
    pub previous_value: super::team_common::MemberExternalId,
}

impl MemberChangeExternalIdDetails {
    pub fn new(
        new_value: super::team_common::MemberExternalId,
        previous_value: super::team_common::MemberExternalId,
    ) -> Self {
        MemberChangeExternalIdDetails {
            new_value,
            previous_value,
        }
    }

}

const MEMBER_CHANGE_EXTERNAL_ID_DETAILS_FIELDS: &[&str] = &["new_value",
                                                            "previous_value"];
impl MemberChangeExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeExternalIdDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeExternalIdDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeExternalIdDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeExternalIdDetails", MEMBER_CHANGE_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeExternalIdDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeExternalIdType {
    pub description: String,
}

impl MemberChangeExternalIdType {
    pub fn new(description: String) -> Self {
        MemberChangeExternalIdType {
            description,
        }
    }

}

const MEMBER_CHANGE_EXTERNAL_ID_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeExternalIdType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeExternalIdType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeExternalIdType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeExternalIdType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeExternalIdType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeExternalIdType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeExternalIdType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeExternalIdType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeExternalIdType", MEMBER_CHANGE_EXTERNAL_ID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeExternalIdType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeExternalIdType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed membership type (limited/full) of member.
#[derive(Debug)]
pub struct MemberChangeMembershipTypeDetails {
    /// Previous membership type.
    pub prev_value: TeamMembershipType,
    /// New membership type.
    pub new_value: TeamMembershipType,
}

impl MemberChangeMembershipTypeDetails {
    pub fn new(prev_value: TeamMembershipType, new_value: TeamMembershipType) -> Self {
        MemberChangeMembershipTypeDetails {
            prev_value,
            new_value,
        }
    }

}

const MEMBER_CHANGE_MEMBERSHIP_TYPE_DETAILS_FIELDS: &[&str] = &["prev_value",
                                                                "new_value"];
impl MemberChangeMembershipTypeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeMembershipTypeDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeMembershipTypeDetails>, V::Error> {
        let mut field_prev_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "prev_value" => {
                    if field_prev_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("prev_value"));
                    }
                    field_prev_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeMembershipTypeDetails {
            prev_value: field_prev_value.ok_or_else(|| ::serde::de::Error::missing_field("prev_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("prev_value", &self.prev_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeMembershipTypeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeMembershipTypeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeMembershipTypeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeMembershipTypeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeMembershipTypeDetails", MEMBER_CHANGE_MEMBERSHIP_TYPE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeMembershipTypeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeMembershipTypeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeMembershipTypeType {
    pub description: String,
}

impl MemberChangeMembershipTypeType {
    pub fn new(description: String) -> Self {
        MemberChangeMembershipTypeType {
            description,
        }
    }

}

const MEMBER_CHANGE_MEMBERSHIP_TYPE_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeMembershipTypeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeMembershipTypeType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeMembershipTypeType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeMembershipTypeType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeMembershipTypeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeMembershipTypeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeMembershipTypeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeMembershipTypeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeMembershipTypeType", MEMBER_CHANGE_MEMBERSHIP_TYPE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeMembershipTypeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeMembershipTypeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team member name.
#[derive(Debug)]
pub struct MemberChangeNameDetails {
    /// New user's name.
    pub new_value: UserNameLogInfo,
    /// Previous user's name. Might be missing due to historical data gap.
    pub previous_value: Option<UserNameLogInfo>,
}

impl MemberChangeNameDetails {
    pub fn new(new_value: UserNameLogInfo) -> Self {
        MemberChangeNameDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<UserNameLogInfo>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_CHANGE_NAME_DETAILS_FIELDS: &[&str] = &["new_value",
                                                     "previous_value"];
impl MemberChangeNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeNameDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeNameDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeNameDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeNameDetails", MEMBER_CHANGE_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeNameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeNameType {
    pub description: String,
}

impl MemberChangeNameType {
    pub fn new(description: String) -> Self {
        MemberChangeNameType {
            description,
        }
    }

}

const MEMBER_CHANGE_NAME_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeNameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeNameType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeNameType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeNameType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeNameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeNameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeNameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeNameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeNameType", MEMBER_CHANGE_NAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeNameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeNameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed member status (invited, joined, suspended, etc.).
#[derive(Debug)]
pub struct MemberChangeStatusDetails {
    /// New member status.
    pub new_value: MemberStatus,
    /// Previous member status. Might be missing due to historical data gap.
    pub previous_value: Option<MemberStatus>,
    /// Additional information indicating the action taken that caused status change.
    pub action: Option<ActionDetails>,
}

impl MemberChangeStatusDetails {
    pub fn new(new_value: MemberStatus) -> Self {
        MemberChangeStatusDetails {
            new_value,
            previous_value: None,
            action: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MemberStatus>) -> Self {
        self.previous_value = value;
        self
    }

    pub fn with_action(mut self, value: Option<ActionDetails>) -> Self {
        self.action = value;
        self
    }

}

const MEMBER_CHANGE_STATUS_DETAILS_FIELDS: &[&str] = &["new_value",
                                                       "previous_value",
                                                       "action"];
impl MemberChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeStatusDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeStatusDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut field_action = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "action" => {
                    if field_action.is_some() {
                        return Err(::serde::de::Error::duplicate_field("action"));
                    }
                    field_action = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeStatusDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
            action: field_action,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("action", &self.action)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeStatusDetails", MEMBER_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeStatusDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberChangeStatusType {
    pub description: String,
}

impl MemberChangeStatusType {
    pub fn new(description: String) -> Self {
        MemberChangeStatusType {
            description,
        }
    }

}

const MEMBER_CHANGE_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl MemberChangeStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberChangeStatusType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberChangeStatusType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberChangeStatusType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberChangeStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberChangeStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberChangeStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberChangeStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberChangeStatusType", MEMBER_CHANGE_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberChangeStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberChangeStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Cleared manually added contacts.
#[derive(Debug)]
pub struct MemberDeleteManualContactsDetails {
}

impl Default for MemberDeleteManualContactsDetails {
    fn default() -> Self {
        MemberDeleteManualContactsDetails {
        }
    }
}

const MEMBER_DELETE_MANUAL_CONTACTS_DETAILS_FIELDS: &[&str] = &[];
impl MemberDeleteManualContactsDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberDeleteManualContactsDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(MemberDeleteManualContactsDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberDeleteManualContactsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberDeleteManualContactsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberDeleteManualContactsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberDeleteManualContactsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberDeleteManualContactsDetails", MEMBER_DELETE_MANUAL_CONTACTS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberDeleteManualContactsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberDeleteManualContactsDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberDeleteManualContactsType {
    pub description: String,
}

impl MemberDeleteManualContactsType {
    pub fn new(description: String) -> Self {
        MemberDeleteManualContactsType {
            description,
        }
    }

}

const MEMBER_DELETE_MANUAL_CONTACTS_TYPE_FIELDS: &[&str] = &["description"];
impl MemberDeleteManualContactsType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberDeleteManualContactsType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberDeleteManualContactsType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberDeleteManualContactsType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberDeleteManualContactsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberDeleteManualContactsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberDeleteManualContactsType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberDeleteManualContactsType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberDeleteManualContactsType", MEMBER_DELETE_MANUAL_CONTACTS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberDeleteManualContactsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberDeleteManualContactsType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted team member profile photo.
#[derive(Debug)]
pub struct MemberDeleteProfilePhotoDetails {
}

impl Default for MemberDeleteProfilePhotoDetails {
    fn default() -> Self {
        MemberDeleteProfilePhotoDetails {
        }
    }
}

const MEMBER_DELETE_PROFILE_PHOTO_DETAILS_FIELDS: &[&str] = &[];
impl MemberDeleteProfilePhotoDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberDeleteProfilePhotoDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(MemberDeleteProfilePhotoDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberDeleteProfilePhotoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberDeleteProfilePhotoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberDeleteProfilePhotoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberDeleteProfilePhotoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberDeleteProfilePhotoDetails", MEMBER_DELETE_PROFILE_PHOTO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberDeleteProfilePhotoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberDeleteProfilePhotoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberDeleteProfilePhotoType {
    pub description: String,
}

impl MemberDeleteProfilePhotoType {
    pub fn new(description: String) -> Self {
        MemberDeleteProfilePhotoType {
            description,
        }
    }

}

const MEMBER_DELETE_PROFILE_PHOTO_TYPE_FIELDS: &[&str] = &["description"];
impl MemberDeleteProfilePhotoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberDeleteProfilePhotoType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberDeleteProfilePhotoType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberDeleteProfilePhotoType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberDeleteProfilePhotoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberDeleteProfilePhotoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberDeleteProfilePhotoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberDeleteProfilePhotoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberDeleteProfilePhotoType", MEMBER_DELETE_PROFILE_PHOTO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberDeleteProfilePhotoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberDeleteProfilePhotoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted contents of deleted team member account.
#[derive(Debug)]
pub struct MemberPermanentlyDeleteAccountContentsDetails {
}

impl Default for MemberPermanentlyDeleteAccountContentsDetails {
    fn default() -> Self {
        MemberPermanentlyDeleteAccountContentsDetails {
        }
    }
}

const MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_DETAILS_FIELDS: &[&str] = &[];
impl MemberPermanentlyDeleteAccountContentsDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberPermanentlyDeleteAccountContentsDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(MemberPermanentlyDeleteAccountContentsDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberPermanentlyDeleteAccountContentsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberPermanentlyDeleteAccountContentsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberPermanentlyDeleteAccountContentsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberPermanentlyDeleteAccountContentsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberPermanentlyDeleteAccountContentsDetails", MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberPermanentlyDeleteAccountContentsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberPermanentlyDeleteAccountContentsDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberPermanentlyDeleteAccountContentsType {
    pub description: String,
}

impl MemberPermanentlyDeleteAccountContentsType {
    pub fn new(description: String) -> Self {
        MemberPermanentlyDeleteAccountContentsType {
            description,
        }
    }

}

const MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_TYPE_FIELDS: &[&str] = &["description"];
impl MemberPermanentlyDeleteAccountContentsType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberPermanentlyDeleteAccountContentsType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberPermanentlyDeleteAccountContentsType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberPermanentlyDeleteAccountContentsType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberPermanentlyDeleteAccountContentsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberPermanentlyDeleteAccountContentsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberPermanentlyDeleteAccountContentsType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberPermanentlyDeleteAccountContentsType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberPermanentlyDeleteAccountContentsType", MEMBER_PERMANENTLY_DELETE_ACCOUNT_CONTENTS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberPermanentlyDeleteAccountContentsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberPermanentlyDeleteAccountContentsType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MemberRemoveActionType {
    Delete,
    Offboard,
    Leave,
    OffboardAndRetainTeamFolders,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRemoveActionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberRemoveActionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberRemoveActionType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "delete" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberRemoveActionType::Delete)
                    }
                    "offboard" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberRemoveActionType::Offboard)
                    }
                    "leave" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberRemoveActionType::Leave)
                    }
                    "offboard_and_retain_team_folders" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberRemoveActionType::OffboardAndRetainTeamFolders)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberRemoveActionType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["delete",
                                    "offboard",
                                    "leave",
                                    "offboard_and_retain_team_folders",
                                    "other"];
        deserializer.deserialize_struct("MemberRemoveActionType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRemoveActionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberRemoveActionType::Delete => {
                // unit
                let mut s = serializer.serialize_struct("MemberRemoveActionType", 1)?;
                s.serialize_field(".tag", "delete")?;
                s.end()
            }
            MemberRemoveActionType::Offboard => {
                // unit
                let mut s = serializer.serialize_struct("MemberRemoveActionType", 1)?;
                s.serialize_field(".tag", "offboard")?;
                s.end()
            }
            MemberRemoveActionType::Leave => {
                // unit
                let mut s = serializer.serialize_struct("MemberRemoveActionType", 1)?;
                s.serialize_field(".tag", "leave")?;
                s.end()
            }
            MemberRemoveActionType::OffboardAndRetainTeamFolders => {
                // unit
                let mut s = serializer.serialize_struct("MemberRemoveActionType", 1)?;
                s.serialize_field(".tag", "offboard_and_retain_team_folders")?;
                s.end()
            }
            MemberRemoveActionType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Removed the external ID for team member.
#[derive(Debug)]
pub struct MemberRemoveExternalIdDetails {
    /// Old external id.
    pub previous_value: super::team_common::MemberExternalId,
}

impl MemberRemoveExternalIdDetails {
    pub fn new(previous_value: super::team_common::MemberExternalId) -> Self {
        MemberRemoveExternalIdDetails {
            previous_value,
        }
    }

}

const MEMBER_REMOVE_EXTERNAL_ID_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl MemberRemoveExternalIdDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberRemoveExternalIdDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberRemoveExternalIdDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberRemoveExternalIdDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRemoveExternalIdDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberRemoveExternalIdDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberRemoveExternalIdDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberRemoveExternalIdDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberRemoveExternalIdDetails", MEMBER_REMOVE_EXTERNAL_ID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRemoveExternalIdDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberRemoveExternalIdDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberRemoveExternalIdType {
    pub description: String,
}

impl MemberRemoveExternalIdType {
    pub fn new(description: String) -> Self {
        MemberRemoveExternalIdType {
            description,
        }
    }

}

const MEMBER_REMOVE_EXTERNAL_ID_TYPE_FIELDS: &[&str] = &["description"];
impl MemberRemoveExternalIdType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberRemoveExternalIdType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberRemoveExternalIdType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberRemoveExternalIdType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRemoveExternalIdType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberRemoveExternalIdType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberRemoveExternalIdType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberRemoveExternalIdType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberRemoveExternalIdType", MEMBER_REMOVE_EXTERNAL_ID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRemoveExternalIdType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberRemoveExternalIdType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether users can find team when not invited.
#[derive(Debug)]
pub struct MemberRequestsChangePolicyDetails {
    /// New member change requests policy.
    pub new_value: MemberRequestsPolicy,
    /// Previous member change requests policy. Might be missing due to historical data gap.
    pub previous_value: Option<MemberRequestsPolicy>,
}

impl MemberRequestsChangePolicyDetails {
    pub fn new(new_value: MemberRequestsPolicy) -> Self {
        MemberRequestsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MemberRequestsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl MemberRequestsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberRequestsChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberRequestsChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberRequestsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRequestsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberRequestsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberRequestsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberRequestsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberRequestsChangePolicyDetails", MEMBER_REQUESTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRequestsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberRequestsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberRequestsChangePolicyType {
    pub description: String,
}

impl MemberRequestsChangePolicyType {
    pub fn new(description: String) -> Self {
        MemberRequestsChangePolicyType {
            description,
        }
    }

}

const MEMBER_REQUESTS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MemberRequestsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberRequestsChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberRequestsChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberRequestsChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRequestsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberRequestsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberRequestsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberRequestsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberRequestsChangePolicyType", MEMBER_REQUESTS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRequestsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberRequestsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MemberRequestsPolicy {
    AutoAccept,
    Disabled,
    RequireApproval,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberRequestsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberRequestsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberRequestsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "auto_accept" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberRequestsPolicy::AutoAccept)
                    }
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberRequestsPolicy::Disabled)
                    }
                    "require_approval" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberRequestsPolicy::RequireApproval)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberRequestsPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["auto_accept",
                                    "disabled",
                                    "require_approval",
                                    "other"];
        deserializer.deserialize_struct("MemberRequestsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberRequestsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberRequestsPolicy::AutoAccept => {
                // unit
                let mut s = serializer.serialize_struct("MemberRequestsPolicy", 1)?;
                s.serialize_field(".tag", "auto_accept")?;
                s.end()
            }
            MemberRequestsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberRequestsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MemberRequestsPolicy::RequireApproval => {
                // unit
                let mut s = serializer.serialize_struct("MemberRequestsPolicy", 1)?;
                s.serialize_field(".tag", "require_approval")?;
                s.end()
            }
            MemberRequestsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Policy for controlling whether team members can send team invites
#[derive(Debug)]
pub enum MemberSendInvitePolicy {
    Disabled,
    SpecificMembers,
    Everyone,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSendInvitePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberSendInvitePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSendInvitePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberSendInvitePolicy::Disabled)
                    }
                    "specific_members" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberSendInvitePolicy::SpecificMembers)
                    }
                    "everyone" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberSendInvitePolicy::Everyone)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberSendInvitePolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "specific_members",
                                    "everyone",
                                    "other"];
        deserializer.deserialize_struct("MemberSendInvitePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSendInvitePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberSendInvitePolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberSendInvitePolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MemberSendInvitePolicy::SpecificMembers => {
                // unit
                let mut s = serializer.serialize_struct("MemberSendInvitePolicy", 1)?;
                s.serialize_field(".tag", "specific_members")?;
                s.end()
            }
            MemberSendInvitePolicy::Everyone => {
                // unit
                let mut s = serializer.serialize_struct("MemberSendInvitePolicy", 1)?;
                s.serialize_field(".tag", "everyone")?;
                s.end()
            }
            MemberSendInvitePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed member send invite policy for team.
#[derive(Debug)]
pub struct MemberSendInvitePolicyChangedDetails {
    /// New team member send invite policy.
    pub new_value: MemberSendInvitePolicy,
    /// Previous team member send invite policy.
    pub previous_value: MemberSendInvitePolicy,
}

impl MemberSendInvitePolicyChangedDetails {
    pub fn new(new_value: MemberSendInvitePolicy, previous_value: MemberSendInvitePolicy) -> Self {
        MemberSendInvitePolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const MEMBER_SEND_INVITE_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                    "previous_value"];
impl MemberSendInvitePolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSendInvitePolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSendInvitePolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSendInvitePolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSendInvitePolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSendInvitePolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSendInvitePolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSendInvitePolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSendInvitePolicyChangedDetails", MEMBER_SEND_INVITE_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSendInvitePolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSendInvitePolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSendInvitePolicyChangedType {
    pub description: String,
}

impl MemberSendInvitePolicyChangedType {
    pub fn new(description: String) -> Self {
        MemberSendInvitePolicyChangedType {
            description,
        }
    }

}

const MEMBER_SEND_INVITE_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSendInvitePolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSendInvitePolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSendInvitePolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSendInvitePolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSendInvitePolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSendInvitePolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSendInvitePolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSendInvitePolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSendInvitePolicyChangedType", MEMBER_SEND_INVITE_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSendInvitePolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSendInvitePolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set team member profile photo.
#[derive(Debug)]
pub struct MemberSetProfilePhotoDetails {
}

impl Default for MemberSetProfilePhotoDetails {
    fn default() -> Self {
        MemberSetProfilePhotoDetails {
        }
    }
}

const MEMBER_SET_PROFILE_PHOTO_DETAILS_FIELDS: &[&str] = &[];
impl MemberSetProfilePhotoDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSetProfilePhotoDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(MemberSetProfilePhotoDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSetProfilePhotoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSetProfilePhotoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSetProfilePhotoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSetProfilePhotoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSetProfilePhotoDetails", MEMBER_SET_PROFILE_PHOTO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSetProfilePhotoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSetProfilePhotoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberSetProfilePhotoType {
    pub description: String,
}

impl MemberSetProfilePhotoType {
    pub fn new(description: String) -> Self {
        MemberSetProfilePhotoType {
            description,
        }
    }

}

const MEMBER_SET_PROFILE_PHOTO_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSetProfilePhotoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSetProfilePhotoType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSetProfilePhotoType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSetProfilePhotoType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSetProfilePhotoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSetProfilePhotoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSetProfilePhotoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSetProfilePhotoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSetProfilePhotoType", MEMBER_SET_PROFILE_PHOTO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSetProfilePhotoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSetProfilePhotoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set custom member space limit.
#[derive(Debug)]
pub struct MemberSpaceLimitsAddCustomQuotaDetails {
    /// New custom quota value in bytes.
    pub new_value: u64,
}

impl MemberSpaceLimitsAddCustomQuotaDetails {
    pub fn new(new_value: u64) -> Self {
        MemberSpaceLimitsAddCustomQuotaDetails {
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_DETAILS_FIELDS: &[&str] = &["new_value"];
impl MemberSpaceLimitsAddCustomQuotaDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsAddCustomQuotaDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsAddCustomQuotaDetails>, V::Error> {
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsAddCustomQuotaDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsAddCustomQuotaDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsAddCustomQuotaDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsAddCustomQuotaDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsAddCustomQuotaDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsAddCustomQuotaDetails", MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsAddCustomQuotaDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsAddCustomQuotaDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsAddCustomQuotaType {
    pub description: String,
}

impl MemberSpaceLimitsAddCustomQuotaType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsAddCustomQuotaType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsAddCustomQuotaType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsAddCustomQuotaType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsAddCustomQuotaType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsAddCustomQuotaType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsAddCustomQuotaType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsAddCustomQuotaType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsAddCustomQuotaType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsAddCustomQuotaType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsAddCustomQuotaType", MEMBER_SPACE_LIMITS_ADD_CUSTOM_QUOTA_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsAddCustomQuotaType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsAddCustomQuotaType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added members to member space limit exception list.
#[derive(Debug)]
pub struct MemberSpaceLimitsAddExceptionDetails {
}

impl Default for MemberSpaceLimitsAddExceptionDetails {
    fn default() -> Self {
        MemberSpaceLimitsAddExceptionDetails {
        }
    }
}

const MEMBER_SPACE_LIMITS_ADD_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl MemberSpaceLimitsAddExceptionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsAddExceptionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(MemberSpaceLimitsAddExceptionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsAddExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsAddExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsAddExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsAddExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsAddExceptionDetails", MEMBER_SPACE_LIMITS_ADD_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsAddExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSpaceLimitsAddExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsAddExceptionType {
    pub description: String,
}

impl MemberSpaceLimitsAddExceptionType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsAddExceptionType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_ADD_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsAddExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsAddExceptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsAddExceptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsAddExceptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsAddExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsAddExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsAddExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsAddExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsAddExceptionType", MEMBER_SPACE_LIMITS_ADD_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsAddExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsAddExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed member space limit type for team.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangeCapsTypePolicyDetails {
    /// Previous space limit type.
    pub previous_value: SpaceCapsType,
    /// New space limit type.
    pub new_value: SpaceCapsType,
}

impl MemberSpaceLimitsChangeCapsTypePolicyDetails {
    pub fn new(previous_value: SpaceCapsType, new_value: SpaceCapsType) -> Self {
        MemberSpaceLimitsChangeCapsTypePolicyDetails {
            previous_value,
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                              "new_value"];
impl MemberSpaceLimitsChangeCapsTypePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsChangeCapsTypePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsChangeCapsTypePolicyDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsChangeCapsTypePolicyDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeCapsTypePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeCapsTypePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeCapsTypePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeCapsTypePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeCapsTypePolicyDetails", MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeCapsTypePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeCapsTypePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsChangeCapsTypePolicyType {
    pub description: String,
}

impl MemberSpaceLimitsChangeCapsTypePolicyType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsChangeCapsTypePolicyType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsChangeCapsTypePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsChangeCapsTypePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsChangeCapsTypePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsChangeCapsTypePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeCapsTypePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeCapsTypePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeCapsTypePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeCapsTypePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeCapsTypePolicyType", MEMBER_SPACE_LIMITS_CHANGE_CAPS_TYPE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeCapsTypePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeCapsTypePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed custom member space limit.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangeCustomQuotaDetails {
    /// Previous custom quota value in bytes.
    pub previous_value: u64,
    /// New custom quota value in bytes.
    pub new_value: u64,
}

impl MemberSpaceLimitsChangeCustomQuotaDetails {
    pub fn new(previous_value: u64, new_value: u64) -> Self {
        MemberSpaceLimitsChangeCustomQuotaDetails {
            previous_value,
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                          "new_value"];
impl MemberSpaceLimitsChangeCustomQuotaDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsChangeCustomQuotaDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsChangeCustomQuotaDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsChangeCustomQuotaDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeCustomQuotaDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeCustomQuotaDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeCustomQuotaDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeCustomQuotaDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeCustomQuotaDetails", MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeCustomQuotaDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeCustomQuotaDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsChangeCustomQuotaType {
    pub description: String,
}

impl MemberSpaceLimitsChangeCustomQuotaType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsChangeCustomQuotaType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsChangeCustomQuotaType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsChangeCustomQuotaType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsChangeCustomQuotaType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsChangeCustomQuotaType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeCustomQuotaType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeCustomQuotaType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeCustomQuotaType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeCustomQuotaType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeCustomQuotaType", MEMBER_SPACE_LIMITS_CHANGE_CUSTOM_QUOTA_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeCustomQuotaType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeCustomQuotaType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team default member space limit.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangePolicyDetails {
    /// Previous team default limit value in bytes. Might be missing due to historical data gap.
    pub previous_value: Option<u64>,
    /// New team default limit value in bytes. Might be missing due to historical data gap.
    pub new_value: Option<u64>,
}

impl Default for MemberSpaceLimitsChangePolicyDetails {
    fn default() -> Self {
        MemberSpaceLimitsChangePolicyDetails {
            previous_value: None,
            new_value: None,
        }
    }
}

const MEMBER_SPACE_LIMITS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                    "new_value"];
impl MemberSpaceLimitsChangePolicyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsChangePolicyDetails, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = MemberSpaceLimitsChangePolicyDetails {
            previous_value: field_previous_value,
            new_value: field_new_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangePolicyDetails", MEMBER_SPACE_LIMITS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsChangePolicyType {
    pub description: String,
}

impl MemberSpaceLimitsChangePolicyType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsChangePolicyType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangePolicyType", MEMBER_SPACE_LIMITS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed space limit status.
#[derive(Debug)]
pub struct MemberSpaceLimitsChangeStatusDetails {
    /// Previous storage quota status.
    pub previous_value: SpaceLimitsStatus,
    /// New storage quota status.
    pub new_value: SpaceLimitsStatus,
}

impl MemberSpaceLimitsChangeStatusDetails {
    pub fn new(previous_value: SpaceLimitsStatus, new_value: SpaceLimitsStatus) -> Self {
        MemberSpaceLimitsChangeStatusDetails {
            previous_value,
            new_value,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_STATUS_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                    "new_value"];
impl MemberSpaceLimitsChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsChangeStatusDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsChangeStatusDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsChangeStatusDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeStatusDetails", MEMBER_SPACE_LIMITS_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeStatusDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsChangeStatusType {
    pub description: String,
}

impl MemberSpaceLimitsChangeStatusType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsChangeStatusType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_CHANGE_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsChangeStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsChangeStatusType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsChangeStatusType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsChangeStatusType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsChangeStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsChangeStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsChangeStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsChangeStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsChangeStatusType", MEMBER_SPACE_LIMITS_CHANGE_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsChangeStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsChangeStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed custom member space limit.
#[derive(Debug)]
pub struct MemberSpaceLimitsRemoveCustomQuotaDetails {
}

impl Default for MemberSpaceLimitsRemoveCustomQuotaDetails {
    fn default() -> Self {
        MemberSpaceLimitsRemoveCustomQuotaDetails {
        }
    }
}

const MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_DETAILS_FIELDS: &[&str] = &[];
impl MemberSpaceLimitsRemoveCustomQuotaDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsRemoveCustomQuotaDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(MemberSpaceLimitsRemoveCustomQuotaDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsRemoveCustomQuotaDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsRemoveCustomQuotaDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsRemoveCustomQuotaDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsRemoveCustomQuotaDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsRemoveCustomQuotaDetails", MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsRemoveCustomQuotaDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSpaceLimitsRemoveCustomQuotaDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsRemoveCustomQuotaType {
    pub description: String,
}

impl MemberSpaceLimitsRemoveCustomQuotaType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsRemoveCustomQuotaType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsRemoveCustomQuotaType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsRemoveCustomQuotaType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsRemoveCustomQuotaType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsRemoveCustomQuotaType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsRemoveCustomQuotaType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsRemoveCustomQuotaType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsRemoveCustomQuotaType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsRemoveCustomQuotaType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsRemoveCustomQuotaType", MEMBER_SPACE_LIMITS_REMOVE_CUSTOM_QUOTA_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsRemoveCustomQuotaType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsRemoveCustomQuotaType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed members from member space limit exception list.
#[derive(Debug)]
pub struct MemberSpaceLimitsRemoveExceptionDetails {
}

impl Default for MemberSpaceLimitsRemoveExceptionDetails {
    fn default() -> Self {
        MemberSpaceLimitsRemoveExceptionDetails {
        }
    }
}

const MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl MemberSpaceLimitsRemoveExceptionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberSpaceLimitsRemoveExceptionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(MemberSpaceLimitsRemoveExceptionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsRemoveExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsRemoveExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsRemoveExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsRemoveExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsRemoveExceptionDetails", MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsRemoveExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberSpaceLimitsRemoveExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberSpaceLimitsRemoveExceptionType {
    pub description: String,
}

impl MemberSpaceLimitsRemoveExceptionType {
    pub fn new(description: String) -> Self {
        MemberSpaceLimitsRemoveExceptionType {
            description,
        }
    }

}

const MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSpaceLimitsRemoveExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSpaceLimitsRemoveExceptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSpaceLimitsRemoveExceptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSpaceLimitsRemoveExceptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSpaceLimitsRemoveExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSpaceLimitsRemoveExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSpaceLimitsRemoveExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSpaceLimitsRemoveExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSpaceLimitsRemoveExceptionType", MEMBER_SPACE_LIMITS_REMOVE_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSpaceLimitsRemoveExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSpaceLimitsRemoveExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MemberStatus {
    NotJoined,
    Invited,
    Active,
    Suspended,
    Removed,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "not_joined" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberStatus::NotJoined)
                    }
                    "invited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberStatus::Invited)
                    }
                    "active" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberStatus::Active)
                    }
                    "suspended" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberStatus::Suspended)
                    }
                    "removed" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberStatus::Removed)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberStatus::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["not_joined",
                                    "invited",
                                    "active",
                                    "suspended",
                                    "removed",
                                    "other"];
        deserializer.deserialize_struct("MemberStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberStatus::NotJoined => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "not_joined")?;
                s.end()
            }
            MemberStatus::Invited => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "invited")?;
                s.end()
            }
            MemberStatus::Active => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "active")?;
                s.end()
            }
            MemberStatus::Suspended => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "suspended")?;
                s.end()
            }
            MemberStatus::Removed => {
                // unit
                let mut s = serializer.serialize_struct("MemberStatus", 1)?;
                s.serialize_field(".tag", "removed")?;
                s.end()
            }
            MemberStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Suggested person to add to team.
#[derive(Debug)]
pub struct MemberSuggestDetails {
    /// suggested users emails.
    pub suggested_members: Vec<EmailAddress>,
}

impl MemberSuggestDetails {
    pub fn new(suggested_members: Vec<EmailAddress>) -> Self {
        MemberSuggestDetails {
            suggested_members,
        }
    }

}

const MEMBER_SUGGEST_DETAILS_FIELDS: &[&str] = &["suggested_members"];
impl MemberSuggestDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSuggestDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSuggestDetails>, V::Error> {
        let mut field_suggested_members = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "suggested_members" => {
                    if field_suggested_members.is_some() {
                        return Err(::serde::de::Error::duplicate_field("suggested_members"));
                    }
                    field_suggested_members = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSuggestDetails {
            suggested_members: field_suggested_members.ok_or_else(|| ::serde::de::Error::missing_field("suggested_members"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("suggested_members", &self.suggested_members)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestDetails", MEMBER_SUGGEST_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSuggestDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSuggestType {
    pub description: String,
}

impl MemberSuggestType {
    pub fn new(description: String) -> Self {
        MemberSuggestType {
            description,
        }
    }

}

const MEMBER_SUGGEST_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSuggestType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSuggestType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSuggestType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSuggestType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestType", MEMBER_SUGGEST_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSuggestType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled option for team members to suggest people to add to team.
#[derive(Debug)]
pub struct MemberSuggestionsChangePolicyDetails {
    /// New team member suggestions policy.
    pub new_value: MemberSuggestionsPolicy,
    /// Previous team member suggestions policy. Might be missing due to historical data gap.
    pub previous_value: Option<MemberSuggestionsPolicy>,
}

impl MemberSuggestionsChangePolicyDetails {
    pub fn new(new_value: MemberSuggestionsPolicy) -> Self {
        MemberSuggestionsChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MemberSuggestionsPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const MEMBER_SUGGESTIONS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                   "previous_value"];
impl MemberSuggestionsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSuggestionsChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSuggestionsChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSuggestionsChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestionsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestionsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestionsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestionsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestionsChangePolicyDetails", MEMBER_SUGGESTIONS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestionsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSuggestionsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberSuggestionsChangePolicyType {
    pub description: String,
}

impl MemberSuggestionsChangePolicyType {
    pub fn new(description: String) -> Self {
        MemberSuggestionsChangePolicyType {
            description,
        }
    }

}

const MEMBER_SUGGESTIONS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MemberSuggestionsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberSuggestionsChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberSuggestionsChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberSuggestionsChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestionsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberSuggestionsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestionsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberSuggestionsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberSuggestionsChangePolicyType", MEMBER_SUGGESTIONS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestionsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberSuggestionsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Member suggestions policy
#[derive(Debug)]
pub enum MemberSuggestionsPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSuggestionsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberSuggestionsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberSuggestionsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberSuggestionsPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberSuggestionsPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MemberSuggestionsPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("MemberSuggestionsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSuggestionsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberSuggestionsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberSuggestionsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MemberSuggestionsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("MemberSuggestionsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            MemberSuggestionsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Transferred contents of deleted member account to another member.
#[derive(Debug)]
pub struct MemberTransferAccountContentsDetails {
}

impl Default for MemberTransferAccountContentsDetails {
    fn default() -> Self {
        MemberTransferAccountContentsDetails {
        }
    }
}

const MEMBER_TRANSFER_ACCOUNT_CONTENTS_DETAILS_FIELDS: &[&str] = &[];
impl MemberTransferAccountContentsDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MemberTransferAccountContentsDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(MemberTransferAccountContentsDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberTransferAccountContentsDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberTransferAccountContentsDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberTransferAccountContentsDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberTransferAccountContentsDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberTransferAccountContentsDetails", MEMBER_TRANSFER_ACCOUNT_CONTENTS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberTransferAccountContentsDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("MemberTransferAccountContentsDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct MemberTransferAccountContentsType {
    pub description: String,
}

impl MemberTransferAccountContentsType {
    pub fn new(description: String) -> Self {
        MemberTransferAccountContentsType {
            description,
        }
    }

}

const MEMBER_TRANSFER_ACCOUNT_CONTENTS_TYPE_FIELDS: &[&str] = &["description"];
impl MemberTransferAccountContentsType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberTransferAccountContentsType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberTransferAccountContentsType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberTransferAccountContentsType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberTransferAccountContentsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberTransferAccountContentsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MemberTransferAccountContentsType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberTransferAccountContentsType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberTransferAccountContentsType", MEMBER_TRANSFER_ACCOUNT_CONTENTS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberTransferAccountContentsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberTransferAccountContentsType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled Microsoft Office add-in.
#[derive(Debug)]
pub struct MicrosoftOfficeAddinChangePolicyDetails {
    /// New Microsoft Office addin policy.
    pub new_value: MicrosoftOfficeAddinPolicy,
    /// Previous Microsoft Office addin policy. Might be missing due to historical data gap.
    pub previous_value: Option<MicrosoftOfficeAddinPolicy>,
}

impl MicrosoftOfficeAddinChangePolicyDetails {
    pub fn new(new_value: MicrosoftOfficeAddinPolicy) -> Self {
        MicrosoftOfficeAddinChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<MicrosoftOfficeAddinPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                       "previous_value"];
impl MicrosoftOfficeAddinChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MicrosoftOfficeAddinChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MicrosoftOfficeAddinChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MicrosoftOfficeAddinChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MicrosoftOfficeAddinChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MicrosoftOfficeAddinChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MicrosoftOfficeAddinChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MicrosoftOfficeAddinChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MicrosoftOfficeAddinChangePolicyDetails", MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MicrosoftOfficeAddinChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MicrosoftOfficeAddinChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MicrosoftOfficeAddinChangePolicyType {
    pub description: String,
}

impl MicrosoftOfficeAddinChangePolicyType {
    pub fn new(description: String) -> Self {
        MicrosoftOfficeAddinChangePolicyType {
            description,
        }
    }

}

const MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl MicrosoftOfficeAddinChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MicrosoftOfficeAddinChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MicrosoftOfficeAddinChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MicrosoftOfficeAddinChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MicrosoftOfficeAddinChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MicrosoftOfficeAddinChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MicrosoftOfficeAddinChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MicrosoftOfficeAddinChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MicrosoftOfficeAddinChangePolicyType", MICROSOFT_OFFICE_ADDIN_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MicrosoftOfficeAddinChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MicrosoftOfficeAddinChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Microsoft Office addin policy
#[derive(Debug)]
pub enum MicrosoftOfficeAddinPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MicrosoftOfficeAddinPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MicrosoftOfficeAddinPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MicrosoftOfficeAddinPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MicrosoftOfficeAddinPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MicrosoftOfficeAddinPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(MicrosoftOfficeAddinPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("MicrosoftOfficeAddinPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MicrosoftOfficeAddinPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MicrosoftOfficeAddinPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("MicrosoftOfficeAddinPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            MicrosoftOfficeAddinPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("MicrosoftOfficeAddinPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            MicrosoftOfficeAddinPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// An indication that an error occurred while retrieving the event. Some attributes of the event
/// may be omitted as a result.
#[derive(Debug)]
pub struct MissingDetails {
    /// All the data that could be retrieved and converted from the source event.
    pub source_event_fields: Option<String>,
}

impl Default for MissingDetails {
    fn default() -> Self {
        MissingDetails {
            source_event_fields: None,
        }
    }
}

const MISSING_DETAILS_FIELDS: &[&str] = &["source_event_fields"];
impl MissingDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MissingDetails, V::Error> {
        let mut field_source_event_fields = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "source_event_fields" => {
                    if field_source_event_fields.is_some() {
                        return Err(::serde::de::Error::duplicate_field("source_event_fields"));
                    }
                    field_source_event_fields = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = MissingDetails {
            source_event_fields: field_source_event_fields,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("source_event_fields", &self.source_event_fields)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MissingDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MissingDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MissingDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MissingDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MissingDetails", MISSING_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MissingDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MissingDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information about linked Dropbox mobile client sessions
#[derive(Debug)]
pub struct MobileDeviceSessionLogInfo {
    /// The device name.
    pub device_name: String,
    /// The mobile application type.
    pub client_type: super::team::MobileClientPlatform,
    /// The IP address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub ip_address: Option<IpAddress>,
    /// The time this session was created. Might be missing due to historical data gap.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session. Might be missing due to historical data
    /// gap.
    pub updated: Option<super::common::DropboxTimestamp>,
    /// Mobile session unique id. Might be missing due to historical data gap.
    pub session_info: Option<MobileSessionLogInfo>,
    /// The Dropbox client version.
    pub client_version: Option<String>,
    /// The hosting OS version.
    pub os_version: Option<String>,
    /// last carrier used by the device.
    pub last_carrier: Option<String>,
}

impl MobileDeviceSessionLogInfo {
    pub fn new(device_name: String, client_type: super::team::MobileClientPlatform) -> Self {
        MobileDeviceSessionLogInfo {
            device_name,
            client_type,
            ip_address: None,
            created: None,
            updated: None,
            session_info: None,
            client_version: None,
            os_version: None,
            last_carrier: None,
        }
    }

    pub fn with_ip_address(mut self, value: Option<IpAddress>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

    pub fn with_session_info(mut self, value: Option<MobileSessionLogInfo>) -> Self {
        self.session_info = value;
        self
    }

    pub fn with_client_version(mut self, value: Option<String>) -> Self {
        self.client_version = value;
        self
    }

    pub fn with_os_version(mut self, value: Option<String>) -> Self {
        self.os_version = value;
        self
    }

    pub fn with_last_carrier(mut self, value: Option<String>) -> Self {
        self.last_carrier = value;
        self
    }

}

const MOBILE_DEVICE_SESSION_LOG_INFO_FIELDS: &[&str] = &["device_name",
                                                         "client_type",
                                                         "ip_address",
                                                         "created",
                                                         "updated",
                                                         "session_info",
                                                         "client_version",
                                                         "os_version",
                                                         "last_carrier"];
impl MobileDeviceSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MobileDeviceSessionLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MobileDeviceSessionLogInfo>, V::Error> {
        let mut field_device_name = None;
        let mut field_client_type = None;
        let mut field_ip_address = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut field_session_info = None;
        let mut field_client_version = None;
        let mut field_os_version = None;
        let mut field_last_carrier = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "device_name" => {
                    if field_device_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("device_name"));
                    }
                    field_device_name = Some(map.next_value()?);
                }
                "client_type" => {
                    if field_client_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("client_type"));
                    }
                    field_client_type = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(::serde::de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(::serde::de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(::serde::de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                "session_info" => {
                    if field_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_info"));
                    }
                    field_session_info = Some(map.next_value()?);
                }
                "client_version" => {
                    if field_client_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("client_version"));
                    }
                    field_client_version = Some(map.next_value()?);
                }
                "os_version" => {
                    if field_os_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("os_version"));
                    }
                    field_os_version = Some(map.next_value()?);
                }
                "last_carrier" => {
                    if field_last_carrier.is_some() {
                        return Err(::serde::de::Error::duplicate_field("last_carrier"));
                    }
                    field_last_carrier = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MobileDeviceSessionLogInfo {
            device_name: field_device_name.ok_or_else(|| ::serde::de::Error::missing_field("device_name"))?,
            client_type: field_client_type.ok_or_else(|| ::serde::de::Error::missing_field("client_type"))?,
            ip_address: field_ip_address,
            created: field_created,
            updated: field_updated,
            session_info: field_session_info,
            client_version: field_client_version,
            os_version: field_os_version,
            last_carrier: field_last_carrier,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("device_name", &self.device_name)?;
        s.serialize_field("client_type", &self.client_type)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)?;
        s.serialize_field("session_info", &self.session_info)?;
        s.serialize_field("client_version", &self.client_version)?;
        s.serialize_field("os_version", &self.os_version)?;
        s.serialize_field("last_carrier", &self.last_carrier)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MobileDeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MobileDeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MobileDeviceSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MobileDeviceSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MobileDeviceSessionLogInfo", MOBILE_DEVICE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MobileDeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MobileDeviceSessionLogInfo", 9)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Mobile session.
#[derive(Debug)]
pub struct MobileSessionLogInfo {
    /// Session ID. Might be missing due to historical data gap.
    pub session_id: Option<super::common::SessionId>,
}

impl Default for MobileSessionLogInfo {
    fn default() -> Self {
        MobileSessionLogInfo {
            session_id: None,
        }
    }
}

const MOBILE_SESSION_LOG_INFO_FIELDS: &[&str] = &["session_id"];
impl MobileSessionLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MobileSessionLogInfo, V::Error> {
        let mut field_session_id = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = MobileSessionLogInfo {
            session_id: field_session_id,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MobileSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MobileSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a MobileSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MobileSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MobileSessionLogInfo", MOBILE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MobileSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MobileSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Namespace relative path details.
#[derive(Debug)]
pub struct NamespaceRelativePathLogInfo {
    /// Namespace ID. Might be missing due to historical data gap.
    pub ns_id: Option<NamespaceId>,
    /// A path relative to the specified namespace ID. Might be missing due to historical data gap.
    pub relative_path: Option<FilePath>,
    /// True if the namespace is shared. Might be missing due to historical data gap.
    pub is_shared_namespace: Option<bool>,
}

impl Default for NamespaceRelativePathLogInfo {
    fn default() -> Self {
        NamespaceRelativePathLogInfo {
            ns_id: None,
            relative_path: None,
            is_shared_namespace: None,
        }
    }
}

const NAMESPACE_RELATIVE_PATH_LOG_INFO_FIELDS: &[&str] = &["ns_id",
                                                           "relative_path",
                                                           "is_shared_namespace"];
impl NamespaceRelativePathLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NamespaceRelativePathLogInfo, V::Error> {
        let mut field_ns_id = None;
        let mut field_relative_path = None;
        let mut field_is_shared_namespace = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "ns_id" => {
                    if field_ns_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("ns_id"));
                    }
                    field_ns_id = Some(map.next_value()?);
                }
                "relative_path" => {
                    if field_relative_path.is_some() {
                        return Err(::serde::de::Error::duplicate_field("relative_path"));
                    }
                    field_relative_path = Some(map.next_value()?);
                }
                "is_shared_namespace" => {
                    if field_is_shared_namespace.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_shared_namespace"));
                    }
                    field_is_shared_namespace = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = NamespaceRelativePathLogInfo {
            ns_id: field_ns_id,
            relative_path: field_relative_path,
            is_shared_namespace: field_is_shared_namespace,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("ns_id", &self.ns_id)?;
        s.serialize_field("relative_path", &self.relative_path)?;
        s.serialize_field("is_shared_namespace", &self.is_shared_namespace)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NamespaceRelativePathLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NamespaceRelativePathLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NamespaceRelativePathLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NamespaceRelativePathLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NamespaceRelativePathLogInfo", NAMESPACE_RELATIVE_PATH_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NamespaceRelativePathLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NamespaceRelativePathLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled network control.
#[derive(Debug)]
pub struct NetworkControlChangePolicyDetails {
    /// New network control policy.
    pub new_value: NetworkControlPolicy,
    /// Previous network control policy. Might be missing due to historical data gap.
    pub previous_value: Option<NetworkControlPolicy>,
}

impl NetworkControlChangePolicyDetails {
    pub fn new(new_value: NetworkControlPolicy) -> Self {
        NetworkControlChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<NetworkControlPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const NETWORK_CONTROL_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl NetworkControlChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NetworkControlChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NetworkControlChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NetworkControlChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NetworkControlChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NetworkControlChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NetworkControlChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NetworkControlChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NetworkControlChangePolicyDetails", NETWORK_CONTROL_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NetworkControlChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NetworkControlChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct NetworkControlChangePolicyType {
    pub description: String,
}

impl NetworkControlChangePolicyType {
    pub fn new(description: String) -> Self {
        NetworkControlChangePolicyType {
            description,
        }
    }

}

const NETWORK_CONTROL_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl NetworkControlChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NetworkControlChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NetworkControlChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NetworkControlChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NetworkControlChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NetworkControlChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NetworkControlChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NetworkControlChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NetworkControlChangePolicyType", NETWORK_CONTROL_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NetworkControlChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NetworkControlChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Network control policy
#[derive(Debug)]
pub enum NetworkControlPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for NetworkControlPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = NetworkControlPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NetworkControlPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(NetworkControlPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(NetworkControlPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(NetworkControlPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("NetworkControlPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for NetworkControlPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            NetworkControlPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("NetworkControlPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            NetworkControlPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("NetworkControlPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            NetworkControlPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Report created: Links created with no expiration.
#[derive(Debug)]
pub struct NoExpirationLinkGenCreateReportDetails {
    /// Report start date.
    pub start_date: super::common::DropboxTimestamp,
    /// Report end date.
    pub end_date: super::common::DropboxTimestamp,
}

impl NoExpirationLinkGenCreateReportDetails {
    pub fn new(
        start_date: super::common::DropboxTimestamp,
        end_date: super::common::DropboxTimestamp,
    ) -> Self {
        NoExpirationLinkGenCreateReportDetails {
            start_date,
            end_date,
        }
    }

}

const NO_EXPIRATION_LINK_GEN_CREATE_REPORT_DETAILS_FIELDS: &[&str] = &["start_date",
                                                                       "end_date"];
impl NoExpirationLinkGenCreateReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoExpirationLinkGenCreateReportDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoExpirationLinkGenCreateReportDetails>, V::Error> {
        let mut field_start_date = None;
        let mut field_end_date = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "end_date" => {
                    if field_end_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("end_date"));
                    }
                    field_end_date = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoExpirationLinkGenCreateReportDetails {
            start_date: field_start_date.ok_or_else(|| ::serde::de::Error::missing_field("start_date"))?,
            end_date: field_end_date.ok_or_else(|| ::serde::de::Error::missing_field("end_date"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("end_date", &self.end_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoExpirationLinkGenCreateReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoExpirationLinkGenCreateReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoExpirationLinkGenCreateReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoExpirationLinkGenCreateReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoExpirationLinkGenCreateReportDetails", NO_EXPIRATION_LINK_GEN_CREATE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoExpirationLinkGenCreateReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoExpirationLinkGenCreateReportDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct NoExpirationLinkGenCreateReportType {
    pub description: String,
}

impl NoExpirationLinkGenCreateReportType {
    pub fn new(description: String) -> Self {
        NoExpirationLinkGenCreateReportType {
            description,
        }
    }

}

const NO_EXPIRATION_LINK_GEN_CREATE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl NoExpirationLinkGenCreateReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoExpirationLinkGenCreateReportType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoExpirationLinkGenCreateReportType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoExpirationLinkGenCreateReportType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoExpirationLinkGenCreateReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoExpirationLinkGenCreateReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoExpirationLinkGenCreateReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoExpirationLinkGenCreateReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoExpirationLinkGenCreateReportType", NO_EXPIRATION_LINK_GEN_CREATE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoExpirationLinkGenCreateReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoExpirationLinkGenCreateReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Couldn't create report: Links created with no expiration.
#[derive(Debug)]
pub struct NoExpirationLinkGenReportFailedDetails {
    /// Failure reason.
    pub failure_reason: super::team::TeamReportFailureReason,
}

impl NoExpirationLinkGenReportFailedDetails {
    pub fn new(failure_reason: super::team::TeamReportFailureReason) -> Self {
        NoExpirationLinkGenReportFailedDetails {
            failure_reason,
        }
    }

}

const NO_EXPIRATION_LINK_GEN_REPORT_FAILED_DETAILS_FIELDS: &[&str] = &["failure_reason"];
impl NoExpirationLinkGenReportFailedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoExpirationLinkGenReportFailedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoExpirationLinkGenReportFailedDetails>, V::Error> {
        let mut field_failure_reason = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "failure_reason" => {
                    if field_failure_reason.is_some() {
                        return Err(::serde::de::Error::duplicate_field("failure_reason"));
                    }
                    field_failure_reason = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoExpirationLinkGenReportFailedDetails {
            failure_reason: field_failure_reason.ok_or_else(|| ::serde::de::Error::missing_field("failure_reason"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("failure_reason", &self.failure_reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoExpirationLinkGenReportFailedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoExpirationLinkGenReportFailedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoExpirationLinkGenReportFailedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoExpirationLinkGenReportFailedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoExpirationLinkGenReportFailedDetails", NO_EXPIRATION_LINK_GEN_REPORT_FAILED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoExpirationLinkGenReportFailedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoExpirationLinkGenReportFailedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct NoExpirationLinkGenReportFailedType {
    pub description: String,
}

impl NoExpirationLinkGenReportFailedType {
    pub fn new(description: String) -> Self {
        NoExpirationLinkGenReportFailedType {
            description,
        }
    }

}

const NO_EXPIRATION_LINK_GEN_REPORT_FAILED_TYPE_FIELDS: &[&str] = &["description"];
impl NoExpirationLinkGenReportFailedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoExpirationLinkGenReportFailedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoExpirationLinkGenReportFailedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoExpirationLinkGenReportFailedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoExpirationLinkGenReportFailedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoExpirationLinkGenReportFailedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoExpirationLinkGenReportFailedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoExpirationLinkGenReportFailedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoExpirationLinkGenReportFailedType", NO_EXPIRATION_LINK_GEN_REPORT_FAILED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoExpirationLinkGenReportFailedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoExpirationLinkGenReportFailedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Report created: Links created without passwords.
#[derive(Debug)]
pub struct NoPasswordLinkGenCreateReportDetails {
    /// Report start date.
    pub start_date: super::common::DropboxTimestamp,
    /// Report end date.
    pub end_date: super::common::DropboxTimestamp,
}

impl NoPasswordLinkGenCreateReportDetails {
    pub fn new(
        start_date: super::common::DropboxTimestamp,
        end_date: super::common::DropboxTimestamp,
    ) -> Self {
        NoPasswordLinkGenCreateReportDetails {
            start_date,
            end_date,
        }
    }

}

const NO_PASSWORD_LINK_GEN_CREATE_REPORT_DETAILS_FIELDS: &[&str] = &["start_date",
                                                                     "end_date"];
impl NoPasswordLinkGenCreateReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoPasswordLinkGenCreateReportDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoPasswordLinkGenCreateReportDetails>, V::Error> {
        let mut field_start_date = None;
        let mut field_end_date = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "end_date" => {
                    if field_end_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("end_date"));
                    }
                    field_end_date = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoPasswordLinkGenCreateReportDetails {
            start_date: field_start_date.ok_or_else(|| ::serde::de::Error::missing_field("start_date"))?,
            end_date: field_end_date.ok_or_else(|| ::serde::de::Error::missing_field("end_date"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("end_date", &self.end_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoPasswordLinkGenCreateReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoPasswordLinkGenCreateReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoPasswordLinkGenCreateReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoPasswordLinkGenCreateReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoPasswordLinkGenCreateReportDetails", NO_PASSWORD_LINK_GEN_CREATE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoPasswordLinkGenCreateReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoPasswordLinkGenCreateReportDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct NoPasswordLinkGenCreateReportType {
    pub description: String,
}

impl NoPasswordLinkGenCreateReportType {
    pub fn new(description: String) -> Self {
        NoPasswordLinkGenCreateReportType {
            description,
        }
    }

}

const NO_PASSWORD_LINK_GEN_CREATE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl NoPasswordLinkGenCreateReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoPasswordLinkGenCreateReportType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoPasswordLinkGenCreateReportType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoPasswordLinkGenCreateReportType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoPasswordLinkGenCreateReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoPasswordLinkGenCreateReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoPasswordLinkGenCreateReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoPasswordLinkGenCreateReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoPasswordLinkGenCreateReportType", NO_PASSWORD_LINK_GEN_CREATE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoPasswordLinkGenCreateReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoPasswordLinkGenCreateReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Couldn't create report: Links created without passwords.
#[derive(Debug)]
pub struct NoPasswordLinkGenReportFailedDetails {
    /// Failure reason.
    pub failure_reason: super::team::TeamReportFailureReason,
}

impl NoPasswordLinkGenReportFailedDetails {
    pub fn new(failure_reason: super::team::TeamReportFailureReason) -> Self {
        NoPasswordLinkGenReportFailedDetails {
            failure_reason,
        }
    }

}

const NO_PASSWORD_LINK_GEN_REPORT_FAILED_DETAILS_FIELDS: &[&str] = &["failure_reason"];
impl NoPasswordLinkGenReportFailedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoPasswordLinkGenReportFailedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoPasswordLinkGenReportFailedDetails>, V::Error> {
        let mut field_failure_reason = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "failure_reason" => {
                    if field_failure_reason.is_some() {
                        return Err(::serde::de::Error::duplicate_field("failure_reason"));
                    }
                    field_failure_reason = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoPasswordLinkGenReportFailedDetails {
            failure_reason: field_failure_reason.ok_or_else(|| ::serde::de::Error::missing_field("failure_reason"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("failure_reason", &self.failure_reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoPasswordLinkGenReportFailedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoPasswordLinkGenReportFailedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoPasswordLinkGenReportFailedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoPasswordLinkGenReportFailedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoPasswordLinkGenReportFailedDetails", NO_PASSWORD_LINK_GEN_REPORT_FAILED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoPasswordLinkGenReportFailedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoPasswordLinkGenReportFailedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct NoPasswordLinkGenReportFailedType {
    pub description: String,
}

impl NoPasswordLinkGenReportFailedType {
    pub fn new(description: String) -> Self {
        NoPasswordLinkGenReportFailedType {
            description,
        }
    }

}

const NO_PASSWORD_LINK_GEN_REPORT_FAILED_TYPE_FIELDS: &[&str] = &["description"];
impl NoPasswordLinkGenReportFailedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoPasswordLinkGenReportFailedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoPasswordLinkGenReportFailedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoPasswordLinkGenReportFailedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoPasswordLinkGenReportFailedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoPasswordLinkGenReportFailedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoPasswordLinkGenReportFailedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoPasswordLinkGenReportFailedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoPasswordLinkGenReportFailedType", NO_PASSWORD_LINK_GEN_REPORT_FAILED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoPasswordLinkGenReportFailedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoPasswordLinkGenReportFailedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Report created: Views of links without passwords.
#[derive(Debug)]
pub struct NoPasswordLinkViewCreateReportDetails {
    /// Report start date.
    pub start_date: super::common::DropboxTimestamp,
    /// Report end date.
    pub end_date: super::common::DropboxTimestamp,
}

impl NoPasswordLinkViewCreateReportDetails {
    pub fn new(
        start_date: super::common::DropboxTimestamp,
        end_date: super::common::DropboxTimestamp,
    ) -> Self {
        NoPasswordLinkViewCreateReportDetails {
            start_date,
            end_date,
        }
    }

}

const NO_PASSWORD_LINK_VIEW_CREATE_REPORT_DETAILS_FIELDS: &[&str] = &["start_date",
                                                                      "end_date"];
impl NoPasswordLinkViewCreateReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoPasswordLinkViewCreateReportDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoPasswordLinkViewCreateReportDetails>, V::Error> {
        let mut field_start_date = None;
        let mut field_end_date = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "end_date" => {
                    if field_end_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("end_date"));
                    }
                    field_end_date = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoPasswordLinkViewCreateReportDetails {
            start_date: field_start_date.ok_or_else(|| ::serde::de::Error::missing_field("start_date"))?,
            end_date: field_end_date.ok_or_else(|| ::serde::de::Error::missing_field("end_date"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("end_date", &self.end_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoPasswordLinkViewCreateReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoPasswordLinkViewCreateReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoPasswordLinkViewCreateReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoPasswordLinkViewCreateReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoPasswordLinkViewCreateReportDetails", NO_PASSWORD_LINK_VIEW_CREATE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoPasswordLinkViewCreateReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoPasswordLinkViewCreateReportDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct NoPasswordLinkViewCreateReportType {
    pub description: String,
}

impl NoPasswordLinkViewCreateReportType {
    pub fn new(description: String) -> Self {
        NoPasswordLinkViewCreateReportType {
            description,
        }
    }

}

const NO_PASSWORD_LINK_VIEW_CREATE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl NoPasswordLinkViewCreateReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoPasswordLinkViewCreateReportType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoPasswordLinkViewCreateReportType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoPasswordLinkViewCreateReportType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoPasswordLinkViewCreateReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoPasswordLinkViewCreateReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoPasswordLinkViewCreateReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoPasswordLinkViewCreateReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoPasswordLinkViewCreateReportType", NO_PASSWORD_LINK_VIEW_CREATE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoPasswordLinkViewCreateReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoPasswordLinkViewCreateReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Couldn't create report: Views of links without passwords.
#[derive(Debug)]
pub struct NoPasswordLinkViewReportFailedDetails {
    /// Failure reason.
    pub failure_reason: super::team::TeamReportFailureReason,
}

impl NoPasswordLinkViewReportFailedDetails {
    pub fn new(failure_reason: super::team::TeamReportFailureReason) -> Self {
        NoPasswordLinkViewReportFailedDetails {
            failure_reason,
        }
    }

}

const NO_PASSWORD_LINK_VIEW_REPORT_FAILED_DETAILS_FIELDS: &[&str] = &["failure_reason"];
impl NoPasswordLinkViewReportFailedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoPasswordLinkViewReportFailedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoPasswordLinkViewReportFailedDetails>, V::Error> {
        let mut field_failure_reason = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "failure_reason" => {
                    if field_failure_reason.is_some() {
                        return Err(::serde::de::Error::duplicate_field("failure_reason"));
                    }
                    field_failure_reason = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoPasswordLinkViewReportFailedDetails {
            failure_reason: field_failure_reason.ok_or_else(|| ::serde::de::Error::missing_field("failure_reason"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("failure_reason", &self.failure_reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoPasswordLinkViewReportFailedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoPasswordLinkViewReportFailedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoPasswordLinkViewReportFailedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoPasswordLinkViewReportFailedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoPasswordLinkViewReportFailedDetails", NO_PASSWORD_LINK_VIEW_REPORT_FAILED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoPasswordLinkViewReportFailedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoPasswordLinkViewReportFailedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct NoPasswordLinkViewReportFailedType {
    pub description: String,
}

impl NoPasswordLinkViewReportFailedType {
    pub fn new(description: String) -> Self {
        NoPasswordLinkViewReportFailedType {
            description,
        }
    }

}

const NO_PASSWORD_LINK_VIEW_REPORT_FAILED_TYPE_FIELDS: &[&str] = &["description"];
impl NoPasswordLinkViewReportFailedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoPasswordLinkViewReportFailedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoPasswordLinkViewReportFailedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoPasswordLinkViewReportFailedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoPasswordLinkViewReportFailedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoPasswordLinkViewReportFailedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoPasswordLinkViewReportFailedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoPasswordLinkViewReportFailedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoPasswordLinkViewReportFailedType", NO_PASSWORD_LINK_VIEW_REPORT_FAILED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoPasswordLinkViewReportFailedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoPasswordLinkViewReportFailedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Non team member's logged information.
#[derive(Debug)]
pub struct NonTeamMemberLogInfo {
    /// User unique ID. Might be missing due to historical data gap.
    pub account_id: Option<super::users_common::AccountId>,
    /// User display name. Might be missing due to historical data gap.
    pub display_name: Option<super::common::DisplayNameLegacy>,
    /// User email address. Might be missing due to historical data gap.
    pub email: Option<EmailAddress>,
}

impl Default for NonTeamMemberLogInfo {
    fn default() -> Self {
        NonTeamMemberLogInfo {
            account_id: None,
            display_name: None,
            email: None,
        }
    }
}

const NON_TEAM_MEMBER_LOG_INFO_FIELDS: &[&str] = &["account_id",
                                                   "display_name",
                                                   "email"];
impl NonTeamMemberLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NonTeamMemberLogInfo, V::Error> {
        let mut field_account_id = None;
        let mut field_display_name = None;
        let mut field_email = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = NonTeamMemberLogInfo {
            account_id: field_account_id,
            display_name: field_display_name,
            email: field_email,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("email", &self.email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NonTeamMemberLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NonTeamMemberLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NonTeamMemberLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NonTeamMemberLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NonTeamMemberLogInfo", NON_TEAM_MEMBER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NonTeamMemberLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NonTeamMemberLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The email to which the request was sent
#[derive(Debug)]
pub struct NonTrustedTeamDetails {
    /// The email to which the request was sent.
    pub team: String,
}

impl NonTrustedTeamDetails {
    pub fn new(team: String) -> Self {
        NonTrustedTeamDetails {
            team,
        }
    }

}

const NON_TRUSTED_TEAM_DETAILS_FIELDS: &[&str] = &["team"];
impl NonTrustedTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NonTrustedTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NonTrustedTeamDetails>, V::Error> {
        let mut field_team = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "team" => {
                    if field_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team"));
                    }
                    field_team = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NonTrustedTeamDetails {
            team: field_team.ok_or_else(|| ::serde::de::Error::missing_field("team"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team", &self.team)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NonTrustedTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NonTrustedTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NonTrustedTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NonTrustedTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NonTrustedTeamDetails", NON_TRUSTED_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NonTrustedTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NonTrustedTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed Paper doc to invite-only.
#[derive(Debug)]
pub struct NoteAclInviteOnlyDetails {
}

impl Default for NoteAclInviteOnlyDetails {
    fn default() -> Self {
        NoteAclInviteOnlyDetails {
        }
    }
}

const NOTE_ACL_INVITE_ONLY_DETAILS_FIELDS: &[&str] = &[];
impl NoteAclInviteOnlyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteAclInviteOnlyDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(NoteAclInviteOnlyDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclInviteOnlyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclInviteOnlyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteAclInviteOnlyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclInviteOnlyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclInviteOnlyDetails", NOTE_ACL_INVITE_ONLY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclInviteOnlyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteAclInviteOnlyDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteAclInviteOnlyType {
    pub description: String,
}

impl NoteAclInviteOnlyType {
    pub fn new(description: String) -> Self {
        NoteAclInviteOnlyType {
            description,
        }
    }

}

const NOTE_ACL_INVITE_ONLY_TYPE_FIELDS: &[&str] = &["description"];
impl NoteAclInviteOnlyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoteAclInviteOnlyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoteAclInviteOnlyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoteAclInviteOnlyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclInviteOnlyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclInviteOnlyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteAclInviteOnlyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclInviteOnlyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclInviteOnlyType", NOTE_ACL_INVITE_ONLY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclInviteOnlyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteAclInviteOnlyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed Paper doc to link-accessible.
#[derive(Debug)]
pub struct NoteAclLinkDetails {
}

impl Default for NoteAclLinkDetails {
    fn default() -> Self {
        NoteAclLinkDetails {
        }
    }
}

const NOTE_ACL_LINK_DETAILS_FIELDS: &[&str] = &[];
impl NoteAclLinkDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteAclLinkDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(NoteAclLinkDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteAclLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclLinkDetails", NOTE_ACL_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteAclLinkDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteAclLinkType {
    pub description: String,
}

impl NoteAclLinkType {
    pub fn new(description: String) -> Self {
        NoteAclLinkType {
            description,
        }
    }

}

const NOTE_ACL_LINK_TYPE_FIELDS: &[&str] = &["description"];
impl NoteAclLinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoteAclLinkType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoteAclLinkType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoteAclLinkType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclLinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclLinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteAclLinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclLinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclLinkType", NOTE_ACL_LINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclLinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteAclLinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed Paper doc to link-accessible for team.
#[derive(Debug)]
pub struct NoteAclTeamLinkDetails {
}

impl Default for NoteAclTeamLinkDetails {
    fn default() -> Self {
        NoteAclTeamLinkDetails {
        }
    }
}

const NOTE_ACL_TEAM_LINK_DETAILS_FIELDS: &[&str] = &[];
impl NoteAclTeamLinkDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteAclTeamLinkDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(NoteAclTeamLinkDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclTeamLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclTeamLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteAclTeamLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclTeamLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclTeamLinkDetails", NOTE_ACL_TEAM_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclTeamLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteAclTeamLinkDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteAclTeamLinkType {
    pub description: String,
}

impl NoteAclTeamLinkType {
    pub fn new(description: String) -> Self {
        NoteAclTeamLinkType {
            description,
        }
    }

}

const NOTE_ACL_TEAM_LINK_TYPE_FIELDS: &[&str] = &["description"];
impl NoteAclTeamLinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoteAclTeamLinkType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoteAclTeamLinkType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoteAclTeamLinkType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteAclTeamLinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteAclTeamLinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteAclTeamLinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteAclTeamLinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteAclTeamLinkType", NOTE_ACL_TEAM_LINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteAclTeamLinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteAclTeamLinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared received Paper doc.
#[derive(Debug)]
pub struct NoteShareReceiveDetails {
}

impl Default for NoteShareReceiveDetails {
    fn default() -> Self {
        NoteShareReceiveDetails {
        }
    }
}

const NOTE_SHARE_RECEIVE_DETAILS_FIELDS: &[&str] = &[];
impl NoteShareReceiveDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteShareReceiveDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(NoteShareReceiveDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteShareReceiveDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteShareReceiveDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteShareReceiveDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteShareReceiveDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteShareReceiveDetails", NOTE_SHARE_RECEIVE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteShareReceiveDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteShareReceiveDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteShareReceiveType {
    pub description: String,
}

impl NoteShareReceiveType {
    pub fn new(description: String) -> Self {
        NoteShareReceiveType {
            description,
        }
    }

}

const NOTE_SHARE_RECEIVE_TYPE_FIELDS: &[&str] = &["description"];
impl NoteShareReceiveType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoteShareReceiveType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoteShareReceiveType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoteShareReceiveType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteShareReceiveType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteShareReceiveType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteShareReceiveType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteShareReceiveType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteShareReceiveType", NOTE_SHARE_RECEIVE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteShareReceiveType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteShareReceiveType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared Paper doc.
#[derive(Debug)]
pub struct NoteSharedDetails {
}

impl Default for NoteSharedDetails {
    fn default() -> Self {
        NoteSharedDetails {
        }
    }
}

const NOTE_SHARED_DETAILS_FIELDS: &[&str] = &[];
impl NoteSharedDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<NoteSharedDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(NoteSharedDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteSharedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteSharedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteSharedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteSharedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteSharedDetails", NOTE_SHARED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteSharedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("NoteSharedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct NoteSharedType {
    pub description: String,
}

impl NoteSharedType {
    pub fn new(description: String) -> Self {
        NoteSharedType {
            description,
        }
    }

}

const NOTE_SHARED_TYPE_FIELDS: &[&str] = &["description"];
impl NoteSharedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NoteSharedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NoteSharedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NoteSharedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NoteSharedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NoteSharedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NoteSharedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NoteSharedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NoteSharedType", NOTE_SHARED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NoteSharedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NoteSharedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Opened shared Paper doc.
#[derive(Debug)]
pub struct OpenNoteSharedDetails {
}

impl Default for OpenNoteSharedDetails {
    fn default() -> Self {
        OpenNoteSharedDetails {
        }
    }
}

const OPEN_NOTE_SHARED_DETAILS_FIELDS: &[&str] = &[];
impl OpenNoteSharedDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<OpenNoteSharedDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(OpenNoteSharedDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OpenNoteSharedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OpenNoteSharedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a OpenNoteSharedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OpenNoteSharedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OpenNoteSharedDetails", OPEN_NOTE_SHARED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OpenNoteSharedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("OpenNoteSharedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct OpenNoteSharedType {
    pub description: String,
}

impl OpenNoteSharedType {
    pub fn new(description: String) -> Self {
        OpenNoteSharedType {
            description,
        }
    }

}

const OPEN_NOTE_SHARED_TYPE_FIELDS: &[&str] = &["description"];
impl OpenNoteSharedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<OpenNoteSharedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<OpenNoteSharedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = OpenNoteSharedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OpenNoteSharedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OpenNoteSharedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a OpenNoteSharedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OpenNoteSharedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OpenNoteSharedType", OPEN_NOTE_SHARED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OpenNoteSharedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OpenNoteSharedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// More details about the organization.
#[derive(Debug)]
pub struct OrganizationDetails {
    /// The name of the organization.
    pub organization: String,
}

impl OrganizationDetails {
    pub fn new(organization: String) -> Self {
        OrganizationDetails {
            organization,
        }
    }

}

const ORGANIZATION_DETAILS_FIELDS: &[&str] = &["organization"];
impl OrganizationDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<OrganizationDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<OrganizationDetails>, V::Error> {
        let mut field_organization = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "organization" => {
                    if field_organization.is_some() {
                        return Err(::serde::de::Error::duplicate_field("organization"));
                    }
                    field_organization = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = OrganizationDetails {
            organization: field_organization.ok_or_else(|| ::serde::de::Error::missing_field("organization"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("organization", &self.organization)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OrganizationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OrganizationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a OrganizationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OrganizationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OrganizationDetails", ORGANIZATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OrganizationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OrganizationDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The name of the organization
#[derive(Debug)]
pub struct OrganizationName {
    /// The name of the organization.
    pub organization: String,
}

impl OrganizationName {
    pub fn new(organization: String) -> Self {
        OrganizationName {
            organization,
        }
    }

}

const ORGANIZATION_NAME_FIELDS: &[&str] = &["organization"];
impl OrganizationName {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<OrganizationName, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<OrganizationName>, V::Error> {
        let mut field_organization = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "organization" => {
                    if field_organization.is_some() {
                        return Err(::serde::de::Error::duplicate_field("organization"));
                    }
                    field_organization = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = OrganizationName {
            organization: field_organization.ok_or_else(|| ::serde::de::Error::missing_field("organization"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("organization", &self.organization)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OrganizationName {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OrganizationName;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a OrganizationName struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OrganizationName::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OrganizationName", ORGANIZATION_NAME_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OrganizationName {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OrganizationName", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The origin from which the actor performed the action.
#[derive(Debug)]
pub struct OriginLogInfo {
    /// The method that was used to perform the action.
    pub access_method: AccessMethodLogInfo,
    /// Geographic location details.
    pub geo_location: Option<GeoLocationLogInfo>,
}

impl OriginLogInfo {
    pub fn new(access_method: AccessMethodLogInfo) -> Self {
        OriginLogInfo {
            access_method,
            geo_location: None,
        }
    }

    pub fn with_geo_location(mut self, value: Option<GeoLocationLogInfo>) -> Self {
        self.geo_location = value;
        self
    }

}

const ORIGIN_LOG_INFO_FIELDS: &[&str] = &["access_method",
                                          "geo_location"];
impl OriginLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<OriginLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<OriginLogInfo>, V::Error> {
        let mut field_access_method = None;
        let mut field_geo_location = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "access_method" => {
                    if field_access_method.is_some() {
                        return Err(::serde::de::Error::duplicate_field("access_method"));
                    }
                    field_access_method = Some(map.next_value()?);
                }
                "geo_location" => {
                    if field_geo_location.is_some() {
                        return Err(::serde::de::Error::duplicate_field("geo_location"));
                    }
                    field_geo_location = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = OriginLogInfo {
            access_method: field_access_method.ok_or_else(|| ::serde::de::Error::missing_field("access_method"))?,
            geo_location: field_geo_location,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_method", &self.access_method)?;
        s.serialize_field("geo_location", &self.geo_location)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OriginLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OriginLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a OriginLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OriginLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OriginLogInfo", ORIGIN_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OriginLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OriginLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Report created: Views of old links.
#[derive(Debug)]
pub struct OutdatedLinkViewCreateReportDetails {
    /// Report start date.
    pub start_date: super::common::DropboxTimestamp,
    /// Report end date.
    pub end_date: super::common::DropboxTimestamp,
}

impl OutdatedLinkViewCreateReportDetails {
    pub fn new(
        start_date: super::common::DropboxTimestamp,
        end_date: super::common::DropboxTimestamp,
    ) -> Self {
        OutdatedLinkViewCreateReportDetails {
            start_date,
            end_date,
        }
    }

}

const OUTDATED_LINK_VIEW_CREATE_REPORT_DETAILS_FIELDS: &[&str] = &["start_date",
                                                                   "end_date"];
impl OutdatedLinkViewCreateReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<OutdatedLinkViewCreateReportDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<OutdatedLinkViewCreateReportDetails>, V::Error> {
        let mut field_start_date = None;
        let mut field_end_date = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "end_date" => {
                    if field_end_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("end_date"));
                    }
                    field_end_date = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = OutdatedLinkViewCreateReportDetails {
            start_date: field_start_date.ok_or_else(|| ::serde::de::Error::missing_field("start_date"))?,
            end_date: field_end_date.ok_or_else(|| ::serde::de::Error::missing_field("end_date"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("end_date", &self.end_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OutdatedLinkViewCreateReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OutdatedLinkViewCreateReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a OutdatedLinkViewCreateReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OutdatedLinkViewCreateReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OutdatedLinkViewCreateReportDetails", OUTDATED_LINK_VIEW_CREATE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OutdatedLinkViewCreateReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OutdatedLinkViewCreateReportDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct OutdatedLinkViewCreateReportType {
    pub description: String,
}

impl OutdatedLinkViewCreateReportType {
    pub fn new(description: String) -> Self {
        OutdatedLinkViewCreateReportType {
            description,
        }
    }

}

const OUTDATED_LINK_VIEW_CREATE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl OutdatedLinkViewCreateReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<OutdatedLinkViewCreateReportType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<OutdatedLinkViewCreateReportType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = OutdatedLinkViewCreateReportType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OutdatedLinkViewCreateReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OutdatedLinkViewCreateReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a OutdatedLinkViewCreateReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OutdatedLinkViewCreateReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OutdatedLinkViewCreateReportType", OUTDATED_LINK_VIEW_CREATE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OutdatedLinkViewCreateReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OutdatedLinkViewCreateReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Couldn't create report: Views of old links.
#[derive(Debug)]
pub struct OutdatedLinkViewReportFailedDetails {
    /// Failure reason.
    pub failure_reason: super::team::TeamReportFailureReason,
}

impl OutdatedLinkViewReportFailedDetails {
    pub fn new(failure_reason: super::team::TeamReportFailureReason) -> Self {
        OutdatedLinkViewReportFailedDetails {
            failure_reason,
        }
    }

}

const OUTDATED_LINK_VIEW_REPORT_FAILED_DETAILS_FIELDS: &[&str] = &["failure_reason"];
impl OutdatedLinkViewReportFailedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<OutdatedLinkViewReportFailedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<OutdatedLinkViewReportFailedDetails>, V::Error> {
        let mut field_failure_reason = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "failure_reason" => {
                    if field_failure_reason.is_some() {
                        return Err(::serde::de::Error::duplicate_field("failure_reason"));
                    }
                    field_failure_reason = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = OutdatedLinkViewReportFailedDetails {
            failure_reason: field_failure_reason.ok_or_else(|| ::serde::de::Error::missing_field("failure_reason"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("failure_reason", &self.failure_reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OutdatedLinkViewReportFailedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OutdatedLinkViewReportFailedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a OutdatedLinkViewReportFailedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OutdatedLinkViewReportFailedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OutdatedLinkViewReportFailedDetails", OUTDATED_LINK_VIEW_REPORT_FAILED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OutdatedLinkViewReportFailedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OutdatedLinkViewReportFailedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct OutdatedLinkViewReportFailedType {
    pub description: String,
}

impl OutdatedLinkViewReportFailedType {
    pub fn new(description: String) -> Self {
        OutdatedLinkViewReportFailedType {
            description,
        }
    }

}

const OUTDATED_LINK_VIEW_REPORT_FAILED_TYPE_FIELDS: &[&str] = &["description"];
impl OutdatedLinkViewReportFailedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<OutdatedLinkViewReportFailedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<OutdatedLinkViewReportFailedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = OutdatedLinkViewReportFailedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for OutdatedLinkViewReportFailedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = OutdatedLinkViewReportFailedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a OutdatedLinkViewReportFailedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                OutdatedLinkViewReportFailedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("OutdatedLinkViewReportFailedType", OUTDATED_LINK_VIEW_REPORT_FAILED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for OutdatedLinkViewReportFailedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("OutdatedLinkViewReportFailedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PaperAccessType {
    Viewer,
    Commenter,
    Editor,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperAccessType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "viewer" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperAccessType::Viewer)
                    }
                    "commenter" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperAccessType::Commenter)
                    }
                    "editor" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperAccessType::Editor)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperAccessType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["viewer",
                                    "commenter",
                                    "editor",
                                    "other"];
        deserializer.deserialize_struct("PaperAccessType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperAccessType::Viewer => {
                // unit
                let mut s = serializer.serialize_struct("PaperAccessType", 1)?;
                s.serialize_field(".tag", "viewer")?;
                s.end()
            }
            PaperAccessType::Commenter => {
                // unit
                let mut s = serializer.serialize_struct("PaperAccessType", 1)?;
                s.serialize_field(".tag", "commenter")?;
                s.end()
            }
            PaperAccessType::Editor => {
                // unit
                let mut s = serializer.serialize_struct("PaperAccessType", 1)?;
                s.serialize_field(".tag", "editor")?;
                s.end()
            }
            PaperAccessType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Exported all team Paper docs.
#[derive(Debug)]
pub struct PaperAdminExportStartDetails {
}

impl Default for PaperAdminExportStartDetails {
    fn default() -> Self {
        PaperAdminExportStartDetails {
        }
    }
}

const PAPER_ADMIN_EXPORT_START_DETAILS_FIELDS: &[&str] = &[];
impl PaperAdminExportStartDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperAdminExportStartDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(PaperAdminExportStartDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperAdminExportStartDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperAdminExportStartDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperAdminExportStartDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperAdminExportStartDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperAdminExportStartDetails", PAPER_ADMIN_EXPORT_START_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperAdminExportStartDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperAdminExportStartDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PaperAdminExportStartType {
    pub description: String,
}

impl PaperAdminExportStartType {
    pub fn new(description: String) -> Self {
        PaperAdminExportStartType {
            description,
        }
    }

}

const PAPER_ADMIN_EXPORT_START_TYPE_FIELDS: &[&str] = &["description"];
impl PaperAdminExportStartType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperAdminExportStartType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperAdminExportStartType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperAdminExportStartType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperAdminExportStartType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperAdminExportStartType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperAdminExportStartType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperAdminExportStartType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperAdminExportStartType", PAPER_ADMIN_EXPORT_START_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperAdminExportStartType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperAdminExportStartType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether Dropbox Paper, when enabled, is deployed to all members or to specific members.
#[derive(Debug)]
pub struct PaperChangeDeploymentPolicyDetails {
    /// New Dropbox Paper deployment policy.
    pub new_value: super::team_policies::PaperDeploymentPolicy,
    /// Previous Dropbox Paper deployment policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::PaperDeploymentPolicy>,
}

impl PaperChangeDeploymentPolicyDetails {
    pub fn new(new_value: super::team_policies::PaperDeploymentPolicy) -> Self {
        PaperChangeDeploymentPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_policies::PaperDeploymentPolicy>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const PAPER_CHANGE_DEPLOYMENT_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                 "previous_value"];
impl PaperChangeDeploymentPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperChangeDeploymentPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperChangeDeploymentPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperChangeDeploymentPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeDeploymentPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeDeploymentPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperChangeDeploymentPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeDeploymentPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeDeploymentPolicyDetails", PAPER_CHANGE_DEPLOYMENT_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeDeploymentPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeDeploymentPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperChangeDeploymentPolicyType {
    pub description: String,
}

impl PaperChangeDeploymentPolicyType {
    pub fn new(description: String) -> Self {
        PaperChangeDeploymentPolicyType {
            description,
        }
    }

}

const PAPER_CHANGE_DEPLOYMENT_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperChangeDeploymentPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperChangeDeploymentPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperChangeDeploymentPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperChangeDeploymentPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeDeploymentPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeDeploymentPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperChangeDeploymentPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeDeploymentPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeDeploymentPolicyType", PAPER_CHANGE_DEPLOYMENT_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeDeploymentPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeDeploymentPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether non-members can view Paper docs with link.
#[derive(Debug)]
pub struct PaperChangeMemberLinkPolicyDetails {
    /// New paper external link accessibility policy.
    pub new_value: PaperMemberPolicy,
}

impl PaperChangeMemberLinkPolicyDetails {
    pub fn new(new_value: PaperMemberPolicy) -> Self {
        PaperChangeMemberLinkPolicyDetails {
            new_value,
        }
    }

}

const PAPER_CHANGE_MEMBER_LINK_POLICY_DETAILS_FIELDS: &[&str] = &["new_value"];
impl PaperChangeMemberLinkPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperChangeMemberLinkPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperChangeMemberLinkPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperChangeMemberLinkPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeMemberLinkPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeMemberLinkPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperChangeMemberLinkPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeMemberLinkPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeMemberLinkPolicyDetails", PAPER_CHANGE_MEMBER_LINK_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeMemberLinkPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeMemberLinkPolicyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperChangeMemberLinkPolicyType {
    pub description: String,
}

impl PaperChangeMemberLinkPolicyType {
    pub fn new(description: String) -> Self {
        PaperChangeMemberLinkPolicyType {
            description,
        }
    }

}

const PAPER_CHANGE_MEMBER_LINK_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperChangeMemberLinkPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperChangeMemberLinkPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperChangeMemberLinkPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperChangeMemberLinkPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeMemberLinkPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeMemberLinkPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperChangeMemberLinkPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeMemberLinkPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeMemberLinkPolicyType", PAPER_CHANGE_MEMBER_LINK_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeMemberLinkPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeMemberLinkPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether members can share Paper docs outside team, and if docs are accessible only by
/// team members or anyone by default.
#[derive(Debug)]
pub struct PaperChangeMemberPolicyDetails {
    /// New paper external accessibility policy.
    pub new_value: PaperMemberPolicy,
    /// Previous paper external accessibility policy. Might be missing due to historical data gap.
    pub previous_value: Option<PaperMemberPolicy>,
}

impl PaperChangeMemberPolicyDetails {
    pub fn new(new_value: PaperMemberPolicy) -> Self {
        PaperChangeMemberPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<PaperMemberPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const PAPER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                             "previous_value"];
impl PaperChangeMemberPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperChangeMemberPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperChangeMemberPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperChangeMemberPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeMemberPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeMemberPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperChangeMemberPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeMemberPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeMemberPolicyDetails", PAPER_CHANGE_MEMBER_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeMemberPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeMemberPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperChangeMemberPolicyType {
    pub description: String,
}

impl PaperChangeMemberPolicyType {
    pub fn new(description: String) -> Self {
        PaperChangeMemberPolicyType {
            description,
        }
    }

}

const PAPER_CHANGE_MEMBER_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperChangeMemberPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperChangeMemberPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperChangeMemberPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperChangeMemberPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangeMemberPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangeMemberPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperChangeMemberPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangeMemberPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangeMemberPolicyType", PAPER_CHANGE_MEMBER_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangeMemberPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangeMemberPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled Dropbox Paper for team.
#[derive(Debug)]
pub struct PaperChangePolicyDetails {
    /// New Dropbox Paper policy.
    pub new_value: super::team_policies::PaperEnabledPolicy,
    /// Previous Dropbox Paper policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::PaperEnabledPolicy>,
}

impl PaperChangePolicyDetails {
    pub fn new(new_value: super::team_policies::PaperEnabledPolicy) -> Self {
        PaperChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_policies::PaperEnabledPolicy>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const PAPER_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                      "previous_value"];
impl PaperChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangePolicyDetails", PAPER_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperChangePolicyType {
    pub description: String,
}

impl PaperChangePolicyType {
    pub fn new(description: String) -> Self {
        PaperChangePolicyType {
            description,
        }
    }

}

const PAPER_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperChangePolicyType", PAPER_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added users and/or groups to Paper doc/folder.
#[derive(Debug)]
pub struct PaperContentAddMemberDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentAddMemberDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentAddMemberDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_ADD_MEMBER_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentAddMemberDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentAddMemberDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentAddMemberDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddMemberDetails", PAPER_CONTENT_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentAddMemberType {
    pub description: String,
}

impl PaperContentAddMemberType {
    pub fn new(description: String) -> Self {
        PaperContentAddMemberType {
            description,
        }
    }

}

const PAPER_CONTENT_ADD_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentAddMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentAddMemberType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentAddMemberType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentAddMemberType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddMemberType", PAPER_CONTENT_ADD_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added Paper doc/folder to folder.
#[derive(Debug)]
pub struct PaperContentAddToFolderDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Parent asset position in the Assets list.
    pub parent_asset_index: u64,
}

impl PaperContentAddToFolderDetails {
    pub fn new(event_uuid: String, target_asset_index: u64, parent_asset_index: u64) -> Self {
        PaperContentAddToFolderDetails {
            event_uuid,
            target_asset_index,
            parent_asset_index,
        }
    }

}

const PAPER_CONTENT_ADD_TO_FOLDER_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                              "target_asset_index",
                                                              "parent_asset_index"];
impl PaperContentAddToFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentAddToFolderDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentAddToFolderDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_target_asset_index = None;
        let mut field_parent_asset_index = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "parent_asset_index" => {
                    if field_parent_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("parent_asset_index"));
                    }
                    field_parent_asset_index = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentAddToFolderDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            parent_asset_index: field_parent_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("parent_asset_index"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("parent_asset_index", &self.parent_asset_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddToFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddToFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddToFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddToFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddToFolderDetails", PAPER_CONTENT_ADD_TO_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddToFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddToFolderDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentAddToFolderType {
    pub description: String,
}

impl PaperContentAddToFolderType {
    pub fn new(description: String) -> Self {
        PaperContentAddToFolderType {
            description,
        }
    }

}

const PAPER_CONTENT_ADD_TO_FOLDER_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentAddToFolderType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentAddToFolderType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentAddToFolderType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentAddToFolderType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentAddToFolderType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentAddToFolderType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentAddToFolderType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentAddToFolderType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentAddToFolderType", PAPER_CONTENT_ADD_TO_FOLDER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentAddToFolderType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentAddToFolderType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Archived Paper doc/folder.
#[derive(Debug)]
pub struct PaperContentArchiveDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentArchiveDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentArchiveDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_ARCHIVE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentArchiveDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentArchiveDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentArchiveDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentArchiveDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentArchiveDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentArchiveDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentArchiveDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentArchiveDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentArchiveDetails", PAPER_CONTENT_ARCHIVE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentArchiveDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentArchiveDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentArchiveType {
    pub description: String,
}

impl PaperContentArchiveType {
    pub fn new(description: String) -> Self {
        PaperContentArchiveType {
            description,
        }
    }

}

const PAPER_CONTENT_ARCHIVE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentArchiveType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentArchiveType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentArchiveType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentArchiveType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentArchiveType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentArchiveType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentArchiveType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentArchiveType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentArchiveType", PAPER_CONTENT_ARCHIVE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentArchiveType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentArchiveType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created Paper doc/folder.
#[derive(Debug)]
pub struct PaperContentCreateDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentCreateDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentCreateDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_CREATE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentCreateDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentCreateDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentCreateDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentCreateDetails", PAPER_CONTENT_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentCreateDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentCreateType {
    pub description: String,
}

impl PaperContentCreateType {
    pub fn new(description: String) -> Self {
        PaperContentCreateType {
            description,
        }
    }

}

const PAPER_CONTENT_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentCreateType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentCreateType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentCreateType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentCreateType", PAPER_CONTENT_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted Paper doc/folder.
#[derive(Debug)]
pub struct PaperContentPermanentlyDeleteDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentPermanentlyDeleteDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentPermanentlyDeleteDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_PERMANENTLY_DELETE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentPermanentlyDeleteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentPermanentlyDeleteDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentPermanentlyDeleteDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentPermanentlyDeleteDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentPermanentlyDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentPermanentlyDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentPermanentlyDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentPermanentlyDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentPermanentlyDeleteDetails", PAPER_CONTENT_PERMANENTLY_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentPermanentlyDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentPermanentlyDeleteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentPermanentlyDeleteType {
    pub description: String,
}

impl PaperContentPermanentlyDeleteType {
    pub fn new(description: String) -> Self {
        PaperContentPermanentlyDeleteType {
            description,
        }
    }

}

const PAPER_CONTENT_PERMANENTLY_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentPermanentlyDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentPermanentlyDeleteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentPermanentlyDeleteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentPermanentlyDeleteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentPermanentlyDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentPermanentlyDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentPermanentlyDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentPermanentlyDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentPermanentlyDeleteType", PAPER_CONTENT_PERMANENTLY_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentPermanentlyDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentPermanentlyDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed Paper doc/folder from folder.
#[derive(Debug)]
pub struct PaperContentRemoveFromFolderDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Target asset position in the Assets list.
    pub target_asset_index: Option<u64>,
    /// Parent asset position in the Assets list.
    pub parent_asset_index: Option<u64>,
}

impl PaperContentRemoveFromFolderDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRemoveFromFolderDetails {
            event_uuid,
            target_asset_index: None,
            parent_asset_index: None,
        }
    }

    pub fn with_target_asset_index(mut self, value: Option<u64>) -> Self {
        self.target_asset_index = value;
        self
    }

    pub fn with_parent_asset_index(mut self, value: Option<u64>) -> Self {
        self.parent_asset_index = value;
        self
    }

}

const PAPER_CONTENT_REMOVE_FROM_FOLDER_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                                   "target_asset_index",
                                                                   "parent_asset_index"];
impl PaperContentRemoveFromFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentRemoveFromFolderDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentRemoveFromFolderDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_target_asset_index = None;
        let mut field_parent_asset_index = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "parent_asset_index" => {
                    if field_parent_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("parent_asset_index"));
                    }
                    field_parent_asset_index = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentRemoveFromFolderDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            target_asset_index: field_target_asset_index,
            parent_asset_index: field_parent_asset_index,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("parent_asset_index", &self.parent_asset_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveFromFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveFromFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveFromFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveFromFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveFromFolderDetails", PAPER_CONTENT_REMOVE_FROM_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveFromFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveFromFolderDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentRemoveFromFolderType {
    pub description: String,
}

impl PaperContentRemoveFromFolderType {
    pub fn new(description: String) -> Self {
        PaperContentRemoveFromFolderType {
            description,
        }
    }

}

const PAPER_CONTENT_REMOVE_FROM_FOLDER_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentRemoveFromFolderType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentRemoveFromFolderType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentRemoveFromFolderType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentRemoveFromFolderType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveFromFolderType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveFromFolderType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveFromFolderType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveFromFolderType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveFromFolderType", PAPER_CONTENT_REMOVE_FROM_FOLDER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveFromFolderType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveFromFolderType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed users and/or groups from Paper doc/folder.
#[derive(Debug)]
pub struct PaperContentRemoveMemberDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRemoveMemberDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRemoveMemberDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentRemoveMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentRemoveMemberDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentRemoveMemberDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentRemoveMemberDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveMemberDetails", PAPER_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentRemoveMemberType {
    pub description: String,
}

impl PaperContentRemoveMemberType {
    pub fn new(description: String) -> Self {
        PaperContentRemoveMemberType {
            description,
        }
    }

}

const PAPER_CONTENT_REMOVE_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentRemoveMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentRemoveMemberType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentRemoveMemberType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentRemoveMemberType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRemoveMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRemoveMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentRemoveMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRemoveMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRemoveMemberType", PAPER_CONTENT_REMOVE_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRemoveMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRemoveMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed Paper doc/folder.
#[derive(Debug)]
pub struct PaperContentRenameDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRenameDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRenameDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_RENAME_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentRenameDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentRenameDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentRenameDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRenameDetails", PAPER_CONTENT_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRenameDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentRenameType {
    pub description: String,
}

impl PaperContentRenameType {
    pub fn new(description: String) -> Self {
        PaperContentRenameType {
            description,
        }
    }

}

const PAPER_CONTENT_RENAME_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentRenameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentRenameType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentRenameType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentRenameType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRenameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRenameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentRenameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRenameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRenameType", PAPER_CONTENT_RENAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRenameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRenameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored archived Paper doc/folder.
#[derive(Debug)]
pub struct PaperContentRestoreDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperContentRestoreDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperContentRestoreDetails {
            event_uuid,
        }
    }

}

const PAPER_CONTENT_RESTORE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperContentRestoreDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentRestoreDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentRestoreDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentRestoreDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRestoreDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRestoreDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentRestoreDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRestoreDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRestoreDetails", PAPER_CONTENT_RESTORE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRestoreDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRestoreDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperContentRestoreType {
    pub description: String,
}

impl PaperContentRestoreType {
    pub fn new(description: String) -> Self {
        PaperContentRestoreType {
            description,
        }
    }

}

const PAPER_CONTENT_RESTORE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperContentRestoreType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperContentRestoreType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperContentRestoreType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperContentRestoreType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperContentRestoreType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperContentRestoreType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperContentRestoreType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperContentRestoreType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperContentRestoreType", PAPER_CONTENT_RESTORE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperContentRestoreType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperContentRestoreType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy to set default access for newly created Paper folders.
#[derive(Debug)]
pub enum PaperDefaultFolderPolicy {
    EveryoneInTeam,
    InviteOnly,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDefaultFolderPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperDefaultFolderPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDefaultFolderPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "everyone_in_team" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDefaultFolderPolicy::EveryoneInTeam)
                    }
                    "invite_only" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDefaultFolderPolicy::InviteOnly)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDefaultFolderPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["everyone_in_team",
                                    "invite_only",
                                    "other"];
        deserializer.deserialize_struct("PaperDefaultFolderPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDefaultFolderPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperDefaultFolderPolicy::EveryoneInTeam => {
                // unit
                let mut s = serializer.serialize_struct("PaperDefaultFolderPolicy", 1)?;
                s.serialize_field(".tag", "everyone_in_team")?;
                s.end()
            }
            PaperDefaultFolderPolicy::InviteOnly => {
                // unit
                let mut s = serializer.serialize_struct("PaperDefaultFolderPolicy", 1)?;
                s.serialize_field(".tag", "invite_only")?;
                s.end()
            }
            PaperDefaultFolderPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed Paper Default Folder Policy setting for team.
#[derive(Debug)]
pub struct PaperDefaultFolderPolicyChangedDetails {
    /// New Paper Default Folder Policy.
    pub new_value: PaperDefaultFolderPolicy,
    /// Previous Paper Default Folder Policy.
    pub previous_value: PaperDefaultFolderPolicy,
}

impl PaperDefaultFolderPolicyChangedDetails {
    pub fn new(
        new_value: PaperDefaultFolderPolicy,
        previous_value: PaperDefaultFolderPolicy,
    ) -> Self {
        PaperDefaultFolderPolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const PAPER_DEFAULT_FOLDER_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                      "previous_value"];
impl PaperDefaultFolderPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDefaultFolderPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDefaultFolderPolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDefaultFolderPolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDefaultFolderPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDefaultFolderPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDefaultFolderPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDefaultFolderPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDefaultFolderPolicyChangedDetails", PAPER_DEFAULT_FOLDER_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDefaultFolderPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDefaultFolderPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDefaultFolderPolicyChangedType {
    pub description: String,
}

impl PaperDefaultFolderPolicyChangedType {
    pub fn new(description: String) -> Self {
        PaperDefaultFolderPolicyChangedType {
            description,
        }
    }

}

const PAPER_DEFAULT_FOLDER_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDefaultFolderPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDefaultFolderPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDefaultFolderPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDefaultFolderPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDefaultFolderPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDefaultFolderPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDefaultFolderPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDefaultFolderPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDefaultFolderPolicyChangedType", PAPER_DEFAULT_FOLDER_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDefaultFolderPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDefaultFolderPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if team members can use Paper Desktop
#[derive(Debug)]
pub enum PaperDesktopPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDesktopPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperDesktopPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDesktopPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDesktopPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDesktopPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDesktopPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("PaperDesktopPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDesktopPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperDesktopPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("PaperDesktopPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            PaperDesktopPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("PaperDesktopPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            PaperDesktopPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Enabled/disabled Paper Desktop for team.
#[derive(Debug)]
pub struct PaperDesktopPolicyChangedDetails {
    /// New Paper Desktop policy.
    pub new_value: PaperDesktopPolicy,
    /// Previous Paper Desktop policy.
    pub previous_value: PaperDesktopPolicy,
}

impl PaperDesktopPolicyChangedDetails {
    pub fn new(new_value: PaperDesktopPolicy, previous_value: PaperDesktopPolicy) -> Self {
        PaperDesktopPolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const PAPER_DESKTOP_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                               "previous_value"];
impl PaperDesktopPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDesktopPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDesktopPolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDesktopPolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDesktopPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDesktopPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDesktopPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDesktopPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDesktopPolicyChangedDetails", PAPER_DESKTOP_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDesktopPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDesktopPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDesktopPolicyChangedType {
    pub description: String,
}

impl PaperDesktopPolicyChangedType {
    pub fn new(description: String) -> Self {
        PaperDesktopPolicyChangedType {
            description,
        }
    }

}

const PAPER_DESKTOP_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDesktopPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDesktopPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDesktopPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDesktopPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDesktopPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDesktopPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDesktopPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDesktopPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDesktopPolicyChangedType", PAPER_DESKTOP_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDesktopPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDesktopPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added Paper doc comment.
#[derive(Debug)]
pub struct PaperDocAddCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocAddCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocAddCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_ADD_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                        "comment_text"];
impl PaperDocAddCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocAddCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocAddCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocAddCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocAddCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocAddCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocAddCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocAddCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocAddCommentDetails", PAPER_DOC_ADD_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocAddCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocAddCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocAddCommentType {
    pub description: String,
}

impl PaperDocAddCommentType {
    pub fn new(description: String) -> Self {
        PaperDocAddCommentType {
            description,
        }
    }

}

const PAPER_DOC_ADD_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocAddCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocAddCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocAddCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocAddCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocAddCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocAddCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocAddCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocAddCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocAddCommentType", PAPER_DOC_ADD_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocAddCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocAddCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed member permissions for Paper doc.
#[derive(Debug)]
pub struct PaperDocChangeMemberRoleDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Paper doc access type.
    pub access_type: PaperAccessType,
}

impl PaperDocChangeMemberRoleDetails {
    pub fn new(event_uuid: String, access_type: PaperAccessType) -> Self {
        PaperDocChangeMemberRoleDetails {
            event_uuid,
            access_type,
        }
    }

}

const PAPER_DOC_CHANGE_MEMBER_ROLE_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                               "access_type"];
impl PaperDocChangeMemberRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocChangeMemberRoleDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocChangeMemberRoleDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_access_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocChangeMemberRoleDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            access_type: field_access_type.ok_or_else(|| ::serde::de::Error::missing_field("access_type"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("access_type", &self.access_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeMemberRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeMemberRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeMemberRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeMemberRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeMemberRoleDetails", PAPER_DOC_CHANGE_MEMBER_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeMemberRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeMemberRoleDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocChangeMemberRoleType {
    pub description: String,
}

impl PaperDocChangeMemberRoleType {
    pub fn new(description: String) -> Self {
        PaperDocChangeMemberRoleType {
            description,
        }
    }

}

const PAPER_DOC_CHANGE_MEMBER_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocChangeMemberRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocChangeMemberRoleType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocChangeMemberRoleType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocChangeMemberRoleType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeMemberRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeMemberRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeMemberRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeMemberRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeMemberRoleType", PAPER_DOC_CHANGE_MEMBER_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeMemberRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeMemberRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed sharing setting for Paper doc.
#[derive(Debug)]
pub struct PaperDocChangeSharingPolicyDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Sharing policy with external users. Might be missing due to historical data gap.
    pub public_sharing_policy: Option<String>,
    /// Sharing policy with team. Might be missing due to historical data gap.
    pub team_sharing_policy: Option<String>,
}

impl PaperDocChangeSharingPolicyDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocChangeSharingPolicyDetails {
            event_uuid,
            public_sharing_policy: None,
            team_sharing_policy: None,
        }
    }

    pub fn with_public_sharing_policy(mut self, value: Option<String>) -> Self {
        self.public_sharing_policy = value;
        self
    }

    pub fn with_team_sharing_policy(mut self, value: Option<String>) -> Self {
        self.team_sharing_policy = value;
        self
    }

}

const PAPER_DOC_CHANGE_SHARING_POLICY_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                                  "public_sharing_policy",
                                                                  "team_sharing_policy"];
impl PaperDocChangeSharingPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocChangeSharingPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocChangeSharingPolicyDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_public_sharing_policy = None;
        let mut field_team_sharing_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "public_sharing_policy" => {
                    if field_public_sharing_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("public_sharing_policy"));
                    }
                    field_public_sharing_policy = Some(map.next_value()?);
                }
                "team_sharing_policy" => {
                    if field_team_sharing_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_sharing_policy"));
                    }
                    field_team_sharing_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocChangeSharingPolicyDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            public_sharing_policy: field_public_sharing_policy,
            team_sharing_policy: field_team_sharing_policy,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("public_sharing_policy", &self.public_sharing_policy)?;
        s.serialize_field("team_sharing_policy", &self.team_sharing_policy)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeSharingPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeSharingPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeSharingPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeSharingPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeSharingPolicyDetails", PAPER_DOC_CHANGE_SHARING_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeSharingPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeSharingPolicyDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocChangeSharingPolicyType {
    pub description: String,
}

impl PaperDocChangeSharingPolicyType {
    pub fn new(description: String) -> Self {
        PaperDocChangeSharingPolicyType {
            description,
        }
    }

}

const PAPER_DOC_CHANGE_SHARING_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocChangeSharingPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocChangeSharingPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocChangeSharingPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocChangeSharingPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeSharingPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeSharingPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeSharingPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeSharingPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeSharingPolicyType", PAPER_DOC_CHANGE_SHARING_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeSharingPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeSharingPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed/unfollowed Paper doc.
#[derive(Debug)]
pub struct PaperDocChangeSubscriptionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// New doc subscription level.
    pub new_subscription_level: String,
    /// Previous doc subscription level. Might be missing due to historical data gap.
    pub previous_subscription_level: Option<String>,
}

impl PaperDocChangeSubscriptionDetails {
    pub fn new(event_uuid: String, new_subscription_level: String) -> Self {
        PaperDocChangeSubscriptionDetails {
            event_uuid,
            new_subscription_level,
            previous_subscription_level: None,
        }
    }

    pub fn with_previous_subscription_level(mut self, value: Option<String>) -> Self {
        self.previous_subscription_level = value;
        self
    }

}

const PAPER_DOC_CHANGE_SUBSCRIPTION_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                                "new_subscription_level",
                                                                "previous_subscription_level"];
impl PaperDocChangeSubscriptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocChangeSubscriptionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocChangeSubscriptionDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_new_subscription_level = None;
        let mut field_previous_subscription_level = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "new_subscription_level" => {
                    if field_new_subscription_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_subscription_level"));
                    }
                    field_new_subscription_level = Some(map.next_value()?);
                }
                "previous_subscription_level" => {
                    if field_previous_subscription_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_subscription_level"));
                    }
                    field_previous_subscription_level = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocChangeSubscriptionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            new_subscription_level: field_new_subscription_level.ok_or_else(|| ::serde::de::Error::missing_field("new_subscription_level"))?,
            previous_subscription_level: field_previous_subscription_level,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("new_subscription_level", &self.new_subscription_level)?;
        s.serialize_field("previous_subscription_level", &self.previous_subscription_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeSubscriptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeSubscriptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeSubscriptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeSubscriptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeSubscriptionDetails", PAPER_DOC_CHANGE_SUBSCRIPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeSubscriptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeSubscriptionDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocChangeSubscriptionType {
    pub description: String,
}

impl PaperDocChangeSubscriptionType {
    pub fn new(description: String) -> Self {
        PaperDocChangeSubscriptionType {
            description,
        }
    }

}

const PAPER_DOC_CHANGE_SUBSCRIPTION_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocChangeSubscriptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocChangeSubscriptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocChangeSubscriptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocChangeSubscriptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocChangeSubscriptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocChangeSubscriptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocChangeSubscriptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocChangeSubscriptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocChangeSubscriptionType", PAPER_DOC_CHANGE_SUBSCRIPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocChangeSubscriptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocChangeSubscriptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted Paper doc comment.
#[derive(Debug)]
pub struct PaperDocDeleteCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocDeleteCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocDeleteCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_DELETE_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                           "comment_text"];
impl PaperDocDeleteCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocDeleteCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocDeleteCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocDeleteCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeleteCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeleteCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeleteCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeleteCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeleteCommentDetails", PAPER_DOC_DELETE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeleteCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeleteCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocDeleteCommentType {
    pub description: String,
}

impl PaperDocDeleteCommentType {
    pub fn new(description: String) -> Self {
        PaperDocDeleteCommentType {
            description,
        }
    }

}

const PAPER_DOC_DELETE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocDeleteCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocDeleteCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocDeleteCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocDeleteCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeleteCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeleteCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeleteCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeleteCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeleteCommentType", PAPER_DOC_DELETE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeleteCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeleteCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Archived Paper doc.
#[derive(Debug)]
pub struct PaperDocDeletedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocDeletedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocDeletedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_DELETED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocDeletedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocDeletedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocDeletedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocDeletedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeletedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeletedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeletedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeletedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeletedDetails", PAPER_DOC_DELETED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeletedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeletedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocDeletedType {
    pub description: String,
}

impl PaperDocDeletedType {
    pub fn new(description: String) -> Self {
        PaperDocDeletedType {
            description,
        }
    }

}

const PAPER_DOC_DELETED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocDeletedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocDeletedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocDeletedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocDeletedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDeletedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDeletedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocDeletedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDeletedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDeletedType", PAPER_DOC_DELETED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDeletedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDeletedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded Paper doc in specific format.
#[derive(Debug)]
pub struct PaperDocDownloadDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Export file format.
    pub export_file_format: PaperDownloadFormat,
}

impl PaperDocDownloadDetails {
    pub fn new(event_uuid: String, export_file_format: PaperDownloadFormat) -> Self {
        PaperDocDownloadDetails {
            event_uuid,
            export_file_format,
        }
    }

}

const PAPER_DOC_DOWNLOAD_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                     "export_file_format"];
impl PaperDocDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocDownloadDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocDownloadDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_export_file_format = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "export_file_format" => {
                    if field_export_file_format.is_some() {
                        return Err(::serde::de::Error::duplicate_field("export_file_format"));
                    }
                    field_export_file_format = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocDownloadDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            export_file_format: field_export_file_format.ok_or_else(|| ::serde::de::Error::missing_field("export_file_format"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("export_file_format", &self.export_file_format)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDownloadDetails", PAPER_DOC_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDownloadDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocDownloadType {
    pub description: String,
}

impl PaperDocDownloadType {
    pub fn new(description: String) -> Self {
        PaperDocDownloadType {
            description,
        }
    }

}

const PAPER_DOC_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocDownloadType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocDownloadType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocDownloadType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocDownloadType", PAPER_DOC_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited Paper doc comment.
#[derive(Debug)]
pub struct PaperDocEditCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocEditCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocEditCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_EDIT_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                         "comment_text"];
impl PaperDocEditCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocEditCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocEditCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocEditCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditCommentDetails", PAPER_DOC_EDIT_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocEditCommentType {
    pub description: String,
}

impl PaperDocEditCommentType {
    pub fn new(description: String) -> Self {
        PaperDocEditCommentType {
            description,
        }
    }

}

const PAPER_DOC_EDIT_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocEditCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocEditCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocEditCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocEditCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditCommentType", PAPER_DOC_EDIT_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited Paper doc.
#[derive(Debug)]
pub struct PaperDocEditDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocEditDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocEditDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_EDIT_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocEditDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocEditDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocEditDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocEditDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditDetails", PAPER_DOC_EDIT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocEditType {
    pub description: String,
}

impl PaperDocEditType {
    pub fn new(description: String) -> Self {
        PaperDocEditType {
            description,
        }
    }

}

const PAPER_DOC_EDIT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocEditType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocEditType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocEditType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocEditType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocEditType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocEditType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocEditType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocEditType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocEditType", PAPER_DOC_EDIT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocEditType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocEditType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed Paper doc.
#[derive(Debug)]
pub struct PaperDocFollowedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocFollowedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocFollowedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_FOLLOWED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocFollowedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocFollowedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocFollowedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocFollowedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocFollowedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocFollowedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocFollowedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocFollowedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocFollowedDetails", PAPER_DOC_FOLLOWED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocFollowedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocFollowedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocFollowedType {
    pub description: String,
}

impl PaperDocFollowedType {
    pub fn new(description: String) -> Self {
        PaperDocFollowedType {
            description,
        }
    }

}

const PAPER_DOC_FOLLOWED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocFollowedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocFollowedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocFollowedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocFollowedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocFollowedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocFollowedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocFollowedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocFollowedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocFollowedType", PAPER_DOC_FOLLOWED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocFollowedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocFollowedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Mentioned user in Paper doc.
#[derive(Debug)]
pub struct PaperDocMentionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocMentionDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocMentionDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_MENTION_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocMentionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocMentionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocMentionDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocMentionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocMentionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocMentionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocMentionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocMentionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocMentionDetails", PAPER_DOC_MENTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocMentionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocMentionDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocMentionType {
    pub description: String,
}

impl PaperDocMentionType {
    pub fn new(description: String) -> Self {
        PaperDocMentionType {
            description,
        }
    }

}

const PAPER_DOC_MENTION_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocMentionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocMentionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocMentionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocMentionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocMentionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocMentionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocMentionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocMentionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocMentionType", PAPER_DOC_MENTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocMentionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocMentionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Transferred ownership of Paper doc.
#[derive(Debug)]
pub struct PaperDocOwnershipChangedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// New owner.
    pub new_owner_user_id: super::users_common::AccountId,
    /// Previous owner.
    pub old_owner_user_id: Option<super::users_common::AccountId>,
}

impl PaperDocOwnershipChangedDetails {
    pub fn new(event_uuid: String, new_owner_user_id: super::users_common::AccountId) -> Self {
        PaperDocOwnershipChangedDetails {
            event_uuid,
            new_owner_user_id,
            old_owner_user_id: None,
        }
    }

    pub fn with_old_owner_user_id(
        mut self,
        value: Option<super::users_common::AccountId>,
    ) -> Self {
        self.old_owner_user_id = value;
        self
    }

}

const PAPER_DOC_OWNERSHIP_CHANGED_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                              "new_owner_user_id",
                                                              "old_owner_user_id"];
impl PaperDocOwnershipChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocOwnershipChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocOwnershipChangedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_new_owner_user_id = None;
        let mut field_old_owner_user_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "new_owner_user_id" => {
                    if field_new_owner_user_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_owner_user_id"));
                    }
                    field_new_owner_user_id = Some(map.next_value()?);
                }
                "old_owner_user_id" => {
                    if field_old_owner_user_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("old_owner_user_id"));
                    }
                    field_old_owner_user_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocOwnershipChangedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            new_owner_user_id: field_new_owner_user_id.ok_or_else(|| ::serde::de::Error::missing_field("new_owner_user_id"))?,
            old_owner_user_id: field_old_owner_user_id,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("new_owner_user_id", &self.new_owner_user_id)?;
        s.serialize_field("old_owner_user_id", &self.old_owner_user_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocOwnershipChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocOwnershipChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocOwnershipChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocOwnershipChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocOwnershipChangedDetails", PAPER_DOC_OWNERSHIP_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocOwnershipChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocOwnershipChangedDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocOwnershipChangedType {
    pub description: String,
}

impl PaperDocOwnershipChangedType {
    pub fn new(description: String) -> Self {
        PaperDocOwnershipChangedType {
            description,
        }
    }

}

const PAPER_DOC_OWNERSHIP_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocOwnershipChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocOwnershipChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocOwnershipChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocOwnershipChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocOwnershipChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocOwnershipChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocOwnershipChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocOwnershipChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocOwnershipChangedType", PAPER_DOC_OWNERSHIP_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocOwnershipChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocOwnershipChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested access to Paper doc.
#[derive(Debug)]
pub struct PaperDocRequestAccessDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocRequestAccessDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocRequestAccessDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_REQUEST_ACCESS_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocRequestAccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocRequestAccessDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocRequestAccessDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocRequestAccessDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRequestAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRequestAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocRequestAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRequestAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRequestAccessDetails", PAPER_DOC_REQUEST_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRequestAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRequestAccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocRequestAccessType {
    pub description: String,
}

impl PaperDocRequestAccessType {
    pub fn new(description: String) -> Self {
        PaperDocRequestAccessType {
            description,
        }
    }

}

const PAPER_DOC_REQUEST_ACCESS_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocRequestAccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocRequestAccessType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocRequestAccessType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocRequestAccessType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRequestAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRequestAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocRequestAccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRequestAccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRequestAccessType", PAPER_DOC_REQUEST_ACCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRequestAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRequestAccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Resolved Paper doc comment.
#[derive(Debug)]
pub struct PaperDocResolveCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocResolveCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocResolveCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_RESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                            "comment_text"];
impl PaperDocResolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocResolveCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocResolveCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocResolveCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocResolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocResolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocResolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocResolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocResolveCommentDetails", PAPER_DOC_RESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocResolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocResolveCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocResolveCommentType {
    pub description: String,
}

impl PaperDocResolveCommentType {
    pub fn new(description: String) -> Self {
        PaperDocResolveCommentType {
            description,
        }
    }

}

const PAPER_DOC_RESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocResolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocResolveCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocResolveCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocResolveCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocResolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocResolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocResolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocResolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocResolveCommentType", PAPER_DOC_RESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocResolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocResolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored Paper doc to previous version.
#[derive(Debug)]
pub struct PaperDocRevertDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocRevertDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocRevertDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_REVERT_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocRevertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocRevertDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocRevertDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocRevertDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRevertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRevertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocRevertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRevertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRevertDetails", PAPER_DOC_REVERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRevertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRevertDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocRevertType {
    pub description: String,
}

impl PaperDocRevertType {
    pub fn new(description: String) -> Self {
        PaperDocRevertType {
            description,
        }
    }

}

const PAPER_DOC_REVERT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocRevertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocRevertType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocRevertType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocRevertType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocRevertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocRevertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocRevertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocRevertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocRevertType", PAPER_DOC_REVERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocRevertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocRevertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared Paper doc via Slack.
#[derive(Debug)]
pub struct PaperDocSlackShareDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocSlackShareDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocSlackShareDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_SLACK_SHARE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocSlackShareDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocSlackShareDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocSlackShareDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocSlackShareDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocSlackShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocSlackShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocSlackShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocSlackShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocSlackShareDetails", PAPER_DOC_SLACK_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocSlackShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocSlackShareDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocSlackShareType {
    pub description: String,
}

impl PaperDocSlackShareType {
    pub fn new(description: String) -> Self {
        PaperDocSlackShareType {
            description,
        }
    }

}

const PAPER_DOC_SLACK_SHARE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocSlackShareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocSlackShareType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocSlackShareType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocSlackShareType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocSlackShareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocSlackShareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocSlackShareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocSlackShareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocSlackShareType", PAPER_DOC_SLACK_SHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocSlackShareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocSlackShareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared Paper doc with users and/or groups.
#[derive(Debug)]
pub struct PaperDocTeamInviteDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocTeamInviteDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocTeamInviteDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_TEAM_INVITE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocTeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocTeamInviteDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocTeamInviteDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocTeamInviteDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocTeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocTeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocTeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocTeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocTeamInviteDetails", PAPER_DOC_TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocTeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocTeamInviteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocTeamInviteType {
    pub description: String,
}

impl PaperDocTeamInviteType {
    pub fn new(description: String) -> Self {
        PaperDocTeamInviteType {
            description,
        }
    }

}

const PAPER_DOC_TEAM_INVITE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocTeamInviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocTeamInviteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocTeamInviteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocTeamInviteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocTeamInviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocTeamInviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocTeamInviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocTeamInviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocTeamInviteType", PAPER_DOC_TEAM_INVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocTeamInviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocTeamInviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted Paper doc.
#[derive(Debug)]
pub struct PaperDocTrashedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocTrashedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocTrashedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_TRASHED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocTrashedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocTrashedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocTrashedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocTrashedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocTrashedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocTrashedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocTrashedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocTrashedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocTrashedDetails", PAPER_DOC_TRASHED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocTrashedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocTrashedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocTrashedType {
    pub description: String,
}

impl PaperDocTrashedType {
    pub fn new(description: String) -> Self {
        PaperDocTrashedType {
            description,
        }
    }

}

const PAPER_DOC_TRASHED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocTrashedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocTrashedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocTrashedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocTrashedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocTrashedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocTrashedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocTrashedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocTrashedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocTrashedType", PAPER_DOC_TRASHED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocTrashedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocTrashedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unresolved Paper doc comment.
#[derive(Debug)]
pub struct PaperDocUnresolveCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text. Might be missing due to historical data gap.
    pub comment_text: Option<String>,
}

impl PaperDocUnresolveCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocUnresolveCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const PAPER_DOC_UNRESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                              "comment_text"];
impl PaperDocUnresolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocUnresolveCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocUnresolveCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocUnresolveCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocUnresolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocUnresolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocUnresolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocUnresolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocUnresolveCommentDetails", PAPER_DOC_UNRESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocUnresolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocUnresolveCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocUnresolveCommentType {
    pub description: String,
}

impl PaperDocUnresolveCommentType {
    pub fn new(description: String) -> Self {
        PaperDocUnresolveCommentType {
            description,
        }
    }

}

const PAPER_DOC_UNRESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocUnresolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocUnresolveCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocUnresolveCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocUnresolveCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocUnresolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocUnresolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocUnresolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocUnresolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocUnresolveCommentType", PAPER_DOC_UNRESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocUnresolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocUnresolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored Paper doc.
#[derive(Debug)]
pub struct PaperDocUntrashedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocUntrashedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocUntrashedDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_UNTRASHED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocUntrashedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocUntrashedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocUntrashedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocUntrashedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocUntrashedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocUntrashedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocUntrashedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocUntrashedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocUntrashedDetails", PAPER_DOC_UNTRASHED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocUntrashedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocUntrashedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocUntrashedType {
    pub description: String,
}

impl PaperDocUntrashedType {
    pub fn new(description: String) -> Self {
        PaperDocUntrashedType {
            description,
        }
    }

}

const PAPER_DOC_UNTRASHED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocUntrashedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocUntrashedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocUntrashedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocUntrashedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocUntrashedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocUntrashedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocUntrashedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocUntrashedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocUntrashedType", PAPER_DOC_UNTRASHED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocUntrashedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocUntrashedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Viewed Paper doc.
#[derive(Debug)]
pub struct PaperDocViewDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperDocViewDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperDocViewDetails {
            event_uuid,
        }
    }

}

const PAPER_DOC_VIEW_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperDocViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocViewDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocViewDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocViewDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocViewDetails", PAPER_DOC_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocViewDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperDocViewType {
    pub description: String,
}

impl PaperDocViewType {
    pub fn new(description: String) -> Self {
        PaperDocViewType {
            description,
        }
    }

}

const PAPER_DOC_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl PaperDocViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocViewType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocViewType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocViewType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocViewType", PAPER_DOC_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper document's logged information.
#[derive(Debug)]
pub struct PaperDocumentLogInfo {
    /// Papers document Id.
    pub doc_id: String,
    /// Paper document title.
    pub doc_title: String,
}

impl PaperDocumentLogInfo {
    pub fn new(doc_id: String, doc_title: String) -> Self {
        PaperDocumentLogInfo {
            doc_id,
            doc_title,
        }
    }

}

const PAPER_DOCUMENT_LOG_INFO_FIELDS: &[&str] = &["doc_id",
                                                  "doc_title"];
impl PaperDocumentLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperDocumentLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperDocumentLogInfo>, V::Error> {
        let mut field_doc_id = None;
        let mut field_doc_title = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "doc_id" => {
                    if field_doc_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_id"));
                    }
                    field_doc_id = Some(map.next_value()?);
                }
                "doc_title" => {
                    if field_doc_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("doc_title"));
                    }
                    field_doc_title = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperDocumentLogInfo {
            doc_id: field_doc_id.ok_or_else(|| ::serde::de::Error::missing_field("doc_id"))?,
            doc_title: field_doc_title.ok_or_else(|| ::serde::de::Error::missing_field("doc_title"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("doc_id", &self.doc_id)?;
        s.serialize_field("doc_title", &self.doc_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDocumentLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperDocumentLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDocumentLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperDocumentLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperDocumentLogInfo", PAPER_DOCUMENT_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDocumentLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperDocumentLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PaperDownloadFormat {
    Docx,
    Html,
    Markdown,
    Pdf,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperDownloadFormat {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperDownloadFormat;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperDownloadFormat structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "docx" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDownloadFormat::Docx)
                    }
                    "html" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDownloadFormat::Html)
                    }
                    "markdown" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDownloadFormat::Markdown)
                    }
                    "pdf" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDownloadFormat::Pdf)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperDownloadFormat::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["docx",
                                    "html",
                                    "markdown",
                                    "pdf",
                                    "other"];
        deserializer.deserialize_struct("PaperDownloadFormat", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperDownloadFormat {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperDownloadFormat::Docx => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "docx")?;
                s.end()
            }
            PaperDownloadFormat::Html => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "html")?;
                s.end()
            }
            PaperDownloadFormat::Markdown => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "markdown")?;
                s.end()
            }
            PaperDownloadFormat::Pdf => {
                // unit
                let mut s = serializer.serialize_struct("PaperDownloadFormat", 1)?;
                s.serialize_field(".tag", "pdf")?;
                s.end()
            }
            PaperDownloadFormat::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added users to Paper-enabled users list.
#[derive(Debug)]
pub struct PaperEnabledUsersGroupAdditionDetails {
}

impl Default for PaperEnabledUsersGroupAdditionDetails {
    fn default() -> Self {
        PaperEnabledUsersGroupAdditionDetails {
        }
    }
}

const PAPER_ENABLED_USERS_GROUP_ADDITION_DETAILS_FIELDS: &[&str] = &[];
impl PaperEnabledUsersGroupAdditionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperEnabledUsersGroupAdditionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(PaperEnabledUsersGroupAdditionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupAdditionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupAdditionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupAdditionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupAdditionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupAdditionDetails", PAPER_ENABLED_USERS_GROUP_ADDITION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupAdditionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperEnabledUsersGroupAdditionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PaperEnabledUsersGroupAdditionType {
    pub description: String,
}

impl PaperEnabledUsersGroupAdditionType {
    pub fn new(description: String) -> Self {
        PaperEnabledUsersGroupAdditionType {
            description,
        }
    }

}

const PAPER_ENABLED_USERS_GROUP_ADDITION_TYPE_FIELDS: &[&str] = &["description"];
impl PaperEnabledUsersGroupAdditionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperEnabledUsersGroupAdditionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperEnabledUsersGroupAdditionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperEnabledUsersGroupAdditionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupAdditionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupAdditionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupAdditionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupAdditionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupAdditionType", PAPER_ENABLED_USERS_GROUP_ADDITION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupAdditionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperEnabledUsersGroupAdditionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed users from Paper-enabled users list.
#[derive(Debug)]
pub struct PaperEnabledUsersGroupRemovalDetails {
}

impl Default for PaperEnabledUsersGroupRemovalDetails {
    fn default() -> Self {
        PaperEnabledUsersGroupRemovalDetails {
        }
    }
}

const PAPER_ENABLED_USERS_GROUP_REMOVAL_DETAILS_FIELDS: &[&str] = &[];
impl PaperEnabledUsersGroupRemovalDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PaperEnabledUsersGroupRemovalDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(PaperEnabledUsersGroupRemovalDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupRemovalDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupRemovalDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupRemovalDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupRemovalDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupRemovalDetails", PAPER_ENABLED_USERS_GROUP_REMOVAL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupRemovalDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PaperEnabledUsersGroupRemovalDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PaperEnabledUsersGroupRemovalType {
    pub description: String,
}

impl PaperEnabledUsersGroupRemovalType {
    pub fn new(description: String) -> Self {
        PaperEnabledUsersGroupRemovalType {
            description,
        }
    }

}

const PAPER_ENABLED_USERS_GROUP_REMOVAL_TYPE_FIELDS: &[&str] = &["description"];
impl PaperEnabledUsersGroupRemovalType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperEnabledUsersGroupRemovalType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperEnabledUsersGroupRemovalType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperEnabledUsersGroupRemovalType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperEnabledUsersGroupRemovalType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperEnabledUsersGroupRemovalType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperEnabledUsersGroupRemovalType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperEnabledUsersGroupRemovalType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperEnabledUsersGroupRemovalType", PAPER_ENABLED_USERS_GROUP_REMOVAL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperEnabledUsersGroupRemovalType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperEnabledUsersGroupRemovalType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed Paper external sharing setting to anyone.
#[derive(Debug)]
pub struct PaperExternalViewAllowDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperExternalViewAllowDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperExternalViewAllowDetails {
            event_uuid,
        }
    }

}

const PAPER_EXTERNAL_VIEW_ALLOW_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperExternalViewAllowDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperExternalViewAllowDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperExternalViewAllowDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperExternalViewAllowDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewAllowDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewAllowDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewAllowDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewAllowDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewAllowDetails", PAPER_EXTERNAL_VIEW_ALLOW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewAllowDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewAllowDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperExternalViewAllowType {
    pub description: String,
}

impl PaperExternalViewAllowType {
    pub fn new(description: String) -> Self {
        PaperExternalViewAllowType {
            description,
        }
    }

}

const PAPER_EXTERNAL_VIEW_ALLOW_TYPE_FIELDS: &[&str] = &["description"];
impl PaperExternalViewAllowType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperExternalViewAllowType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperExternalViewAllowType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperExternalViewAllowType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewAllowType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewAllowType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewAllowType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewAllowType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewAllowType", PAPER_EXTERNAL_VIEW_ALLOW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewAllowType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewAllowType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed Paper external sharing setting to default team.
#[derive(Debug)]
pub struct PaperExternalViewDefaultTeamDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperExternalViewDefaultTeamDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperExternalViewDefaultTeamDetails {
            event_uuid,
        }
    }

}

const PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperExternalViewDefaultTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperExternalViewDefaultTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperExternalViewDefaultTeamDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperExternalViewDefaultTeamDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewDefaultTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewDefaultTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewDefaultTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewDefaultTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewDefaultTeamDetails", PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewDefaultTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewDefaultTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperExternalViewDefaultTeamType {
    pub description: String,
}

impl PaperExternalViewDefaultTeamType {
    pub fn new(description: String) -> Self {
        PaperExternalViewDefaultTeamType {
            description,
        }
    }

}

const PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl PaperExternalViewDefaultTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperExternalViewDefaultTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperExternalViewDefaultTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperExternalViewDefaultTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewDefaultTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewDefaultTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewDefaultTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewDefaultTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewDefaultTeamType", PAPER_EXTERNAL_VIEW_DEFAULT_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewDefaultTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewDefaultTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed Paper external sharing setting to team-only.
#[derive(Debug)]
pub struct PaperExternalViewForbidDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperExternalViewForbidDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperExternalViewForbidDetails {
            event_uuid,
        }
    }

}

const PAPER_EXTERNAL_VIEW_FORBID_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperExternalViewForbidDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperExternalViewForbidDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperExternalViewForbidDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperExternalViewForbidDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewForbidDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewForbidDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewForbidDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewForbidDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewForbidDetails", PAPER_EXTERNAL_VIEW_FORBID_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewForbidDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewForbidDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperExternalViewForbidType {
    pub description: String,
}

impl PaperExternalViewForbidType {
    pub fn new(description: String) -> Self {
        PaperExternalViewForbidType {
            description,
        }
    }

}

const PAPER_EXTERNAL_VIEW_FORBID_TYPE_FIELDS: &[&str] = &["description"];
impl PaperExternalViewForbidType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperExternalViewForbidType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperExternalViewForbidType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperExternalViewForbidType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperExternalViewForbidType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperExternalViewForbidType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperExternalViewForbidType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperExternalViewForbidType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperExternalViewForbidType", PAPER_EXTERNAL_VIEW_FORBID_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperExternalViewForbidType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperExternalViewForbidType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed/unfollowed Paper folder.
#[derive(Debug)]
pub struct PaperFolderChangeSubscriptionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// New folder subscription level.
    pub new_subscription_level: String,
    /// Previous folder subscription level. Might be missing due to historical data gap.
    pub previous_subscription_level: Option<String>,
}

impl PaperFolderChangeSubscriptionDetails {
    pub fn new(event_uuid: String, new_subscription_level: String) -> Self {
        PaperFolderChangeSubscriptionDetails {
            event_uuid,
            new_subscription_level,
            previous_subscription_level: None,
        }
    }

    pub fn with_previous_subscription_level(mut self, value: Option<String>) -> Self {
        self.previous_subscription_level = value;
        self
    }

}

const PAPER_FOLDER_CHANGE_SUBSCRIPTION_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                                   "new_subscription_level",
                                                                   "previous_subscription_level"];
impl PaperFolderChangeSubscriptionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperFolderChangeSubscriptionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperFolderChangeSubscriptionDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_new_subscription_level = None;
        let mut field_previous_subscription_level = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "new_subscription_level" => {
                    if field_new_subscription_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_subscription_level"));
                    }
                    field_new_subscription_level = Some(map.next_value()?);
                }
                "previous_subscription_level" => {
                    if field_previous_subscription_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_subscription_level"));
                    }
                    field_previous_subscription_level = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperFolderChangeSubscriptionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            new_subscription_level: field_new_subscription_level.ok_or_else(|| ::serde::de::Error::missing_field("new_subscription_level"))?,
            previous_subscription_level: field_previous_subscription_level,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("new_subscription_level", &self.new_subscription_level)?;
        s.serialize_field("previous_subscription_level", &self.previous_subscription_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderChangeSubscriptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderChangeSubscriptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperFolderChangeSubscriptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderChangeSubscriptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderChangeSubscriptionDetails", PAPER_FOLDER_CHANGE_SUBSCRIPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderChangeSubscriptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderChangeSubscriptionDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperFolderChangeSubscriptionType {
    pub description: String,
}

impl PaperFolderChangeSubscriptionType {
    pub fn new(description: String) -> Self {
        PaperFolderChangeSubscriptionType {
            description,
        }
    }

}

const PAPER_FOLDER_CHANGE_SUBSCRIPTION_TYPE_FIELDS: &[&str] = &["description"];
impl PaperFolderChangeSubscriptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperFolderChangeSubscriptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperFolderChangeSubscriptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperFolderChangeSubscriptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderChangeSubscriptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderChangeSubscriptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperFolderChangeSubscriptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderChangeSubscriptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderChangeSubscriptionType", PAPER_FOLDER_CHANGE_SUBSCRIPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderChangeSubscriptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderChangeSubscriptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Archived Paper folder.
#[derive(Debug)]
pub struct PaperFolderDeletedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperFolderDeletedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperFolderDeletedDetails {
            event_uuid,
        }
    }

}

const PAPER_FOLDER_DELETED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperFolderDeletedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperFolderDeletedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperFolderDeletedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperFolderDeletedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderDeletedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderDeletedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperFolderDeletedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderDeletedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderDeletedDetails", PAPER_FOLDER_DELETED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderDeletedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderDeletedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperFolderDeletedType {
    pub description: String,
}

impl PaperFolderDeletedType {
    pub fn new(description: String) -> Self {
        PaperFolderDeletedType {
            description,
        }
    }

}

const PAPER_FOLDER_DELETED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperFolderDeletedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperFolderDeletedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperFolderDeletedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperFolderDeletedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderDeletedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderDeletedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperFolderDeletedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderDeletedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderDeletedType", PAPER_FOLDER_DELETED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderDeletedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderDeletedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Followed Paper folder.
#[derive(Debug)]
pub struct PaperFolderFollowedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperFolderFollowedDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperFolderFollowedDetails {
            event_uuid,
        }
    }

}

const PAPER_FOLDER_FOLLOWED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperFolderFollowedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperFolderFollowedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperFolderFollowedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperFolderFollowedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderFollowedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderFollowedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperFolderFollowedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderFollowedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderFollowedDetails", PAPER_FOLDER_FOLLOWED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderFollowedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderFollowedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperFolderFollowedType {
    pub description: String,
}

impl PaperFolderFollowedType {
    pub fn new(description: String) -> Self {
        PaperFolderFollowedType {
            description,
        }
    }

}

const PAPER_FOLDER_FOLLOWED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperFolderFollowedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperFolderFollowedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperFolderFollowedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperFolderFollowedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderFollowedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderFollowedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperFolderFollowedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderFollowedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderFollowedType", PAPER_FOLDER_FOLLOWED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderFollowedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderFollowedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Paper folder's logged information.
#[derive(Debug)]
pub struct PaperFolderLogInfo {
    /// Papers folder Id.
    pub folder_id: String,
    /// Paper folder name.
    pub folder_name: String,
}

impl PaperFolderLogInfo {
    pub fn new(folder_id: String, folder_name: String) -> Self {
        PaperFolderLogInfo {
            folder_id,
            folder_name,
        }
    }

}

const PAPER_FOLDER_LOG_INFO_FIELDS: &[&str] = &["folder_id",
                                                "folder_name"];
impl PaperFolderLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperFolderLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperFolderLogInfo>, V::Error> {
        let mut field_folder_id = None;
        let mut field_folder_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "folder_id" => {
                    if field_folder_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("folder_id"));
                    }
                    field_folder_id = Some(map.next_value()?);
                }
                "folder_name" => {
                    if field_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("folder_name"));
                    }
                    field_folder_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperFolderLogInfo {
            folder_id: field_folder_id.ok_or_else(|| ::serde::de::Error::missing_field("folder_id"))?,
            folder_name: field_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("folder_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("folder_id", &self.folder_id)?;
        s.serialize_field("folder_name", &self.folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperFolderLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderLogInfo", PAPER_FOLDER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared Paper folder with users and/or groups.
#[derive(Debug)]
pub struct PaperFolderTeamInviteDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperFolderTeamInviteDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperFolderTeamInviteDetails {
            event_uuid,
        }
    }

}

const PAPER_FOLDER_TEAM_INVITE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperFolderTeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperFolderTeamInviteDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperFolderTeamInviteDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperFolderTeamInviteDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderTeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderTeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperFolderTeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderTeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderTeamInviteDetails", PAPER_FOLDER_TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderTeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderTeamInviteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperFolderTeamInviteType {
    pub description: String,
}

impl PaperFolderTeamInviteType {
    pub fn new(description: String) -> Self {
        PaperFolderTeamInviteType {
            description,
        }
    }

}

const PAPER_FOLDER_TEAM_INVITE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperFolderTeamInviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperFolderTeamInviteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperFolderTeamInviteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperFolderTeamInviteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperFolderTeamInviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperFolderTeamInviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperFolderTeamInviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperFolderTeamInviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperFolderTeamInviteType", PAPER_FOLDER_TEAM_INVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperFolderTeamInviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperFolderTeamInviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if team members can share Paper documents externally.
#[derive(Debug)]
pub enum PaperMemberPolicy {
    AnyoneWithLink,
    OnlyTeam,
    TeamAndExplicitlyShared,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PaperMemberPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PaperMemberPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperMemberPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "anyone_with_link" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperMemberPolicy::AnyoneWithLink)
                    }
                    "only_team" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperMemberPolicy::OnlyTeam)
                    }
                    "team_and_explicitly_shared" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperMemberPolicy::TeamAndExplicitlyShared)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PaperMemberPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["anyone_with_link",
                                    "only_team",
                                    "team_and_explicitly_shared",
                                    "other"];
        deserializer.deserialize_struct("PaperMemberPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PaperMemberPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PaperMemberPolicy::AnyoneWithLink => {
                // unit
                let mut s = serializer.serialize_struct("PaperMemberPolicy", 1)?;
                s.serialize_field(".tag", "anyone_with_link")?;
                s.end()
            }
            PaperMemberPolicy::OnlyTeam => {
                // unit
                let mut s = serializer.serialize_struct("PaperMemberPolicy", 1)?;
                s.serialize_field(".tag", "only_team")?;
                s.end()
            }
            PaperMemberPolicy::TeamAndExplicitlyShared => {
                // unit
                let mut s = serializer.serialize_struct("PaperMemberPolicy", 1)?;
                s.serialize_field(".tag", "team_and_explicitly_shared")?;
                s.end()
            }
            PaperMemberPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed permissions for published doc.
#[derive(Debug)]
pub struct PaperPublishedLinkChangePermissionDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// New permission level.
    pub new_permission_level: String,
    /// Previous permission level.
    pub previous_permission_level: String,
}

impl PaperPublishedLinkChangePermissionDetails {
    pub fn new(
        event_uuid: String,
        new_permission_level: String,
        previous_permission_level: String,
    ) -> Self {
        PaperPublishedLinkChangePermissionDetails {
            event_uuid,
            new_permission_level,
            previous_permission_level,
        }
    }

}

const PAPER_PUBLISHED_LINK_CHANGE_PERMISSION_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                                         "new_permission_level",
                                                                         "previous_permission_level"];
impl PaperPublishedLinkChangePermissionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperPublishedLinkChangePermissionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperPublishedLinkChangePermissionDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_new_permission_level = None;
        let mut field_previous_permission_level = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "new_permission_level" => {
                    if field_new_permission_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_permission_level"));
                    }
                    field_new_permission_level = Some(map.next_value()?);
                }
                "previous_permission_level" => {
                    if field_previous_permission_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_permission_level"));
                    }
                    field_previous_permission_level = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperPublishedLinkChangePermissionDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            new_permission_level: field_new_permission_level.ok_or_else(|| ::serde::de::Error::missing_field("new_permission_level"))?,
            previous_permission_level: field_previous_permission_level.ok_or_else(|| ::serde::de::Error::missing_field("previous_permission_level"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("new_permission_level", &self.new_permission_level)?;
        s.serialize_field("previous_permission_level", &self.previous_permission_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperPublishedLinkChangePermissionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperPublishedLinkChangePermissionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperPublishedLinkChangePermissionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperPublishedLinkChangePermissionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperPublishedLinkChangePermissionDetails", PAPER_PUBLISHED_LINK_CHANGE_PERMISSION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperPublishedLinkChangePermissionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperPublishedLinkChangePermissionDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperPublishedLinkChangePermissionType {
    pub description: String,
}

impl PaperPublishedLinkChangePermissionType {
    pub fn new(description: String) -> Self {
        PaperPublishedLinkChangePermissionType {
            description,
        }
    }

}

const PAPER_PUBLISHED_LINK_CHANGE_PERMISSION_TYPE_FIELDS: &[&str] = &["description"];
impl PaperPublishedLinkChangePermissionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperPublishedLinkChangePermissionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperPublishedLinkChangePermissionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperPublishedLinkChangePermissionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperPublishedLinkChangePermissionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperPublishedLinkChangePermissionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperPublishedLinkChangePermissionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperPublishedLinkChangePermissionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperPublishedLinkChangePermissionType", PAPER_PUBLISHED_LINK_CHANGE_PERMISSION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperPublishedLinkChangePermissionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperPublishedLinkChangePermissionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Published doc.
#[derive(Debug)]
pub struct PaperPublishedLinkCreateDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperPublishedLinkCreateDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperPublishedLinkCreateDetails {
            event_uuid,
        }
    }

}

const PAPER_PUBLISHED_LINK_CREATE_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperPublishedLinkCreateDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperPublishedLinkCreateDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperPublishedLinkCreateDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperPublishedLinkCreateDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperPublishedLinkCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperPublishedLinkCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperPublishedLinkCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperPublishedLinkCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperPublishedLinkCreateDetails", PAPER_PUBLISHED_LINK_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperPublishedLinkCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperPublishedLinkCreateDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperPublishedLinkCreateType {
    pub description: String,
}

impl PaperPublishedLinkCreateType {
    pub fn new(description: String) -> Self {
        PaperPublishedLinkCreateType {
            description,
        }
    }

}

const PAPER_PUBLISHED_LINK_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl PaperPublishedLinkCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperPublishedLinkCreateType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperPublishedLinkCreateType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperPublishedLinkCreateType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperPublishedLinkCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperPublishedLinkCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperPublishedLinkCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperPublishedLinkCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperPublishedLinkCreateType", PAPER_PUBLISHED_LINK_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperPublishedLinkCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperPublishedLinkCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unpublished doc.
#[derive(Debug)]
pub struct PaperPublishedLinkDisabledDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperPublishedLinkDisabledDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperPublishedLinkDisabledDetails {
            event_uuid,
        }
    }

}

const PAPER_PUBLISHED_LINK_DISABLED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperPublishedLinkDisabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperPublishedLinkDisabledDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperPublishedLinkDisabledDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperPublishedLinkDisabledDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperPublishedLinkDisabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperPublishedLinkDisabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperPublishedLinkDisabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperPublishedLinkDisabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperPublishedLinkDisabledDetails", PAPER_PUBLISHED_LINK_DISABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperPublishedLinkDisabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperPublishedLinkDisabledDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperPublishedLinkDisabledType {
    pub description: String,
}

impl PaperPublishedLinkDisabledType {
    pub fn new(description: String) -> Self {
        PaperPublishedLinkDisabledType {
            description,
        }
    }

}

const PAPER_PUBLISHED_LINK_DISABLED_TYPE_FIELDS: &[&str] = &["description"];
impl PaperPublishedLinkDisabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperPublishedLinkDisabledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperPublishedLinkDisabledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperPublishedLinkDisabledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperPublishedLinkDisabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperPublishedLinkDisabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperPublishedLinkDisabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperPublishedLinkDisabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperPublishedLinkDisabledType", PAPER_PUBLISHED_LINK_DISABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperPublishedLinkDisabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperPublishedLinkDisabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Viewed published doc.
#[derive(Debug)]
pub struct PaperPublishedLinkViewDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl PaperPublishedLinkViewDetails {
    pub fn new(event_uuid: String) -> Self {
        PaperPublishedLinkViewDetails {
            event_uuid,
        }
    }

}

const PAPER_PUBLISHED_LINK_VIEW_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl PaperPublishedLinkViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperPublishedLinkViewDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperPublishedLinkViewDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperPublishedLinkViewDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperPublishedLinkViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperPublishedLinkViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperPublishedLinkViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperPublishedLinkViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperPublishedLinkViewDetails", PAPER_PUBLISHED_LINK_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperPublishedLinkViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperPublishedLinkViewDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PaperPublishedLinkViewType {
    pub description: String,
}

impl PaperPublishedLinkViewType {
    pub fn new(description: String) -> Self {
        PaperPublishedLinkViewType {
            description,
        }
    }

}

const PAPER_PUBLISHED_LINK_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl PaperPublishedLinkViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PaperPublishedLinkViewType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PaperPublishedLinkViewType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PaperPublishedLinkViewType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PaperPublishedLinkViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PaperPublishedLinkViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PaperPublishedLinkViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PaperPublishedLinkViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PaperPublishedLinkViewType", PAPER_PUBLISHED_LINK_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PaperPublishedLinkViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PaperPublishedLinkViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// A user or group
#[derive(Debug)]
pub enum ParticipantLogInfo {
    /// A user with a Dropbox account.
    User(UserLogInfo),
    /// Group details.
    Group(GroupLogInfo),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ParticipantLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ParticipantLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ParticipantLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user" => {
                        match map.next_key()? {
                            Some("user") => Ok(ParticipantLogInfo::User(map.next_value()?)),
                            None => Err(de::Error::missing_field("user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "group" => Ok(ParticipantLogInfo::Group(GroupLogInfo::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ParticipantLogInfo::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["user",
                                    "group",
                                    "other"];
        deserializer.deserialize_struct("ParticipantLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ParticipantLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ParticipantLogInfo::User(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("ParticipantLogInfo", 2)?;
                s.serialize_field(".tag", "user")?;
                s.serialize_field("user", x)?;
                s.end()
            }
            ParticipantLogInfo::Group(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("ParticipantLogInfo", 4)?;
                s.serialize_field(".tag", "group")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            ParticipantLogInfo::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum PassPolicy {
    Enabled,
    Allow,
    Disabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PassPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PassPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PassPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PassPolicy::Enabled)
                    }
                    "allow" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PassPolicy::Allow)
                    }
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PassPolicy::Disabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PassPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["enabled",
                                    "allow",
                                    "disabled",
                                    "other"];
        deserializer.deserialize_struct("PassPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PassPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PassPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("PassPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            PassPolicy::Allow => {
                // unit
                let mut s = serializer.serialize_struct("PassPolicy", 1)?;
                s.serialize_field(".tag", "allow")?;
                s.end()
            }
            PassPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("PassPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            PassPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed password.
#[derive(Debug)]
pub struct PasswordChangeDetails {
}

impl Default for PasswordChangeDetails {
    fn default() -> Self {
        PasswordChangeDetails {
        }
    }
}

const PASSWORD_CHANGE_DETAILS_FIELDS: &[&str] = &[];
impl PasswordChangeDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PasswordChangeDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(PasswordChangeDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordChangeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordChangeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PasswordChangeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordChangeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordChangeDetails", PASSWORD_CHANGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordChangeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordChangeDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PasswordChangeType {
    pub description: String,
}

impl PasswordChangeType {
    pub fn new(description: String) -> Self {
        PasswordChangeType {
            description,
        }
    }

}

const PASSWORD_CHANGE_TYPE_FIELDS: &[&str] = &["description"];
impl PasswordChangeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PasswordChangeType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PasswordChangeType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PasswordChangeType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordChangeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordChangeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PasswordChangeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordChangeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordChangeType", PASSWORD_CHANGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordChangeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PasswordChangeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reset all team member passwords.
#[derive(Debug)]
pub struct PasswordResetAllDetails {
}

impl Default for PasswordResetAllDetails {
    fn default() -> Self {
        PasswordResetAllDetails {
        }
    }
}

const PASSWORD_RESET_ALL_DETAILS_FIELDS: &[&str] = &[];
impl PasswordResetAllDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PasswordResetAllDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(PasswordResetAllDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetAllDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetAllDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PasswordResetAllDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetAllDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetAllDetails", PASSWORD_RESET_ALL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetAllDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordResetAllDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PasswordResetAllType {
    pub description: String,
}

impl PasswordResetAllType {
    pub fn new(description: String) -> Self {
        PasswordResetAllType {
            description,
        }
    }

}

const PASSWORD_RESET_ALL_TYPE_FIELDS: &[&str] = &["description"];
impl PasswordResetAllType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PasswordResetAllType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PasswordResetAllType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PasswordResetAllType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetAllType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetAllType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PasswordResetAllType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetAllType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetAllType", PASSWORD_RESET_ALL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetAllType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PasswordResetAllType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reset password.
#[derive(Debug)]
pub struct PasswordResetDetails {
}

impl Default for PasswordResetDetails {
    fn default() -> Self {
        PasswordResetDetails {
        }
    }
}

const PASSWORD_RESET_DETAILS_FIELDS: &[&str] = &[];
impl PasswordResetDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<PasswordResetDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(PasswordResetDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PasswordResetDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetDetails", PASSWORD_RESET_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("PasswordResetDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct PasswordResetType {
    pub description: String,
}

impl PasswordResetType {
    pub fn new(description: String) -> Self {
        PasswordResetType {
            description,
        }
    }

}

const PASSWORD_RESET_TYPE_FIELDS: &[&str] = &["description"];
impl PasswordResetType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PasswordResetType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PasswordResetType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PasswordResetType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordResetType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordResetType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PasswordResetType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordResetType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordResetType", PASSWORD_RESET_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordResetType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PasswordResetType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team password strength requirements.
#[derive(Debug)]
pub struct PasswordStrengthRequirementsChangePolicyDetails {
    /// Old password strength policy.
    pub previous_value: super::team_policies::PasswordStrengthPolicy,
    /// New password strength policy.
    pub new_value: super::team_policies::PasswordStrengthPolicy,
}

impl PasswordStrengthRequirementsChangePolicyDetails {
    pub fn new(
        previous_value: super::team_policies::PasswordStrengthPolicy,
        new_value: super::team_policies::PasswordStrengthPolicy,
    ) -> Self {
        PasswordStrengthRequirementsChangePolicyDetails {
            previous_value,
            new_value,
        }
    }

}

const PASSWORD_STRENGTH_REQUIREMENTS_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                               "new_value"];
impl PasswordStrengthRequirementsChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PasswordStrengthRequirementsChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PasswordStrengthRequirementsChangePolicyDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PasswordStrengthRequirementsChangePolicyDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordStrengthRequirementsChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordStrengthRequirementsChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PasswordStrengthRequirementsChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordStrengthRequirementsChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordStrengthRequirementsChangePolicyDetails", PASSWORD_STRENGTH_REQUIREMENTS_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordStrengthRequirementsChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PasswordStrengthRequirementsChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PasswordStrengthRequirementsChangePolicyType {
    pub description: String,
}

impl PasswordStrengthRequirementsChangePolicyType {
    pub fn new(description: String) -> Self {
        PasswordStrengthRequirementsChangePolicyType {
            description,
        }
    }

}

const PASSWORD_STRENGTH_REQUIREMENTS_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PasswordStrengthRequirementsChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PasswordStrengthRequirementsChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PasswordStrengthRequirementsChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PasswordStrengthRequirementsChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PasswordStrengthRequirementsChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PasswordStrengthRequirementsChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PasswordStrengthRequirementsChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PasswordStrengthRequirementsChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PasswordStrengthRequirementsChangePolicyType", PASSWORD_STRENGTH_REQUIREMENTS_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PasswordStrengthRequirementsChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PasswordStrengthRequirementsChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Path's details.
#[derive(Debug)]
pub struct PathLogInfo {
    /// Path relative to the namespace containing the content.
    pub namespace_relative: NamespaceRelativePathLogInfo,
    /// Fully qualified path relative to event's context. Might be missing due to historical data
    /// gap.
    pub contextual: Option<FilePath>,
}

impl PathLogInfo {
    pub fn new(namespace_relative: NamespaceRelativePathLogInfo) -> Self {
        PathLogInfo {
            namespace_relative,
            contextual: None,
        }
    }

    pub fn with_contextual(mut self, value: Option<FilePath>) -> Self {
        self.contextual = value;
        self
    }

}

const PATH_LOG_INFO_FIELDS: &[&str] = &["namespace_relative",
                                        "contextual"];
impl PathLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PathLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PathLogInfo>, V::Error> {
        let mut field_namespace_relative = None;
        let mut field_contextual = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "namespace_relative" => {
                    if field_namespace_relative.is_some() {
                        return Err(::serde::de::Error::duplicate_field("namespace_relative"));
                    }
                    field_namespace_relative = Some(map.next_value()?);
                }
                "contextual" => {
                    if field_contextual.is_some() {
                        return Err(::serde::de::Error::duplicate_field("contextual"));
                    }
                    field_contextual = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PathLogInfo {
            namespace_relative: field_namespace_relative.ok_or_else(|| ::serde::de::Error::missing_field("namespace_relative"))?,
            contextual: field_contextual,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("namespace_relative", &self.namespace_relative)?;
        s.serialize_field("contextual", &self.contextual)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PathLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PathLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PathLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PathLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PathLogInfo", PATH_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PathLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PathLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added pending secondary email.
#[derive(Debug)]
pub struct PendingSecondaryEmailAddedDetails {
    /// New pending secondary email.
    pub secondary_email: EmailAddress,
}

impl PendingSecondaryEmailAddedDetails {
    pub fn new(secondary_email: EmailAddress) -> Self {
        PendingSecondaryEmailAddedDetails {
            secondary_email,
        }
    }

}

const PENDING_SECONDARY_EMAIL_ADDED_DETAILS_FIELDS: &[&str] = &["secondary_email"];
impl PendingSecondaryEmailAddedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PendingSecondaryEmailAddedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PendingSecondaryEmailAddedDetails>, V::Error> {
        let mut field_secondary_email = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_email" => {
                    if field_secondary_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_email"));
                    }
                    field_secondary_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PendingSecondaryEmailAddedDetails {
            secondary_email: field_secondary_email.ok_or_else(|| ::serde::de::Error::missing_field("secondary_email"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_email", &self.secondary_email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PendingSecondaryEmailAddedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PendingSecondaryEmailAddedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PendingSecondaryEmailAddedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PendingSecondaryEmailAddedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PendingSecondaryEmailAddedDetails", PENDING_SECONDARY_EMAIL_ADDED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PendingSecondaryEmailAddedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PendingSecondaryEmailAddedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PendingSecondaryEmailAddedType {
    pub description: String,
}

impl PendingSecondaryEmailAddedType {
    pub fn new(description: String) -> Self {
        PendingSecondaryEmailAddedType {
            description,
        }
    }

}

const PENDING_SECONDARY_EMAIL_ADDED_TYPE_FIELDS: &[&str] = &["description"];
impl PendingSecondaryEmailAddedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PendingSecondaryEmailAddedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PendingSecondaryEmailAddedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PendingSecondaryEmailAddedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PendingSecondaryEmailAddedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PendingSecondaryEmailAddedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PendingSecondaryEmailAddedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PendingSecondaryEmailAddedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PendingSecondaryEmailAddedType", PENDING_SECONDARY_EMAIL_ADDED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PendingSecondaryEmailAddedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PendingSecondaryEmailAddedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled ability of team members to permanently delete content.
#[derive(Debug)]
pub struct PermanentDeleteChangePolicyDetails {
    /// New permanent delete content policy.
    pub new_value: ContentPermanentDeletePolicy,
    /// Previous permanent delete content policy. Might be missing due to historical data gap.
    pub previous_value: Option<ContentPermanentDeletePolicy>,
}

impl PermanentDeleteChangePolicyDetails {
    pub fn new(new_value: ContentPermanentDeletePolicy) -> Self {
        PermanentDeleteChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<ContentPermanentDeletePolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const PERMANENT_DELETE_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                 "previous_value"];
impl PermanentDeleteChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PermanentDeleteChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PermanentDeleteChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PermanentDeleteChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PermanentDeleteChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PermanentDeleteChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PermanentDeleteChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PermanentDeleteChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PermanentDeleteChangePolicyDetails", PERMANENT_DELETE_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PermanentDeleteChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PermanentDeleteChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct PermanentDeleteChangePolicyType {
    pub description: String,
}

impl PermanentDeleteChangePolicyType {
    pub fn new(description: String) -> Self {
        PermanentDeleteChangePolicyType {
            description,
        }
    }

}

const PERMANENT_DELETE_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl PermanentDeleteChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PermanentDeleteChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PermanentDeleteChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PermanentDeleteChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PermanentDeleteChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PermanentDeleteChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PermanentDeleteChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PermanentDeleteChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PermanentDeleteChangePolicyType", PERMANENT_DELETE_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PermanentDeleteChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PermanentDeleteChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum PlacementRestriction {
    AustraliaOnly,
    EuropeOnly,
    JapanOnly,
    None,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PlacementRestriction {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PlacementRestriction;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PlacementRestriction structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "australia_only" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PlacementRestriction::AustraliaOnly)
                    }
                    "europe_only" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PlacementRestriction::EuropeOnly)
                    }
                    "japan_only" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PlacementRestriction::JapanOnly)
                    }
                    "none" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PlacementRestriction::None)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(PlacementRestriction::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["australia_only",
                                    "europe_only",
                                    "japan_only",
                                    "none",
                                    "other"];
        deserializer.deserialize_struct("PlacementRestriction", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PlacementRestriction {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PlacementRestriction::AustraliaOnly => {
                // unit
                let mut s = serializer.serialize_struct("PlacementRestriction", 1)?;
                s.serialize_field(".tag", "australia_only")?;
                s.end()
            }
            PlacementRestriction::EuropeOnly => {
                // unit
                let mut s = serializer.serialize_struct("PlacementRestriction", 1)?;
                s.serialize_field(".tag", "europe_only")?;
                s.end()
            }
            PlacementRestriction::JapanOnly => {
                // unit
                let mut s = serializer.serialize_struct("PlacementRestriction", 1)?;
                s.serialize_field(".tag", "japan_only")?;
                s.end()
            }
            PlacementRestriction::None => {
                // unit
                let mut s = serializer.serialize_struct("PlacementRestriction", 1)?;
                s.serialize_field(".tag", "none")?;
                s.end()
            }
            PlacementRestriction::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Team merge request acceptance details shown to the primary team
#[derive(Debug)]
pub struct PrimaryTeamRequestAcceptedDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl PrimaryTeamRequestAcceptedDetails {
    pub fn new(secondary_team: String, sent_by: String) -> Self {
        PrimaryTeamRequestAcceptedDetails {
            secondary_team,
            sent_by,
        }
    }

}

const PRIMARY_TEAM_REQUEST_ACCEPTED_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                                "sent_by"];
impl PrimaryTeamRequestAcceptedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PrimaryTeamRequestAcceptedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PrimaryTeamRequestAcceptedDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PrimaryTeamRequestAcceptedDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PrimaryTeamRequestAcceptedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PrimaryTeamRequestAcceptedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PrimaryTeamRequestAcceptedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PrimaryTeamRequestAcceptedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PrimaryTeamRequestAcceptedDetails", PRIMARY_TEAM_REQUEST_ACCEPTED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PrimaryTeamRequestAcceptedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PrimaryTeamRequestAcceptedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request cancellation details shown to the primary team
#[derive(Debug)]
pub struct PrimaryTeamRequestCanceledDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl PrimaryTeamRequestCanceledDetails {
    pub fn new(secondary_team: String, sent_by: String) -> Self {
        PrimaryTeamRequestCanceledDetails {
            secondary_team,
            sent_by,
        }
    }

}

const PRIMARY_TEAM_REQUEST_CANCELED_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                                "sent_by"];
impl PrimaryTeamRequestCanceledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PrimaryTeamRequestCanceledDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PrimaryTeamRequestCanceledDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PrimaryTeamRequestCanceledDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PrimaryTeamRequestCanceledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PrimaryTeamRequestCanceledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PrimaryTeamRequestCanceledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PrimaryTeamRequestCanceledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PrimaryTeamRequestCanceledDetails", PRIMARY_TEAM_REQUEST_CANCELED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PrimaryTeamRequestCanceledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PrimaryTeamRequestCanceledDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request expiration details shown to the primary team
#[derive(Debug)]
pub struct PrimaryTeamRequestExpiredDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl PrimaryTeamRequestExpiredDetails {
    pub fn new(secondary_team: String, sent_by: String) -> Self {
        PrimaryTeamRequestExpiredDetails {
            secondary_team,
            sent_by,
        }
    }

}

const PRIMARY_TEAM_REQUEST_EXPIRED_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                               "sent_by"];
impl PrimaryTeamRequestExpiredDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PrimaryTeamRequestExpiredDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PrimaryTeamRequestExpiredDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PrimaryTeamRequestExpiredDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PrimaryTeamRequestExpiredDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PrimaryTeamRequestExpiredDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PrimaryTeamRequestExpiredDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PrimaryTeamRequestExpiredDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PrimaryTeamRequestExpiredDetails", PRIMARY_TEAM_REQUEST_EXPIRED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PrimaryTeamRequestExpiredDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PrimaryTeamRequestExpiredDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request reminder details shown to the primary team
#[derive(Debug)]
pub struct PrimaryTeamRequestReminderDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the primary team admin the request was sent to.
    pub sent_to: String,
}

impl PrimaryTeamRequestReminderDetails {
    pub fn new(secondary_team: String, sent_to: String) -> Self {
        PrimaryTeamRequestReminderDetails {
            secondary_team,
            sent_to,
        }
    }

}

const PRIMARY_TEAM_REQUEST_REMINDER_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                                "sent_to"];
impl PrimaryTeamRequestReminderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<PrimaryTeamRequestReminderDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<PrimaryTeamRequestReminderDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_to = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = PrimaryTeamRequestReminderDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_to", &self.sent_to)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for PrimaryTeamRequestReminderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = PrimaryTeamRequestReminderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PrimaryTeamRequestReminderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                PrimaryTeamRequestReminderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("PrimaryTeamRequestReminderDetails", PRIMARY_TEAM_REQUEST_REMINDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for PrimaryTeamRequestReminderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("PrimaryTeamRequestReminderDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Quick action type.
#[derive(Debug)]
pub enum QuickActionType {
    DeleteSharedLink,
    ResetPassword,
    RestoreFileOrFolder,
    UnlinkApp,
    UnlinkDevice,
    UnlinkSession,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for QuickActionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = QuickActionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a QuickActionType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "delete_shared_link" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(QuickActionType::DeleteSharedLink)
                    }
                    "reset_password" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(QuickActionType::ResetPassword)
                    }
                    "restore_file_or_folder" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(QuickActionType::RestoreFileOrFolder)
                    }
                    "unlink_app" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(QuickActionType::UnlinkApp)
                    }
                    "unlink_device" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(QuickActionType::UnlinkDevice)
                    }
                    "unlink_session" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(QuickActionType::UnlinkSession)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(QuickActionType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["delete_shared_link",
                                    "reset_password",
                                    "restore_file_or_folder",
                                    "unlink_app",
                                    "unlink_device",
                                    "unlink_session",
                                    "other"];
        deserializer.deserialize_struct("QuickActionType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for QuickActionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            QuickActionType::DeleteSharedLink => {
                // unit
                let mut s = serializer.serialize_struct("QuickActionType", 1)?;
                s.serialize_field(".tag", "delete_shared_link")?;
                s.end()
            }
            QuickActionType::ResetPassword => {
                // unit
                let mut s = serializer.serialize_struct("QuickActionType", 1)?;
                s.serialize_field(".tag", "reset_password")?;
                s.end()
            }
            QuickActionType::RestoreFileOrFolder => {
                // unit
                let mut s = serializer.serialize_struct("QuickActionType", 1)?;
                s.serialize_field(".tag", "restore_file_or_folder")?;
                s.end()
            }
            QuickActionType::UnlinkApp => {
                // unit
                let mut s = serializer.serialize_struct("QuickActionType", 1)?;
                s.serialize_field(".tag", "unlink_app")?;
                s.end()
            }
            QuickActionType::UnlinkDevice => {
                // unit
                let mut s = serializer.serialize_struct("QuickActionType", 1)?;
                s.serialize_field(".tag", "unlink_device")?;
                s.end()
            }
            QuickActionType::UnlinkSession => {
                // unit
                let mut s = serializer.serialize_struct("QuickActionType", 1)?;
                s.serialize_field(".tag", "unlink_session")?;
                s.end()
            }
            QuickActionType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Provides the indices of the source asset and the destination asset for a relocate action.
#[derive(Debug)]
pub struct RelocateAssetReferencesLogInfo {
    /// Source asset position in the Assets list.
    pub src_asset_index: u64,
    /// Destination asset position in the Assets list.
    pub dest_asset_index: u64,
}

impl RelocateAssetReferencesLogInfo {
    pub fn new(src_asset_index: u64, dest_asset_index: u64) -> Self {
        RelocateAssetReferencesLogInfo {
            src_asset_index,
            dest_asset_index,
        }
    }

}

const RELOCATE_ASSET_REFERENCES_LOG_INFO_FIELDS: &[&str] = &["src_asset_index",
                                                             "dest_asset_index"];
impl RelocateAssetReferencesLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RelocateAssetReferencesLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RelocateAssetReferencesLogInfo>, V::Error> {
        let mut field_src_asset_index = None;
        let mut field_dest_asset_index = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "src_asset_index" => {
                    if field_src_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("src_asset_index"));
                    }
                    field_src_asset_index = Some(map.next_value()?);
                }
                "dest_asset_index" => {
                    if field_dest_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("dest_asset_index"));
                    }
                    field_dest_asset_index = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RelocateAssetReferencesLogInfo {
            src_asset_index: field_src_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("src_asset_index"))?,
            dest_asset_index: field_dest_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("dest_asset_index"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("src_asset_index", &self.src_asset_index)?;
        s.serialize_field("dest_asset_index", &self.dest_asset_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RelocateAssetReferencesLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RelocateAssetReferencesLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RelocateAssetReferencesLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RelocateAssetReferencesLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RelocateAssetReferencesLogInfo", RELOCATE_ASSET_REFERENCES_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RelocateAssetReferencesLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RelocateAssetReferencesLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reseller information.
#[derive(Debug)]
pub struct ResellerLogInfo {
    /// Reseller name.
    pub reseller_name: String,
    /// Reseller email.
    pub reseller_email: EmailAddress,
}

impl ResellerLogInfo {
    pub fn new(reseller_name: String, reseller_email: EmailAddress) -> Self {
        ResellerLogInfo {
            reseller_name,
            reseller_email,
        }
    }

}

const RESELLER_LOG_INFO_FIELDS: &[&str] = &["reseller_name",
                                            "reseller_email"];
impl ResellerLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ResellerLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ResellerLogInfo>, V::Error> {
        let mut field_reseller_name = None;
        let mut field_reseller_email = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "reseller_name" => {
                    if field_reseller_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("reseller_name"));
                    }
                    field_reseller_name = Some(map.next_value()?);
                }
                "reseller_email" => {
                    if field_reseller_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("reseller_email"));
                    }
                    field_reseller_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ResellerLogInfo {
            reseller_name: field_reseller_name.ok_or_else(|| ::serde::de::Error::missing_field("reseller_name"))?,
            reseller_email: field_reseller_email.ok_or_else(|| ::serde::de::Error::missing_field("reseller_email"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("reseller_name", &self.reseller_name)?;
        s.serialize_field("reseller_email", &self.reseller_email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ResellerLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerLogInfo", RESELLER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ResellerLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled reseller support.
#[derive(Debug)]
pub struct ResellerSupportChangePolicyDetails {
    /// New Reseller support policy.
    pub new_value: ResellerSupportPolicy,
    /// Previous Reseller support policy.
    pub previous_value: ResellerSupportPolicy,
}

impl ResellerSupportChangePolicyDetails {
    pub fn new(new_value: ResellerSupportPolicy, previous_value: ResellerSupportPolicy) -> Self {
        ResellerSupportChangePolicyDetails {
            new_value,
            previous_value,
        }
    }

}

const RESELLER_SUPPORT_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                 "previous_value"];
impl ResellerSupportChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ResellerSupportChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ResellerSupportChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ResellerSupportChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportChangePolicyDetails", RESELLER_SUPPORT_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ResellerSupportChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ResellerSupportChangePolicyType {
    pub description: String,
}

impl ResellerSupportChangePolicyType {
    pub fn new(description: String) -> Self {
        ResellerSupportChangePolicyType {
            description,
        }
    }

}

const RESELLER_SUPPORT_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl ResellerSupportChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ResellerSupportChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ResellerSupportChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ResellerSupportChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportChangePolicyType", RESELLER_SUPPORT_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ResellerSupportChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if reseller can access the admin console as administrator
#[derive(Debug)]
pub enum ResellerSupportPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ResellerSupportPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ResellerSupportPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ResellerSupportPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ResellerSupportPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("ResellerSupportPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ResellerSupportPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("ResellerSupportPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            ResellerSupportPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("ResellerSupportPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            ResellerSupportPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Ended reseller support session.
#[derive(Debug)]
pub struct ResellerSupportSessionEndDetails {
}

impl Default for ResellerSupportSessionEndDetails {
    fn default() -> Self {
        ResellerSupportSessionEndDetails {
        }
    }
}

const RESELLER_SUPPORT_SESSION_END_DETAILS_FIELDS: &[&str] = &[];
impl ResellerSupportSessionEndDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ResellerSupportSessionEndDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(ResellerSupportSessionEndDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionEndDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionEndDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionEndDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionEndDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionEndDetails", RESELLER_SUPPORT_SESSION_END_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionEndDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ResellerSupportSessionEndDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct ResellerSupportSessionEndType {
    pub description: String,
}

impl ResellerSupportSessionEndType {
    pub fn new(description: String) -> Self {
        ResellerSupportSessionEndType {
            description,
        }
    }

}

const RESELLER_SUPPORT_SESSION_END_TYPE_FIELDS: &[&str] = &["description"];
impl ResellerSupportSessionEndType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ResellerSupportSessionEndType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ResellerSupportSessionEndType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ResellerSupportSessionEndType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionEndType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionEndType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionEndType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionEndType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionEndType", RESELLER_SUPPORT_SESSION_END_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionEndType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ResellerSupportSessionEndType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Started reseller support session.
#[derive(Debug)]
pub struct ResellerSupportSessionStartDetails {
}

impl Default for ResellerSupportSessionStartDetails {
    fn default() -> Self {
        ResellerSupportSessionStartDetails {
        }
    }
}

const RESELLER_SUPPORT_SESSION_START_DETAILS_FIELDS: &[&str] = &[];
impl ResellerSupportSessionStartDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ResellerSupportSessionStartDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(ResellerSupportSessionStartDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionStartDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionStartDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionStartDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionStartDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionStartDetails", RESELLER_SUPPORT_SESSION_START_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionStartDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ResellerSupportSessionStartDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct ResellerSupportSessionStartType {
    pub description: String,
}

impl ResellerSupportSessionStartType {
    pub fn new(description: String) -> Self {
        ResellerSupportSessionStartType {
            description,
        }
    }

}

const RESELLER_SUPPORT_SESSION_START_TYPE_FIELDS: &[&str] = &["description"];
impl ResellerSupportSessionStartType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ResellerSupportSessionStartType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ResellerSupportSessionStartType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ResellerSupportSessionStartType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ResellerSupportSessionStartType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ResellerSupportSessionStartType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ResellerSupportSessionStartType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ResellerSupportSessionStartType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ResellerSupportSessionStartType", RESELLER_SUPPORT_SESSION_START_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ResellerSupportSessionStartType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ResellerSupportSessionStartType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Rewound a folder.
#[derive(Debug)]
pub struct RewindFolderDetails {
    /// Folder was Rewound to this date.
    pub rewind_folder_target_ts_ms: super::common::DropboxTimestamp,
}

impl RewindFolderDetails {
    pub fn new(rewind_folder_target_ts_ms: super::common::DropboxTimestamp) -> Self {
        RewindFolderDetails {
            rewind_folder_target_ts_ms,
        }
    }

}

const REWIND_FOLDER_DETAILS_FIELDS: &[&str] = &["rewind_folder_target_ts_ms"];
impl RewindFolderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RewindFolderDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RewindFolderDetails>, V::Error> {
        let mut field_rewind_folder_target_ts_ms = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "rewind_folder_target_ts_ms" => {
                    if field_rewind_folder_target_ts_ms.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rewind_folder_target_ts_ms"));
                    }
                    field_rewind_folder_target_ts_ms = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RewindFolderDetails {
            rewind_folder_target_ts_ms: field_rewind_folder_target_ts_ms.ok_or_else(|| ::serde::de::Error::missing_field("rewind_folder_target_ts_ms"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("rewind_folder_target_ts_ms", &self.rewind_folder_target_ts_ms)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RewindFolderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RewindFolderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RewindFolderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RewindFolderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RewindFolderDetails", REWIND_FOLDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RewindFolderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RewindFolderDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct RewindFolderType {
    pub description: String,
}

impl RewindFolderType {
    pub fn new(description: String) -> Self {
        RewindFolderType {
            description,
        }
    }

}

const REWIND_FOLDER_TYPE_FIELDS: &[&str] = &["description"];
impl RewindFolderType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RewindFolderType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RewindFolderType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RewindFolderType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RewindFolderType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RewindFolderType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RewindFolderType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RewindFolderType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RewindFolderType", REWIND_FOLDER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RewindFolderType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RewindFolderType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling whether team members can rewind
#[derive(Debug)]
pub enum RewindPolicy {
    AdminsOnly,
    Everyone,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RewindPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RewindPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RewindPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "admins_only" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(RewindPolicy::AdminsOnly)
                    }
                    "everyone" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(RewindPolicy::Everyone)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(RewindPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["admins_only",
                                    "everyone",
                                    "other"];
        deserializer.deserialize_struct("RewindPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RewindPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RewindPolicy::AdminsOnly => {
                // unit
                let mut s = serializer.serialize_struct("RewindPolicy", 1)?;
                s.serialize_field(".tag", "admins_only")?;
                s.end()
            }
            RewindPolicy::Everyone => {
                // unit
                let mut s = serializer.serialize_struct("RewindPolicy", 1)?;
                s.serialize_field(".tag", "everyone")?;
                s.end()
            }
            RewindPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed Rewind policy for team.
#[derive(Debug)]
pub struct RewindPolicyChangedDetails {
    /// New Dropbox Rewind policy.
    pub new_value: RewindPolicy,
    /// Previous Dropbox Rewind policy.
    pub previous_value: RewindPolicy,
}

impl RewindPolicyChangedDetails {
    pub fn new(new_value: RewindPolicy, previous_value: RewindPolicy) -> Self {
        RewindPolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const REWIND_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                        "previous_value"];
impl RewindPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RewindPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RewindPolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RewindPolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RewindPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RewindPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RewindPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RewindPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RewindPolicyChangedDetails", REWIND_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RewindPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RewindPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct RewindPolicyChangedType {
    pub description: String,
}

impl RewindPolicyChangedType {
    pub fn new(description: String) -> Self {
        RewindPolicyChangedType {
            description,
        }
    }

}

const REWIND_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl RewindPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RewindPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RewindPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RewindPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RewindPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RewindPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RewindPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RewindPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RewindPolicyChangedType", REWIND_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RewindPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RewindPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted secondary email.
#[derive(Debug)]
pub struct SecondaryEmailDeletedDetails {
    /// Deleted secondary email.
    pub secondary_email: EmailAddress,
}

impl SecondaryEmailDeletedDetails {
    pub fn new(secondary_email: EmailAddress) -> Self {
        SecondaryEmailDeletedDetails {
            secondary_email,
        }
    }

}

const SECONDARY_EMAIL_DELETED_DETAILS_FIELDS: &[&str] = &["secondary_email"];
impl SecondaryEmailDeletedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryEmailDeletedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryEmailDeletedDetails>, V::Error> {
        let mut field_secondary_email = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_email" => {
                    if field_secondary_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_email"));
                    }
                    field_secondary_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryEmailDeletedDetails {
            secondary_email: field_secondary_email.ok_or_else(|| ::serde::de::Error::missing_field("secondary_email"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_email", &self.secondary_email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryEmailDeletedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryEmailDeletedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryEmailDeletedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryEmailDeletedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryEmailDeletedDetails", SECONDARY_EMAIL_DELETED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryEmailDeletedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryEmailDeletedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SecondaryEmailDeletedType {
    pub description: String,
}

impl SecondaryEmailDeletedType {
    pub fn new(description: String) -> Self {
        SecondaryEmailDeletedType {
            description,
        }
    }

}

const SECONDARY_EMAIL_DELETED_TYPE_FIELDS: &[&str] = &["description"];
impl SecondaryEmailDeletedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryEmailDeletedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryEmailDeletedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryEmailDeletedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryEmailDeletedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryEmailDeletedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryEmailDeletedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryEmailDeletedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryEmailDeletedType", SECONDARY_EMAIL_DELETED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryEmailDeletedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryEmailDeletedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Verified secondary email.
#[derive(Debug)]
pub struct SecondaryEmailVerifiedDetails {
    /// Verified secondary email.
    pub secondary_email: EmailAddress,
}

impl SecondaryEmailVerifiedDetails {
    pub fn new(secondary_email: EmailAddress) -> Self {
        SecondaryEmailVerifiedDetails {
            secondary_email,
        }
    }

}

const SECONDARY_EMAIL_VERIFIED_DETAILS_FIELDS: &[&str] = &["secondary_email"];
impl SecondaryEmailVerifiedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryEmailVerifiedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryEmailVerifiedDetails>, V::Error> {
        let mut field_secondary_email = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_email" => {
                    if field_secondary_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_email"));
                    }
                    field_secondary_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryEmailVerifiedDetails {
            secondary_email: field_secondary_email.ok_or_else(|| ::serde::de::Error::missing_field("secondary_email"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_email", &self.secondary_email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryEmailVerifiedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryEmailVerifiedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryEmailVerifiedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryEmailVerifiedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryEmailVerifiedDetails", SECONDARY_EMAIL_VERIFIED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryEmailVerifiedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryEmailVerifiedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SecondaryEmailVerifiedType {
    pub description: String,
}

impl SecondaryEmailVerifiedType {
    pub fn new(description: String) -> Self {
        SecondaryEmailVerifiedType {
            description,
        }
    }

}

const SECONDARY_EMAIL_VERIFIED_TYPE_FIELDS: &[&str] = &["description"];
impl SecondaryEmailVerifiedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryEmailVerifiedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryEmailVerifiedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryEmailVerifiedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryEmailVerifiedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryEmailVerifiedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryEmailVerifiedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryEmailVerifiedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryEmailVerifiedType", SECONDARY_EMAIL_VERIFIED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryEmailVerifiedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryEmailVerifiedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum SecondaryMailsPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryMailsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SecondaryMailsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryMailsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SecondaryMailsPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SecondaryMailsPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SecondaryMailsPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("SecondaryMailsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryMailsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SecondaryMailsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("SecondaryMailsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            SecondaryMailsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("SecondaryMailsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            SecondaryMailsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Secondary mails policy changed.
#[derive(Debug)]
pub struct SecondaryMailsPolicyChangedDetails {
    /// Previous secondary mails policy.
    pub previous_value: SecondaryMailsPolicy,
    /// New secondary mails policy.
    pub new_value: SecondaryMailsPolicy,
}

impl SecondaryMailsPolicyChangedDetails {
    pub fn new(previous_value: SecondaryMailsPolicy, new_value: SecondaryMailsPolicy) -> Self {
        SecondaryMailsPolicyChangedDetails {
            previous_value,
            new_value,
        }
    }

}

const SECONDARY_MAILS_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                 "new_value"];
impl SecondaryMailsPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryMailsPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryMailsPolicyChangedDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryMailsPolicyChangedDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryMailsPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryMailsPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryMailsPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryMailsPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryMailsPolicyChangedDetails", SECONDARY_MAILS_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryMailsPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryMailsPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SecondaryMailsPolicyChangedType {
    pub description: String,
}

impl SecondaryMailsPolicyChangedType {
    pub fn new(description: String) -> Self {
        SecondaryMailsPolicyChangedType {
            description,
        }
    }

}

const SECONDARY_MAILS_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl SecondaryMailsPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryMailsPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryMailsPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryMailsPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryMailsPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryMailsPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryMailsPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryMailsPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryMailsPolicyChangedType", SECONDARY_MAILS_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryMailsPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryMailsPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request acceptance details shown to the secondary team
#[derive(Debug)]
pub struct SecondaryTeamRequestAcceptedDetails {
    /// The primary team name.
    pub primary_team: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl SecondaryTeamRequestAcceptedDetails {
    pub fn new(primary_team: String, sent_by: String) -> Self {
        SecondaryTeamRequestAcceptedDetails {
            primary_team,
            sent_by,
        }
    }

}

const SECONDARY_TEAM_REQUEST_ACCEPTED_DETAILS_FIELDS: &[&str] = &["primary_team",
                                                                  "sent_by"];
impl SecondaryTeamRequestAcceptedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryTeamRequestAcceptedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryTeamRequestAcceptedDetails>, V::Error> {
        let mut field_primary_team = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "primary_team" => {
                    if field_primary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("primary_team"));
                    }
                    field_primary_team = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryTeamRequestAcceptedDetails {
            primary_team: field_primary_team.ok_or_else(|| ::serde::de::Error::missing_field("primary_team"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("primary_team", &self.primary_team)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryTeamRequestAcceptedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryTeamRequestAcceptedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryTeamRequestAcceptedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryTeamRequestAcceptedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryTeamRequestAcceptedDetails", SECONDARY_TEAM_REQUEST_ACCEPTED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryTeamRequestAcceptedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryTeamRequestAcceptedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request cancellation details shown to the secondary team
#[derive(Debug)]
pub struct SecondaryTeamRequestCanceledDetails {
    /// The email of the primary team admin that the request was sent to.
    pub sent_to: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl SecondaryTeamRequestCanceledDetails {
    pub fn new(sent_to: String, sent_by: String) -> Self {
        SecondaryTeamRequestCanceledDetails {
            sent_to,
            sent_by,
        }
    }

}

const SECONDARY_TEAM_REQUEST_CANCELED_DETAILS_FIELDS: &[&str] = &["sent_to",
                                                                  "sent_by"];
impl SecondaryTeamRequestCanceledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryTeamRequestCanceledDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryTeamRequestCanceledDetails>, V::Error> {
        let mut field_sent_to = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryTeamRequestCanceledDetails {
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sent_to", &self.sent_to)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryTeamRequestCanceledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryTeamRequestCanceledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryTeamRequestCanceledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryTeamRequestCanceledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryTeamRequestCanceledDetails", SECONDARY_TEAM_REQUEST_CANCELED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryTeamRequestCanceledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryTeamRequestCanceledDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request expiration details shown to the secondary team
#[derive(Debug)]
pub struct SecondaryTeamRequestExpiredDetails {
    /// The email of the primary team admin the request was sent to.
    pub sent_to: String,
}

impl SecondaryTeamRequestExpiredDetails {
    pub fn new(sent_to: String) -> Self {
        SecondaryTeamRequestExpiredDetails {
            sent_to,
        }
    }

}

const SECONDARY_TEAM_REQUEST_EXPIRED_DETAILS_FIELDS: &[&str] = &["sent_to"];
impl SecondaryTeamRequestExpiredDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryTeamRequestExpiredDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryTeamRequestExpiredDetails>, V::Error> {
        let mut field_sent_to = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryTeamRequestExpiredDetails {
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sent_to", &self.sent_to)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryTeamRequestExpiredDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryTeamRequestExpiredDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryTeamRequestExpiredDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryTeamRequestExpiredDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryTeamRequestExpiredDetails", SECONDARY_TEAM_REQUEST_EXPIRED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryTeamRequestExpiredDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryTeamRequestExpiredDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request reminder details shown to the secondary team
#[derive(Debug)]
pub struct SecondaryTeamRequestReminderDetails {
    /// The email of the primary team admin the request was sent to.
    pub sent_to: String,
}

impl SecondaryTeamRequestReminderDetails {
    pub fn new(sent_to: String) -> Self {
        SecondaryTeamRequestReminderDetails {
            sent_to,
        }
    }

}

const SECONDARY_TEAM_REQUEST_REMINDER_DETAILS_FIELDS: &[&str] = &["sent_to"];
impl SecondaryTeamRequestReminderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryTeamRequestReminderDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryTeamRequestReminderDetails>, V::Error> {
        let mut field_sent_to = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryTeamRequestReminderDetails {
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sent_to", &self.sent_to)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryTeamRequestReminderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryTeamRequestReminderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryTeamRequestReminderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryTeamRequestReminderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryTeamRequestReminderDetails", SECONDARY_TEAM_REQUEST_REMINDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryTeamRequestReminderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryTeamRequestReminderDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Session's logged information.
#[derive(Debug)]
pub enum SessionLogInfo {
    Web(WebSessionLogInfo),
    Desktop(DesktopSessionLogInfo),
    Mobile(MobileSessionLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for SessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SessionLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "web" => Ok(SessionLogInfo::Web(WebSessionLogInfo::internal_deserialize(map)?)),
                    "desktop" => Ok(SessionLogInfo::Desktop(DesktopSessionLogInfo::internal_deserialize(map)?)),
                    "mobile" => Ok(SessionLogInfo::Mobile(MobileSessionLogInfo::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SessionLogInfo::_Unknown)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["mobile",
                                    "mobile",
                                    "mobile"];
        deserializer.deserialize_struct("SessionLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            SessionLogInfo::Web(ref x) => {
                let mut s = serializer.serialize_struct("SessionLogInfo", 2)?;
                s.serialize_field(".tag", "web")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.end()
            }
            SessionLogInfo::Desktop(ref x) => {
                let mut s = serializer.serialize_struct("SessionLogInfo", 2)?;
                s.serialize_field(".tag", "desktop")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.end()
            }
            SessionLogInfo::Mobile(ref x) => {
                let mut s = serializer.serialize_struct("SessionLogInfo", 2)?;
                s.serialize_field(".tag", "mobile")?;
                s.serialize_field("session_id", &x.session_id)?;
                s.end()
            }
            SessionLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// Added team to shared folder.
#[derive(Debug)]
pub struct SfAddGroupDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Team name.
    pub team_name: String,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfAddGroupDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String, team_name: String) -> Self {
        SfAddGroupDetails {
            target_asset_index,
            original_folder_name,
            team_name,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_ADD_GROUP_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                               "original_folder_name",
                                               "team_name",
                                               "sharing_permission"];
impl SfAddGroupDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfAddGroupDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfAddGroupDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_team_name = None;
        let mut field_sharing_permission = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfAddGroupDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
            team_name: field_team_name.ok_or_else(|| ::serde::de::Error::missing_field("team_name"))?,
            sharing_permission: field_sharing_permission,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("team_name", &self.team_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAddGroupDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAddGroupDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfAddGroupDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAddGroupDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAddGroupDetails", SF_ADD_GROUP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAddGroupDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAddGroupDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfAddGroupType {
    pub description: String,
}

impl SfAddGroupType {
    pub fn new(description: String) -> Self {
        SfAddGroupType {
            description,
        }
    }

}

const SF_ADD_GROUP_TYPE_FIELDS: &[&str] = &["description"];
impl SfAddGroupType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfAddGroupType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfAddGroupType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfAddGroupType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAddGroupType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAddGroupType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfAddGroupType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAddGroupType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAddGroupType", SF_ADD_GROUP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAddGroupType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAddGroupType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Allowed non-collaborators to view links to files in shared folder.
#[derive(Debug)]
pub struct SfAllowNonMembersToViewSharedLinksDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Shared folder type. Might be missing due to historical data gap.
    pub shared_folder_type: Option<String>,
}

impl SfAllowNonMembersToViewSharedLinksDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfAllowNonMembersToViewSharedLinksDetails {
            target_asset_index,
            original_folder_name,
            shared_folder_type: None,
        }
    }

    pub fn with_shared_folder_type(mut self, value: Option<String>) -> Self {
        self.shared_folder_type = value;
        self
    }

}

const SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                                            "original_folder_name",
                                                                            "shared_folder_type"];
impl SfAllowNonMembersToViewSharedLinksDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfAllowNonMembersToViewSharedLinksDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfAllowNonMembersToViewSharedLinksDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_shared_folder_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "shared_folder_type" => {
                    if field_shared_folder_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_folder_type"));
                    }
                    field_shared_folder_type = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfAllowNonMembersToViewSharedLinksDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
            shared_folder_type: field_shared_folder_type,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("shared_folder_type", &self.shared_folder_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAllowNonMembersToViewSharedLinksDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAllowNonMembersToViewSharedLinksDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfAllowNonMembersToViewSharedLinksDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAllowNonMembersToViewSharedLinksDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAllowNonMembersToViewSharedLinksDetails", SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAllowNonMembersToViewSharedLinksDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAllowNonMembersToViewSharedLinksDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfAllowNonMembersToViewSharedLinksType {
    pub description: String,
}

impl SfAllowNonMembersToViewSharedLinksType {
    pub fn new(description: String) -> Self {
        SfAllowNonMembersToViewSharedLinksType {
            description,
        }
    }

}

const SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_TYPE_FIELDS: &[&str] = &["description"];
impl SfAllowNonMembersToViewSharedLinksType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfAllowNonMembersToViewSharedLinksType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfAllowNonMembersToViewSharedLinksType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfAllowNonMembersToViewSharedLinksType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfAllowNonMembersToViewSharedLinksType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfAllowNonMembersToViewSharedLinksType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfAllowNonMembersToViewSharedLinksType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfAllowNonMembersToViewSharedLinksType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfAllowNonMembersToViewSharedLinksType", SF_ALLOW_NON_MEMBERS_TO_VIEW_SHARED_LINKS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfAllowNonMembersToViewSharedLinksType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfAllowNonMembersToViewSharedLinksType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Set team members to see warning before sharing folders outside team.
#[derive(Debug)]
pub struct SfExternalInviteWarnDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New sharing permission. Might be missing due to historical data gap.
    pub new_sharing_permission: Option<String>,
    /// Previous sharing permission. Might be missing due to historical data gap.
    pub previous_sharing_permission: Option<String>,
}

impl SfExternalInviteWarnDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfExternalInviteWarnDetails {
            target_asset_index,
            original_folder_name,
            new_sharing_permission: None,
            previous_sharing_permission: None,
        }
    }

    pub fn with_new_sharing_permission(mut self, value: Option<String>) -> Self {
        self.new_sharing_permission = value;
        self
    }

    pub fn with_previous_sharing_permission(mut self, value: Option<String>) -> Self {
        self.previous_sharing_permission = value;
        self
    }

}

const SF_EXTERNAL_INVITE_WARN_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                          "original_folder_name",
                                                          "new_sharing_permission",
                                                          "previous_sharing_permission"];
impl SfExternalInviteWarnDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfExternalInviteWarnDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfExternalInviteWarnDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_sharing_permission = None;
        let mut field_previous_sharing_permission = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_sharing_permission" => {
                    if field_new_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_sharing_permission"));
                    }
                    field_new_sharing_permission = Some(map.next_value()?);
                }
                "previous_sharing_permission" => {
                    if field_previous_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_sharing_permission"));
                    }
                    field_previous_sharing_permission = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfExternalInviteWarnDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
            new_sharing_permission: field_new_sharing_permission,
            previous_sharing_permission: field_previous_sharing_permission,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_sharing_permission", &self.new_sharing_permission)?;
        s.serialize_field("previous_sharing_permission", &self.previous_sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfExternalInviteWarnDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfExternalInviteWarnDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfExternalInviteWarnDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfExternalInviteWarnDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfExternalInviteWarnDetails", SF_EXTERNAL_INVITE_WARN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfExternalInviteWarnDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfExternalInviteWarnDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfExternalInviteWarnType {
    pub description: String,
}

impl SfExternalInviteWarnType {
    pub fn new(description: String) -> Self {
        SfExternalInviteWarnType {
            description,
        }
    }

}

const SF_EXTERNAL_INVITE_WARN_TYPE_FIELDS: &[&str] = &["description"];
impl SfExternalInviteWarnType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfExternalInviteWarnType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfExternalInviteWarnType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfExternalInviteWarnType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfExternalInviteWarnType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfExternalInviteWarnType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfExternalInviteWarnType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfExternalInviteWarnType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfExternalInviteWarnType", SF_EXTERNAL_INVITE_WARN_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfExternalInviteWarnType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfExternalInviteWarnType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed Facebook user's role in shared folder.
#[derive(Debug)]
pub struct SfFbInviteChangeRoleDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Previous sharing permission. Might be missing due to historical data gap.
    pub previous_sharing_permission: Option<String>,
    /// New sharing permission. Might be missing due to historical data gap.
    pub new_sharing_permission: Option<String>,
}

impl SfFbInviteChangeRoleDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfFbInviteChangeRoleDetails {
            target_asset_index,
            original_folder_name,
            previous_sharing_permission: None,
            new_sharing_permission: None,
        }
    }

    pub fn with_previous_sharing_permission(mut self, value: Option<String>) -> Self {
        self.previous_sharing_permission = value;
        self
    }

    pub fn with_new_sharing_permission(mut self, value: Option<String>) -> Self {
        self.new_sharing_permission = value;
        self
    }

}

const SF_FB_INVITE_CHANGE_ROLE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                           "original_folder_name",
                                                           "previous_sharing_permission",
                                                           "new_sharing_permission"];
impl SfFbInviteChangeRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfFbInviteChangeRoleDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfFbInviteChangeRoleDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_previous_sharing_permission = None;
        let mut field_new_sharing_permission = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "previous_sharing_permission" => {
                    if field_previous_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_sharing_permission"));
                    }
                    field_previous_sharing_permission = Some(map.next_value()?);
                }
                "new_sharing_permission" => {
                    if field_new_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_sharing_permission"));
                    }
                    field_new_sharing_permission = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfFbInviteChangeRoleDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
            previous_sharing_permission: field_previous_sharing_permission,
            new_sharing_permission: field_new_sharing_permission,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("previous_sharing_permission", &self.previous_sharing_permission)?;
        s.serialize_field("new_sharing_permission", &self.new_sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbInviteChangeRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbInviteChangeRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfFbInviteChangeRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbInviteChangeRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbInviteChangeRoleDetails", SF_FB_INVITE_CHANGE_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbInviteChangeRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbInviteChangeRoleDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfFbInviteChangeRoleType {
    pub description: String,
}

impl SfFbInviteChangeRoleType {
    pub fn new(description: String) -> Self {
        SfFbInviteChangeRoleType {
            description,
        }
    }

}

const SF_FB_INVITE_CHANGE_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl SfFbInviteChangeRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfFbInviteChangeRoleType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfFbInviteChangeRoleType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfFbInviteChangeRoleType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbInviteChangeRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbInviteChangeRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfFbInviteChangeRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbInviteChangeRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbInviteChangeRoleType", SF_FB_INVITE_CHANGE_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbInviteChangeRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbInviteChangeRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Invited Facebook users to shared folder.
#[derive(Debug)]
pub struct SfFbInviteDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfFbInviteDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfFbInviteDetails {
            target_asset_index,
            original_folder_name,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_FB_INVITE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                               "original_folder_name",
                                               "sharing_permission"];
impl SfFbInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfFbInviteDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfFbInviteDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_sharing_permission = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfFbInviteDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
            sharing_permission: field_sharing_permission,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfFbInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbInviteDetails", SF_FB_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbInviteDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfFbInviteType {
    pub description: String,
}

impl SfFbInviteType {
    pub fn new(description: String) -> Self {
        SfFbInviteType {
            description,
        }
    }

}

const SF_FB_INVITE_TYPE_FIELDS: &[&str] = &["description"];
impl SfFbInviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfFbInviteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfFbInviteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfFbInviteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbInviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbInviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfFbInviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbInviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbInviteType", SF_FB_INVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbInviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbInviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Uninvited Facebook user from shared folder.
#[derive(Debug)]
pub struct SfFbUninviteDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfFbUninviteDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfFbUninviteDetails {
            target_asset_index,
            original_folder_name,
        }
    }

}

const SF_FB_UNINVITE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                 "original_folder_name"];
impl SfFbUninviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfFbUninviteDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfFbUninviteDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfFbUninviteDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbUninviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbUninviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfFbUninviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbUninviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbUninviteDetails", SF_FB_UNINVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbUninviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbUninviteDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfFbUninviteType {
    pub description: String,
}

impl SfFbUninviteType {
    pub fn new(description: String) -> Self {
        SfFbUninviteType {
            description,
        }
    }

}

const SF_FB_UNINVITE_TYPE_FIELDS: &[&str] = &["description"];
impl SfFbUninviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfFbUninviteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfFbUninviteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfFbUninviteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfFbUninviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfFbUninviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfFbUninviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfFbUninviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfFbUninviteType", SF_FB_UNINVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfFbUninviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfFbUninviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Invited group to shared folder.
#[derive(Debug)]
pub struct SfInviteGroupDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
}

impl SfInviteGroupDetails {
    pub fn new(target_asset_index: u64) -> Self {
        SfInviteGroupDetails {
            target_asset_index,
        }
    }

}

const SF_INVITE_GROUP_DETAILS_FIELDS: &[&str] = &["target_asset_index"];
impl SfInviteGroupDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfInviteGroupDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfInviteGroupDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfInviteGroupDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfInviteGroupDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfInviteGroupDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfInviteGroupDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfInviteGroupDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfInviteGroupDetails", SF_INVITE_GROUP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfInviteGroupDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfInviteGroupDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfInviteGroupType {
    pub description: String,
}

impl SfInviteGroupType {
    pub fn new(description: String) -> Self {
        SfInviteGroupType {
            description,
        }
    }

}

const SF_INVITE_GROUP_TYPE_FIELDS: &[&str] = &["description"];
impl SfInviteGroupType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfInviteGroupType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfInviteGroupType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfInviteGroupType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfInviteGroupType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfInviteGroupType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfInviteGroupType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfInviteGroupType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfInviteGroupType", SF_INVITE_GROUP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfInviteGroupType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfInviteGroupType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Granted access to shared folder.
#[derive(Debug)]
pub struct SfTeamGrantAccessDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamGrantAccessDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamGrantAccessDetails {
            target_asset_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_GRANT_ACCESS_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                       "original_folder_name"];
impl SfTeamGrantAccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamGrantAccessDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamGrantAccessDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamGrantAccessDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamGrantAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamGrantAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamGrantAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamGrantAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamGrantAccessDetails", SF_TEAM_GRANT_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamGrantAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamGrantAccessDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamGrantAccessType {
    pub description: String,
}

impl SfTeamGrantAccessType {
    pub fn new(description: String) -> Self {
        SfTeamGrantAccessType {
            description,
        }
    }

}

const SF_TEAM_GRANT_ACCESS_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamGrantAccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamGrantAccessType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamGrantAccessType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamGrantAccessType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamGrantAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamGrantAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamGrantAccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamGrantAccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamGrantAccessType", SF_TEAM_GRANT_ACCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamGrantAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamGrantAccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team member's role in shared folder.
#[derive(Debug)]
pub struct SfTeamInviteChangeRoleDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// New sharing permission. Might be missing due to historical data gap.
    pub new_sharing_permission: Option<String>,
    /// Previous sharing permission. Might be missing due to historical data gap.
    pub previous_sharing_permission: Option<String>,
}

impl SfTeamInviteChangeRoleDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamInviteChangeRoleDetails {
            target_asset_index,
            original_folder_name,
            new_sharing_permission: None,
            previous_sharing_permission: None,
        }
    }

    pub fn with_new_sharing_permission(mut self, value: Option<String>) -> Self {
        self.new_sharing_permission = value;
        self
    }

    pub fn with_previous_sharing_permission(mut self, value: Option<String>) -> Self {
        self.previous_sharing_permission = value;
        self
    }

}

const SF_TEAM_INVITE_CHANGE_ROLE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                             "original_folder_name",
                                                             "new_sharing_permission",
                                                             "previous_sharing_permission"];
impl SfTeamInviteChangeRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamInviteChangeRoleDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamInviteChangeRoleDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_new_sharing_permission = None;
        let mut field_previous_sharing_permission = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "new_sharing_permission" => {
                    if field_new_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_sharing_permission"));
                    }
                    field_new_sharing_permission = Some(map.next_value()?);
                }
                "previous_sharing_permission" => {
                    if field_previous_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_sharing_permission"));
                    }
                    field_previous_sharing_permission = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamInviteChangeRoleDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
            new_sharing_permission: field_new_sharing_permission,
            previous_sharing_permission: field_previous_sharing_permission,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("new_sharing_permission", &self.new_sharing_permission)?;
        s.serialize_field("previous_sharing_permission", &self.previous_sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteChangeRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteChangeRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteChangeRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteChangeRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteChangeRoleDetails", SF_TEAM_INVITE_CHANGE_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteChangeRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteChangeRoleDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamInviteChangeRoleType {
    pub description: String,
}

impl SfTeamInviteChangeRoleType {
    pub fn new(description: String) -> Self {
        SfTeamInviteChangeRoleType {
            description,
        }
    }

}

const SF_TEAM_INVITE_CHANGE_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamInviteChangeRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamInviteChangeRoleType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamInviteChangeRoleType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamInviteChangeRoleType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteChangeRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteChangeRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteChangeRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteChangeRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteChangeRoleType", SF_TEAM_INVITE_CHANGE_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteChangeRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteChangeRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Invited team members to shared folder.
#[derive(Debug)]
pub struct SfTeamInviteDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfTeamInviteDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamInviteDetails {
            target_asset_index,
            original_folder_name,
            sharing_permission: None,
        }
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_TEAM_INVITE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                 "original_folder_name",
                                                 "sharing_permission"];
impl SfTeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamInviteDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamInviteDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_sharing_permission = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamInviteDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
            sharing_permission: field_sharing_permission,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteDetails", SF_TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamInviteType {
    pub description: String,
}

impl SfTeamInviteType {
    pub fn new(description: String) -> Self {
        SfTeamInviteType {
            description,
        }
    }

}

const SF_TEAM_INVITE_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamInviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamInviteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamInviteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamInviteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamInviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamInviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamInviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamInviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamInviteType", SF_TEAM_INVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamInviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamInviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Joined team member's shared folder.
#[derive(Debug)]
pub struct SfTeamJoinDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamJoinDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamJoinDetails {
            target_asset_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_JOIN_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                               "original_folder_name"];
impl SfTeamJoinDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamJoinDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamJoinDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamJoinDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinDetails", SF_TEAM_JOIN_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Joined team member's shared folder from link.
#[derive(Debug)]
pub struct SfTeamJoinFromOobLinkDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
    /// Shared link token key.
    pub token_key: Option<String>,
    /// Sharing permission. Might be missing due to historical data gap.
    pub sharing_permission: Option<String>,
}

impl SfTeamJoinFromOobLinkDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamJoinFromOobLinkDetails {
            target_asset_index,
            original_folder_name,
            token_key: None,
            sharing_permission: None,
        }
    }

    pub fn with_token_key(mut self, value: Option<String>) -> Self {
        self.token_key = value;
        self
    }

    pub fn with_sharing_permission(mut self, value: Option<String>) -> Self {
        self.sharing_permission = value;
        self
    }

}

const SF_TEAM_JOIN_FROM_OOB_LINK_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                             "original_folder_name",
                                                             "token_key",
                                                             "sharing_permission"];
impl SfTeamJoinFromOobLinkDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamJoinFromOobLinkDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamJoinFromOobLinkDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut field_token_key = None;
        let mut field_sharing_permission = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                "token_key" => {
                    if field_token_key.is_some() {
                        return Err(::serde::de::Error::duplicate_field("token_key"));
                    }
                    field_token_key = Some(map.next_value()?);
                }
                "sharing_permission" => {
                    if field_sharing_permission.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sharing_permission"));
                    }
                    field_sharing_permission = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamJoinFromOobLinkDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
            token_key: field_token_key,
            sharing_permission: field_sharing_permission,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)?;
        s.serialize_field("token_key", &self.token_key)?;
        s.serialize_field("sharing_permission", &self.sharing_permission)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinFromOobLinkDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinFromOobLinkDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinFromOobLinkDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinFromOobLinkDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinFromOobLinkDetails", SF_TEAM_JOIN_FROM_OOB_LINK_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinFromOobLinkDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinFromOobLinkDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamJoinFromOobLinkType {
    pub description: String,
}

impl SfTeamJoinFromOobLinkType {
    pub fn new(description: String) -> Self {
        SfTeamJoinFromOobLinkType {
            description,
        }
    }

}

const SF_TEAM_JOIN_FROM_OOB_LINK_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamJoinFromOobLinkType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamJoinFromOobLinkType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamJoinFromOobLinkType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamJoinFromOobLinkType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinFromOobLinkType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinFromOobLinkType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinFromOobLinkType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinFromOobLinkType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinFromOobLinkType", SF_TEAM_JOIN_FROM_OOB_LINK_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinFromOobLinkType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinFromOobLinkType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamJoinType {
    pub description: String,
}

impl SfTeamJoinType {
    pub fn new(description: String) -> Self {
        SfTeamJoinType {
            description,
        }
    }

}

const SF_TEAM_JOIN_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamJoinType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamJoinType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamJoinType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamJoinType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamJoinType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamJoinType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamJoinType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamJoinType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamJoinType", SF_TEAM_JOIN_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamJoinType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamJoinType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unshared folder with team member.
#[derive(Debug)]
pub struct SfTeamUninviteDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
    /// Original shared folder name.
    pub original_folder_name: String,
}

impl SfTeamUninviteDetails {
    pub fn new(target_asset_index: u64, original_folder_name: String) -> Self {
        SfTeamUninviteDetails {
            target_asset_index,
            original_folder_name,
        }
    }

}

const SF_TEAM_UNINVITE_DETAILS_FIELDS: &[&str] = &["target_asset_index",
                                                   "original_folder_name"];
impl SfTeamUninviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamUninviteDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamUninviteDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut field_original_folder_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                "original_folder_name" => {
                    if field_original_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("original_folder_name"));
                    }
                    field_original_folder_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamUninviteDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
            original_folder_name: field_original_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("original_folder_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)?;
        s.serialize_field("original_folder_name", &self.original_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamUninviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamUninviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamUninviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamUninviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamUninviteDetails", SF_TEAM_UNINVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamUninviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamUninviteDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SfTeamUninviteType {
    pub description: String,
}

impl SfTeamUninviteType {
    pub fn new(description: String) -> Self {
        SfTeamUninviteType {
            description,
        }
    }

}

const SF_TEAM_UNINVITE_TYPE_FIELDS: &[&str] = &["description"];
impl SfTeamUninviteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SfTeamUninviteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SfTeamUninviteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SfTeamUninviteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SfTeamUninviteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SfTeamUninviteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SfTeamUninviteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SfTeamUninviteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SfTeamUninviteType", SF_TEAM_UNINVITE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SfTeamUninviteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SfTeamUninviteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Invited user to Dropbox and added them to shared file/folder.
#[derive(Debug)]
pub struct SharedContentAddInviteesDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// A list of invitees.
    pub invitees: Vec<EmailAddress>,
}

impl SharedContentAddInviteesDetails {
    pub fn new(
        shared_content_access_level: super::sharing::AccessLevel,
        invitees: Vec<EmailAddress>,
    ) -> Self {
        SharedContentAddInviteesDetails {
            shared_content_access_level,
            invitees,
        }
    }

}

const SHARED_CONTENT_ADD_INVITEES_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                              "invitees"];
impl SharedContentAddInviteesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentAddInviteesDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentAddInviteesDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_invitees = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "invitees" => {
                    if field_invitees.is_some() {
                        return Err(::serde::de::Error::duplicate_field("invitees"));
                    }
                    field_invitees = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentAddInviteesDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            invitees: field_invitees.ok_or_else(|| ::serde::de::Error::missing_field("invitees"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("invitees", &self.invitees)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddInviteesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddInviteesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddInviteesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddInviteesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddInviteesDetails", SHARED_CONTENT_ADD_INVITEES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddInviteesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddInviteesDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentAddInviteesType {
    pub description: String,
}

impl SharedContentAddInviteesType {
    pub fn new(description: String) -> Self {
        SharedContentAddInviteesType {
            description,
        }
    }

}

const SHARED_CONTENT_ADD_INVITEES_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentAddInviteesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentAddInviteesType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentAddInviteesType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentAddInviteesType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddInviteesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddInviteesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddInviteesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddInviteesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddInviteesType", SHARED_CONTENT_ADD_INVITEES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddInviteesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddInviteesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added expiration date to link for shared file/folder.
#[derive(Debug)]
pub struct SharedContentAddLinkExpiryDetails {
    /// New shared content link expiration date. Might be missing due to historical data gap.
    pub new_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedContentAddLinkExpiryDetails {
    fn default() -> Self {
        SharedContentAddLinkExpiryDetails {
            new_value: None,
        }
    }
}

const SHARED_CONTENT_ADD_LINK_EXPIRY_DETAILS_FIELDS: &[&str] = &["new_value"];
impl SharedContentAddLinkExpiryDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddLinkExpiryDetails, V::Error> {
        let mut field_new_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedContentAddLinkExpiryDetails {
            new_value: field_new_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkExpiryDetails", SHARED_CONTENT_ADD_LINK_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddLinkExpiryDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentAddLinkExpiryType {
    pub description: String,
}

impl SharedContentAddLinkExpiryType {
    pub fn new(description: String) -> Self {
        SharedContentAddLinkExpiryType {
            description,
        }
    }

}

const SHARED_CONTENT_ADD_LINK_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentAddLinkExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentAddLinkExpiryType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentAddLinkExpiryType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentAddLinkExpiryType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkExpiryType", SHARED_CONTENT_ADD_LINK_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddLinkExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added password to link for shared file/folder.
#[derive(Debug)]
pub struct SharedContentAddLinkPasswordDetails {
}

impl Default for SharedContentAddLinkPasswordDetails {
    fn default() -> Self {
        SharedContentAddLinkPasswordDetails {
        }
    }
}

const SHARED_CONTENT_ADD_LINK_PASSWORD_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentAddLinkPasswordDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentAddLinkPasswordDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SharedContentAddLinkPasswordDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkPasswordDetails", SHARED_CONTENT_ADD_LINK_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentAddLinkPasswordDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentAddLinkPasswordType {
    pub description: String,
}

impl SharedContentAddLinkPasswordType {
    pub fn new(description: String) -> Self {
        SharedContentAddLinkPasswordType {
            description,
        }
    }

}

const SHARED_CONTENT_ADD_LINK_PASSWORD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentAddLinkPasswordType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentAddLinkPasswordType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentAddLinkPasswordType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentAddLinkPasswordType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddLinkPasswordType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddLinkPasswordType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddLinkPasswordType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddLinkPasswordType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddLinkPasswordType", SHARED_CONTENT_ADD_LINK_PASSWORD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddLinkPasswordType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddLinkPasswordType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added users and/or groups to shared file/folder.
#[derive(Debug)]
pub struct SharedContentAddMemberDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
}

impl SharedContentAddMemberDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedContentAddMemberDetails {
            shared_content_access_level,
        }
    }

}

const SHARED_CONTENT_ADD_MEMBER_DETAILS_FIELDS: &[&str] = &["shared_content_access_level"];
impl SharedContentAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentAddMemberDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentAddMemberDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentAddMemberDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddMemberDetails", SHARED_CONTENT_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentAddMemberType {
    pub description: String,
}

impl SharedContentAddMemberType {
    pub fn new(description: String) -> Self {
        SharedContentAddMemberType {
            description,
        }
    }

}

const SHARED_CONTENT_ADD_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentAddMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentAddMemberType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentAddMemberType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentAddMemberType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentAddMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentAddMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentAddMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentAddMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentAddMemberType", SHARED_CONTENT_ADD_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentAddMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentAddMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether members can download shared file/folder.
#[derive(Debug)]
pub struct SharedContentChangeDownloadsPolicyDetails {
    /// New downloads policy.
    pub new_value: DownloadPolicyType,
    /// Previous downloads policy. Might be missing due to historical data gap.
    pub previous_value: Option<DownloadPolicyType>,
}

impl SharedContentChangeDownloadsPolicyDetails {
    pub fn new(new_value: DownloadPolicyType) -> Self {
        SharedContentChangeDownloadsPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<DownloadPolicyType>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl SharedContentChangeDownloadsPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeDownloadsPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeDownloadsPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeDownloadsPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeDownloadsPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeDownloadsPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeDownloadsPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeDownloadsPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeDownloadsPolicyDetails", SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeDownloadsPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeDownloadsPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeDownloadsPolicyType {
    pub description: String,
}

impl SharedContentChangeDownloadsPolicyType {
    pub fn new(description: String) -> Self {
        SharedContentChangeDownloadsPolicyType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeDownloadsPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeDownloadsPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeDownloadsPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeDownloadsPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeDownloadsPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeDownloadsPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeDownloadsPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeDownloadsPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeDownloadsPolicyType", SHARED_CONTENT_CHANGE_DOWNLOADS_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeDownloadsPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeDownloadsPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed access type of invitee to shared file/folder before invite was accepted.
#[derive(Debug)]
pub struct SharedContentChangeInviteeRoleDetails {
    /// New access level.
    pub new_access_level: super::sharing::AccessLevel,
    /// The invitee whose role was changed.
    pub invitee: EmailAddress,
    /// Previous access level. Might be missing due to historical data gap.
    pub previous_access_level: Option<super::sharing::AccessLevel>,
}

impl SharedContentChangeInviteeRoleDetails {
    pub fn new(new_access_level: super::sharing::AccessLevel, invitee: EmailAddress) -> Self {
        SharedContentChangeInviteeRoleDetails {
            new_access_level,
            invitee,
            previous_access_level: None,
        }
    }

    pub fn with_previous_access_level(
        mut self,
        value: Option<super::sharing::AccessLevel>,
    ) -> Self {
        self.previous_access_level = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_INVITEE_ROLE_DETAILS_FIELDS: &[&str] = &["new_access_level",
                                                                     "invitee",
                                                                     "previous_access_level"];
impl SharedContentChangeInviteeRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeInviteeRoleDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeInviteeRoleDetails>, V::Error> {
        let mut field_new_access_level = None;
        let mut field_invitee = None;
        let mut field_previous_access_level = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_access_level" => {
                    if field_new_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_access_level"));
                    }
                    field_new_access_level = Some(map.next_value()?);
                }
                "invitee" => {
                    if field_invitee.is_some() {
                        return Err(::serde::de::Error::duplicate_field("invitee"));
                    }
                    field_invitee = Some(map.next_value()?);
                }
                "previous_access_level" => {
                    if field_previous_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_access_level"));
                    }
                    field_previous_access_level = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeInviteeRoleDetails {
            new_access_level: field_new_access_level.ok_or_else(|| ::serde::de::Error::missing_field("new_access_level"))?,
            invitee: field_invitee.ok_or_else(|| ::serde::de::Error::missing_field("invitee"))?,
            previous_access_level: field_previous_access_level,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_access_level", &self.new_access_level)?;
        s.serialize_field("invitee", &self.invitee)?;
        s.serialize_field("previous_access_level", &self.previous_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeInviteeRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeInviteeRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeInviteeRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeInviteeRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeInviteeRoleDetails", SHARED_CONTENT_CHANGE_INVITEE_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeInviteeRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeInviteeRoleDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeInviteeRoleType {
    pub description: String,
}

impl SharedContentChangeInviteeRoleType {
    pub fn new(description: String) -> Self {
        SharedContentChangeInviteeRoleType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_INVITEE_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeInviteeRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeInviteeRoleType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeInviteeRoleType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeInviteeRoleType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeInviteeRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeInviteeRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeInviteeRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeInviteeRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeInviteeRoleType", SHARED_CONTENT_CHANGE_INVITEE_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeInviteeRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeInviteeRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed link audience of shared file/folder.
#[derive(Debug)]
pub struct SharedContentChangeLinkAudienceDetails {
    /// New link audience value.
    pub new_value: super::sharing::LinkAudience,
    /// Previous link audience value.
    pub previous_value: Option<super::sharing::LinkAudience>,
}

impl SharedContentChangeLinkAudienceDetails {
    pub fn new(new_value: super::sharing::LinkAudience) -> Self {
        SharedContentChangeLinkAudienceDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::LinkAudience>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_LINK_AUDIENCE_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                      "previous_value"];
impl SharedContentChangeLinkAudienceDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeLinkAudienceDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeLinkAudienceDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeLinkAudienceDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkAudienceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkAudienceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkAudienceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkAudienceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkAudienceDetails", SHARED_CONTENT_CHANGE_LINK_AUDIENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkAudienceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkAudienceDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeLinkAudienceType {
    pub description: String,
}

impl SharedContentChangeLinkAudienceType {
    pub fn new(description: String) -> Self {
        SharedContentChangeLinkAudienceType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_LINK_AUDIENCE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeLinkAudienceType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeLinkAudienceType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeLinkAudienceType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeLinkAudienceType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkAudienceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkAudienceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkAudienceType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkAudienceType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkAudienceType", SHARED_CONTENT_CHANGE_LINK_AUDIENCE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkAudienceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkAudienceType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed link expiration of shared file/folder.
#[derive(Debug)]
pub struct SharedContentChangeLinkExpiryDetails {
    /// New shared content link expiration date. Might be missing due to historical data gap.
    pub new_value: Option<super::common::DropboxTimestamp>,
    /// Previous shared content link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedContentChangeLinkExpiryDetails {
    fn default() -> Self {
        SharedContentChangeLinkExpiryDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const SHARED_CONTENT_CHANGE_LINK_EXPIRY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                    "previous_value"];
impl SharedContentChangeLinkExpiryDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeLinkExpiryDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedContentChangeLinkExpiryDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkExpiryDetails", SHARED_CONTENT_CHANGE_LINK_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkExpiryDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeLinkExpiryType {
    pub description: String,
}

impl SharedContentChangeLinkExpiryType {
    pub fn new(description: String) -> Self {
        SharedContentChangeLinkExpiryType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_LINK_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeLinkExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeLinkExpiryType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeLinkExpiryType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeLinkExpiryType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkExpiryType", SHARED_CONTENT_CHANGE_LINK_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed link password of shared file/folder.
#[derive(Debug)]
pub struct SharedContentChangeLinkPasswordDetails {
}

impl Default for SharedContentChangeLinkPasswordDetails {
    fn default() -> Self {
        SharedContentChangeLinkPasswordDetails {
        }
    }
}

const SHARED_CONTENT_CHANGE_LINK_PASSWORD_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentChangeLinkPasswordDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentChangeLinkPasswordDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SharedContentChangeLinkPasswordDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkPasswordDetails", SHARED_CONTENT_CHANGE_LINK_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentChangeLinkPasswordDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeLinkPasswordType {
    pub description: String,
}

impl SharedContentChangeLinkPasswordType {
    pub fn new(description: String) -> Self {
        SharedContentChangeLinkPasswordType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_LINK_PASSWORD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeLinkPasswordType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeLinkPasswordType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeLinkPasswordType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeLinkPasswordType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeLinkPasswordType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeLinkPasswordType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeLinkPasswordType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeLinkPasswordType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeLinkPasswordType", SHARED_CONTENT_CHANGE_LINK_PASSWORD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeLinkPasswordType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeLinkPasswordType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed access type of shared file/folder member.
#[derive(Debug)]
pub struct SharedContentChangeMemberRoleDetails {
    /// New access level.
    pub new_access_level: super::sharing::AccessLevel,
    /// Previous access level. Might be missing due to historical data gap.
    pub previous_access_level: Option<super::sharing::AccessLevel>,
}

impl SharedContentChangeMemberRoleDetails {
    pub fn new(new_access_level: super::sharing::AccessLevel) -> Self {
        SharedContentChangeMemberRoleDetails {
            new_access_level,
            previous_access_level: None,
        }
    }

    pub fn with_previous_access_level(
        mut self,
        value: Option<super::sharing::AccessLevel>,
    ) -> Self {
        self.previous_access_level = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_MEMBER_ROLE_DETAILS_FIELDS: &[&str] = &["new_access_level",
                                                                    "previous_access_level"];
impl SharedContentChangeMemberRoleDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeMemberRoleDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeMemberRoleDetails>, V::Error> {
        let mut field_new_access_level = None;
        let mut field_previous_access_level = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_access_level" => {
                    if field_new_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_access_level"));
                    }
                    field_new_access_level = Some(map.next_value()?);
                }
                "previous_access_level" => {
                    if field_previous_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_access_level"));
                    }
                    field_previous_access_level = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeMemberRoleDetails {
            new_access_level: field_new_access_level.ok_or_else(|| ::serde::de::Error::missing_field("new_access_level"))?,
            previous_access_level: field_previous_access_level,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_access_level", &self.new_access_level)?;
        s.serialize_field("previous_access_level", &self.previous_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeMemberRoleDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeMemberRoleDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeMemberRoleDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeMemberRoleDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeMemberRoleDetails", SHARED_CONTENT_CHANGE_MEMBER_ROLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeMemberRoleDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeMemberRoleDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeMemberRoleType {
    pub description: String,
}

impl SharedContentChangeMemberRoleType {
    pub fn new(description: String) -> Self {
        SharedContentChangeMemberRoleType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_MEMBER_ROLE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeMemberRoleType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeMemberRoleType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeMemberRoleType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeMemberRoleType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeMemberRoleType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeMemberRoleType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeMemberRoleType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeMemberRoleType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeMemberRoleType", SHARED_CONTENT_CHANGE_MEMBER_ROLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeMemberRoleType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeMemberRoleType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether members can see who viewed shared file/folder.
#[derive(Debug)]
pub struct SharedContentChangeViewerInfoPolicyDetails {
    /// New viewer info policy.
    pub new_value: super::sharing::ViewerInfoPolicy,
    /// Previous view info policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::sharing::ViewerInfoPolicy>,
}

impl SharedContentChangeViewerInfoPolicyDetails {
    pub fn new(new_value: super::sharing::ViewerInfoPolicy) -> Self {
        SharedContentChangeViewerInfoPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::ViewerInfoPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                           "previous_value"];
impl SharedContentChangeViewerInfoPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeViewerInfoPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeViewerInfoPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeViewerInfoPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeViewerInfoPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeViewerInfoPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeViewerInfoPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeViewerInfoPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeViewerInfoPolicyDetails", SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeViewerInfoPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeViewerInfoPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentChangeViewerInfoPolicyType {
    pub description: String,
}

impl SharedContentChangeViewerInfoPolicyType {
    pub fn new(description: String) -> Self {
        SharedContentChangeViewerInfoPolicyType {
            description,
        }
    }

}

const SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentChangeViewerInfoPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentChangeViewerInfoPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentChangeViewerInfoPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentChangeViewerInfoPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentChangeViewerInfoPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentChangeViewerInfoPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentChangeViewerInfoPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentChangeViewerInfoPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentChangeViewerInfoPolicyType", SHARED_CONTENT_CHANGE_VIEWER_INFO_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentChangeViewerInfoPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentChangeViewerInfoPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Acquired membership of shared file/folder by accepting invite.
#[derive(Debug)]
pub struct SharedContentClaimInvitationDetails {
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl Default for SharedContentClaimInvitationDetails {
    fn default() -> Self {
        SharedContentClaimInvitationDetails {
            shared_content_link: None,
        }
    }
}

const SHARED_CONTENT_CLAIM_INVITATION_DETAILS_FIELDS: &[&str] = &["shared_content_link"];
impl SharedContentClaimInvitationDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentClaimInvitationDetails, V::Error> {
        let mut field_shared_content_link = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedContentClaimInvitationDetails {
            shared_content_link: field_shared_content_link,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentClaimInvitationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentClaimInvitationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentClaimInvitationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentClaimInvitationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentClaimInvitationDetails", SHARED_CONTENT_CLAIM_INVITATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentClaimInvitationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentClaimInvitationDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentClaimInvitationType {
    pub description: String,
}

impl SharedContentClaimInvitationType {
    pub fn new(description: String) -> Self {
        SharedContentClaimInvitationType {
            description,
        }
    }

}

const SHARED_CONTENT_CLAIM_INVITATION_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentClaimInvitationType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentClaimInvitationType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentClaimInvitationType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentClaimInvitationType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentClaimInvitationType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentClaimInvitationType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentClaimInvitationType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentClaimInvitationType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentClaimInvitationType", SHARED_CONTENT_CLAIM_INVITATION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentClaimInvitationType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentClaimInvitationType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Copied shared file/folder to own Dropbox.
#[derive(Debug)]
pub struct SharedContentCopyDetails {
    /// Shared content link.
    pub shared_content_link: String,
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// The path where the member saved the content.
    pub destination_path: FilePath,
    /// The shared content owner.
    pub shared_content_owner: Option<UserLogInfo>,
}

impl SharedContentCopyDetails {
    pub fn new(
        shared_content_link: String,
        shared_content_access_level: super::sharing::AccessLevel,
        destination_path: FilePath,
    ) -> Self {
        SharedContentCopyDetails {
            shared_content_link,
            shared_content_access_level,
            destination_path,
            shared_content_owner: None,
        }
    }

    pub fn with_shared_content_owner(mut self, value: Option<UserLogInfo>) -> Self {
        self.shared_content_owner = value;
        self
    }

}

const SHARED_CONTENT_COPY_DETAILS_FIELDS: &[&str] = &["shared_content_link",
                                                      "shared_content_access_level",
                                                      "destination_path",
                                                      "shared_content_owner"];
impl SharedContentCopyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentCopyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentCopyDetails>, V::Error> {
        let mut field_shared_content_link = None;
        let mut field_shared_content_access_level = None;
        let mut field_destination_path = None;
        let mut field_shared_content_owner = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "destination_path" => {
                    if field_destination_path.is_some() {
                        return Err(::serde::de::Error::duplicate_field("destination_path"));
                    }
                    field_destination_path = Some(map.next_value()?);
                }
                "shared_content_owner" => {
                    if field_shared_content_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_owner"));
                    }
                    field_shared_content_owner = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentCopyDetails {
            shared_content_link: field_shared_content_link.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_link"))?,
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            destination_path: field_destination_path.ok_or_else(|| ::serde::de::Error::missing_field("destination_path"))?,
            shared_content_owner: field_shared_content_owner,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("destination_path", &self.destination_path)?;
        s.serialize_field("shared_content_owner", &self.shared_content_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentCopyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentCopyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentCopyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentCopyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentCopyDetails", SHARED_CONTENT_COPY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentCopyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentCopyDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentCopyType {
    pub description: String,
}

impl SharedContentCopyType {
    pub fn new(description: String) -> Self {
        SharedContentCopyType {
            description,
        }
    }

}

const SHARED_CONTENT_COPY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentCopyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentCopyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentCopyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentCopyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentCopyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentCopyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentCopyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentCopyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentCopyType", SHARED_CONTENT_COPY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentCopyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentCopyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded shared file/folder.
#[derive(Debug)]
pub struct SharedContentDownloadDetails {
    /// Shared content link.
    pub shared_content_link: String,
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// The shared content owner.
    pub shared_content_owner: Option<UserLogInfo>,
}

impl SharedContentDownloadDetails {
    pub fn new(
        shared_content_link: String,
        shared_content_access_level: super::sharing::AccessLevel,
    ) -> Self {
        SharedContentDownloadDetails {
            shared_content_link,
            shared_content_access_level,
            shared_content_owner: None,
        }
    }

    pub fn with_shared_content_owner(mut self, value: Option<UserLogInfo>) -> Self {
        self.shared_content_owner = value;
        self
    }

}

const SHARED_CONTENT_DOWNLOAD_DETAILS_FIELDS: &[&str] = &["shared_content_link",
                                                          "shared_content_access_level",
                                                          "shared_content_owner"];
impl SharedContentDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentDownloadDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentDownloadDetails>, V::Error> {
        let mut field_shared_content_link = None;
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_owner = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_owner" => {
                    if field_shared_content_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_owner"));
                    }
                    field_shared_content_owner = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentDownloadDetails {
            shared_content_link: field_shared_content_link.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_link"))?,
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_owner: field_shared_content_owner,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_owner", &self.shared_content_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentDownloadDetails", SHARED_CONTENT_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentDownloadDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentDownloadType {
    pub description: String,
}

impl SharedContentDownloadType {
    pub fn new(description: String) -> Self {
        SharedContentDownloadType {
            description,
        }
    }

}

const SHARED_CONTENT_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentDownloadType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentDownloadType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentDownloadType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentDownloadType", SHARED_CONTENT_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Left shared file/folder.
#[derive(Debug)]
pub struct SharedContentRelinquishMembershipDetails {
}

impl Default for SharedContentRelinquishMembershipDetails {
    fn default() -> Self {
        SharedContentRelinquishMembershipDetails {
        }
    }
}

const SHARED_CONTENT_RELINQUISH_MEMBERSHIP_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentRelinquishMembershipDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRelinquishMembershipDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SharedContentRelinquishMembershipDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRelinquishMembershipDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRelinquishMembershipDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRelinquishMembershipDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRelinquishMembershipDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRelinquishMembershipDetails", SHARED_CONTENT_RELINQUISH_MEMBERSHIP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRelinquishMembershipDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentRelinquishMembershipDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRelinquishMembershipType {
    pub description: String,
}

impl SharedContentRelinquishMembershipType {
    pub fn new(description: String) -> Self {
        SharedContentRelinquishMembershipType {
            description,
        }
    }

}

const SHARED_CONTENT_RELINQUISH_MEMBERSHIP_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRelinquishMembershipType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRelinquishMembershipType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRelinquishMembershipType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRelinquishMembershipType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRelinquishMembershipType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRelinquishMembershipType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRelinquishMembershipType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRelinquishMembershipType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRelinquishMembershipType", SHARED_CONTENT_RELINQUISH_MEMBERSHIP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRelinquishMembershipType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRelinquishMembershipType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed invitee from shared file/folder before invite was accepted.
#[derive(Debug)]
pub struct SharedContentRemoveInviteesDetails {
    /// A list of invitees.
    pub invitees: Vec<EmailAddress>,
}

impl SharedContentRemoveInviteesDetails {
    pub fn new(invitees: Vec<EmailAddress>) -> Self {
        SharedContentRemoveInviteesDetails {
            invitees,
        }
    }

}

const SHARED_CONTENT_REMOVE_INVITEES_DETAILS_FIELDS: &[&str] = &["invitees"];
impl SharedContentRemoveInviteesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRemoveInviteesDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRemoveInviteesDetails>, V::Error> {
        let mut field_invitees = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "invitees" => {
                    if field_invitees.is_some() {
                        return Err(::serde::de::Error::duplicate_field("invitees"));
                    }
                    field_invitees = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRemoveInviteesDetails {
            invitees: field_invitees.ok_or_else(|| ::serde::de::Error::missing_field("invitees"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("invitees", &self.invitees)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveInviteesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveInviteesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveInviteesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveInviteesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveInviteesDetails", SHARED_CONTENT_REMOVE_INVITEES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveInviteesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveInviteesDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRemoveInviteesType {
    pub description: String,
}

impl SharedContentRemoveInviteesType {
    pub fn new(description: String) -> Self {
        SharedContentRemoveInviteesType {
            description,
        }
    }

}

const SHARED_CONTENT_REMOVE_INVITEES_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRemoveInviteesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRemoveInviteesType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRemoveInviteesType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRemoveInviteesType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveInviteesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveInviteesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveInviteesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveInviteesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveInviteesType", SHARED_CONTENT_REMOVE_INVITEES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveInviteesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveInviteesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed link expiration date of shared file/folder.
#[derive(Debug)]
pub struct SharedContentRemoveLinkExpiryDetails {
    /// Previous shared content link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedContentRemoveLinkExpiryDetails {
    fn default() -> Self {
        SharedContentRemoveLinkExpiryDetails {
            previous_value: None,
        }
    }
}

const SHARED_CONTENT_REMOVE_LINK_EXPIRY_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl SharedContentRemoveLinkExpiryDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveLinkExpiryDetails, V::Error> {
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedContentRemoveLinkExpiryDetails {
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkExpiryDetails", SHARED_CONTENT_REMOVE_LINK_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveLinkExpiryDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRemoveLinkExpiryType {
    pub description: String,
}

impl SharedContentRemoveLinkExpiryType {
    pub fn new(description: String) -> Self {
        SharedContentRemoveLinkExpiryType {
            description,
        }
    }

}

const SHARED_CONTENT_REMOVE_LINK_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRemoveLinkExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRemoveLinkExpiryType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRemoveLinkExpiryType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRemoveLinkExpiryType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkExpiryType", SHARED_CONTENT_REMOVE_LINK_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveLinkExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed link password of shared file/folder.
#[derive(Debug)]
pub struct SharedContentRemoveLinkPasswordDetails {
}

impl Default for SharedContentRemoveLinkPasswordDetails {
    fn default() -> Self {
        SharedContentRemoveLinkPasswordDetails {
        }
    }
}

const SHARED_CONTENT_REMOVE_LINK_PASSWORD_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentRemoveLinkPasswordDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveLinkPasswordDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SharedContentRemoveLinkPasswordDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkPasswordDetails", SHARED_CONTENT_REMOVE_LINK_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentRemoveLinkPasswordDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRemoveLinkPasswordType {
    pub description: String,
}

impl SharedContentRemoveLinkPasswordType {
    pub fn new(description: String) -> Self {
        SharedContentRemoveLinkPasswordType {
            description,
        }
    }

}

const SHARED_CONTENT_REMOVE_LINK_PASSWORD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRemoveLinkPasswordType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRemoveLinkPasswordType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRemoveLinkPasswordType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRemoveLinkPasswordType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveLinkPasswordType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveLinkPasswordType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveLinkPasswordType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveLinkPasswordType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveLinkPasswordType", SHARED_CONTENT_REMOVE_LINK_PASSWORD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveLinkPasswordType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveLinkPasswordType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed user/group from shared file/folder.
#[derive(Debug)]
pub struct SharedContentRemoveMemberDetails {
    /// Shared content access level.
    pub shared_content_access_level: Option<super::sharing::AccessLevel>,
}

impl Default for SharedContentRemoveMemberDetails {
    fn default() -> Self {
        SharedContentRemoveMemberDetails {
            shared_content_access_level: None,
        }
    }
}

const SHARED_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS: &[&str] = &["shared_content_access_level"];
impl SharedContentRemoveMemberDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRemoveMemberDetails, V::Error> {
        let mut field_shared_content_access_level = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedContentRemoveMemberDetails {
            shared_content_access_level: field_shared_content_access_level,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveMemberDetails", SHARED_CONTENT_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRemoveMemberType {
    pub description: String,
}

impl SharedContentRemoveMemberType {
    pub fn new(description: String) -> Self {
        SharedContentRemoveMemberType {
            description,
        }
    }

}

const SHARED_CONTENT_REMOVE_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRemoveMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRemoveMemberType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRemoveMemberType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRemoveMemberType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRemoveMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRemoveMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRemoveMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRemoveMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRemoveMemberType", SHARED_CONTENT_REMOVE_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRemoveMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRemoveMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested access to shared file/folder.
#[derive(Debug)]
pub struct SharedContentRequestAccessDetails {
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl Default for SharedContentRequestAccessDetails {
    fn default() -> Self {
        SharedContentRequestAccessDetails {
            shared_content_link: None,
        }
    }
}

const SHARED_CONTENT_REQUEST_ACCESS_DETAILS_FIELDS: &[&str] = &["shared_content_link"];
impl SharedContentRequestAccessDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentRequestAccessDetails, V::Error> {
        let mut field_shared_content_link = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedContentRequestAccessDetails {
            shared_content_link: field_shared_content_link,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRequestAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRequestAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRequestAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRequestAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRequestAccessDetails", SHARED_CONTENT_REQUEST_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRequestAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRequestAccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRequestAccessType {
    pub description: String,
}

impl SharedContentRequestAccessType {
    pub fn new(description: String) -> Self {
        SharedContentRequestAccessType {
            description,
        }
    }

}

const SHARED_CONTENT_REQUEST_ACCESS_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRequestAccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRequestAccessType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRequestAccessType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRequestAccessType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRequestAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRequestAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRequestAccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRequestAccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRequestAccessType", SHARED_CONTENT_REQUEST_ACCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRequestAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRequestAccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored shared file/folder invitees.
#[derive(Debug)]
pub struct SharedContentRestoreInviteesDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// A list of invitees.
    pub invitees: Vec<EmailAddress>,
}

impl SharedContentRestoreInviteesDetails {
    pub fn new(
        shared_content_access_level: super::sharing::AccessLevel,
        invitees: Vec<EmailAddress>,
    ) -> Self {
        SharedContentRestoreInviteesDetails {
            shared_content_access_level,
            invitees,
        }
    }

}

const SHARED_CONTENT_RESTORE_INVITEES_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                  "invitees"];
impl SharedContentRestoreInviteesDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRestoreInviteesDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRestoreInviteesDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_invitees = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "invitees" => {
                    if field_invitees.is_some() {
                        return Err(::serde::de::Error::duplicate_field("invitees"));
                    }
                    field_invitees = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRestoreInviteesDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            invitees: field_invitees.ok_or_else(|| ::serde::de::Error::missing_field("invitees"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("invitees", &self.invitees)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRestoreInviteesDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRestoreInviteesDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRestoreInviteesDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRestoreInviteesDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRestoreInviteesDetails", SHARED_CONTENT_RESTORE_INVITEES_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRestoreInviteesDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRestoreInviteesDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRestoreInviteesType {
    pub description: String,
}

impl SharedContentRestoreInviteesType {
    pub fn new(description: String) -> Self {
        SharedContentRestoreInviteesType {
            description,
        }
    }

}

const SHARED_CONTENT_RESTORE_INVITEES_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRestoreInviteesType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRestoreInviteesType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRestoreInviteesType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRestoreInviteesType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRestoreInviteesType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRestoreInviteesType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRestoreInviteesType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRestoreInviteesType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRestoreInviteesType", SHARED_CONTENT_RESTORE_INVITEES_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRestoreInviteesType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRestoreInviteesType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored users and/or groups to membership of shared file/folder.
#[derive(Debug)]
pub struct SharedContentRestoreMemberDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
}

impl SharedContentRestoreMemberDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedContentRestoreMemberDetails {
            shared_content_access_level,
        }
    }

}

const SHARED_CONTENT_RESTORE_MEMBER_DETAILS_FIELDS: &[&str] = &["shared_content_access_level"];
impl SharedContentRestoreMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRestoreMemberDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRestoreMemberDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRestoreMemberDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRestoreMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRestoreMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRestoreMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRestoreMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRestoreMemberDetails", SHARED_CONTENT_RESTORE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRestoreMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRestoreMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentRestoreMemberType {
    pub description: String,
}

impl SharedContentRestoreMemberType {
    pub fn new(description: String) -> Self {
        SharedContentRestoreMemberType {
            description,
        }
    }

}

const SHARED_CONTENT_RESTORE_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentRestoreMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentRestoreMemberType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentRestoreMemberType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentRestoreMemberType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentRestoreMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentRestoreMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentRestoreMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentRestoreMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentRestoreMemberType", SHARED_CONTENT_RESTORE_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentRestoreMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentRestoreMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unshared file/folder by clearing membership.
#[derive(Debug)]
pub struct SharedContentUnshareDetails {
}

impl Default for SharedContentUnshareDetails {
    fn default() -> Self {
        SharedContentUnshareDetails {
        }
    }
}

const SHARED_CONTENT_UNSHARE_DETAILS_FIELDS: &[&str] = &[];
impl SharedContentUnshareDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedContentUnshareDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SharedContentUnshareDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentUnshareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentUnshareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentUnshareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentUnshareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentUnshareDetails", SHARED_CONTENT_UNSHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentUnshareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedContentUnshareDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedContentUnshareType {
    pub description: String,
}

impl SharedContentUnshareType {
    pub fn new(description: String) -> Self {
        SharedContentUnshareType {
            description,
        }
    }

}

const SHARED_CONTENT_UNSHARE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentUnshareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentUnshareType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentUnshareType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentUnshareType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentUnshareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentUnshareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentUnshareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentUnshareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentUnshareType", SHARED_CONTENT_UNSHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentUnshareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentUnshareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Previewed shared file/folder.
#[derive(Debug)]
pub struct SharedContentViewDetails {
    /// Shared content link.
    pub shared_content_link: String,
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// The shared content owner.
    pub shared_content_owner: Option<UserLogInfo>,
}

impl SharedContentViewDetails {
    pub fn new(
        shared_content_link: String,
        shared_content_access_level: super::sharing::AccessLevel,
    ) -> Self {
        SharedContentViewDetails {
            shared_content_link,
            shared_content_access_level,
            shared_content_owner: None,
        }
    }

    pub fn with_shared_content_owner(mut self, value: Option<UserLogInfo>) -> Self {
        self.shared_content_owner = value;
        self
    }

}

const SHARED_CONTENT_VIEW_DETAILS_FIELDS: &[&str] = &["shared_content_link",
                                                      "shared_content_access_level",
                                                      "shared_content_owner"];
impl SharedContentViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentViewDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentViewDetails>, V::Error> {
        let mut field_shared_content_link = None;
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_owner = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_owner" => {
                    if field_shared_content_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_owner"));
                    }
                    field_shared_content_owner = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentViewDetails {
            shared_content_link: field_shared_content_link.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_link"))?,
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_owner: field_shared_content_owner,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_owner", &self.shared_content_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentViewDetails", SHARED_CONTENT_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentViewDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedContentViewType {
    pub description: String,
}

impl SharedContentViewType {
    pub fn new(description: String) -> Self {
        SharedContentViewType {
            description,
        }
    }

}

const SHARED_CONTENT_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl SharedContentViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedContentViewType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedContentViewType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedContentViewType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedContentViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedContentViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedContentViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedContentViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedContentViewType", SHARED_CONTENT_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedContentViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedContentViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can access shared folder via link.
#[derive(Debug)]
pub struct SharedFolderChangeLinkPolicyDetails {
    /// New shared folder link policy.
    pub new_value: super::sharing::SharedLinkPolicy,
    /// Previous shared folder link policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::sharing::SharedLinkPolicy>,
}

impl SharedFolderChangeLinkPolicyDetails {
    pub fn new(new_value: super::sharing::SharedLinkPolicy) -> Self {
        SharedFolderChangeLinkPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::SharedLinkPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_LINK_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                   "previous_value"];
impl SharedFolderChangeLinkPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderChangeLinkPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderChangeLinkPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderChangeLinkPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeLinkPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeLinkPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeLinkPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeLinkPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeLinkPolicyDetails", SHARED_FOLDER_CHANGE_LINK_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeLinkPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeLinkPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderChangeLinkPolicyType {
    pub description: String,
}

impl SharedFolderChangeLinkPolicyType {
    pub fn new(description: String) -> Self {
        SharedFolderChangeLinkPolicyType {
            description,
        }
    }

}

const SHARED_FOLDER_CHANGE_LINK_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderChangeLinkPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderChangeLinkPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderChangeLinkPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderChangeLinkPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeLinkPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeLinkPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeLinkPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeLinkPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeLinkPolicyType", SHARED_FOLDER_CHANGE_LINK_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeLinkPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeLinkPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether shared folder inherits members from parent folder.
#[derive(Debug)]
pub struct SharedFolderChangeMembersInheritancePolicyDetails {
    /// New member inheritance policy.
    pub new_value: SharedFolderMembersInheritancePolicy,
    /// Previous member inheritance policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharedFolderMembersInheritancePolicy>,
}

impl SharedFolderChangeMembersInheritancePolicyDetails {
    pub fn new(new_value: SharedFolderMembersInheritancePolicy) -> Self {
        SharedFolderChangeMembersInheritancePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<SharedFolderMembersInheritancePolicy>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                                  "previous_value"];
impl SharedFolderChangeMembersInheritancePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderChangeMembersInheritancePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderChangeMembersInheritancePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderChangeMembersInheritancePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersInheritancePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersInheritancePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersInheritancePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersInheritancePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersInheritancePolicyDetails", SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersInheritancePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersInheritancePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderChangeMembersInheritancePolicyType {
    pub description: String,
}

impl SharedFolderChangeMembersInheritancePolicyType {
    pub fn new(description: String) -> Self {
        SharedFolderChangeMembersInheritancePolicyType {
            description,
        }
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderChangeMembersInheritancePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderChangeMembersInheritancePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderChangeMembersInheritancePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderChangeMembersInheritancePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersInheritancePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersInheritancePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersInheritancePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersInheritancePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersInheritancePolicyType", SHARED_FOLDER_CHANGE_MEMBERS_INHERITANCE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersInheritancePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersInheritancePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can add/remove members of shared folder.
#[derive(Debug)]
pub struct SharedFolderChangeMembersManagementPolicyDetails {
    /// New members management policy.
    pub new_value: super::sharing::AclUpdatePolicy,
    /// Previous members management policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::sharing::AclUpdatePolicy>,
}

impl SharedFolderChangeMembersManagementPolicyDetails {
    pub fn new(new_value: super::sharing::AclUpdatePolicy) -> Self {
        SharedFolderChangeMembersManagementPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::AclUpdatePolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                                 "previous_value"];
impl SharedFolderChangeMembersManagementPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderChangeMembersManagementPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderChangeMembersManagementPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderChangeMembersManagementPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersManagementPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersManagementPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersManagementPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersManagementPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersManagementPolicyDetails", SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersManagementPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersManagementPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderChangeMembersManagementPolicyType {
    pub description: String,
}

impl SharedFolderChangeMembersManagementPolicyType {
    pub fn new(description: String) -> Self {
        SharedFolderChangeMembersManagementPolicyType {
            description,
        }
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderChangeMembersManagementPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderChangeMembersManagementPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderChangeMembersManagementPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderChangeMembersManagementPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersManagementPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersManagementPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersManagementPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersManagementPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersManagementPolicyType", SHARED_FOLDER_CHANGE_MEMBERS_MANAGEMENT_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersManagementPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersManagementPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed who can become member of shared folder.
#[derive(Debug)]
pub struct SharedFolderChangeMembersPolicyDetails {
    /// New external invite policy.
    pub new_value: super::sharing::MemberPolicy,
    /// Previous external invite policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::sharing::MemberPolicy>,
}

impl SharedFolderChangeMembersPolicyDetails {
    pub fn new(new_value: super::sharing::MemberPolicy) -> Self {
        SharedFolderChangeMembersPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::MemberPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                      "previous_value"];
impl SharedFolderChangeMembersPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderChangeMembersPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderChangeMembersPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderChangeMembersPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersPolicyDetails", SHARED_FOLDER_CHANGE_MEMBERS_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderChangeMembersPolicyType {
    pub description: String,
}

impl SharedFolderChangeMembersPolicyType {
    pub fn new(description: String) -> Self {
        SharedFolderChangeMembersPolicyType {
            description,
        }
    }

}

const SHARED_FOLDER_CHANGE_MEMBERS_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderChangeMembersPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderChangeMembersPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderChangeMembersPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderChangeMembersPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderChangeMembersPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderChangeMembersPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderChangeMembersPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderChangeMembersPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderChangeMembersPolicyType", SHARED_FOLDER_CHANGE_MEMBERS_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderChangeMembersPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderChangeMembersPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created shared folder.
#[derive(Debug)]
pub struct SharedFolderCreateDetails {
    /// Target namespace ID. Might be missing due to historical data gap.
    pub target_ns_id: Option<NamespaceId>,
}

impl Default for SharedFolderCreateDetails {
    fn default() -> Self {
        SharedFolderCreateDetails {
            target_ns_id: None,
        }
    }
}

const SHARED_FOLDER_CREATE_DETAILS_FIELDS: &[&str] = &["target_ns_id"];
impl SharedFolderCreateDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderCreateDetails, V::Error> {
        let mut field_target_ns_id = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "target_ns_id" => {
                    if field_target_ns_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_ns_id"));
                    }
                    field_target_ns_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedFolderCreateDetails {
            target_ns_id: field_target_ns_id,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_ns_id", &self.target_ns_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderCreateDetails", SHARED_FOLDER_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderCreateDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderCreateType {
    pub description: String,
}

impl SharedFolderCreateType {
    pub fn new(description: String) -> Self {
        SharedFolderCreateType {
            description,
        }
    }

}

const SHARED_FOLDER_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderCreateType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderCreateType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderCreateType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderCreateType", SHARED_FOLDER_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Declined team member's invite to shared folder.
#[derive(Debug)]
pub struct SharedFolderDeclineInvitationDetails {
}

impl Default for SharedFolderDeclineInvitationDetails {
    fn default() -> Self {
        SharedFolderDeclineInvitationDetails {
        }
    }
}

const SHARED_FOLDER_DECLINE_INVITATION_DETAILS_FIELDS: &[&str] = &[];
impl SharedFolderDeclineInvitationDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderDeclineInvitationDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SharedFolderDeclineInvitationDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderDeclineInvitationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderDeclineInvitationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderDeclineInvitationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderDeclineInvitationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderDeclineInvitationDetails", SHARED_FOLDER_DECLINE_INVITATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderDeclineInvitationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedFolderDeclineInvitationDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderDeclineInvitationType {
    pub description: String,
}

impl SharedFolderDeclineInvitationType {
    pub fn new(description: String) -> Self {
        SharedFolderDeclineInvitationType {
            description,
        }
    }

}

const SHARED_FOLDER_DECLINE_INVITATION_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderDeclineInvitationType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderDeclineInvitationType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderDeclineInvitationType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderDeclineInvitationType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderDeclineInvitationType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderDeclineInvitationType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderDeclineInvitationType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderDeclineInvitationType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderDeclineInvitationType", SHARED_FOLDER_DECLINE_INVITATION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderDeclineInvitationType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderDeclineInvitationType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Specifies if a shared folder inherits its members from the parent folder.
#[derive(Debug)]
pub enum SharedFolderMembersInheritancePolicy {
    InheritMembers,
    DontInheritMembers,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMembersInheritancePolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedFolderMembersInheritancePolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMembersInheritancePolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "inherit_members" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedFolderMembersInheritancePolicy::InheritMembers)
                    }
                    "dont_inherit_members" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedFolderMembersInheritancePolicy::DontInheritMembers)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedFolderMembersInheritancePolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["inherit_members",
                                    "dont_inherit_members",
                                    "other"];
        deserializer.deserialize_struct("SharedFolderMembersInheritancePolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMembersInheritancePolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedFolderMembersInheritancePolicy::InheritMembers => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMembersInheritancePolicy", 1)?;
                s.serialize_field(".tag", "inherit_members")?;
                s.end()
            }
            SharedFolderMembersInheritancePolicy::DontInheritMembers => {
                // unit
                let mut s = serializer.serialize_struct("SharedFolderMembersInheritancePolicy", 1)?;
                s.serialize_field(".tag", "dont_inherit_members")?;
                s.end()
            }
            SharedFolderMembersInheritancePolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added shared folder to own Dropbox.
#[derive(Debug)]
pub struct SharedFolderMountDetails {
}

impl Default for SharedFolderMountDetails {
    fn default() -> Self {
        SharedFolderMountDetails {
        }
    }
}

const SHARED_FOLDER_MOUNT_DETAILS_FIELDS: &[&str] = &[];
impl SharedFolderMountDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderMountDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SharedFolderMountDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderMountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderMountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderMountDetails", SHARED_FOLDER_MOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedFolderMountDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderMountType {
    pub description: String,
}

impl SharedFolderMountType {
    pub fn new(description: String) -> Self {
        SharedFolderMountType {
            description,
        }
    }

}

const SHARED_FOLDER_MOUNT_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderMountType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderMountType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderMountType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderMountType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderMountType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderMountType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderMountType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderMountType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderMountType", SHARED_FOLDER_MOUNT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderMountType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderMountType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed parent of shared folder.
#[derive(Debug)]
pub struct SharedFolderNestDetails {
    /// Previous parent namespace ID. Might be missing due to historical data gap.
    pub previous_parent_ns_id: Option<NamespaceId>,
    /// New parent namespace ID. Might be missing due to historical data gap.
    pub new_parent_ns_id: Option<NamespaceId>,
    /// Previous namespace path. Might be missing due to historical data gap.
    pub previous_ns_path: Option<FilePath>,
    /// New namespace path. Might be missing due to historical data gap.
    pub new_ns_path: Option<FilePath>,
}

impl Default for SharedFolderNestDetails {
    fn default() -> Self {
        SharedFolderNestDetails {
            previous_parent_ns_id: None,
            new_parent_ns_id: None,
            previous_ns_path: None,
            new_ns_path: None,
        }
    }
}

const SHARED_FOLDER_NEST_DETAILS_FIELDS: &[&str] = &["previous_parent_ns_id",
                                                     "new_parent_ns_id",
                                                     "previous_ns_path",
                                                     "new_ns_path"];
impl SharedFolderNestDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderNestDetails, V::Error> {
        let mut field_previous_parent_ns_id = None;
        let mut field_new_parent_ns_id = None;
        let mut field_previous_ns_path = None;
        let mut field_new_ns_path = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "previous_parent_ns_id" => {
                    if field_previous_parent_ns_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_parent_ns_id"));
                    }
                    field_previous_parent_ns_id = Some(map.next_value()?);
                }
                "new_parent_ns_id" => {
                    if field_new_parent_ns_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_parent_ns_id"));
                    }
                    field_new_parent_ns_id = Some(map.next_value()?);
                }
                "previous_ns_path" => {
                    if field_previous_ns_path.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_ns_path"));
                    }
                    field_previous_ns_path = Some(map.next_value()?);
                }
                "new_ns_path" => {
                    if field_new_ns_path.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_ns_path"));
                    }
                    field_new_ns_path = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedFolderNestDetails {
            previous_parent_ns_id: field_previous_parent_ns_id,
            new_parent_ns_id: field_new_parent_ns_id,
            previous_ns_path: field_previous_ns_path,
            new_ns_path: field_new_ns_path,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_parent_ns_id", &self.previous_parent_ns_id)?;
        s.serialize_field("new_parent_ns_id", &self.new_parent_ns_id)?;
        s.serialize_field("previous_ns_path", &self.previous_ns_path)?;
        s.serialize_field("new_ns_path", &self.new_ns_path)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderNestDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderNestDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderNestDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderNestDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderNestDetails", SHARED_FOLDER_NEST_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderNestDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderNestDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderNestType {
    pub description: String,
}

impl SharedFolderNestType {
    pub fn new(description: String) -> Self {
        SharedFolderNestType {
            description,
        }
    }

}

const SHARED_FOLDER_NEST_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderNestType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderNestType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderNestType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderNestType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderNestType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderNestType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderNestType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderNestType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderNestType", SHARED_FOLDER_NEST_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderNestType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderNestType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Transferred ownership of shared folder to another member.
#[derive(Debug)]
pub struct SharedFolderTransferOwnershipDetails {
    /// The email address of the new shared folder owner.
    pub new_owner_email: EmailAddress,
    /// The email address of the previous shared folder owner.
    pub previous_owner_email: Option<EmailAddress>,
}

impl SharedFolderTransferOwnershipDetails {
    pub fn new(new_owner_email: EmailAddress) -> Self {
        SharedFolderTransferOwnershipDetails {
            new_owner_email,
            previous_owner_email: None,
        }
    }

    pub fn with_previous_owner_email(mut self, value: Option<EmailAddress>) -> Self {
        self.previous_owner_email = value;
        self
    }

}

const SHARED_FOLDER_TRANSFER_OWNERSHIP_DETAILS_FIELDS: &[&str] = &["new_owner_email",
                                                                   "previous_owner_email"];
impl SharedFolderTransferOwnershipDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderTransferOwnershipDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderTransferOwnershipDetails>, V::Error> {
        let mut field_new_owner_email = None;
        let mut field_previous_owner_email = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_owner_email" => {
                    if field_new_owner_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_owner_email"));
                    }
                    field_new_owner_email = Some(map.next_value()?);
                }
                "previous_owner_email" => {
                    if field_previous_owner_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_owner_email"));
                    }
                    field_previous_owner_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderTransferOwnershipDetails {
            new_owner_email: field_new_owner_email.ok_or_else(|| ::serde::de::Error::missing_field("new_owner_email"))?,
            previous_owner_email: field_previous_owner_email,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_owner_email", &self.new_owner_email)?;
        s.serialize_field("previous_owner_email", &self.previous_owner_email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderTransferOwnershipDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderTransferOwnershipDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderTransferOwnershipDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderTransferOwnershipDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderTransferOwnershipDetails", SHARED_FOLDER_TRANSFER_OWNERSHIP_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderTransferOwnershipDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderTransferOwnershipDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderTransferOwnershipType {
    pub description: String,
}

impl SharedFolderTransferOwnershipType {
    pub fn new(description: String) -> Self {
        SharedFolderTransferOwnershipType {
            description,
        }
    }

}

const SHARED_FOLDER_TRANSFER_OWNERSHIP_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderTransferOwnershipType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderTransferOwnershipType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderTransferOwnershipType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderTransferOwnershipType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderTransferOwnershipType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderTransferOwnershipType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderTransferOwnershipType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderTransferOwnershipType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderTransferOwnershipType", SHARED_FOLDER_TRANSFER_OWNERSHIP_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderTransferOwnershipType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderTransferOwnershipType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted shared folder from Dropbox.
#[derive(Debug)]
pub struct SharedFolderUnmountDetails {
}

impl Default for SharedFolderUnmountDetails {
    fn default() -> Self {
        SharedFolderUnmountDetails {
        }
    }
}

const SHARED_FOLDER_UNMOUNT_DETAILS_FIELDS: &[&str] = &[];
impl SharedFolderUnmountDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedFolderUnmountDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SharedFolderUnmountDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderUnmountDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderUnmountDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderUnmountDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderUnmountDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderUnmountDetails", SHARED_FOLDER_UNMOUNT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderUnmountDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedFolderUnmountDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedFolderUnmountType {
    pub description: String,
}

impl SharedFolderUnmountType {
    pub fn new(description: String) -> Self {
        SharedFolderUnmountType {
            description,
        }
    }

}

const SHARED_FOLDER_UNMOUNT_TYPE_FIELDS: &[&str] = &["description"];
impl SharedFolderUnmountType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedFolderUnmountType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedFolderUnmountType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedFolderUnmountType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedFolderUnmountType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedFolderUnmountType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedFolderUnmountType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedFolderUnmountType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedFolderUnmountType", SHARED_FOLDER_UNMOUNT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedFolderUnmountType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedFolderUnmountType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Shared link access level.
#[derive(Debug)]
pub enum SharedLinkAccessLevel {
    None,
    Reader,
    Writer,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkAccessLevel {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedLinkAccessLevel;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkAccessLevel structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "none" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedLinkAccessLevel::None)
                    }
                    "reader" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedLinkAccessLevel::Reader)
                    }
                    "writer" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedLinkAccessLevel::Writer)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedLinkAccessLevel::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["none",
                                    "reader",
                                    "writer",
                                    "other"];
        deserializer.deserialize_struct("SharedLinkAccessLevel", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkAccessLevel {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedLinkAccessLevel::None => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessLevel", 1)?;
                s.serialize_field(".tag", "none")?;
                s.end()
            }
            SharedLinkAccessLevel::Reader => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessLevel", 1)?;
                s.serialize_field(".tag", "reader")?;
                s.end()
            }
            SharedLinkAccessLevel::Writer => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkAccessLevel", 1)?;
                s.serialize_field(".tag", "writer")?;
                s.end()
            }
            SharedLinkAccessLevel::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added shared link expiration date.
#[derive(Debug)]
pub struct SharedLinkAddExpiryDetails {
    /// New shared link expiration date.
    pub new_value: super::common::DropboxTimestamp,
}

impl SharedLinkAddExpiryDetails {
    pub fn new(new_value: super::common::DropboxTimestamp) -> Self {
        SharedLinkAddExpiryDetails {
            new_value,
        }
    }

}

const SHARED_LINK_ADD_EXPIRY_DETAILS_FIELDS: &[&str] = &["new_value"];
impl SharedLinkAddExpiryDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkAddExpiryDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkAddExpiryDetails>, V::Error> {
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkAddExpiryDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkAddExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkAddExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkAddExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkAddExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkAddExpiryDetails", SHARED_LINK_ADD_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkAddExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkAddExpiryDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkAddExpiryType {
    pub description: String,
}

impl SharedLinkAddExpiryType {
    pub fn new(description: String) -> Self {
        SharedLinkAddExpiryType {
            description,
        }
    }

}

const SHARED_LINK_ADD_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkAddExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkAddExpiryType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkAddExpiryType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkAddExpiryType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkAddExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkAddExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkAddExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkAddExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkAddExpiryType", SHARED_LINK_ADD_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkAddExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkAddExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed shared link expiration date.
#[derive(Debug)]
pub struct SharedLinkChangeExpiryDetails {
    /// New shared link expiration date. Might be missing due to historical data gap.
    pub new_value: Option<super::common::DropboxTimestamp>,
    /// Previous shared link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedLinkChangeExpiryDetails {
    fn default() -> Self {
        SharedLinkChangeExpiryDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const SHARED_LINK_CHANGE_EXPIRY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                            "previous_value"];
impl SharedLinkChangeExpiryDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkChangeExpiryDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedLinkChangeExpiryDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkChangeExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkChangeExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkChangeExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkChangeExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkChangeExpiryDetails", SHARED_LINK_CHANGE_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkChangeExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkChangeExpiryDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkChangeExpiryType {
    pub description: String,
}

impl SharedLinkChangeExpiryType {
    pub fn new(description: String) -> Self {
        SharedLinkChangeExpiryType {
            description,
        }
    }

}

const SHARED_LINK_CHANGE_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkChangeExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkChangeExpiryType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkChangeExpiryType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkChangeExpiryType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkChangeExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkChangeExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkChangeExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkChangeExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkChangeExpiryType", SHARED_LINK_CHANGE_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkChangeExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkChangeExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed visibility of shared link.
#[derive(Debug)]
pub struct SharedLinkChangeVisibilityDetails {
    /// New shared link visibility.
    pub new_value: SharedLinkVisibility,
    /// Previous shared link visibility. Might be missing due to historical data gap.
    pub previous_value: Option<SharedLinkVisibility>,
}

impl SharedLinkChangeVisibilityDetails {
    pub fn new(new_value: SharedLinkVisibility) -> Self {
        SharedLinkChangeVisibilityDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharedLinkVisibility>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_LINK_CHANGE_VISIBILITY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                "previous_value"];
impl SharedLinkChangeVisibilityDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkChangeVisibilityDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkChangeVisibilityDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkChangeVisibilityDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkChangeVisibilityDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkChangeVisibilityDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkChangeVisibilityDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkChangeVisibilityDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkChangeVisibilityDetails", SHARED_LINK_CHANGE_VISIBILITY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkChangeVisibilityDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkChangeVisibilityDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkChangeVisibilityType {
    pub description: String,
}

impl SharedLinkChangeVisibilityType {
    pub fn new(description: String) -> Self {
        SharedLinkChangeVisibilityType {
            description,
        }
    }

}

const SHARED_LINK_CHANGE_VISIBILITY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkChangeVisibilityType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkChangeVisibilityType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkChangeVisibilityType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkChangeVisibilityType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkChangeVisibilityType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkChangeVisibilityType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkChangeVisibilityType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkChangeVisibilityType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkChangeVisibilityType", SHARED_LINK_CHANGE_VISIBILITY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkChangeVisibilityType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkChangeVisibilityType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added file/folder to Dropbox from shared link.
#[derive(Debug)]
pub struct SharedLinkCopyDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
}

impl Default for SharedLinkCopyDetails {
    fn default() -> Self {
        SharedLinkCopyDetails {
            shared_link_owner: None,
        }
    }
}

const SHARED_LINK_COPY_DETAILS_FIELDS: &[&str] = &["shared_link_owner"];
impl SharedLinkCopyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkCopyDetails, V::Error> {
        let mut field_shared_link_owner = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedLinkCopyDetails {
            shared_link_owner: field_shared_link_owner,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkCopyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkCopyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkCopyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkCopyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkCopyDetails", SHARED_LINK_COPY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkCopyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkCopyDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkCopyType {
    pub description: String,
}

impl SharedLinkCopyType {
    pub fn new(description: String) -> Self {
        SharedLinkCopyType {
            description,
        }
    }

}

const SHARED_LINK_COPY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkCopyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkCopyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkCopyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkCopyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkCopyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkCopyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkCopyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkCopyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkCopyType", SHARED_LINK_COPY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkCopyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkCopyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created shared link.
#[derive(Debug)]
pub struct SharedLinkCreateDetails {
    /// Defines who can access the shared link. Might be missing due to historical data gap.
    pub shared_link_access_level: Option<SharedLinkAccessLevel>,
}

impl Default for SharedLinkCreateDetails {
    fn default() -> Self {
        SharedLinkCreateDetails {
            shared_link_access_level: None,
        }
    }
}

const SHARED_LINK_CREATE_DETAILS_FIELDS: &[&str] = &["shared_link_access_level"];
impl SharedLinkCreateDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkCreateDetails, V::Error> {
        let mut field_shared_link_access_level = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "shared_link_access_level" => {
                    if field_shared_link_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_link_access_level"));
                    }
                    field_shared_link_access_level = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedLinkCreateDetails {
            shared_link_access_level: field_shared_link_access_level,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_access_level", &self.shared_link_access_level)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkCreateDetails", SHARED_LINK_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkCreateDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkCreateType {
    pub description: String,
}

impl SharedLinkCreateType {
    pub fn new(description: String) -> Self {
        SharedLinkCreateType {
            description,
        }
    }

}

const SHARED_LINK_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkCreateType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkCreateType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkCreateType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkCreateType", SHARED_LINK_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed shared link.
#[derive(Debug)]
pub struct SharedLinkDisableDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
}

impl Default for SharedLinkDisableDetails {
    fn default() -> Self {
        SharedLinkDisableDetails {
            shared_link_owner: None,
        }
    }
}

const SHARED_LINK_DISABLE_DETAILS_FIELDS: &[&str] = &["shared_link_owner"];
impl SharedLinkDisableDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkDisableDetails, V::Error> {
        let mut field_shared_link_owner = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedLinkDisableDetails {
            shared_link_owner: field_shared_link_owner,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkDisableDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkDisableDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkDisableDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkDisableDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkDisableDetails", SHARED_LINK_DISABLE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkDisableDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkDisableDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkDisableType {
    pub description: String,
}

impl SharedLinkDisableType {
    pub fn new(description: String) -> Self {
        SharedLinkDisableType {
            description,
        }
    }

}

const SHARED_LINK_DISABLE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkDisableType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkDisableType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkDisableType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkDisableType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkDisableType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkDisableType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkDisableType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkDisableType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkDisableType", SHARED_LINK_DISABLE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkDisableType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkDisableType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded file/folder from shared link.
#[derive(Debug)]
pub struct SharedLinkDownloadDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
}

impl Default for SharedLinkDownloadDetails {
    fn default() -> Self {
        SharedLinkDownloadDetails {
            shared_link_owner: None,
        }
    }
}

const SHARED_LINK_DOWNLOAD_DETAILS_FIELDS: &[&str] = &["shared_link_owner"];
impl SharedLinkDownloadDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkDownloadDetails, V::Error> {
        let mut field_shared_link_owner = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedLinkDownloadDetails {
            shared_link_owner: field_shared_link_owner,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkDownloadDetails", SHARED_LINK_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkDownloadDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkDownloadType {
    pub description: String,
}

impl SharedLinkDownloadType {
    pub fn new(description: String) -> Self {
        SharedLinkDownloadType {
            description,
        }
    }

}

const SHARED_LINK_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkDownloadType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkDownloadType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkDownloadType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkDownloadType", SHARED_LINK_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed shared link expiration date.
#[derive(Debug)]
pub struct SharedLinkRemoveExpiryDetails {
    /// Previous shared link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl Default for SharedLinkRemoveExpiryDetails {
    fn default() -> Self {
        SharedLinkRemoveExpiryDetails {
            previous_value: None,
        }
    }
}

const SHARED_LINK_REMOVE_EXPIRY_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl SharedLinkRemoveExpiryDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkRemoveExpiryDetails, V::Error> {
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedLinkRemoveExpiryDetails {
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkRemoveExpiryDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkRemoveExpiryDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkRemoveExpiryDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkRemoveExpiryDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkRemoveExpiryDetails", SHARED_LINK_REMOVE_EXPIRY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkRemoveExpiryDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkRemoveExpiryDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkRemoveExpiryType {
    pub description: String,
}

impl SharedLinkRemoveExpiryType {
    pub fn new(description: String) -> Self {
        SharedLinkRemoveExpiryType {
            description,
        }
    }

}

const SHARED_LINK_REMOVE_EXPIRY_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkRemoveExpiryType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkRemoveExpiryType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkRemoveExpiryType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkRemoveExpiryType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkRemoveExpiryType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkRemoveExpiryType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkRemoveExpiryType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkRemoveExpiryType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkRemoveExpiryType", SHARED_LINK_REMOVE_EXPIRY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkRemoveExpiryType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkRemoveExpiryType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added an expiration date to the shared link.
#[derive(Debug)]
pub struct SharedLinkSettingsAddExpirationDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// Shared content link.
    pub shared_content_link: Option<String>,
    /// New shared content link expiration date. Might be missing due to historical data gap.
    pub new_value: Option<super::common::DropboxTimestamp>,
}

impl SharedLinkSettingsAddExpirationDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedLinkSettingsAddExpirationDetails {
            shared_content_access_level,
            shared_content_link: None,
            new_value: None,
        }
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

    pub fn with_new_value(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.new_value = value;
        self
    }

}

const SHARED_LINK_SETTINGS_ADD_EXPIRATION_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                      "shared_content_link",
                                                                      "new_value"];
impl SharedLinkSettingsAddExpirationDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsAddExpirationDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsAddExpirationDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_link = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsAddExpirationDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_link: field_shared_content_link,
            new_value: field_new_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsAddExpirationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsAddExpirationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsAddExpirationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsAddExpirationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsAddExpirationDetails", SHARED_LINK_SETTINGS_ADD_EXPIRATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsAddExpirationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsAddExpirationDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkSettingsAddExpirationType {
    pub description: String,
}

impl SharedLinkSettingsAddExpirationType {
    pub fn new(description: String) -> Self {
        SharedLinkSettingsAddExpirationType {
            description,
        }
    }

}

const SHARED_LINK_SETTINGS_ADD_EXPIRATION_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkSettingsAddExpirationType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsAddExpirationType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsAddExpirationType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsAddExpirationType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsAddExpirationType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsAddExpirationType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsAddExpirationType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsAddExpirationType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsAddExpirationType", SHARED_LINK_SETTINGS_ADD_EXPIRATION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsAddExpirationType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsAddExpirationType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added a password to the shared link.
#[derive(Debug)]
pub struct SharedLinkSettingsAddPasswordDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl SharedLinkSettingsAddPasswordDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedLinkSettingsAddPasswordDetails {
            shared_content_access_level,
            shared_content_link: None,
        }
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

}

const SHARED_LINK_SETTINGS_ADD_PASSWORD_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                    "shared_content_link"];
impl SharedLinkSettingsAddPasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsAddPasswordDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsAddPasswordDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_link = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsAddPasswordDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_link: field_shared_content_link,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsAddPasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsAddPasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsAddPasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsAddPasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsAddPasswordDetails", SHARED_LINK_SETTINGS_ADD_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsAddPasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsAddPasswordDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkSettingsAddPasswordType {
    pub description: String,
}

impl SharedLinkSettingsAddPasswordType {
    pub fn new(description: String) -> Self {
        SharedLinkSettingsAddPasswordType {
            description,
        }
    }

}

const SHARED_LINK_SETTINGS_ADD_PASSWORD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkSettingsAddPasswordType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsAddPasswordType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsAddPasswordType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsAddPasswordType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsAddPasswordType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsAddPasswordType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsAddPasswordType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsAddPasswordType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsAddPasswordType", SHARED_LINK_SETTINGS_ADD_PASSWORD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsAddPasswordType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsAddPasswordType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Disabled downloads.
#[derive(Debug)]
pub struct SharedLinkSettingsAllowDownloadDisabledDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl SharedLinkSettingsAllowDownloadDisabledDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedLinkSettingsAllowDownloadDisabledDetails {
            shared_content_access_level,
            shared_content_link: None,
        }
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

}

const SHARED_LINK_SETTINGS_ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                               "shared_content_link"];
impl SharedLinkSettingsAllowDownloadDisabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsAllowDownloadDisabledDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsAllowDownloadDisabledDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_link = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsAllowDownloadDisabledDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_link: field_shared_content_link,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsAllowDownloadDisabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsAllowDownloadDisabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsAllowDownloadDisabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsAllowDownloadDisabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsAllowDownloadDisabledDetails", SHARED_LINK_SETTINGS_ALLOW_DOWNLOAD_DISABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsAllowDownloadDisabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsAllowDownloadDisabledDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkSettingsAllowDownloadDisabledType {
    pub description: String,
}

impl SharedLinkSettingsAllowDownloadDisabledType {
    pub fn new(description: String) -> Self {
        SharedLinkSettingsAllowDownloadDisabledType {
            description,
        }
    }

}

const SHARED_LINK_SETTINGS_ALLOW_DOWNLOAD_DISABLED_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkSettingsAllowDownloadDisabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsAllowDownloadDisabledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsAllowDownloadDisabledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsAllowDownloadDisabledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsAllowDownloadDisabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsAllowDownloadDisabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsAllowDownloadDisabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsAllowDownloadDisabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsAllowDownloadDisabledType", SHARED_LINK_SETTINGS_ALLOW_DOWNLOAD_DISABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsAllowDownloadDisabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsAllowDownloadDisabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled downloads.
#[derive(Debug)]
pub struct SharedLinkSettingsAllowDownloadEnabledDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl SharedLinkSettingsAllowDownloadEnabledDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedLinkSettingsAllowDownloadEnabledDetails {
            shared_content_access_level,
            shared_content_link: None,
        }
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

}

const SHARED_LINK_SETTINGS_ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                              "shared_content_link"];
impl SharedLinkSettingsAllowDownloadEnabledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsAllowDownloadEnabledDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsAllowDownloadEnabledDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_link = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsAllowDownloadEnabledDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_link: field_shared_content_link,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsAllowDownloadEnabledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsAllowDownloadEnabledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsAllowDownloadEnabledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsAllowDownloadEnabledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsAllowDownloadEnabledDetails", SHARED_LINK_SETTINGS_ALLOW_DOWNLOAD_ENABLED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsAllowDownloadEnabledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsAllowDownloadEnabledDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkSettingsAllowDownloadEnabledType {
    pub description: String,
}

impl SharedLinkSettingsAllowDownloadEnabledType {
    pub fn new(description: String) -> Self {
        SharedLinkSettingsAllowDownloadEnabledType {
            description,
        }
    }

}

const SHARED_LINK_SETTINGS_ALLOW_DOWNLOAD_ENABLED_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkSettingsAllowDownloadEnabledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsAllowDownloadEnabledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsAllowDownloadEnabledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsAllowDownloadEnabledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsAllowDownloadEnabledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsAllowDownloadEnabledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsAllowDownloadEnabledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsAllowDownloadEnabledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsAllowDownloadEnabledType", SHARED_LINK_SETTINGS_ALLOW_DOWNLOAD_ENABLED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsAllowDownloadEnabledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsAllowDownloadEnabledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the audience of the shared link.
#[derive(Debug)]
pub struct SharedLinkSettingsChangeAudienceDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// New link audience value.
    pub new_value: super::sharing::LinkAudience,
    /// Shared content link.
    pub shared_content_link: Option<String>,
    /// Previous link audience value.
    pub previous_value: Option<super::sharing::LinkAudience>,
}

impl SharedLinkSettingsChangeAudienceDetails {
    pub fn new(
        shared_content_access_level: super::sharing::AccessLevel,
        new_value: super::sharing::LinkAudience,
    ) -> Self {
        SharedLinkSettingsChangeAudienceDetails {
            shared_content_access_level,
            new_value,
            shared_content_link: None,
            previous_value: None,
        }
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

    pub fn with_previous_value(mut self, value: Option<super::sharing::LinkAudience>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_LINK_SETTINGS_CHANGE_AUDIENCE_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                       "new_value",
                                                                       "shared_content_link",
                                                                       "previous_value"];
impl SharedLinkSettingsChangeAudienceDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsChangeAudienceDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsChangeAudienceDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_new_value = None;
        let mut field_shared_content_link = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsChangeAudienceDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            shared_content_link: field_shared_content_link,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsChangeAudienceDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsChangeAudienceDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsChangeAudienceDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsChangeAudienceDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsChangeAudienceDetails", SHARED_LINK_SETTINGS_CHANGE_AUDIENCE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsChangeAudienceDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsChangeAudienceDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkSettingsChangeAudienceType {
    pub description: String,
}

impl SharedLinkSettingsChangeAudienceType {
    pub fn new(description: String) -> Self {
        SharedLinkSettingsChangeAudienceType {
            description,
        }
    }

}

const SHARED_LINK_SETTINGS_CHANGE_AUDIENCE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkSettingsChangeAudienceType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsChangeAudienceType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsChangeAudienceType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsChangeAudienceType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsChangeAudienceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsChangeAudienceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsChangeAudienceType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsChangeAudienceType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsChangeAudienceType", SHARED_LINK_SETTINGS_CHANGE_AUDIENCE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsChangeAudienceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsChangeAudienceType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the expiration date of the shared link.
#[derive(Debug)]
pub struct SharedLinkSettingsChangeExpirationDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// Shared content link.
    pub shared_content_link: Option<String>,
    /// New shared content link expiration date. Might be missing due to historical data gap.
    pub new_value: Option<super::common::DropboxTimestamp>,
    /// Previous shared content link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl SharedLinkSettingsChangeExpirationDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedLinkSettingsChangeExpirationDetails {
            shared_content_access_level,
            shared_content_link: None,
            new_value: None,
            previous_value: None,
        }
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

    pub fn with_new_value(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.new_value = value;
        self
    }

    pub fn with_previous_value(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_LINK_SETTINGS_CHANGE_EXPIRATION_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                         "shared_content_link",
                                                                         "new_value",
                                                                         "previous_value"];
impl SharedLinkSettingsChangeExpirationDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsChangeExpirationDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsChangeExpirationDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_link = None;
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsChangeExpirationDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_link: field_shared_content_link,
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsChangeExpirationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsChangeExpirationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsChangeExpirationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsChangeExpirationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsChangeExpirationDetails", SHARED_LINK_SETTINGS_CHANGE_EXPIRATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsChangeExpirationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsChangeExpirationDetails", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkSettingsChangeExpirationType {
    pub description: String,
}

impl SharedLinkSettingsChangeExpirationType {
    pub fn new(description: String) -> Self {
        SharedLinkSettingsChangeExpirationType {
            description,
        }
    }

}

const SHARED_LINK_SETTINGS_CHANGE_EXPIRATION_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkSettingsChangeExpirationType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsChangeExpirationType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsChangeExpirationType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsChangeExpirationType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsChangeExpirationType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsChangeExpirationType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsChangeExpirationType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsChangeExpirationType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsChangeExpirationType", SHARED_LINK_SETTINGS_CHANGE_EXPIRATION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsChangeExpirationType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsChangeExpirationType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed the password of the shared link.
#[derive(Debug)]
pub struct SharedLinkSettingsChangePasswordDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl SharedLinkSettingsChangePasswordDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedLinkSettingsChangePasswordDetails {
            shared_content_access_level,
            shared_content_link: None,
        }
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

}

const SHARED_LINK_SETTINGS_CHANGE_PASSWORD_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                       "shared_content_link"];
impl SharedLinkSettingsChangePasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsChangePasswordDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsChangePasswordDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_link = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsChangePasswordDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_link: field_shared_content_link,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsChangePasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsChangePasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsChangePasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsChangePasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsChangePasswordDetails", SHARED_LINK_SETTINGS_CHANGE_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsChangePasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsChangePasswordDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkSettingsChangePasswordType {
    pub description: String,
}

impl SharedLinkSettingsChangePasswordType {
    pub fn new(description: String) -> Self {
        SharedLinkSettingsChangePasswordType {
            description,
        }
    }

}

const SHARED_LINK_SETTINGS_CHANGE_PASSWORD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkSettingsChangePasswordType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsChangePasswordType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsChangePasswordType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsChangePasswordType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsChangePasswordType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsChangePasswordType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsChangePasswordType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsChangePasswordType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsChangePasswordType", SHARED_LINK_SETTINGS_CHANGE_PASSWORD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsChangePasswordType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsChangePasswordType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the expiration date from the shared link.
#[derive(Debug)]
pub struct SharedLinkSettingsRemoveExpirationDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// Shared content link.
    pub shared_content_link: Option<String>,
    /// Previous shared link expiration date. Might be missing due to historical data gap.
    pub previous_value: Option<super::common::DropboxTimestamp>,
}

impl SharedLinkSettingsRemoveExpirationDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedLinkSettingsRemoveExpirationDetails {
            shared_content_access_level,
            shared_content_link: None,
            previous_value: None,
        }
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

    pub fn with_previous_value(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARED_LINK_SETTINGS_REMOVE_EXPIRATION_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                         "shared_content_link",
                                                                         "previous_value"];
impl SharedLinkSettingsRemoveExpirationDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsRemoveExpirationDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsRemoveExpirationDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_link = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsRemoveExpirationDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_link: field_shared_content_link,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsRemoveExpirationDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsRemoveExpirationDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsRemoveExpirationDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsRemoveExpirationDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsRemoveExpirationDetails", SHARED_LINK_SETTINGS_REMOVE_EXPIRATION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsRemoveExpirationDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsRemoveExpirationDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkSettingsRemoveExpirationType {
    pub description: String,
}

impl SharedLinkSettingsRemoveExpirationType {
    pub fn new(description: String) -> Self {
        SharedLinkSettingsRemoveExpirationType {
            description,
        }
    }

}

const SHARED_LINK_SETTINGS_REMOVE_EXPIRATION_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkSettingsRemoveExpirationType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsRemoveExpirationType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsRemoveExpirationType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsRemoveExpirationType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsRemoveExpirationType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsRemoveExpirationType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsRemoveExpirationType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsRemoveExpirationType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsRemoveExpirationType", SHARED_LINK_SETTINGS_REMOVE_EXPIRATION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsRemoveExpirationType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsRemoveExpirationType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed the password from the shared link.
#[derive(Debug)]
pub struct SharedLinkSettingsRemovePasswordDetails {
    /// Shared content access level.
    pub shared_content_access_level: super::sharing::AccessLevel,
    /// Shared content link.
    pub shared_content_link: Option<String>,
}

impl SharedLinkSettingsRemovePasswordDetails {
    pub fn new(shared_content_access_level: super::sharing::AccessLevel) -> Self {
        SharedLinkSettingsRemovePasswordDetails {
            shared_content_access_level,
            shared_content_link: None,
        }
    }

    pub fn with_shared_content_link(mut self, value: Option<String>) -> Self {
        self.shared_content_link = value;
        self
    }

}

const SHARED_LINK_SETTINGS_REMOVE_PASSWORD_DETAILS_FIELDS: &[&str] = &["shared_content_access_level",
                                                                       "shared_content_link"];
impl SharedLinkSettingsRemovePasswordDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsRemovePasswordDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsRemovePasswordDetails>, V::Error> {
        let mut field_shared_content_access_level = None;
        let mut field_shared_content_link = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "shared_content_access_level" => {
                    if field_shared_content_access_level.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_access_level"));
                    }
                    field_shared_content_access_level = Some(map.next_value()?);
                }
                "shared_content_link" => {
                    if field_shared_content_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_content_link"));
                    }
                    field_shared_content_link = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsRemovePasswordDetails {
            shared_content_access_level: field_shared_content_access_level.ok_or_else(|| ::serde::de::Error::missing_field("shared_content_access_level"))?,
            shared_content_link: field_shared_content_link,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_content_access_level", &self.shared_content_access_level)?;
        s.serialize_field("shared_content_link", &self.shared_content_link)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsRemovePasswordDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsRemovePasswordDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsRemovePasswordDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsRemovePasswordDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsRemovePasswordDetails", SHARED_LINK_SETTINGS_REMOVE_PASSWORD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsRemovePasswordDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsRemovePasswordDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkSettingsRemovePasswordType {
    pub description: String,
}

impl SharedLinkSettingsRemovePasswordType {
    pub fn new(description: String) -> Self {
        SharedLinkSettingsRemovePasswordType {
            description,
        }
    }

}

const SHARED_LINK_SETTINGS_REMOVE_PASSWORD_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkSettingsRemovePasswordType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkSettingsRemovePasswordType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkSettingsRemovePasswordType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkSettingsRemovePasswordType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkSettingsRemovePasswordType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkSettingsRemovePasswordType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkSettingsRemovePasswordType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkSettingsRemovePasswordType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkSettingsRemovePasswordType", SHARED_LINK_SETTINGS_REMOVE_PASSWORD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkSettingsRemovePasswordType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkSettingsRemovePasswordType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added members as audience of shared link.
#[derive(Debug)]
pub struct SharedLinkShareDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
    /// Users without a Dropbox account that were added as shared link audience.
    pub external_users: Option<Vec<ExternalUserLogInfo>>,
}

impl Default for SharedLinkShareDetails {
    fn default() -> Self {
        SharedLinkShareDetails {
            shared_link_owner: None,
            external_users: None,
        }
    }
}

const SHARED_LINK_SHARE_DETAILS_FIELDS: &[&str] = &["shared_link_owner",
                                                    "external_users"];
impl SharedLinkShareDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkShareDetails, V::Error> {
        let mut field_shared_link_owner = None;
        let mut field_external_users = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                "external_users" => {
                    if field_external_users.is_some() {
                        return Err(::serde::de::Error::duplicate_field("external_users"));
                    }
                    field_external_users = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedLinkShareDetails {
            shared_link_owner: field_shared_link_owner,
            external_users: field_external_users,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)?;
        s.serialize_field("external_users", &self.external_users)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkShareDetails", SHARED_LINK_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkShareDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkShareType {
    pub description: String,
}

impl SharedLinkShareType {
    pub fn new(description: String) -> Self {
        SharedLinkShareType {
            description,
        }
    }

}

const SHARED_LINK_SHARE_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkShareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkShareType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkShareType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkShareType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkShareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkShareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkShareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkShareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkShareType", SHARED_LINK_SHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkShareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkShareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Opened shared link.
#[derive(Debug)]
pub struct SharedLinkViewDetails {
    /// Shared link owner details. Might be missing due to historical data gap.
    pub shared_link_owner: Option<UserLogInfo>,
}

impl Default for SharedLinkViewDetails {
    fn default() -> Self {
        SharedLinkViewDetails {
            shared_link_owner: None,
        }
    }
}

const SHARED_LINK_VIEW_DETAILS_FIELDS: &[&str] = &["shared_link_owner"];
impl SharedLinkViewDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedLinkViewDetails, V::Error> {
        let mut field_shared_link_owner = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "shared_link_owner" => {
                    if field_shared_link_owner.is_some() {
                        return Err(::serde::de::Error::duplicate_field("shared_link_owner"));
                    }
                    field_shared_link_owner = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SharedLinkViewDetails {
            shared_link_owner: field_shared_link_owner,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("shared_link_owner", &self.shared_link_owner)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkViewDetails", SHARED_LINK_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkViewDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharedLinkViewType {
    pub description: String,
}

impl SharedLinkViewType {
    pub fn new(description: String) -> Self {
        SharedLinkViewType {
            description,
        }
    }

}

const SHARED_LINK_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl SharedLinkViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedLinkViewType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedLinkViewType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedLinkViewType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedLinkViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedLinkViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedLinkViewType", SHARED_LINK_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedLinkViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Defines who has access to a shared link.
#[derive(Debug)]
pub enum SharedLinkVisibility {
    Password,
    Public,
    TeamOnly,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharedLinkVisibility {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharedLinkVisibility;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedLinkVisibility structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "password" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedLinkVisibility::Password)
                    }
                    "public" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedLinkVisibility::Public)
                    }
                    "team_only" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedLinkVisibility::TeamOnly)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharedLinkVisibility::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["password",
                                    "public",
                                    "team_only",
                                    "other"];
        deserializer.deserialize_struct("SharedLinkVisibility", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharedLinkVisibility {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharedLinkVisibility::Password => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkVisibility", 1)?;
                s.serialize_field(".tag", "password")?;
                s.end()
            }
            SharedLinkVisibility::Public => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkVisibility", 1)?;
                s.serialize_field(".tag", "public")?;
                s.end()
            }
            SharedLinkVisibility::TeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharedLinkVisibility", 1)?;
                s.serialize_field(".tag", "team_only")?;
                s.end()
            }
            SharedLinkVisibility::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Opened shared Paper doc.
#[derive(Debug)]
pub struct SharedNoteOpenedDetails {
}

impl Default for SharedNoteOpenedDetails {
    fn default() -> Self {
        SharedNoteOpenedDetails {
        }
    }
}

const SHARED_NOTE_OPENED_DETAILS_FIELDS: &[&str] = &[];
impl SharedNoteOpenedDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SharedNoteOpenedDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SharedNoteOpenedDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedNoteOpenedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedNoteOpenedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedNoteOpenedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedNoteOpenedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedNoteOpenedDetails", SHARED_NOTE_OPENED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedNoteOpenedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SharedNoteOpenedDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SharedNoteOpenedType {
    pub description: String,
}

impl SharedNoteOpenedType {
    pub fn new(description: String) -> Self {
        SharedNoteOpenedType {
            description,
        }
    }

}

const SHARED_NOTE_OPENED_TYPE_FIELDS: &[&str] = &["description"];
impl SharedNoteOpenedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharedNoteOpenedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharedNoteOpenedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharedNoteOpenedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharedNoteOpenedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharedNoteOpenedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharedNoteOpenedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharedNoteOpenedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharedNoteOpenedType", SHARED_NOTE_OPENED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharedNoteOpenedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharedNoteOpenedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether team members can join shared folders owned outside team.
#[derive(Debug)]
pub struct SharingChangeFolderJoinPolicyDetails {
    /// New external join policy.
    pub new_value: SharingFolderJoinPolicy,
    /// Previous external join policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharingFolderJoinPolicy>,
}

impl SharingChangeFolderJoinPolicyDetails {
    pub fn new(new_value: SharingFolderJoinPolicy) -> Self {
        SharingChangeFolderJoinPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharingFolderJoinPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARING_CHANGE_FOLDER_JOIN_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                    "previous_value"];
impl SharingChangeFolderJoinPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharingChangeFolderJoinPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharingChangeFolderJoinPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharingChangeFolderJoinPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeFolderJoinPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeFolderJoinPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharingChangeFolderJoinPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeFolderJoinPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeFolderJoinPolicyDetails", SHARING_CHANGE_FOLDER_JOIN_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeFolderJoinPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeFolderJoinPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharingChangeFolderJoinPolicyType {
    pub description: String,
}

impl SharingChangeFolderJoinPolicyType {
    pub fn new(description: String) -> Self {
        SharingChangeFolderJoinPolicyType {
            description,
        }
    }

}

const SHARING_CHANGE_FOLDER_JOIN_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharingChangeFolderJoinPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharingChangeFolderJoinPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharingChangeFolderJoinPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharingChangeFolderJoinPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeFolderJoinPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeFolderJoinPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharingChangeFolderJoinPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeFolderJoinPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeFolderJoinPolicyType", SHARING_CHANGE_FOLDER_JOIN_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeFolderJoinPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeFolderJoinPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether members can share links outside team, and if links are accessible only by team
/// members or anyone by default.
#[derive(Debug)]
pub struct SharingChangeLinkPolicyDetails {
    /// New external link accessibility policy.
    pub new_value: SharingLinkPolicy,
    /// Previous external link accessibility policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharingLinkPolicy>,
}

impl SharingChangeLinkPolicyDetails {
    pub fn new(new_value: SharingLinkPolicy) -> Self {
        SharingChangeLinkPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharingLinkPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARING_CHANGE_LINK_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                             "previous_value"];
impl SharingChangeLinkPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharingChangeLinkPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharingChangeLinkPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharingChangeLinkPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeLinkPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeLinkPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharingChangeLinkPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeLinkPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeLinkPolicyDetails", SHARING_CHANGE_LINK_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeLinkPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeLinkPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharingChangeLinkPolicyType {
    pub description: String,
}

impl SharingChangeLinkPolicyType {
    pub fn new(description: String) -> Self {
        SharingChangeLinkPolicyType {
            description,
        }
    }

}

const SHARING_CHANGE_LINK_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharingChangeLinkPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharingChangeLinkPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharingChangeLinkPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharingChangeLinkPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeLinkPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeLinkPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharingChangeLinkPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeLinkPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeLinkPolicyType", SHARING_CHANGE_LINK_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeLinkPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeLinkPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed whether members can share files/folders outside team.
#[derive(Debug)]
pub struct SharingChangeMemberPolicyDetails {
    /// New external invite policy.
    pub new_value: SharingMemberPolicy,
    /// Previous external invite policy. Might be missing due to historical data gap.
    pub previous_value: Option<SharingMemberPolicy>,
}

impl SharingChangeMemberPolicyDetails {
    pub fn new(new_value: SharingMemberPolicy) -> Self {
        SharingChangeMemberPolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<SharingMemberPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SHARING_CHANGE_MEMBER_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                               "previous_value"];
impl SharingChangeMemberPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharingChangeMemberPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharingChangeMemberPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharingChangeMemberPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeMemberPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeMemberPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharingChangeMemberPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeMemberPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeMemberPolicyDetails", SHARING_CHANGE_MEMBER_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeMemberPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeMemberPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SharingChangeMemberPolicyType {
    pub description: String,
}

impl SharingChangeMemberPolicyType {
    pub fn new(description: String) -> Self {
        SharingChangeMemberPolicyType {
            description,
        }
    }

}

const SHARING_CHANGE_MEMBER_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SharingChangeMemberPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SharingChangeMemberPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SharingChangeMemberPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SharingChangeMemberPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SharingChangeMemberPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SharingChangeMemberPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharingChangeMemberPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SharingChangeMemberPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SharingChangeMemberPolicyType", SHARING_CHANGE_MEMBER_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SharingChangeMemberPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SharingChangeMemberPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if team members can join shared folders owned by non team members.
#[derive(Debug)]
pub enum SharingFolderJoinPolicy {
    FromAnyone,
    FromTeamOnly,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingFolderJoinPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingFolderJoinPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharingFolderJoinPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "from_anyone" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingFolderJoinPolicy::FromAnyone)
                    }
                    "from_team_only" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingFolderJoinPolicy::FromTeamOnly)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingFolderJoinPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["from_anyone",
                                    "from_team_only",
                                    "other"];
        deserializer.deserialize_struct("SharingFolderJoinPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingFolderJoinPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingFolderJoinPolicy::FromAnyone => {
                // unit
                let mut s = serializer.serialize_struct("SharingFolderJoinPolicy", 1)?;
                s.serialize_field(".tag", "from_anyone")?;
                s.end()
            }
            SharingFolderJoinPolicy::FromTeamOnly => {
                // unit
                let mut s = serializer.serialize_struct("SharingFolderJoinPolicy", 1)?;
                s.serialize_field(".tag", "from_team_only")?;
                s.end()
            }
            SharingFolderJoinPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Policy for controlling if team members can share links externally
#[derive(Debug)]
pub enum SharingLinkPolicy {
    DefaultPrivate,
    DefaultPublic,
    OnlyPrivate,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingLinkPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingLinkPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharingLinkPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "default_private" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingLinkPolicy::DefaultPrivate)
                    }
                    "default_public" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingLinkPolicy::DefaultPublic)
                    }
                    "only_private" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingLinkPolicy::OnlyPrivate)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingLinkPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["default_private",
                                    "default_public",
                                    "only_private",
                                    "other"];
        deserializer.deserialize_struct("SharingLinkPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingLinkPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingLinkPolicy::DefaultPrivate => {
                // unit
                let mut s = serializer.serialize_struct("SharingLinkPolicy", 1)?;
                s.serialize_field(".tag", "default_private")?;
                s.end()
            }
            SharingLinkPolicy::DefaultPublic => {
                // unit
                let mut s = serializer.serialize_struct("SharingLinkPolicy", 1)?;
                s.serialize_field(".tag", "default_public")?;
                s.end()
            }
            SharingLinkPolicy::OnlyPrivate => {
                // unit
                let mut s = serializer.serialize_struct("SharingLinkPolicy", 1)?;
                s.serialize_field(".tag", "only_private")?;
                s.end()
            }
            SharingLinkPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// External sharing policy
#[derive(Debug)]
pub enum SharingMemberPolicy {
    Allow,
    Forbid,
    ForbidWithExclusions,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SharingMemberPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SharingMemberPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SharingMemberPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "allow" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingMemberPolicy::Allow)
                    }
                    "forbid" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingMemberPolicy::Forbid)
                    }
                    "forbid_with_exclusions" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingMemberPolicy::ForbidWithExclusions)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SharingMemberPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["allow",
                                    "forbid",
                                    "forbid_with_exclusions",
                                    "other"];
        deserializer.deserialize_struct("SharingMemberPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SharingMemberPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SharingMemberPolicy::Allow => {
                // unit
                let mut s = serializer.serialize_struct("SharingMemberPolicy", 1)?;
                s.serialize_field(".tag", "allow")?;
                s.end()
            }
            SharingMemberPolicy::Forbid => {
                // unit
                let mut s = serializer.serialize_struct("SharingMemberPolicy", 1)?;
                s.serialize_field(".tag", "forbid")?;
                s.end()
            }
            SharingMemberPolicy::ForbidWithExclusions => {
                // unit
                let mut s = serializer.serialize_struct("SharingMemberPolicy", 1)?;
                s.serialize_field(".tag", "forbid_with_exclusions")?;
                s.end()
            }
            SharingMemberPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Shared link with group.
#[derive(Debug)]
pub struct ShmodelGroupShareDetails {
}

impl Default for ShmodelGroupShareDetails {
    fn default() -> Self {
        ShmodelGroupShareDetails {
        }
    }
}

const SHMODEL_GROUP_SHARE_DETAILS_FIELDS: &[&str] = &[];
impl ShmodelGroupShareDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ShmodelGroupShareDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(ShmodelGroupShareDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelGroupShareDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelGroupShareDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShmodelGroupShareDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelGroupShareDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelGroupShareDetails", SHMODEL_GROUP_SHARE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelGroupShareDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("ShmodelGroupShareDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct ShmodelGroupShareType {
    pub description: String,
}

impl ShmodelGroupShareType {
    pub fn new(description: String) -> Self {
        ShmodelGroupShareType {
            description,
        }
    }

}

const SHMODEL_GROUP_SHARE_TYPE_FIELDS: &[&str] = &["description"];
impl ShmodelGroupShareType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShmodelGroupShareType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShmodelGroupShareType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShmodelGroupShareType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShmodelGroupShareType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShmodelGroupShareType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShmodelGroupShareType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShmodelGroupShareType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShmodelGroupShareType", SHMODEL_GROUP_SHARE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShmodelGroupShareType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShmodelGroupShareType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Granted access to showcase.
#[derive(Debug)]
pub struct ShowcaseAccessGrantedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseAccessGrantedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseAccessGrantedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_ACCESS_GRANTED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseAccessGrantedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseAccessGrantedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseAccessGrantedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseAccessGrantedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseAccessGrantedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseAccessGrantedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseAccessGrantedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseAccessGrantedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseAccessGrantedDetails", SHOWCASE_ACCESS_GRANTED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseAccessGrantedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseAccessGrantedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseAccessGrantedType {
    pub description: String,
}

impl ShowcaseAccessGrantedType {
    pub fn new(description: String) -> Self {
        ShowcaseAccessGrantedType {
            description,
        }
    }

}

const SHOWCASE_ACCESS_GRANTED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseAccessGrantedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseAccessGrantedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseAccessGrantedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseAccessGrantedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseAccessGrantedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseAccessGrantedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseAccessGrantedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseAccessGrantedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseAccessGrantedType", SHOWCASE_ACCESS_GRANTED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseAccessGrantedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseAccessGrantedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added member to showcase.
#[derive(Debug)]
pub struct ShowcaseAddMemberDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseAddMemberDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseAddMemberDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_ADD_MEMBER_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseAddMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseAddMemberDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseAddMemberDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseAddMemberDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseAddMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseAddMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseAddMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseAddMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseAddMemberDetails", SHOWCASE_ADD_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseAddMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseAddMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseAddMemberType {
    pub description: String,
}

impl ShowcaseAddMemberType {
    pub fn new(description: String) -> Self {
        ShowcaseAddMemberType {
            description,
        }
    }

}

const SHOWCASE_ADD_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseAddMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseAddMemberType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseAddMemberType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseAddMemberType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseAddMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseAddMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseAddMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseAddMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseAddMemberType", SHOWCASE_ADD_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseAddMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseAddMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Archived showcase.
#[derive(Debug)]
pub struct ShowcaseArchivedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseArchivedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseArchivedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_ARCHIVED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseArchivedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseArchivedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseArchivedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseArchivedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseArchivedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseArchivedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseArchivedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseArchivedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseArchivedDetails", SHOWCASE_ARCHIVED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseArchivedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseArchivedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseArchivedType {
    pub description: String,
}

impl ShowcaseArchivedType {
    pub fn new(description: String) -> Self {
        ShowcaseArchivedType {
            description,
        }
    }

}

const SHOWCASE_ARCHIVED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseArchivedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseArchivedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseArchivedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseArchivedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseArchivedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseArchivedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseArchivedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseArchivedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseArchivedType", SHOWCASE_ARCHIVED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseArchivedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseArchivedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled downloading files from Dropbox Showcase for team.
#[derive(Debug)]
pub struct ShowcaseChangeDownloadPolicyDetails {
    /// New Dropbox Showcase download policy.
    pub new_value: ShowcaseDownloadPolicy,
    /// Previous Dropbox Showcase download policy.
    pub previous_value: ShowcaseDownloadPolicy,
}

impl ShowcaseChangeDownloadPolicyDetails {
    pub fn new(new_value: ShowcaseDownloadPolicy, previous_value: ShowcaseDownloadPolicy) -> Self {
        ShowcaseChangeDownloadPolicyDetails {
            new_value,
            previous_value,
        }
    }

}

const SHOWCASE_CHANGE_DOWNLOAD_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                  "previous_value"];
impl ShowcaseChangeDownloadPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseChangeDownloadPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseChangeDownloadPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseChangeDownloadPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseChangeDownloadPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseChangeDownloadPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseChangeDownloadPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseChangeDownloadPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseChangeDownloadPolicyDetails", SHOWCASE_CHANGE_DOWNLOAD_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseChangeDownloadPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseChangeDownloadPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseChangeDownloadPolicyType {
    pub description: String,
}

impl ShowcaseChangeDownloadPolicyType {
    pub fn new(description: String) -> Self {
        ShowcaseChangeDownloadPolicyType {
            description,
        }
    }

}

const SHOWCASE_CHANGE_DOWNLOAD_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseChangeDownloadPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseChangeDownloadPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseChangeDownloadPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseChangeDownloadPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseChangeDownloadPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseChangeDownloadPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseChangeDownloadPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseChangeDownloadPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseChangeDownloadPolicyType", SHOWCASE_CHANGE_DOWNLOAD_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseChangeDownloadPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseChangeDownloadPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled Dropbox Showcase for team.
#[derive(Debug)]
pub struct ShowcaseChangeEnabledPolicyDetails {
    /// New Dropbox Showcase policy.
    pub new_value: ShowcaseEnabledPolicy,
    /// Previous Dropbox Showcase policy.
    pub previous_value: ShowcaseEnabledPolicy,
}

impl ShowcaseChangeEnabledPolicyDetails {
    pub fn new(new_value: ShowcaseEnabledPolicy, previous_value: ShowcaseEnabledPolicy) -> Self {
        ShowcaseChangeEnabledPolicyDetails {
            new_value,
            previous_value,
        }
    }

}

const SHOWCASE_CHANGE_ENABLED_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                 "previous_value"];
impl ShowcaseChangeEnabledPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseChangeEnabledPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseChangeEnabledPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseChangeEnabledPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseChangeEnabledPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseChangeEnabledPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseChangeEnabledPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseChangeEnabledPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseChangeEnabledPolicyDetails", SHOWCASE_CHANGE_ENABLED_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseChangeEnabledPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseChangeEnabledPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseChangeEnabledPolicyType {
    pub description: String,
}

impl ShowcaseChangeEnabledPolicyType {
    pub fn new(description: String) -> Self {
        ShowcaseChangeEnabledPolicyType {
            description,
        }
    }

}

const SHOWCASE_CHANGE_ENABLED_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseChangeEnabledPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseChangeEnabledPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseChangeEnabledPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseChangeEnabledPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseChangeEnabledPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseChangeEnabledPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseChangeEnabledPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseChangeEnabledPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseChangeEnabledPolicyType", SHOWCASE_CHANGE_ENABLED_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseChangeEnabledPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseChangeEnabledPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled sharing Dropbox Showcase externally for team.
#[derive(Debug)]
pub struct ShowcaseChangeExternalSharingPolicyDetails {
    /// New Dropbox Showcase external sharing policy.
    pub new_value: ShowcaseExternalSharingPolicy,
    /// Previous Dropbox Showcase external sharing policy.
    pub previous_value: ShowcaseExternalSharingPolicy,
}

impl ShowcaseChangeExternalSharingPolicyDetails {
    pub fn new(
        new_value: ShowcaseExternalSharingPolicy,
        previous_value: ShowcaseExternalSharingPolicy,
    ) -> Self {
        ShowcaseChangeExternalSharingPolicyDetails {
            new_value,
            previous_value,
        }
    }

}

const SHOWCASE_CHANGE_EXTERNAL_SHARING_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                          "previous_value"];
impl ShowcaseChangeExternalSharingPolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseChangeExternalSharingPolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseChangeExternalSharingPolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseChangeExternalSharingPolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseChangeExternalSharingPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseChangeExternalSharingPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseChangeExternalSharingPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseChangeExternalSharingPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseChangeExternalSharingPolicyDetails", SHOWCASE_CHANGE_EXTERNAL_SHARING_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseChangeExternalSharingPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseChangeExternalSharingPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseChangeExternalSharingPolicyType {
    pub description: String,
}

impl ShowcaseChangeExternalSharingPolicyType {
    pub fn new(description: String) -> Self {
        ShowcaseChangeExternalSharingPolicyType {
            description,
        }
    }

}

const SHOWCASE_CHANGE_EXTERNAL_SHARING_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseChangeExternalSharingPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseChangeExternalSharingPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseChangeExternalSharingPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseChangeExternalSharingPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseChangeExternalSharingPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseChangeExternalSharingPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseChangeExternalSharingPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseChangeExternalSharingPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseChangeExternalSharingPolicyType", SHOWCASE_CHANGE_EXTERNAL_SHARING_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseChangeExternalSharingPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseChangeExternalSharingPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created showcase.
#[derive(Debug)]
pub struct ShowcaseCreatedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseCreatedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseCreatedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_CREATED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseCreatedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseCreatedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseCreatedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseCreatedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseCreatedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseCreatedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseCreatedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseCreatedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseCreatedDetails", SHOWCASE_CREATED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseCreatedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseCreatedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseCreatedType {
    pub description: String,
}

impl ShowcaseCreatedType {
    pub fn new(description: String) -> Self {
        ShowcaseCreatedType {
            description,
        }
    }

}

const SHOWCASE_CREATED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseCreatedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseCreatedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseCreatedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseCreatedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseCreatedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseCreatedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseCreatedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseCreatedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseCreatedType", SHOWCASE_CREATED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseCreatedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseCreatedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted showcase comment.
#[derive(Debug)]
pub struct ShowcaseDeleteCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text.
    pub comment_text: Option<String>,
}

impl ShowcaseDeleteCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseDeleteCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const SHOWCASE_DELETE_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                          "comment_text"];
impl ShowcaseDeleteCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseDeleteCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseDeleteCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseDeleteCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseDeleteCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseDeleteCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseDeleteCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseDeleteCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseDeleteCommentDetails", SHOWCASE_DELETE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseDeleteCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseDeleteCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseDeleteCommentType {
    pub description: String,
}

impl ShowcaseDeleteCommentType {
    pub fn new(description: String) -> Self {
        ShowcaseDeleteCommentType {
            description,
        }
    }

}

const SHOWCASE_DELETE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseDeleteCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseDeleteCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseDeleteCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseDeleteCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseDeleteCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseDeleteCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseDeleteCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseDeleteCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseDeleteCommentType", SHOWCASE_DELETE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseDeleteCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseDeleteCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Showcase document's logged information.
#[derive(Debug)]
pub struct ShowcaseDocumentLogInfo {
    /// Showcase document Id.
    pub showcase_id: String,
    /// Showcase document title.
    pub showcase_title: String,
}

impl ShowcaseDocumentLogInfo {
    pub fn new(showcase_id: String, showcase_title: String) -> Self {
        ShowcaseDocumentLogInfo {
            showcase_id,
            showcase_title,
        }
    }

}

const SHOWCASE_DOCUMENT_LOG_INFO_FIELDS: &[&str] = &["showcase_id",
                                                     "showcase_title"];
impl ShowcaseDocumentLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseDocumentLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseDocumentLogInfo>, V::Error> {
        let mut field_showcase_id = None;
        let mut field_showcase_title = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "showcase_id" => {
                    if field_showcase_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("showcase_id"));
                    }
                    field_showcase_id = Some(map.next_value()?);
                }
                "showcase_title" => {
                    if field_showcase_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("showcase_title"));
                    }
                    field_showcase_title = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseDocumentLogInfo {
            showcase_id: field_showcase_id.ok_or_else(|| ::serde::de::Error::missing_field("showcase_id"))?,
            showcase_title: field_showcase_title.ok_or_else(|| ::serde::de::Error::missing_field("showcase_title"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("showcase_id", &self.showcase_id)?;
        s.serialize_field("showcase_title", &self.showcase_title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseDocumentLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseDocumentLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseDocumentLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseDocumentLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseDocumentLogInfo", SHOWCASE_DOCUMENT_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseDocumentLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseDocumentLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling if files can be downloaded from Showcases by team members
#[derive(Debug)]
pub enum ShowcaseDownloadPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseDownloadPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ShowcaseDownloadPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseDownloadPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ShowcaseDownloadPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ShowcaseDownloadPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ShowcaseDownloadPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("ShowcaseDownloadPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseDownloadPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ShowcaseDownloadPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("ShowcaseDownloadPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            ShowcaseDownloadPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("ShowcaseDownloadPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            ShowcaseDownloadPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Edited showcase comment.
#[derive(Debug)]
pub struct ShowcaseEditCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text.
    pub comment_text: Option<String>,
}

impl ShowcaseEditCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseEditCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const SHOWCASE_EDIT_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                        "comment_text"];
impl ShowcaseEditCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseEditCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseEditCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseEditCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseEditCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseEditCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseEditCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseEditCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseEditCommentDetails", SHOWCASE_EDIT_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseEditCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseEditCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseEditCommentType {
    pub description: String,
}

impl ShowcaseEditCommentType {
    pub fn new(description: String) -> Self {
        ShowcaseEditCommentType {
            description,
        }
    }

}

const SHOWCASE_EDIT_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseEditCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseEditCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseEditCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseEditCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseEditCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseEditCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseEditCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseEditCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseEditCommentType", SHOWCASE_EDIT_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseEditCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseEditCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited showcase.
#[derive(Debug)]
pub struct ShowcaseEditedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseEditedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseEditedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_EDITED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseEditedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseEditedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseEditedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseEditedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseEditedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseEditedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseEditedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseEditedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseEditedDetails", SHOWCASE_EDITED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseEditedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseEditedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseEditedType {
    pub description: String,
}

impl ShowcaseEditedType {
    pub fn new(description: String) -> Self {
        ShowcaseEditedType {
            description,
        }
    }

}

const SHOWCASE_EDITED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseEditedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseEditedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseEditedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseEditedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseEditedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseEditedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseEditedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseEditedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseEditedType", SHOWCASE_EDITED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseEditedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseEditedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling whether Showcase is enabled.
#[derive(Debug)]
pub enum ShowcaseEnabledPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseEnabledPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ShowcaseEnabledPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseEnabledPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ShowcaseEnabledPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ShowcaseEnabledPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ShowcaseEnabledPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("ShowcaseEnabledPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseEnabledPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ShowcaseEnabledPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("ShowcaseEnabledPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            ShowcaseEnabledPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("ShowcaseEnabledPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            ShowcaseEnabledPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Policy for controlling if team members can share Showcases externally.
#[derive(Debug)]
pub enum ShowcaseExternalSharingPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseExternalSharingPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ShowcaseExternalSharingPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseExternalSharingPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ShowcaseExternalSharingPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ShowcaseExternalSharingPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ShowcaseExternalSharingPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("ShowcaseExternalSharingPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseExternalSharingPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ShowcaseExternalSharingPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("ShowcaseExternalSharingPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            ShowcaseExternalSharingPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("ShowcaseExternalSharingPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            ShowcaseExternalSharingPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added file to showcase.
#[derive(Debug)]
pub struct ShowcaseFileAddedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseFileAddedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseFileAddedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_FILE_ADDED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseFileAddedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseFileAddedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseFileAddedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseFileAddedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseFileAddedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseFileAddedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseFileAddedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseFileAddedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseFileAddedDetails", SHOWCASE_FILE_ADDED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseFileAddedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseFileAddedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseFileAddedType {
    pub description: String,
}

impl ShowcaseFileAddedType {
    pub fn new(description: String) -> Self {
        ShowcaseFileAddedType {
            description,
        }
    }

}

const SHOWCASE_FILE_ADDED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseFileAddedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseFileAddedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseFileAddedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseFileAddedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseFileAddedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseFileAddedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseFileAddedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseFileAddedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseFileAddedType", SHOWCASE_FILE_ADDED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseFileAddedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseFileAddedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downloaded file from showcase.
#[derive(Debug)]
pub struct ShowcaseFileDownloadDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Showcase download type.
    pub download_type: String,
}

impl ShowcaseFileDownloadDetails {
    pub fn new(event_uuid: String, download_type: String) -> Self {
        ShowcaseFileDownloadDetails {
            event_uuid,
            download_type,
        }
    }

}

const SHOWCASE_FILE_DOWNLOAD_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                         "download_type"];
impl ShowcaseFileDownloadDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseFileDownloadDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseFileDownloadDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_download_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "download_type" => {
                    if field_download_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("download_type"));
                    }
                    field_download_type = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseFileDownloadDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            download_type: field_download_type.ok_or_else(|| ::serde::de::Error::missing_field("download_type"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("download_type", &self.download_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseFileDownloadDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseFileDownloadDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseFileDownloadDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseFileDownloadDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseFileDownloadDetails", SHOWCASE_FILE_DOWNLOAD_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseFileDownloadDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseFileDownloadDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseFileDownloadType {
    pub description: String,
}

impl ShowcaseFileDownloadType {
    pub fn new(description: String) -> Self {
        ShowcaseFileDownloadType {
            description,
        }
    }

}

const SHOWCASE_FILE_DOWNLOAD_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseFileDownloadType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseFileDownloadType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseFileDownloadType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseFileDownloadType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseFileDownloadType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseFileDownloadType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseFileDownloadType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseFileDownloadType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseFileDownloadType", SHOWCASE_FILE_DOWNLOAD_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseFileDownloadType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseFileDownloadType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed file from showcase.
#[derive(Debug)]
pub struct ShowcaseFileRemovedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseFileRemovedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseFileRemovedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_FILE_REMOVED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseFileRemovedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseFileRemovedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseFileRemovedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseFileRemovedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseFileRemovedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseFileRemovedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseFileRemovedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseFileRemovedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseFileRemovedDetails", SHOWCASE_FILE_REMOVED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseFileRemovedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseFileRemovedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseFileRemovedType {
    pub description: String,
}

impl ShowcaseFileRemovedType {
    pub fn new(description: String) -> Self {
        ShowcaseFileRemovedType {
            description,
        }
    }

}

const SHOWCASE_FILE_REMOVED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseFileRemovedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseFileRemovedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseFileRemovedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseFileRemovedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseFileRemovedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseFileRemovedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseFileRemovedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseFileRemovedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseFileRemovedType", SHOWCASE_FILE_REMOVED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseFileRemovedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseFileRemovedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Viewed file in showcase.
#[derive(Debug)]
pub struct ShowcaseFileViewDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseFileViewDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseFileViewDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_FILE_VIEW_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseFileViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseFileViewDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseFileViewDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseFileViewDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseFileViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseFileViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseFileViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseFileViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseFileViewDetails", SHOWCASE_FILE_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseFileViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseFileViewDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseFileViewType {
    pub description: String,
}

impl ShowcaseFileViewType {
    pub fn new(description: String) -> Self {
        ShowcaseFileViewType {
            description,
        }
    }

}

const SHOWCASE_FILE_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseFileViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseFileViewType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseFileViewType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseFileViewType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseFileViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseFileViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseFileViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseFileViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseFileViewType", SHOWCASE_FILE_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseFileViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseFileViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted showcase.
#[derive(Debug)]
pub struct ShowcasePermanentlyDeletedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcasePermanentlyDeletedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcasePermanentlyDeletedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_PERMANENTLY_DELETED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcasePermanentlyDeletedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcasePermanentlyDeletedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcasePermanentlyDeletedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcasePermanentlyDeletedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcasePermanentlyDeletedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcasePermanentlyDeletedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcasePermanentlyDeletedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcasePermanentlyDeletedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcasePermanentlyDeletedDetails", SHOWCASE_PERMANENTLY_DELETED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcasePermanentlyDeletedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcasePermanentlyDeletedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcasePermanentlyDeletedType {
    pub description: String,
}

impl ShowcasePermanentlyDeletedType {
    pub fn new(description: String) -> Self {
        ShowcasePermanentlyDeletedType {
            description,
        }
    }

}

const SHOWCASE_PERMANENTLY_DELETED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcasePermanentlyDeletedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcasePermanentlyDeletedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcasePermanentlyDeletedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcasePermanentlyDeletedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcasePermanentlyDeletedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcasePermanentlyDeletedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcasePermanentlyDeletedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcasePermanentlyDeletedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcasePermanentlyDeletedType", SHOWCASE_PERMANENTLY_DELETED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcasePermanentlyDeletedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcasePermanentlyDeletedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added showcase comment.
#[derive(Debug)]
pub struct ShowcasePostCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text.
    pub comment_text: Option<String>,
}

impl ShowcasePostCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcasePostCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const SHOWCASE_POST_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                        "comment_text"];
impl ShowcasePostCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcasePostCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcasePostCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcasePostCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcasePostCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcasePostCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcasePostCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcasePostCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcasePostCommentDetails", SHOWCASE_POST_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcasePostCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcasePostCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcasePostCommentType {
    pub description: String,
}

impl ShowcasePostCommentType {
    pub fn new(description: String) -> Self {
        ShowcasePostCommentType {
            description,
        }
    }

}

const SHOWCASE_POST_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcasePostCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcasePostCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcasePostCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcasePostCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcasePostCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcasePostCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcasePostCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcasePostCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcasePostCommentType", SHOWCASE_POST_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcasePostCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcasePostCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed member from showcase.
#[derive(Debug)]
pub struct ShowcaseRemoveMemberDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseRemoveMemberDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseRemoveMemberDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_REMOVE_MEMBER_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseRemoveMemberDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseRemoveMemberDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseRemoveMemberDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseRemoveMemberDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseRemoveMemberDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseRemoveMemberDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseRemoveMemberDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseRemoveMemberDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseRemoveMemberDetails", SHOWCASE_REMOVE_MEMBER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseRemoveMemberDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseRemoveMemberDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseRemoveMemberType {
    pub description: String,
}

impl ShowcaseRemoveMemberType {
    pub fn new(description: String) -> Self {
        ShowcaseRemoveMemberType {
            description,
        }
    }

}

const SHOWCASE_REMOVE_MEMBER_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseRemoveMemberType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseRemoveMemberType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseRemoveMemberType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseRemoveMemberType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseRemoveMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseRemoveMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseRemoveMemberType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseRemoveMemberType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseRemoveMemberType", SHOWCASE_REMOVE_MEMBER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseRemoveMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseRemoveMemberType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed showcase.
#[derive(Debug)]
pub struct ShowcaseRenamedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseRenamedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseRenamedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_RENAMED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseRenamedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseRenamedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseRenamedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseRenamedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseRenamedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseRenamedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseRenamedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseRenamedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseRenamedDetails", SHOWCASE_RENAMED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseRenamedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseRenamedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseRenamedType {
    pub description: String,
}

impl ShowcaseRenamedType {
    pub fn new(description: String) -> Self {
        ShowcaseRenamedType {
            description,
        }
    }

}

const SHOWCASE_RENAMED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseRenamedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseRenamedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseRenamedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseRenamedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseRenamedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseRenamedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseRenamedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseRenamedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseRenamedType", SHOWCASE_RENAMED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseRenamedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseRenamedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested access to showcase.
#[derive(Debug)]
pub struct ShowcaseRequestAccessDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseRequestAccessDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseRequestAccessDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_REQUEST_ACCESS_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseRequestAccessDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseRequestAccessDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseRequestAccessDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseRequestAccessDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseRequestAccessDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseRequestAccessDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseRequestAccessDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseRequestAccessDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseRequestAccessDetails", SHOWCASE_REQUEST_ACCESS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseRequestAccessDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseRequestAccessDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseRequestAccessType {
    pub description: String,
}

impl ShowcaseRequestAccessType {
    pub fn new(description: String) -> Self {
        ShowcaseRequestAccessType {
            description,
        }
    }

}

const SHOWCASE_REQUEST_ACCESS_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseRequestAccessType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseRequestAccessType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseRequestAccessType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseRequestAccessType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseRequestAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseRequestAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseRequestAccessType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseRequestAccessType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseRequestAccessType", SHOWCASE_REQUEST_ACCESS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseRequestAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseRequestAccessType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Resolved showcase comment.
#[derive(Debug)]
pub struct ShowcaseResolveCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text.
    pub comment_text: Option<String>,
}

impl ShowcaseResolveCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseResolveCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const SHOWCASE_RESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                           "comment_text"];
impl ShowcaseResolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseResolveCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseResolveCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseResolveCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseResolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseResolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseResolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseResolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseResolveCommentDetails", SHOWCASE_RESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseResolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseResolveCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseResolveCommentType {
    pub description: String,
}

impl ShowcaseResolveCommentType {
    pub fn new(description: String) -> Self {
        ShowcaseResolveCommentType {
            description,
        }
    }

}

const SHOWCASE_RESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseResolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseResolveCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseResolveCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseResolveCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseResolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseResolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseResolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseResolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseResolveCommentType", SHOWCASE_RESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseResolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseResolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unarchived showcase.
#[derive(Debug)]
pub struct ShowcaseRestoredDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseRestoredDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseRestoredDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_RESTORED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseRestoredDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseRestoredDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseRestoredDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseRestoredDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseRestoredDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseRestoredDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseRestoredDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseRestoredDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseRestoredDetails", SHOWCASE_RESTORED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseRestoredDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseRestoredDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseRestoredType {
    pub description: String,
}

impl ShowcaseRestoredType {
    pub fn new(description: String) -> Self {
        ShowcaseRestoredType {
            description,
        }
    }

}

const SHOWCASE_RESTORED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseRestoredType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseRestoredType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseRestoredType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseRestoredType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseRestoredType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseRestoredType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseRestoredType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseRestoredType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseRestoredType", SHOWCASE_RESTORED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseRestoredType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseRestoredType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted showcase (old version).
#[derive(Debug)]
pub struct ShowcaseTrashedDeprecatedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseTrashedDeprecatedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseTrashedDeprecatedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_TRASHED_DEPRECATED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseTrashedDeprecatedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseTrashedDeprecatedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseTrashedDeprecatedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseTrashedDeprecatedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseTrashedDeprecatedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseTrashedDeprecatedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseTrashedDeprecatedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseTrashedDeprecatedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseTrashedDeprecatedDetails", SHOWCASE_TRASHED_DEPRECATED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseTrashedDeprecatedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseTrashedDeprecatedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseTrashedDeprecatedType {
    pub description: String,
}

impl ShowcaseTrashedDeprecatedType {
    pub fn new(description: String) -> Self {
        ShowcaseTrashedDeprecatedType {
            description,
        }
    }

}

const SHOWCASE_TRASHED_DEPRECATED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseTrashedDeprecatedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseTrashedDeprecatedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseTrashedDeprecatedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseTrashedDeprecatedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseTrashedDeprecatedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseTrashedDeprecatedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseTrashedDeprecatedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseTrashedDeprecatedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseTrashedDeprecatedType", SHOWCASE_TRASHED_DEPRECATED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseTrashedDeprecatedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseTrashedDeprecatedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Deleted showcase.
#[derive(Debug)]
pub struct ShowcaseTrashedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseTrashedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseTrashedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_TRASHED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseTrashedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseTrashedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseTrashedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseTrashedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseTrashedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseTrashedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseTrashedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseTrashedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseTrashedDetails", SHOWCASE_TRASHED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseTrashedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseTrashedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseTrashedType {
    pub description: String,
}

impl ShowcaseTrashedType {
    pub fn new(description: String) -> Self {
        ShowcaseTrashedType {
            description,
        }
    }

}

const SHOWCASE_TRASHED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseTrashedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseTrashedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseTrashedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseTrashedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseTrashedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseTrashedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseTrashedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseTrashedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseTrashedType", SHOWCASE_TRASHED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseTrashedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseTrashedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Unresolved showcase comment.
#[derive(Debug)]
pub struct ShowcaseUnresolveCommentDetails {
    /// Event unique identifier.
    pub event_uuid: String,
    /// Comment text.
    pub comment_text: Option<String>,
}

impl ShowcaseUnresolveCommentDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseUnresolveCommentDetails {
            event_uuid,
            comment_text: None,
        }
    }

    pub fn with_comment_text(mut self, value: Option<String>) -> Self {
        self.comment_text = value;
        self
    }

}

const SHOWCASE_UNRESOLVE_COMMENT_DETAILS_FIELDS: &[&str] = &["event_uuid",
                                                             "comment_text"];
impl ShowcaseUnresolveCommentDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseUnresolveCommentDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseUnresolveCommentDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut field_comment_text = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                "comment_text" => {
                    if field_comment_text.is_some() {
                        return Err(::serde::de::Error::duplicate_field("comment_text"));
                    }
                    field_comment_text = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseUnresolveCommentDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
            comment_text: field_comment_text,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)?;
        s.serialize_field("comment_text", &self.comment_text)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseUnresolveCommentDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseUnresolveCommentDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseUnresolveCommentDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseUnresolveCommentDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseUnresolveCommentDetails", SHOWCASE_UNRESOLVE_COMMENT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseUnresolveCommentDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseUnresolveCommentDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseUnresolveCommentType {
    pub description: String,
}

impl ShowcaseUnresolveCommentType {
    pub fn new(description: String) -> Self {
        ShowcaseUnresolveCommentType {
            description,
        }
    }

}

const SHOWCASE_UNRESOLVE_COMMENT_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseUnresolveCommentType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseUnresolveCommentType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseUnresolveCommentType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseUnresolveCommentType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseUnresolveCommentType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseUnresolveCommentType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseUnresolveCommentType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseUnresolveCommentType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseUnresolveCommentType", SHOWCASE_UNRESOLVE_COMMENT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseUnresolveCommentType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseUnresolveCommentType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored showcase (old version).
#[derive(Debug)]
pub struct ShowcaseUntrashedDeprecatedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseUntrashedDeprecatedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseUntrashedDeprecatedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_UNTRASHED_DEPRECATED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseUntrashedDeprecatedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseUntrashedDeprecatedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseUntrashedDeprecatedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseUntrashedDeprecatedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseUntrashedDeprecatedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseUntrashedDeprecatedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseUntrashedDeprecatedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseUntrashedDeprecatedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseUntrashedDeprecatedDetails", SHOWCASE_UNTRASHED_DEPRECATED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseUntrashedDeprecatedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseUntrashedDeprecatedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseUntrashedDeprecatedType {
    pub description: String,
}

impl ShowcaseUntrashedDeprecatedType {
    pub fn new(description: String) -> Self {
        ShowcaseUntrashedDeprecatedType {
            description,
        }
    }

}

const SHOWCASE_UNTRASHED_DEPRECATED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseUntrashedDeprecatedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseUntrashedDeprecatedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseUntrashedDeprecatedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseUntrashedDeprecatedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseUntrashedDeprecatedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseUntrashedDeprecatedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseUntrashedDeprecatedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseUntrashedDeprecatedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseUntrashedDeprecatedType", SHOWCASE_UNTRASHED_DEPRECATED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseUntrashedDeprecatedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseUntrashedDeprecatedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Restored showcase.
#[derive(Debug)]
pub struct ShowcaseUntrashedDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseUntrashedDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseUntrashedDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_UNTRASHED_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseUntrashedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseUntrashedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseUntrashedDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseUntrashedDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseUntrashedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseUntrashedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseUntrashedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseUntrashedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseUntrashedDetails", SHOWCASE_UNTRASHED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseUntrashedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseUntrashedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseUntrashedType {
    pub description: String,
}

impl ShowcaseUntrashedType {
    pub fn new(description: String) -> Self {
        ShowcaseUntrashedType {
            description,
        }
    }

}

const SHOWCASE_UNTRASHED_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseUntrashedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseUntrashedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseUntrashedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseUntrashedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseUntrashedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseUntrashedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseUntrashedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseUntrashedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseUntrashedType", SHOWCASE_UNTRASHED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseUntrashedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseUntrashedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Viewed showcase.
#[derive(Debug)]
pub struct ShowcaseViewDetails {
    /// Event unique identifier.
    pub event_uuid: String,
}

impl ShowcaseViewDetails {
    pub fn new(event_uuid: String) -> Self {
        ShowcaseViewDetails {
            event_uuid,
        }
    }

}

const SHOWCASE_VIEW_DETAILS_FIELDS: &[&str] = &["event_uuid"];
impl ShowcaseViewDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseViewDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseViewDetails>, V::Error> {
        let mut field_event_uuid = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "event_uuid" => {
                    if field_event_uuid.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_uuid"));
                    }
                    field_event_uuid = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseViewDetails {
            event_uuid: field_event_uuid.ok_or_else(|| ::serde::de::Error::missing_field("event_uuid"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("event_uuid", &self.event_uuid)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseViewDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseViewDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseViewDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseViewDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseViewDetails", SHOWCASE_VIEW_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseViewDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseViewDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ShowcaseViewType {
    pub description: String,
}

impl ShowcaseViewType {
    pub fn new(description: String) -> Self {
        ShowcaseViewType {
            description,
        }
    }

}

const SHOWCASE_VIEW_TYPE_FIELDS: &[&str] = &["description"];
impl ShowcaseViewType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ShowcaseViewType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ShowcaseViewType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ShowcaseViewType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ShowcaseViewType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ShowcaseViewType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ShowcaseViewType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ShowcaseViewType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ShowcaseViewType", SHOWCASE_VIEW_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ShowcaseViewType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ShowcaseViewType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Ended admin sign-in-as session.
#[derive(Debug)]
pub struct SignInAsSessionEndDetails {
}

impl Default for SignInAsSessionEndDetails {
    fn default() -> Self {
        SignInAsSessionEndDetails {
        }
    }
}

const SIGN_IN_AS_SESSION_END_DETAILS_FIELDS: &[&str] = &[];
impl SignInAsSessionEndDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SignInAsSessionEndDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SignInAsSessionEndDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionEndDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionEndDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionEndDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionEndDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionEndDetails", SIGN_IN_AS_SESSION_END_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionEndDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SignInAsSessionEndDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SignInAsSessionEndType {
    pub description: String,
}

impl SignInAsSessionEndType {
    pub fn new(description: String) -> Self {
        SignInAsSessionEndType {
            description,
        }
    }

}

const SIGN_IN_AS_SESSION_END_TYPE_FIELDS: &[&str] = &["description"];
impl SignInAsSessionEndType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SignInAsSessionEndType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SignInAsSessionEndType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SignInAsSessionEndType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionEndType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionEndType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionEndType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionEndType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionEndType", SIGN_IN_AS_SESSION_END_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionEndType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SignInAsSessionEndType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Started admin sign-in-as session.
#[derive(Debug)]
pub struct SignInAsSessionStartDetails {
}

impl Default for SignInAsSessionStartDetails {
    fn default() -> Self {
        SignInAsSessionStartDetails {
        }
    }
}

const SIGN_IN_AS_SESSION_START_DETAILS_FIELDS: &[&str] = &[];
impl SignInAsSessionStartDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SignInAsSessionStartDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SignInAsSessionStartDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionStartDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionStartDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionStartDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionStartDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionStartDetails", SIGN_IN_AS_SESSION_START_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionStartDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SignInAsSessionStartDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SignInAsSessionStartType {
    pub description: String,
}

impl SignInAsSessionStartType {
    pub fn new(description: String) -> Self {
        SignInAsSessionStartType {
            description,
        }
    }

}

const SIGN_IN_AS_SESSION_START_TYPE_FIELDS: &[&str] = &["description"];
impl SignInAsSessionStartType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SignInAsSessionStartType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SignInAsSessionStartType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SignInAsSessionStartType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SignInAsSessionStartType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SignInAsSessionStartType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SignInAsSessionStartType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SignInAsSessionStartType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SignInAsSessionStartType", SIGN_IN_AS_SESSION_START_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SignInAsSessionStartType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SignInAsSessionStartType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed default Smart Sync setting for team members.
#[derive(Debug)]
pub struct SmartSyncChangePolicyDetails {
    /// New smart sync policy.
    pub new_value: Option<super::team_policies::SmartSyncPolicy>,
    /// Previous smart sync policy.
    pub previous_value: Option<super::team_policies::SmartSyncPolicy>,
}

impl Default for SmartSyncChangePolicyDetails {
    fn default() -> Self {
        SmartSyncChangePolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const SMART_SYNC_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl SmartSyncChangePolicyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncChangePolicyDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SmartSyncChangePolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmartSyncChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncChangePolicyDetails", SMART_SYNC_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SmartSyncChangePolicyType {
    pub description: String,
}

impl SmartSyncChangePolicyType {
    pub fn new(description: String) -> Self {
        SmartSyncChangePolicyType {
            description,
        }
    }

}

const SMART_SYNC_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SmartSyncChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SmartSyncChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SmartSyncChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SmartSyncChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmartSyncChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncChangePolicyType", SMART_SYNC_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created Smart Sync non-admin devices report.
#[derive(Debug)]
pub struct SmartSyncCreateAdminPrivilegeReportDetails {
}

impl Default for SmartSyncCreateAdminPrivilegeReportDetails {
    fn default() -> Self {
        SmartSyncCreateAdminPrivilegeReportDetails {
        }
    }
}

const SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_DETAILS_FIELDS: &[&str] = &[];
impl SmartSyncCreateAdminPrivilegeReportDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SmartSyncCreateAdminPrivilegeReportDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SmartSyncCreateAdminPrivilegeReportDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncCreateAdminPrivilegeReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncCreateAdminPrivilegeReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmartSyncCreateAdminPrivilegeReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncCreateAdminPrivilegeReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncCreateAdminPrivilegeReportDetails", SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncCreateAdminPrivilegeReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SmartSyncCreateAdminPrivilegeReportDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SmartSyncCreateAdminPrivilegeReportType {
    pub description: String,
}

impl SmartSyncCreateAdminPrivilegeReportType {
    pub fn new(description: String) -> Self {
        SmartSyncCreateAdminPrivilegeReportType {
            description,
        }
    }

}

const SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl SmartSyncCreateAdminPrivilegeReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SmartSyncCreateAdminPrivilegeReportType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SmartSyncCreateAdminPrivilegeReportType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SmartSyncCreateAdminPrivilegeReportType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncCreateAdminPrivilegeReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncCreateAdminPrivilegeReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmartSyncCreateAdminPrivilegeReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncCreateAdminPrivilegeReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncCreateAdminPrivilegeReportType", SMART_SYNC_CREATE_ADMIN_PRIVILEGE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncCreateAdminPrivilegeReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncCreateAdminPrivilegeReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Opted team into Smart Sync.
#[derive(Debug)]
pub struct SmartSyncNotOptOutDetails {
    /// Previous Smart Sync opt out policy.
    pub previous_value: SmartSyncOptOutPolicy,
    /// New Smart Sync opt out policy.
    pub new_value: SmartSyncOptOutPolicy,
}

impl SmartSyncNotOptOutDetails {
    pub fn new(previous_value: SmartSyncOptOutPolicy, new_value: SmartSyncOptOutPolicy) -> Self {
        SmartSyncNotOptOutDetails {
            previous_value,
            new_value,
        }
    }

}

const SMART_SYNC_NOT_OPT_OUT_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                         "new_value"];
impl SmartSyncNotOptOutDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SmartSyncNotOptOutDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SmartSyncNotOptOutDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SmartSyncNotOptOutDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncNotOptOutDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncNotOptOutDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmartSyncNotOptOutDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncNotOptOutDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncNotOptOutDetails", SMART_SYNC_NOT_OPT_OUT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncNotOptOutDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncNotOptOutDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SmartSyncNotOptOutType {
    pub description: String,
}

impl SmartSyncNotOptOutType {
    pub fn new(description: String) -> Self {
        SmartSyncNotOptOutType {
            description,
        }
    }

}

const SMART_SYNC_NOT_OPT_OUT_TYPE_FIELDS: &[&str] = &["description"];
impl SmartSyncNotOptOutType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SmartSyncNotOptOutType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SmartSyncNotOptOutType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SmartSyncNotOptOutType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncNotOptOutType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncNotOptOutType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmartSyncNotOptOutType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncNotOptOutType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncNotOptOutType", SMART_SYNC_NOT_OPT_OUT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncNotOptOutType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncNotOptOutType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Opted team out of Smart Sync.
#[derive(Debug)]
pub struct SmartSyncOptOutDetails {
    /// Previous Smart Sync opt out policy.
    pub previous_value: SmartSyncOptOutPolicy,
    /// New Smart Sync opt out policy.
    pub new_value: SmartSyncOptOutPolicy,
}

impl SmartSyncOptOutDetails {
    pub fn new(previous_value: SmartSyncOptOutPolicy, new_value: SmartSyncOptOutPolicy) -> Self {
        SmartSyncOptOutDetails {
            previous_value,
            new_value,
        }
    }

}

const SMART_SYNC_OPT_OUT_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                     "new_value"];
impl SmartSyncOptOutDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SmartSyncOptOutDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SmartSyncOptOutDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SmartSyncOptOutDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncOptOutDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncOptOutDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmartSyncOptOutDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncOptOutDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncOptOutDetails", SMART_SYNC_OPT_OUT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncOptOutDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncOptOutDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum SmartSyncOptOutPolicy {
    Default,
    OptedOut,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncOptOutPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SmartSyncOptOutPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmartSyncOptOutPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "default" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SmartSyncOptOutPolicy::Default)
                    }
                    "opted_out" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SmartSyncOptOutPolicy::OptedOut)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SmartSyncOptOutPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["default",
                                    "opted_out",
                                    "other"];
        deserializer.deserialize_struct("SmartSyncOptOutPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncOptOutPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SmartSyncOptOutPolicy::Default => {
                // unit
                let mut s = serializer.serialize_struct("SmartSyncOptOutPolicy", 1)?;
                s.serialize_field(".tag", "default")?;
                s.end()
            }
            SmartSyncOptOutPolicy::OptedOut => {
                // unit
                let mut s = serializer.serialize_struct("SmartSyncOptOutPolicy", 1)?;
                s.serialize_field(".tag", "opted_out")?;
                s.end()
            }
            SmartSyncOptOutPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct SmartSyncOptOutType {
    pub description: String,
}

impl SmartSyncOptOutType {
    pub fn new(description: String) -> Self {
        SmartSyncOptOutType {
            description,
        }
    }

}

const SMART_SYNC_OPT_OUT_TYPE_FIELDS: &[&str] = &["description"];
impl SmartSyncOptOutType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SmartSyncOptOutType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SmartSyncOptOutType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SmartSyncOptOutType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmartSyncOptOutType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmartSyncOptOutType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmartSyncOptOutType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmartSyncOptOutType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmartSyncOptOutType", SMART_SYNC_OPT_OUT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmartSyncOptOutType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmartSyncOptOutType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed automatic Smart Sync setting for team.
#[derive(Debug)]
pub struct SmarterSmartSyncPolicyChangedDetails {
    /// Previous automatic Smart Sync setting.
    pub previous_value: super::team_policies::SmarterSmartSyncPolicyState,
    /// New automatic Smart Sync setting.
    pub new_value: super::team_policies::SmarterSmartSyncPolicyState,
}

impl SmarterSmartSyncPolicyChangedDetails {
    pub fn new(
        previous_value: super::team_policies::SmarterSmartSyncPolicyState,
        new_value: super::team_policies::SmarterSmartSyncPolicyState,
    ) -> Self {
        SmarterSmartSyncPolicyChangedDetails {
            previous_value,
            new_value,
        }
    }

}

const SMARTER_SMART_SYNC_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                    "new_value"];
impl SmarterSmartSyncPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SmarterSmartSyncPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SmarterSmartSyncPolicyChangedDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SmarterSmartSyncPolicyChangedDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmarterSmartSyncPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmarterSmartSyncPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmarterSmartSyncPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmarterSmartSyncPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmarterSmartSyncPolicyChangedDetails", SMARTER_SMART_SYNC_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmarterSmartSyncPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmarterSmartSyncPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SmarterSmartSyncPolicyChangedType {
    pub description: String,
}

impl SmarterSmartSyncPolicyChangedType {
    pub fn new(description: String) -> Self {
        SmarterSmartSyncPolicyChangedType {
            description,
        }
    }

}

const SMARTER_SMART_SYNC_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl SmarterSmartSyncPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SmarterSmartSyncPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SmarterSmartSyncPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SmarterSmartSyncPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SmarterSmartSyncPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SmarterSmartSyncPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SmarterSmartSyncPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SmarterSmartSyncPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SmarterSmartSyncPolicyChangedType", SMARTER_SMART_SYNC_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SmarterSmartSyncPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SmarterSmartSyncPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Space limit alert policy
#[derive(Debug)]
pub enum SpaceCapsType {
    Hard,
    Off,
    Soft,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SpaceCapsType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SpaceCapsType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SpaceCapsType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "hard" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SpaceCapsType::Hard)
                    }
                    "off" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SpaceCapsType::Off)
                    }
                    "soft" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SpaceCapsType::Soft)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SpaceCapsType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["hard",
                                    "off",
                                    "soft",
                                    "other"];
        deserializer.deserialize_struct("SpaceCapsType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SpaceCapsType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SpaceCapsType::Hard => {
                // unit
                let mut s = serializer.serialize_struct("SpaceCapsType", 1)?;
                s.serialize_field(".tag", "hard")?;
                s.end()
            }
            SpaceCapsType::Off => {
                // unit
                let mut s = serializer.serialize_struct("SpaceCapsType", 1)?;
                s.serialize_field(".tag", "off")?;
                s.end()
            }
            SpaceCapsType::Soft => {
                // unit
                let mut s = serializer.serialize_struct("SpaceCapsType", 1)?;
                s.serialize_field(".tag", "soft")?;
                s.end()
            }
            SpaceCapsType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum SpaceLimitsStatus {
    WithinQuota,
    NearQuota,
    OverQuota,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for SpaceLimitsStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SpaceLimitsStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SpaceLimitsStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "within_quota" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SpaceLimitsStatus::WithinQuota)
                    }
                    "near_quota" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SpaceLimitsStatus::NearQuota)
                    }
                    "over_quota" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SpaceLimitsStatus::OverQuota)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(SpaceLimitsStatus::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["within_quota",
                                    "near_quota",
                                    "over_quota",
                                    "other"];
        deserializer.deserialize_struct("SpaceLimitsStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SpaceLimitsStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SpaceLimitsStatus::WithinQuota => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsStatus", 1)?;
                s.serialize_field(".tag", "within_quota")?;
                s.end()
            }
            SpaceLimitsStatus::NearQuota => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsStatus", 1)?;
                s.serialize_field(".tag", "near_quota")?;
                s.end()
            }
            SpaceLimitsStatus::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("SpaceLimitsStatus", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            SpaceLimitsStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Added X.509 certificate for SSO.
#[derive(Debug)]
pub struct SsoAddCertDetails {
    /// SSO certificate details.
    pub certificate_details: Certificate,
}

impl SsoAddCertDetails {
    pub fn new(certificate_details: Certificate) -> Self {
        SsoAddCertDetails {
            certificate_details,
        }
    }

}

const SSO_ADD_CERT_DETAILS_FIELDS: &[&str] = &["certificate_details"];
impl SsoAddCertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoAddCertDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoAddCertDetails>, V::Error> {
        let mut field_certificate_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "certificate_details" => {
                    if field_certificate_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("certificate_details"));
                    }
                    field_certificate_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoAddCertDetails {
            certificate_details: field_certificate_details.ok_or_else(|| ::serde::de::Error::missing_field("certificate_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("certificate_details", &self.certificate_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddCertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddCertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoAddCertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddCertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddCertDetails", SSO_ADD_CERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddCertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddCertDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoAddCertType {
    pub description: String,
}

impl SsoAddCertType {
    pub fn new(description: String) -> Self {
        SsoAddCertType {
            description,
        }
    }

}

const SSO_ADD_CERT_TYPE_FIELDS: &[&str] = &["description"];
impl SsoAddCertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoAddCertType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoAddCertType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoAddCertType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddCertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddCertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoAddCertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddCertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddCertType", SSO_ADD_CERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddCertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddCertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added sign-in URL for SSO.
#[derive(Debug)]
pub struct SsoAddLoginUrlDetails {
    /// New single sign-on login URL.
    pub new_value: String,
}

impl SsoAddLoginUrlDetails {
    pub fn new(new_value: String) -> Self {
        SsoAddLoginUrlDetails {
            new_value,
        }
    }

}

const SSO_ADD_LOGIN_URL_DETAILS_FIELDS: &[&str] = &["new_value"];
impl SsoAddLoginUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoAddLoginUrlDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoAddLoginUrlDetails>, V::Error> {
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoAddLoginUrlDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddLoginUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddLoginUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoAddLoginUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddLoginUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddLoginUrlDetails", SSO_ADD_LOGIN_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddLoginUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddLoginUrlDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoAddLoginUrlType {
    pub description: String,
}

impl SsoAddLoginUrlType {
    pub fn new(description: String) -> Self {
        SsoAddLoginUrlType {
            description,
        }
    }

}

const SSO_ADD_LOGIN_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoAddLoginUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoAddLoginUrlType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoAddLoginUrlType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoAddLoginUrlType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddLoginUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddLoginUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoAddLoginUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddLoginUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddLoginUrlType", SSO_ADD_LOGIN_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddLoginUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddLoginUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added sign-out URL for SSO.
#[derive(Debug)]
pub struct SsoAddLogoutUrlDetails {
    /// New single sign-on logout URL. Might be missing due to historical data gap.
    pub new_value: Option<String>,
}

impl Default for SsoAddLogoutUrlDetails {
    fn default() -> Self {
        SsoAddLogoutUrlDetails {
            new_value: None,
        }
    }
}

const SSO_ADD_LOGOUT_URL_DETAILS_FIELDS: &[&str] = &["new_value"];
impl SsoAddLogoutUrlDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoAddLogoutUrlDetails, V::Error> {
        let mut field_new_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SsoAddLogoutUrlDetails {
            new_value: field_new_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddLogoutUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddLogoutUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoAddLogoutUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddLogoutUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddLogoutUrlDetails", SSO_ADD_LOGOUT_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddLogoutUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddLogoutUrlDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoAddLogoutUrlType {
    pub description: String,
}

impl SsoAddLogoutUrlType {
    pub fn new(description: String) -> Self {
        SsoAddLogoutUrlType {
            description,
        }
    }

}

const SSO_ADD_LOGOUT_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoAddLogoutUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoAddLogoutUrlType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoAddLogoutUrlType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoAddLogoutUrlType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoAddLogoutUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoAddLogoutUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoAddLogoutUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoAddLogoutUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoAddLogoutUrlType", SSO_ADD_LOGOUT_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoAddLogoutUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoAddLogoutUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed X.509 certificate for SSO.
#[derive(Debug)]
pub struct SsoChangeCertDetails {
    /// New SSO certificate details.
    pub new_certificate_details: Certificate,
    /// Previous SSO certificate details. Might be missing due to historical data gap.
    pub previous_certificate_details: Option<Certificate>,
}

impl SsoChangeCertDetails {
    pub fn new(new_certificate_details: Certificate) -> Self {
        SsoChangeCertDetails {
            new_certificate_details,
            previous_certificate_details: None,
        }
    }

    pub fn with_previous_certificate_details(mut self, value: Option<Certificate>) -> Self {
        self.previous_certificate_details = value;
        self
    }

}

const SSO_CHANGE_CERT_DETAILS_FIELDS: &[&str] = &["new_certificate_details",
                                                  "previous_certificate_details"];
impl SsoChangeCertDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoChangeCertDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoChangeCertDetails>, V::Error> {
        let mut field_new_certificate_details = None;
        let mut field_previous_certificate_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_certificate_details" => {
                    if field_new_certificate_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_certificate_details"));
                    }
                    field_new_certificate_details = Some(map.next_value()?);
                }
                "previous_certificate_details" => {
                    if field_previous_certificate_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_certificate_details"));
                    }
                    field_previous_certificate_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoChangeCertDetails {
            new_certificate_details: field_new_certificate_details.ok_or_else(|| ::serde::de::Error::missing_field("new_certificate_details"))?,
            previous_certificate_details: field_previous_certificate_details,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_certificate_details", &self.new_certificate_details)?;
        s.serialize_field("previous_certificate_details", &self.previous_certificate_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeCertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeCertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangeCertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeCertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeCertDetails", SSO_CHANGE_CERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeCertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeCertDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangeCertType {
    pub description: String,
}

impl SsoChangeCertType {
    pub fn new(description: String) -> Self {
        SsoChangeCertType {
            description,
        }
    }

}

const SSO_CHANGE_CERT_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangeCertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoChangeCertType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoChangeCertType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoChangeCertType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeCertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeCertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangeCertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeCertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeCertType", SSO_CHANGE_CERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeCertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeCertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed sign-in URL for SSO.
#[derive(Debug)]
pub struct SsoChangeLoginUrlDetails {
    /// Previous single sign-on login URL.
    pub previous_value: String,
    /// New single sign-on login URL.
    pub new_value: String,
}

impl SsoChangeLoginUrlDetails {
    pub fn new(previous_value: String, new_value: String) -> Self {
        SsoChangeLoginUrlDetails {
            previous_value,
            new_value,
        }
    }

}

const SSO_CHANGE_LOGIN_URL_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                       "new_value"];
impl SsoChangeLoginUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoChangeLoginUrlDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoChangeLoginUrlDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoChangeLoginUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLoginUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLoginUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLoginUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLoginUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLoginUrlDetails", SSO_CHANGE_LOGIN_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLoginUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLoginUrlDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangeLoginUrlType {
    pub description: String,
}

impl SsoChangeLoginUrlType {
    pub fn new(description: String) -> Self {
        SsoChangeLoginUrlType {
            description,
        }
    }

}

const SSO_CHANGE_LOGIN_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangeLoginUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoChangeLoginUrlType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoChangeLoginUrlType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoChangeLoginUrlType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLoginUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLoginUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLoginUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLoginUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLoginUrlType", SSO_CHANGE_LOGIN_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLoginUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLoginUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed sign-out URL for SSO.
#[derive(Debug)]
pub struct SsoChangeLogoutUrlDetails {
    /// Previous single sign-on logout URL. Might be missing due to historical data gap.
    pub previous_value: Option<String>,
    /// New single sign-on logout URL. Might be missing due to historical data gap.
    pub new_value: Option<String>,
}

impl Default for SsoChangeLogoutUrlDetails {
    fn default() -> Self {
        SsoChangeLogoutUrlDetails {
            previous_value: None,
            new_value: None,
        }
    }
}

const SSO_CHANGE_LOGOUT_URL_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                        "new_value"];
impl SsoChangeLogoutUrlDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoChangeLogoutUrlDetails, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = SsoChangeLogoutUrlDetails {
            previous_value: field_previous_value,
            new_value: field_new_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLogoutUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLogoutUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLogoutUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLogoutUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLogoutUrlDetails", SSO_CHANGE_LOGOUT_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLogoutUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLogoutUrlDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangeLogoutUrlType {
    pub description: String,
}

impl SsoChangeLogoutUrlType {
    pub fn new(description: String) -> Self {
        SsoChangeLogoutUrlType {
            description,
        }
    }

}

const SSO_CHANGE_LOGOUT_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangeLogoutUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoChangeLogoutUrlType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoChangeLogoutUrlType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoChangeLogoutUrlType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeLogoutUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeLogoutUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangeLogoutUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeLogoutUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeLogoutUrlType", SSO_CHANGE_LOGOUT_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeLogoutUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeLogoutUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed single sign-on setting for team.
#[derive(Debug)]
pub struct SsoChangePolicyDetails {
    /// New single sign-on policy.
    pub new_value: super::team_policies::SsoPolicy,
    /// Previous single sign-on policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::SsoPolicy>,
}

impl SsoChangePolicyDetails {
    pub fn new(new_value: super::team_policies::SsoPolicy) -> Self {
        SsoChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::team_policies::SsoPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const SSO_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                    "previous_value"];
impl SsoChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangePolicyDetails", SSO_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangePolicyType {
    pub description: String,
}

impl SsoChangePolicyType {
    pub fn new(description: String) -> Self {
        SsoChangePolicyType {
            description,
        }
    }

}

const SSO_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangePolicyType", SSO_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed SAML identity mode for SSO.
#[derive(Debug)]
pub struct SsoChangeSamlIdentityModeDetails {
    /// Previous single sign-on identity mode.
    pub previous_value: i64,
    /// New single sign-on identity mode.
    pub new_value: i64,
}

impl SsoChangeSamlIdentityModeDetails {
    pub fn new(previous_value: i64, new_value: i64) -> Self {
        SsoChangeSamlIdentityModeDetails {
            previous_value,
            new_value,
        }
    }

}

const SSO_CHANGE_SAML_IDENTITY_MODE_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                "new_value"];
impl SsoChangeSamlIdentityModeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoChangeSamlIdentityModeDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoChangeSamlIdentityModeDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoChangeSamlIdentityModeDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeSamlIdentityModeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeSamlIdentityModeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangeSamlIdentityModeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeSamlIdentityModeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeSamlIdentityModeDetails", SSO_CHANGE_SAML_IDENTITY_MODE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeSamlIdentityModeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeSamlIdentityModeDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoChangeSamlIdentityModeType {
    pub description: String,
}

impl SsoChangeSamlIdentityModeType {
    pub fn new(description: String) -> Self {
        SsoChangeSamlIdentityModeType {
            description,
        }
    }

}

const SSO_CHANGE_SAML_IDENTITY_MODE_TYPE_FIELDS: &[&str] = &["description"];
impl SsoChangeSamlIdentityModeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoChangeSamlIdentityModeType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoChangeSamlIdentityModeType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoChangeSamlIdentityModeType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoChangeSamlIdentityModeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoChangeSamlIdentityModeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoChangeSamlIdentityModeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoChangeSamlIdentityModeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoChangeSamlIdentityModeType", SSO_CHANGE_SAML_IDENTITY_MODE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoChangeSamlIdentityModeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoChangeSamlIdentityModeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Failed to sign in via SSO.
#[derive(Debug)]
pub struct SsoErrorDetails {
    /// Error details.
    pub error_details: FailureDetailsLogInfo,
}

impl SsoErrorDetails {
    pub fn new(error_details: FailureDetailsLogInfo) -> Self {
        SsoErrorDetails {
            error_details,
        }
    }

}

const SSO_ERROR_DETAILS_FIELDS: &[&str] = &["error_details"];
impl SsoErrorDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoErrorDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoErrorDetails>, V::Error> {
        let mut field_error_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "error_details" => {
                    if field_error_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("error_details"));
                    }
                    field_error_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoErrorDetails {
            error_details: field_error_details.ok_or_else(|| ::serde::de::Error::missing_field("error_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("error_details", &self.error_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoErrorDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoErrorDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoErrorDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoErrorDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoErrorDetails", SSO_ERROR_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoErrorDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoErrorDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoErrorType {
    pub description: String,
}

impl SsoErrorType {
    pub fn new(description: String) -> Self {
        SsoErrorType {
            description,
        }
    }

}

const SSO_ERROR_TYPE_FIELDS: &[&str] = &["description"];
impl SsoErrorType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoErrorType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoErrorType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoErrorType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoErrorType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoErrorType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoErrorType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoErrorType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoErrorType", SSO_ERROR_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoErrorType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoErrorType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed X.509 certificate for SSO.
#[derive(Debug)]
pub struct SsoRemoveCertDetails {
}

impl Default for SsoRemoveCertDetails {
    fn default() -> Self {
        SsoRemoveCertDetails {
        }
    }
}

const SSO_REMOVE_CERT_DETAILS_FIELDS: &[&str] = &[];
impl SsoRemoveCertDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<SsoRemoveCertDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(SsoRemoveCertDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveCertDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveCertDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveCertDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveCertDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveCertDetails", SSO_REMOVE_CERT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveCertDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("SsoRemoveCertDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct SsoRemoveCertType {
    pub description: String,
}

impl SsoRemoveCertType {
    pub fn new(description: String) -> Self {
        SsoRemoveCertType {
            description,
        }
    }

}

const SSO_REMOVE_CERT_TYPE_FIELDS: &[&str] = &["description"];
impl SsoRemoveCertType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoRemoveCertType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoRemoveCertType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoRemoveCertType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveCertType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveCertType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveCertType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveCertType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveCertType", SSO_REMOVE_CERT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveCertType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveCertType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed sign-in URL for SSO.
#[derive(Debug)]
pub struct SsoRemoveLoginUrlDetails {
    /// Previous single sign-on login URL.
    pub previous_value: String,
}

impl SsoRemoveLoginUrlDetails {
    pub fn new(previous_value: String) -> Self {
        SsoRemoveLoginUrlDetails {
            previous_value,
        }
    }

}

const SSO_REMOVE_LOGIN_URL_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl SsoRemoveLoginUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoRemoveLoginUrlDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoRemoveLoginUrlDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoRemoveLoginUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveLoginUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveLoginUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveLoginUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveLoginUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveLoginUrlDetails", SSO_REMOVE_LOGIN_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveLoginUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveLoginUrlDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoRemoveLoginUrlType {
    pub description: String,
}

impl SsoRemoveLoginUrlType {
    pub fn new(description: String) -> Self {
        SsoRemoveLoginUrlType {
            description,
        }
    }

}

const SSO_REMOVE_LOGIN_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoRemoveLoginUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoRemoveLoginUrlType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoRemoveLoginUrlType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoRemoveLoginUrlType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveLoginUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveLoginUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveLoginUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveLoginUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveLoginUrlType", SSO_REMOVE_LOGIN_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveLoginUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveLoginUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed sign-out URL for SSO.
#[derive(Debug)]
pub struct SsoRemoveLogoutUrlDetails {
    /// Previous single sign-on logout URL.
    pub previous_value: String,
}

impl SsoRemoveLogoutUrlDetails {
    pub fn new(previous_value: String) -> Self {
        SsoRemoveLogoutUrlDetails {
            previous_value,
        }
    }

}

const SSO_REMOVE_LOGOUT_URL_DETAILS_FIELDS: &[&str] = &["previous_value"];
impl SsoRemoveLogoutUrlDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoRemoveLogoutUrlDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoRemoveLogoutUrlDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoRemoveLogoutUrlDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveLogoutUrlDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveLogoutUrlDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveLogoutUrlDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveLogoutUrlDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveLogoutUrlDetails", SSO_REMOVE_LOGOUT_URL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveLogoutUrlDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveLogoutUrlDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SsoRemoveLogoutUrlType {
    pub description: String,
}

impl SsoRemoveLogoutUrlType {
    pub fn new(description: String) -> Self {
        SsoRemoveLogoutUrlType {
            description,
        }
    }

}

const SSO_REMOVE_LOGOUT_URL_TYPE_FIELDS: &[&str] = &["description"];
impl SsoRemoveLogoutUrlType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SsoRemoveLogoutUrlType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SsoRemoveLogoutUrlType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SsoRemoveLogoutUrlType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SsoRemoveLogoutUrlType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SsoRemoveLogoutUrlType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SsoRemoveLogoutUrlType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SsoRemoveLogoutUrlType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SsoRemoveLogoutUrlType", SSO_REMOVE_LOGOUT_URL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SsoRemoveLogoutUrlType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SsoRemoveLogoutUrlType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Started enterprise admin session.
#[derive(Debug)]
pub struct StartedEnterpriseAdminSessionDetails {
    /// More information about the organization or team.
    pub federation_extra_details: FedExtraDetails,
}

impl StartedEnterpriseAdminSessionDetails {
    pub fn new(federation_extra_details: FedExtraDetails) -> Self {
        StartedEnterpriseAdminSessionDetails {
            federation_extra_details,
        }
    }

}

const STARTED_ENTERPRISE_ADMIN_SESSION_DETAILS_FIELDS: &[&str] = &["federation_extra_details"];
impl StartedEnterpriseAdminSessionDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<StartedEnterpriseAdminSessionDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<StartedEnterpriseAdminSessionDetails>, V::Error> {
        let mut field_federation_extra_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "federation_extra_details" => {
                    if field_federation_extra_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("federation_extra_details"));
                    }
                    field_federation_extra_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = StartedEnterpriseAdminSessionDetails {
            federation_extra_details: field_federation_extra_details.ok_or_else(|| ::serde::de::Error::missing_field("federation_extra_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("federation_extra_details", &self.federation_extra_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for StartedEnterpriseAdminSessionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = StartedEnterpriseAdminSessionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a StartedEnterpriseAdminSessionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                StartedEnterpriseAdminSessionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("StartedEnterpriseAdminSessionDetails", STARTED_ENTERPRISE_ADMIN_SESSION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for StartedEnterpriseAdminSessionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("StartedEnterpriseAdminSessionDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct StartedEnterpriseAdminSessionType {
    pub description: String,
}

impl StartedEnterpriseAdminSessionType {
    pub fn new(description: String) -> Self {
        StartedEnterpriseAdminSessionType {
            description,
        }
    }

}

const STARTED_ENTERPRISE_ADMIN_SESSION_TYPE_FIELDS: &[&str] = &["description"];
impl StartedEnterpriseAdminSessionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<StartedEnterpriseAdminSessionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<StartedEnterpriseAdminSessionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = StartedEnterpriseAdminSessionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for StartedEnterpriseAdminSessionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = StartedEnterpriseAdminSessionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a StartedEnterpriseAdminSessionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                StartedEnterpriseAdminSessionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("StartedEnterpriseAdminSessionType", STARTED_ENTERPRISE_ADMIN_SESSION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for StartedEnterpriseAdminSessionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("StartedEnterpriseAdminSessionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created team activity report.
#[derive(Debug)]
pub struct TeamActivityCreateReportDetails {
    /// Report start date.
    pub start_date: super::common::DropboxTimestamp,
    /// Report end date.
    pub end_date: super::common::DropboxTimestamp,
}

impl TeamActivityCreateReportDetails {
    pub fn new(
        start_date: super::common::DropboxTimestamp,
        end_date: super::common::DropboxTimestamp,
    ) -> Self {
        TeamActivityCreateReportDetails {
            start_date,
            end_date,
        }
    }

}

const TEAM_ACTIVITY_CREATE_REPORT_DETAILS_FIELDS: &[&str] = &["start_date",
                                                              "end_date"];
impl TeamActivityCreateReportDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamActivityCreateReportDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamActivityCreateReportDetails>, V::Error> {
        let mut field_start_date = None;
        let mut field_end_date = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "end_date" => {
                    if field_end_date.is_some() {
                        return Err(::serde::de::Error::duplicate_field("end_date"));
                    }
                    field_end_date = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamActivityCreateReportDetails {
            start_date: field_start_date.ok_or_else(|| ::serde::de::Error::missing_field("start_date"))?,
            end_date: field_end_date.ok_or_else(|| ::serde::de::Error::missing_field("end_date"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("end_date", &self.end_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamActivityCreateReportDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamActivityCreateReportDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamActivityCreateReportDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamActivityCreateReportDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamActivityCreateReportDetails", TEAM_ACTIVITY_CREATE_REPORT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamActivityCreateReportDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamActivityCreateReportDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Couldn't generate team activity report.
#[derive(Debug)]
pub struct TeamActivityCreateReportFailDetails {
    /// Failure reason.
    pub failure_reason: super::team::TeamReportFailureReason,
}

impl TeamActivityCreateReportFailDetails {
    pub fn new(failure_reason: super::team::TeamReportFailureReason) -> Self {
        TeamActivityCreateReportFailDetails {
            failure_reason,
        }
    }

}

const TEAM_ACTIVITY_CREATE_REPORT_FAIL_DETAILS_FIELDS: &[&str] = &["failure_reason"];
impl TeamActivityCreateReportFailDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamActivityCreateReportFailDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamActivityCreateReportFailDetails>, V::Error> {
        let mut field_failure_reason = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "failure_reason" => {
                    if field_failure_reason.is_some() {
                        return Err(::serde::de::Error::duplicate_field("failure_reason"));
                    }
                    field_failure_reason = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamActivityCreateReportFailDetails {
            failure_reason: field_failure_reason.ok_or_else(|| ::serde::de::Error::missing_field("failure_reason"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("failure_reason", &self.failure_reason)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamActivityCreateReportFailDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamActivityCreateReportFailDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamActivityCreateReportFailDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamActivityCreateReportFailDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamActivityCreateReportFailDetails", TEAM_ACTIVITY_CREATE_REPORT_FAIL_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamActivityCreateReportFailDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamActivityCreateReportFailDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamActivityCreateReportFailType {
    pub description: String,
}

impl TeamActivityCreateReportFailType {
    pub fn new(description: String) -> Self {
        TeamActivityCreateReportFailType {
            description,
        }
    }

}

const TEAM_ACTIVITY_CREATE_REPORT_FAIL_TYPE_FIELDS: &[&str] = &["description"];
impl TeamActivityCreateReportFailType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamActivityCreateReportFailType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamActivityCreateReportFailType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamActivityCreateReportFailType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamActivityCreateReportFailType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamActivityCreateReportFailType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamActivityCreateReportFailType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamActivityCreateReportFailType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamActivityCreateReportFailType", TEAM_ACTIVITY_CREATE_REPORT_FAIL_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamActivityCreateReportFailType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamActivityCreateReportFailType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamActivityCreateReportType {
    pub description: String,
}

impl TeamActivityCreateReportType {
    pub fn new(description: String) -> Self {
        TeamActivityCreateReportType {
            description,
        }
    }

}

const TEAM_ACTIVITY_CREATE_REPORT_TYPE_FIELDS: &[&str] = &["description"];
impl TeamActivityCreateReportType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamActivityCreateReportType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamActivityCreateReportType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamActivityCreateReportType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamActivityCreateReportType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamActivityCreateReportType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamActivityCreateReportType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamActivityCreateReportType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamActivityCreateReportType", TEAM_ACTIVITY_CREATE_REPORT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamActivityCreateReportType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamActivityCreateReportType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// More details about the team.
#[derive(Debug)]
pub struct TeamDetails {
    /// The name of the team.
    pub team: String,
}

impl TeamDetails {
    pub fn new(team: String) -> Self {
        TeamDetails {
            team,
        }
    }

}

const TEAM_DETAILS_FIELDS: &[&str] = &["team"];
impl TeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamDetails>, V::Error> {
        let mut field_team = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "team" => {
                    if field_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team"));
                    }
                    field_team = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamDetails {
            team: field_team.ok_or_else(|| ::serde::de::Error::missing_field("team"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team", &self.team)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamDetails", TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// An audit log event.
#[derive(Debug)]
pub struct TeamEvent {
    /// The Dropbox timestamp representing when the action was taken.
    pub timestamp: super::common::DropboxTimestamp,
    /// The category that this type of action belongs to.
    pub event_category: EventCategory,
    /// The particular type of action taken.
    pub event_type: EventType,
    /// The variable event schema applicable to this type of action, instantiated with respect to
    /// this particular action.
    pub details: EventDetails,
    /// The entity who actually performed the action. Might be missing due to historical data gap.
    pub actor: Option<ActorLogInfo>,
    /// The origin from which the actor performed the action including information about host, ip
    /// address, location, session, etc. If the action was performed programmatically via the API
    /// the origin represents the API client.
    pub origin: Option<OriginLogInfo>,
    /// True if the action involved a non team member either as the actor or as one of the affected
    /// users. Might be missing due to historical data gap.
    pub involve_non_team_member: Option<bool>,
    /// The user or team on whose behalf the actor performed the action. Might be missing due to
    /// historical data gap.
    pub context: Option<ContextLogInfo>,
    /// Zero or more users and/or groups that are affected by the action. Note that this list
    /// doesn't include any actors or users in context.
    pub participants: Option<Vec<ParticipantLogInfo>>,
    /// Zero or more content assets involved in the action. Currently these include Dropbox files
    /// and folders but in the future we might add other asset types such as Paper documents,
    /// folders, projects, etc.
    pub assets: Option<Vec<AssetLogInfo>>,
}

impl TeamEvent {
    pub fn new(
        timestamp: super::common::DropboxTimestamp,
        event_category: EventCategory,
        event_type: EventType,
        details: EventDetails,
    ) -> Self {
        TeamEvent {
            timestamp,
            event_category,
            event_type,
            details,
            actor: None,
            origin: None,
            involve_non_team_member: None,
            context: None,
            participants: None,
            assets: None,
        }
    }

    pub fn with_actor(mut self, value: Option<ActorLogInfo>) -> Self {
        self.actor = value;
        self
    }

    pub fn with_origin(mut self, value: Option<OriginLogInfo>) -> Self {
        self.origin = value;
        self
    }

    pub fn with_involve_non_team_member(mut self, value: Option<bool>) -> Self {
        self.involve_non_team_member = value;
        self
    }

    pub fn with_context(mut self, value: Option<ContextLogInfo>) -> Self {
        self.context = value;
        self
    }

    pub fn with_participants(mut self, value: Option<Vec<ParticipantLogInfo>>) -> Self {
        self.participants = value;
        self
    }

    pub fn with_assets(mut self, value: Option<Vec<AssetLogInfo>>) -> Self {
        self.assets = value;
        self
    }

}

const TEAM_EVENT_FIELDS: &[&str] = &["timestamp",
                                     "event_category",
                                     "event_type",
                                     "details",
                                     "actor",
                                     "origin",
                                     "involve_non_team_member",
                                     "context",
                                     "participants",
                                     "assets"];
impl TeamEvent {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamEvent, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamEvent>, V::Error> {
        let mut field_timestamp = None;
        let mut field_event_category = None;
        let mut field_event_type = None;
        let mut field_details = None;
        let mut field_actor = None;
        let mut field_origin = None;
        let mut field_involve_non_team_member = None;
        let mut field_context = None;
        let mut field_participants = None;
        let mut field_assets = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "timestamp" => {
                    if field_timestamp.is_some() {
                        return Err(::serde::de::Error::duplicate_field("timestamp"));
                    }
                    field_timestamp = Some(map.next_value()?);
                }
                "event_category" => {
                    if field_event_category.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_category"));
                    }
                    field_event_category = Some(map.next_value()?);
                }
                "event_type" => {
                    if field_event_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("event_type"));
                    }
                    field_event_type = Some(map.next_value()?);
                }
                "details" => {
                    if field_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("details"));
                    }
                    field_details = Some(map.next_value()?);
                }
                "actor" => {
                    if field_actor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("actor"));
                    }
                    field_actor = Some(map.next_value()?);
                }
                "origin" => {
                    if field_origin.is_some() {
                        return Err(::serde::de::Error::duplicate_field("origin"));
                    }
                    field_origin = Some(map.next_value()?);
                }
                "involve_non_team_member" => {
                    if field_involve_non_team_member.is_some() {
                        return Err(::serde::de::Error::duplicate_field("involve_non_team_member"));
                    }
                    field_involve_non_team_member = Some(map.next_value()?);
                }
                "context" => {
                    if field_context.is_some() {
                        return Err(::serde::de::Error::duplicate_field("context"));
                    }
                    field_context = Some(map.next_value()?);
                }
                "participants" => {
                    if field_participants.is_some() {
                        return Err(::serde::de::Error::duplicate_field("participants"));
                    }
                    field_participants = Some(map.next_value()?);
                }
                "assets" => {
                    if field_assets.is_some() {
                        return Err(::serde::de::Error::duplicate_field("assets"));
                    }
                    field_assets = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamEvent {
            timestamp: field_timestamp.ok_or_else(|| ::serde::de::Error::missing_field("timestamp"))?,
            event_category: field_event_category.ok_or_else(|| ::serde::de::Error::missing_field("event_category"))?,
            event_type: field_event_type.ok_or_else(|| ::serde::de::Error::missing_field("event_type"))?,
            details: field_details.ok_or_else(|| ::serde::de::Error::missing_field("details"))?,
            actor: field_actor,
            origin: field_origin,
            involve_non_team_member: field_involve_non_team_member,
            context: field_context,
            participants: field_participants,
            assets: field_assets,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("timestamp", &self.timestamp)?;
        s.serialize_field("event_category", &self.event_category)?;
        s.serialize_field("event_type", &self.event_type)?;
        s.serialize_field("details", &self.details)?;
        s.serialize_field("actor", &self.actor)?;
        s.serialize_field("origin", &self.origin)?;
        s.serialize_field("involve_non_team_member", &self.involve_non_team_member)?;
        s.serialize_field("context", &self.context)?;
        s.serialize_field("participants", &self.participants)?;
        s.serialize_field("assets", &self.assets)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamEvent {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamEvent;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamEvent struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamEvent::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamEvent", TEAM_EVENT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamEvent {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamEvent", 10)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling whether App Integrations are enabled for the team.
#[derive(Debug)]
pub enum TeamExtensionsPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamExtensionsPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamExtensionsPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamExtensionsPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamExtensionsPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamExtensionsPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamExtensionsPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("TeamExtensionsPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamExtensionsPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamExtensionsPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("TeamExtensionsPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            TeamExtensionsPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("TeamExtensionsPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            TeamExtensionsPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed App Integrations setting for team.
#[derive(Debug)]
pub struct TeamExtensionsPolicyChangedDetails {
    /// New Extensions policy.
    pub new_value: TeamExtensionsPolicy,
    /// Previous Extensions policy.
    pub previous_value: TeamExtensionsPolicy,
}

impl TeamExtensionsPolicyChangedDetails {
    pub fn new(new_value: TeamExtensionsPolicy, previous_value: TeamExtensionsPolicy) -> Self {
        TeamExtensionsPolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const TEAM_EXTENSIONS_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                 "previous_value"];
impl TeamExtensionsPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamExtensionsPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamExtensionsPolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamExtensionsPolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamExtensionsPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamExtensionsPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamExtensionsPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamExtensionsPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamExtensionsPolicyChangedDetails", TEAM_EXTENSIONS_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamExtensionsPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamExtensionsPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamExtensionsPolicyChangedType {
    pub description: String,
}

impl TeamExtensionsPolicyChangedType {
    pub fn new(description: String) -> Self {
        TeamExtensionsPolicyChangedType {
            description,
        }
    }

}

const TEAM_EXTENSIONS_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl TeamExtensionsPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamExtensionsPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamExtensionsPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamExtensionsPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamExtensionsPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamExtensionsPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamExtensionsPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamExtensionsPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamExtensionsPolicyChangedType", TEAM_EXTENSIONS_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamExtensionsPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamExtensionsPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed archival status of team folder.
#[derive(Debug)]
pub struct TeamFolderChangeStatusDetails {
    /// New team folder status.
    pub new_value: super::team::TeamFolderStatus,
    /// Previous team folder status. Might be missing due to historical data gap.
    pub previous_value: Option<super::team::TeamFolderStatus>,
}

impl TeamFolderChangeStatusDetails {
    pub fn new(new_value: super::team::TeamFolderStatus) -> Self {
        TeamFolderChangeStatusDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<super::team::TeamFolderStatus>) -> Self {
        self.previous_value = value;
        self
    }

}

const TEAM_FOLDER_CHANGE_STATUS_DETAILS_FIELDS: &[&str] = &["new_value",
                                                            "previous_value"];
impl TeamFolderChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderChangeStatusDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderChangeStatusDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderChangeStatusDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderChangeStatusDetails", TEAM_FOLDER_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderChangeStatusDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderChangeStatusType {
    pub description: String,
}

impl TeamFolderChangeStatusType {
    pub fn new(description: String) -> Self {
        TeamFolderChangeStatusType {
            description,
        }
    }

}

const TEAM_FOLDER_CHANGE_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderChangeStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderChangeStatusType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderChangeStatusType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderChangeStatusType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderChangeStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderChangeStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderChangeStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderChangeStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderChangeStatusType", TEAM_FOLDER_CHANGE_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderChangeStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderChangeStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Created team folder in active status.
#[derive(Debug)]
pub struct TeamFolderCreateDetails {
}

impl Default for TeamFolderCreateDetails {
    fn default() -> Self {
        TeamFolderCreateDetails {
        }
    }
}

const TEAM_FOLDER_CREATE_DETAILS_FIELDS: &[&str] = &[];
impl TeamFolderCreateDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderCreateDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TeamFolderCreateDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderCreateDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderCreateDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderCreateDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderCreateDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderCreateDetails", TEAM_FOLDER_CREATE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderCreateDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamFolderCreateDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderCreateType {
    pub description: String,
}

impl TeamFolderCreateType {
    pub fn new(description: String) -> Self {
        TeamFolderCreateType {
            description,
        }
    }

}

const TEAM_FOLDER_CREATE_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderCreateType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderCreateType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderCreateType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderCreateType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderCreateType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderCreateType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderCreateType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderCreateType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderCreateType", TEAM_FOLDER_CREATE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderCreateType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderCreateType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Downgraded team folder to regular shared folder.
#[derive(Debug)]
pub struct TeamFolderDowngradeDetails {
    /// Target asset position in the Assets list.
    pub target_asset_index: u64,
}

impl TeamFolderDowngradeDetails {
    pub fn new(target_asset_index: u64) -> Self {
        TeamFolderDowngradeDetails {
            target_asset_index,
        }
    }

}

const TEAM_FOLDER_DOWNGRADE_DETAILS_FIELDS: &[&str] = &["target_asset_index"];
impl TeamFolderDowngradeDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderDowngradeDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderDowngradeDetails>, V::Error> {
        let mut field_target_asset_index = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "target_asset_index" => {
                    if field_target_asset_index.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_asset_index"));
                    }
                    field_target_asset_index = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderDowngradeDetails {
            target_asset_index: field_target_asset_index.ok_or_else(|| ::serde::de::Error::missing_field("target_asset_index"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("target_asset_index", &self.target_asset_index)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderDowngradeDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderDowngradeDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderDowngradeDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderDowngradeDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderDowngradeDetails", TEAM_FOLDER_DOWNGRADE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderDowngradeDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderDowngradeDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderDowngradeType {
    pub description: String,
}

impl TeamFolderDowngradeType {
    pub fn new(description: String) -> Self {
        TeamFolderDowngradeType {
            description,
        }
    }

}

const TEAM_FOLDER_DOWNGRADE_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderDowngradeType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderDowngradeType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderDowngradeType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderDowngradeType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderDowngradeType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderDowngradeType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderDowngradeType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderDowngradeType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderDowngradeType", TEAM_FOLDER_DOWNGRADE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderDowngradeType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderDowngradeType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Permanently deleted archived team folder.
#[derive(Debug)]
pub struct TeamFolderPermanentlyDeleteDetails {
}

impl Default for TeamFolderPermanentlyDeleteDetails {
    fn default() -> Self {
        TeamFolderPermanentlyDeleteDetails {
        }
    }
}

const TEAM_FOLDER_PERMANENTLY_DELETE_DETAILS_FIELDS: &[&str] = &[];
impl TeamFolderPermanentlyDeleteDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderPermanentlyDeleteDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TeamFolderPermanentlyDeleteDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderPermanentlyDeleteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderPermanentlyDeleteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderPermanentlyDeleteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderPermanentlyDeleteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderPermanentlyDeleteDetails", TEAM_FOLDER_PERMANENTLY_DELETE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderPermanentlyDeleteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamFolderPermanentlyDeleteDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderPermanentlyDeleteType {
    pub description: String,
}

impl TeamFolderPermanentlyDeleteType {
    pub fn new(description: String) -> Self {
        TeamFolderPermanentlyDeleteType {
            description,
        }
    }

}

const TEAM_FOLDER_PERMANENTLY_DELETE_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderPermanentlyDeleteType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderPermanentlyDeleteType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderPermanentlyDeleteType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderPermanentlyDeleteType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderPermanentlyDeleteType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderPermanentlyDeleteType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderPermanentlyDeleteType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderPermanentlyDeleteType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderPermanentlyDeleteType", TEAM_FOLDER_PERMANENTLY_DELETE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderPermanentlyDeleteType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderPermanentlyDeleteType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Renamed active/archived team folder.
#[derive(Debug)]
pub struct TeamFolderRenameDetails {
    /// Previous folder name.
    pub previous_folder_name: String,
    /// New folder name.
    pub new_folder_name: String,
}

impl TeamFolderRenameDetails {
    pub fn new(previous_folder_name: String, new_folder_name: String) -> Self {
        TeamFolderRenameDetails {
            previous_folder_name,
            new_folder_name,
        }
    }

}

const TEAM_FOLDER_RENAME_DETAILS_FIELDS: &[&str] = &["previous_folder_name",
                                                     "new_folder_name"];
impl TeamFolderRenameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderRenameDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderRenameDetails>, V::Error> {
        let mut field_previous_folder_name = None;
        let mut field_new_folder_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_folder_name" => {
                    if field_previous_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_folder_name"));
                    }
                    field_previous_folder_name = Some(map.next_value()?);
                }
                "new_folder_name" => {
                    if field_new_folder_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_folder_name"));
                    }
                    field_new_folder_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderRenameDetails {
            previous_folder_name: field_previous_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("previous_folder_name"))?,
            new_folder_name: field_new_folder_name.ok_or_else(|| ::serde::de::Error::missing_field("new_folder_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_folder_name", &self.previous_folder_name)?;
        s.serialize_field("new_folder_name", &self.new_folder_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderRenameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderRenameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderRenameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderRenameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderRenameDetails", TEAM_FOLDER_RENAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderRenameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderRenameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderRenameType {
    pub description: String,
}

impl TeamFolderRenameType {
    pub fn new(description: String) -> Self {
        TeamFolderRenameType {
            description,
        }
    }

}

const TEAM_FOLDER_RENAME_TYPE_FIELDS: &[&str] = &["description"];
impl TeamFolderRenameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderRenameType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderRenameType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderRenameType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderRenameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderRenameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamFolderRenameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderRenameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderRenameType", TEAM_FOLDER_RENAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderRenameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderRenameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Details about team invites
#[derive(Debug)]
pub struct TeamInviteDetails {
    /// How the user was invited to the team.
    pub invite_method: InviteMethod,
}

impl TeamInviteDetails {
    pub fn new(invite_method: InviteMethod) -> Self {
        TeamInviteDetails {
            invite_method,
        }
    }

}

const TEAM_INVITE_DETAILS_FIELDS: &[&str] = &["invite_method"];
impl TeamInviteDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamInviteDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamInviteDetails>, V::Error> {
        let mut field_invite_method = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "invite_method" => {
                    if field_invite_method.is_some() {
                        return Err(::serde::de::Error::duplicate_field("invite_method"));
                    }
                    field_invite_method = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamInviteDetails {
            invite_method: field_invite_method.ok_or_else(|| ::serde::de::Error::missing_field("invite_method"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("invite_method", &self.invite_method)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamInviteDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamInviteDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamInviteDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamInviteDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamInviteDetails", TEAM_INVITE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamInviteDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamInviteDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team linked app
#[derive(Debug)]
pub struct TeamLinkedAppLogInfo {
    /// App unique ID. Might be missing due to historical data gap.
    pub app_id: Option<AppId>,
    /// App display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for TeamLinkedAppLogInfo {
    fn default() -> Self {
        TeamLinkedAppLogInfo {
            app_id: None,
            display_name: None,
        }
    }
}

const TEAM_LINKED_APP_LOG_INFO_FIELDS: &[&str] = &["app_id",
                                                   "display_name"];
impl TeamLinkedAppLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamLinkedAppLogInfo, V::Error> {
        let mut field_app_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = TeamLinkedAppLogInfo {
            app_id: field_app_id,
            display_name: field_display_name,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamLinkedAppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamLinkedAppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamLinkedAppLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamLinkedAppLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamLinkedAppLogInfo", TEAM_LINKED_APP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamLinkedAppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamLinkedAppLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team's logged information.
#[derive(Debug)]
pub struct TeamLogInfo {
    /// Team display name.
    pub display_name: String,
}

impl TeamLogInfo {
    pub fn new(display_name: String) -> Self {
        TeamLogInfo {
            display_name,
        }
    }

}

const TEAM_LOG_INFO_FIELDS: &[&str] = &["display_name"];
impl TeamLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamLogInfo>, V::Error> {
        let mut field_display_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamLogInfo {
            display_name: field_display_name.ok_or_else(|| ::serde::de::Error::missing_field("display_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamLogInfo", TEAM_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team member's logged information.
#[derive(Debug)]
pub struct TeamMemberLogInfo {
    /// User unique ID. Might be missing due to historical data gap.
    pub account_id: Option<super::users_common::AccountId>,
    /// User display name. Might be missing due to historical data gap.
    pub display_name: Option<super::common::DisplayNameLegacy>,
    /// User email address. Might be missing due to historical data gap.
    pub email: Option<EmailAddress>,
    /// Team member ID. Might be missing due to historical data gap.
    pub team_member_id: Option<super::team_common::TeamMemberId>,
    /// Team member external ID.
    pub member_external_id: Option<super::team_common::MemberExternalId>,
    /// Details about this user&#x2019s team for enterprise event.
    pub team: Option<TeamLogInfo>,
}

impl Default for TeamMemberLogInfo {
    fn default() -> Self {
        TeamMemberLogInfo {
            account_id: None,
            display_name: None,
            email: None,
            team_member_id: None,
            member_external_id: None,
            team: None,
        }
    }
}

const TEAM_MEMBER_LOG_INFO_FIELDS: &[&str] = &["account_id",
                                               "display_name",
                                               "email",
                                               "team_member_id",
                                               "member_external_id",
                                               "team"];
impl TeamMemberLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamMemberLogInfo, V::Error> {
        let mut field_account_id = None;
        let mut field_display_name = None;
        let mut field_email = None;
        let mut field_team_member_id = None;
        let mut field_member_external_id = None;
        let mut field_team = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "member_external_id" => {
                    if field_member_external_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("member_external_id"));
                    }
                    field_member_external_id = Some(map.next_value()?);
                }
                "team" => {
                    if field_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team"));
                    }
                    field_team = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = TeamMemberLogInfo {
            account_id: field_account_id,
            display_name: field_display_name,
            email: field_email,
            team_member_id: field_team_member_id,
            member_external_id: field_member_external_id,
            team: field_team,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("member_external_id", &self.member_external_id)?;
        s.serialize_field("team", &self.team)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMemberLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMemberLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMemberLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMemberLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMemberLogInfo", TEAM_MEMBER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMemberLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMemberLogInfo", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamMembershipType {
    Free,
    Full,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMembershipType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamMembershipType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMembershipType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "free" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamMembershipType::Free)
                    }
                    "full" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamMembershipType::Full)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamMembershipType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["free",
                                    "full",
                                    "other"];
        deserializer.deserialize_struct("TeamMembershipType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMembershipType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamMembershipType::Free => {
                // unit
                let mut s = serializer.serialize_struct("TeamMembershipType", 1)?;
                s.serialize_field(".tag", "free")?;
                s.end()
            }
            TeamMembershipType::Full => {
                // unit
                let mut s = serializer.serialize_struct("TeamMembershipType", 1)?;
                s.serialize_field(".tag", "full")?;
                s.end()
            }
            TeamMembershipType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Merged another team into this team.
#[derive(Debug)]
pub struct TeamMergeFromDetails {
    /// The name of the team that was merged into this team.
    pub team_name: String,
}

impl TeamMergeFromDetails {
    pub fn new(team_name: String) -> Self {
        TeamMergeFromDetails {
            team_name,
        }
    }

}

const TEAM_MERGE_FROM_DETAILS_FIELDS: &[&str] = &["team_name"];
impl TeamMergeFromDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeFromDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeFromDetails>, V::Error> {
        let mut field_team_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeFromDetails {
            team_name: field_team_name.ok_or_else(|| ::serde::de::Error::missing_field("team_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_name", &self.team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeFromDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeFromDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeFromDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeFromDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeFromDetails", TEAM_MERGE_FROM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeFromDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeFromDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeFromType {
    pub description: String,
}

impl TeamMergeFromType {
    pub fn new(description: String) -> Self {
        TeamMergeFromType {
            description,
        }
    }

}

const TEAM_MERGE_FROM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeFromType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeFromType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeFromType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeFromType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeFromType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeFromType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeFromType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeFromType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeFromType", TEAM_MERGE_FROM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeFromType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeFromType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Accepted a team merge request.
#[derive(Debug)]
pub struct TeamMergeRequestAcceptedDetails {
    /// Team merge request acceptance details.
    pub request_accepted_details: TeamMergeRequestAcceptedExtraDetails,
}

impl TeamMergeRequestAcceptedDetails {
    pub fn new(request_accepted_details: TeamMergeRequestAcceptedExtraDetails) -> Self {
        TeamMergeRequestAcceptedDetails {
            request_accepted_details,
        }
    }

}

const TEAM_MERGE_REQUEST_ACCEPTED_DETAILS_FIELDS: &[&str] = &["request_accepted_details"];
impl TeamMergeRequestAcceptedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestAcceptedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestAcceptedDetails>, V::Error> {
        let mut field_request_accepted_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "request_accepted_details" => {
                    if field_request_accepted_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("request_accepted_details"));
                    }
                    field_request_accepted_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestAcceptedDetails {
            request_accepted_details: field_request_accepted_details.ok_or_else(|| ::serde::de::Error::missing_field("request_accepted_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_accepted_details", &self.request_accepted_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestAcceptedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestAcceptedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestAcceptedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestAcceptedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestAcceptedDetails", TEAM_MERGE_REQUEST_ACCEPTED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestAcceptedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestAcceptedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request acceptance details
#[derive(Debug)]
pub enum TeamMergeRequestAcceptedExtraDetails {
    /// Team merge request accepted details shown to the primary team.
    PrimaryTeam(PrimaryTeamRequestAcceptedDetails),
    /// Team merge request accepted details shown to the secondary team.
    SecondaryTeam(SecondaryTeamRequestAcceptedDetails),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestAcceptedExtraDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamMergeRequestAcceptedExtraDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestAcceptedExtraDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "primary_team" => Ok(TeamMergeRequestAcceptedExtraDetails::PrimaryTeam(PrimaryTeamRequestAcceptedDetails::internal_deserialize(map)?)),
                    "secondary_team" => Ok(TeamMergeRequestAcceptedExtraDetails::SecondaryTeam(SecondaryTeamRequestAcceptedDetails::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamMergeRequestAcceptedExtraDetails::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["primary_team",
                                    "secondary_team",
                                    "other"];
        deserializer.deserialize_struct("TeamMergeRequestAcceptedExtraDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestAcceptedExtraDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamMergeRequestAcceptedExtraDetails::PrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamMergeRequestAcceptedExtraDetails", 3)?;
                s.serialize_field(".tag", "primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            TeamMergeRequestAcceptedExtraDetails::SecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamMergeRequestAcceptedExtraDetails", 3)?;
                s.serialize_field(".tag", "secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            TeamMergeRequestAcceptedExtraDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Accepted a team merge request.
#[derive(Debug)]
pub struct TeamMergeRequestAcceptedShownToPrimaryTeamDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl TeamMergeRequestAcceptedShownToPrimaryTeamDetails {
    pub fn new(secondary_team: String, sent_by: String) -> Self {
        TeamMergeRequestAcceptedShownToPrimaryTeamDetails {
            secondary_team,
            sent_by,
        }
    }

}

const TEAM_MERGE_REQUEST_ACCEPTED_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                                                    "sent_by"];
impl TeamMergeRequestAcceptedShownToPrimaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestAcceptedShownToPrimaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestAcceptedShownToPrimaryTeamDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestAcceptedShownToPrimaryTeamDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestAcceptedShownToPrimaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestAcceptedShownToPrimaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestAcceptedShownToPrimaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestAcceptedShownToPrimaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestAcceptedShownToPrimaryTeamDetails", TEAM_MERGE_REQUEST_ACCEPTED_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestAcceptedShownToPrimaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestAcceptedShownToPrimaryTeamDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestAcceptedShownToPrimaryTeamType {
    pub description: String,
}

impl TeamMergeRequestAcceptedShownToPrimaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestAcceptedShownToPrimaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_ACCEPTED_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestAcceptedShownToPrimaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestAcceptedShownToPrimaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestAcceptedShownToPrimaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestAcceptedShownToPrimaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestAcceptedShownToPrimaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestAcceptedShownToPrimaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestAcceptedShownToPrimaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestAcceptedShownToPrimaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestAcceptedShownToPrimaryTeamType", TEAM_MERGE_REQUEST_ACCEPTED_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestAcceptedShownToPrimaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestAcceptedShownToPrimaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Accepted a team merge request.
#[derive(Debug)]
pub struct TeamMergeRequestAcceptedShownToSecondaryTeamDetails {
    /// The primary team name.
    pub primary_team: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl TeamMergeRequestAcceptedShownToSecondaryTeamDetails {
    pub fn new(primary_team: String, sent_by: String) -> Self {
        TeamMergeRequestAcceptedShownToSecondaryTeamDetails {
            primary_team,
            sent_by,
        }
    }

}

const TEAM_MERGE_REQUEST_ACCEPTED_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS: &[&str] = &["primary_team",
                                                                                      "sent_by"];
impl TeamMergeRequestAcceptedShownToSecondaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestAcceptedShownToSecondaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestAcceptedShownToSecondaryTeamDetails>, V::Error> {
        let mut field_primary_team = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "primary_team" => {
                    if field_primary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("primary_team"));
                    }
                    field_primary_team = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestAcceptedShownToSecondaryTeamDetails {
            primary_team: field_primary_team.ok_or_else(|| ::serde::de::Error::missing_field("primary_team"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("primary_team", &self.primary_team)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestAcceptedShownToSecondaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestAcceptedShownToSecondaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestAcceptedShownToSecondaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestAcceptedShownToSecondaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestAcceptedShownToSecondaryTeamDetails", TEAM_MERGE_REQUEST_ACCEPTED_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestAcceptedShownToSecondaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestAcceptedShownToSecondaryTeamDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestAcceptedShownToSecondaryTeamType {
    pub description: String,
}

impl TeamMergeRequestAcceptedShownToSecondaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestAcceptedShownToSecondaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_ACCEPTED_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestAcceptedShownToSecondaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestAcceptedShownToSecondaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestAcceptedShownToSecondaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestAcceptedShownToSecondaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestAcceptedShownToSecondaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestAcceptedShownToSecondaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestAcceptedShownToSecondaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestAcceptedShownToSecondaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestAcceptedShownToSecondaryTeamType", TEAM_MERGE_REQUEST_ACCEPTED_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestAcceptedShownToSecondaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestAcceptedShownToSecondaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestAcceptedType {
    pub description: String,
}

impl TeamMergeRequestAcceptedType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestAcceptedType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_ACCEPTED_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestAcceptedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestAcceptedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestAcceptedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestAcceptedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestAcceptedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestAcceptedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestAcceptedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestAcceptedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestAcceptedType", TEAM_MERGE_REQUEST_ACCEPTED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestAcceptedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestAcceptedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Automatically canceled team merge request.
#[derive(Debug)]
pub struct TeamMergeRequestAutoCanceledDetails {
    /// The cancellation reason.
    pub details: Option<String>,
}

impl Default for TeamMergeRequestAutoCanceledDetails {
    fn default() -> Self {
        TeamMergeRequestAutoCanceledDetails {
            details: None,
        }
    }
}

const TEAM_MERGE_REQUEST_AUTO_CANCELED_DETAILS_FIELDS: &[&str] = &["details"];
impl TeamMergeRequestAutoCanceledDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamMergeRequestAutoCanceledDetails, V::Error> {
        let mut field_details = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "details" => {
                    if field_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("details"));
                    }
                    field_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = TeamMergeRequestAutoCanceledDetails {
            details: field_details,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("details", &self.details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestAutoCanceledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestAutoCanceledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestAutoCanceledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestAutoCanceledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestAutoCanceledDetails", TEAM_MERGE_REQUEST_AUTO_CANCELED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestAutoCanceledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestAutoCanceledDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestAutoCanceledType {
    pub description: String,
}

impl TeamMergeRequestAutoCanceledType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestAutoCanceledType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_AUTO_CANCELED_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestAutoCanceledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestAutoCanceledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestAutoCanceledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestAutoCanceledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestAutoCanceledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestAutoCanceledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestAutoCanceledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestAutoCanceledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestAutoCanceledType", TEAM_MERGE_REQUEST_AUTO_CANCELED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestAutoCanceledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestAutoCanceledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Canceled a team merge request.
#[derive(Debug)]
pub struct TeamMergeRequestCanceledDetails {
    /// Team merge request cancellation details.
    pub request_canceled_details: TeamMergeRequestCanceledExtraDetails,
}

impl TeamMergeRequestCanceledDetails {
    pub fn new(request_canceled_details: TeamMergeRequestCanceledExtraDetails) -> Self {
        TeamMergeRequestCanceledDetails {
            request_canceled_details,
        }
    }

}

const TEAM_MERGE_REQUEST_CANCELED_DETAILS_FIELDS: &[&str] = &["request_canceled_details"];
impl TeamMergeRequestCanceledDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestCanceledDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestCanceledDetails>, V::Error> {
        let mut field_request_canceled_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "request_canceled_details" => {
                    if field_request_canceled_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("request_canceled_details"));
                    }
                    field_request_canceled_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestCanceledDetails {
            request_canceled_details: field_request_canceled_details.ok_or_else(|| ::serde::de::Error::missing_field("request_canceled_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_canceled_details", &self.request_canceled_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestCanceledDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestCanceledDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestCanceledDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestCanceledDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestCanceledDetails", TEAM_MERGE_REQUEST_CANCELED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestCanceledDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestCanceledDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request cancellation details
#[derive(Debug)]
pub enum TeamMergeRequestCanceledExtraDetails {
    /// Team merge request cancellation details shown to the primary team.
    PrimaryTeam(PrimaryTeamRequestCanceledDetails),
    /// Team merge request cancellation details shown to the secondary team.
    SecondaryTeam(SecondaryTeamRequestCanceledDetails),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestCanceledExtraDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamMergeRequestCanceledExtraDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestCanceledExtraDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "primary_team" => Ok(TeamMergeRequestCanceledExtraDetails::PrimaryTeam(PrimaryTeamRequestCanceledDetails::internal_deserialize(map)?)),
                    "secondary_team" => Ok(TeamMergeRequestCanceledExtraDetails::SecondaryTeam(SecondaryTeamRequestCanceledDetails::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamMergeRequestCanceledExtraDetails::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["primary_team",
                                    "secondary_team",
                                    "other"];
        deserializer.deserialize_struct("TeamMergeRequestCanceledExtraDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestCanceledExtraDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamMergeRequestCanceledExtraDetails::PrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamMergeRequestCanceledExtraDetails", 3)?;
                s.serialize_field(".tag", "primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            TeamMergeRequestCanceledExtraDetails::SecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamMergeRequestCanceledExtraDetails", 3)?;
                s.serialize_field(".tag", "secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            TeamMergeRequestCanceledExtraDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Canceled a team merge request.
#[derive(Debug)]
pub struct TeamMergeRequestCanceledShownToPrimaryTeamDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl TeamMergeRequestCanceledShownToPrimaryTeamDetails {
    pub fn new(secondary_team: String, sent_by: String) -> Self {
        TeamMergeRequestCanceledShownToPrimaryTeamDetails {
            secondary_team,
            sent_by,
        }
    }

}

const TEAM_MERGE_REQUEST_CANCELED_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                                                    "sent_by"];
impl TeamMergeRequestCanceledShownToPrimaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestCanceledShownToPrimaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestCanceledShownToPrimaryTeamDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestCanceledShownToPrimaryTeamDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestCanceledShownToPrimaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestCanceledShownToPrimaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestCanceledShownToPrimaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestCanceledShownToPrimaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestCanceledShownToPrimaryTeamDetails", TEAM_MERGE_REQUEST_CANCELED_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestCanceledShownToPrimaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestCanceledShownToPrimaryTeamDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestCanceledShownToPrimaryTeamType {
    pub description: String,
}

impl TeamMergeRequestCanceledShownToPrimaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestCanceledShownToPrimaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_CANCELED_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestCanceledShownToPrimaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestCanceledShownToPrimaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestCanceledShownToPrimaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestCanceledShownToPrimaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestCanceledShownToPrimaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestCanceledShownToPrimaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestCanceledShownToPrimaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestCanceledShownToPrimaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestCanceledShownToPrimaryTeamType", TEAM_MERGE_REQUEST_CANCELED_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestCanceledShownToPrimaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestCanceledShownToPrimaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Canceled a team merge request.
#[derive(Debug)]
pub struct TeamMergeRequestCanceledShownToSecondaryTeamDetails {
    /// The email of the primary team admin that the request was sent to.
    pub sent_to: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl TeamMergeRequestCanceledShownToSecondaryTeamDetails {
    pub fn new(sent_to: String, sent_by: String) -> Self {
        TeamMergeRequestCanceledShownToSecondaryTeamDetails {
            sent_to,
            sent_by,
        }
    }

}

const TEAM_MERGE_REQUEST_CANCELED_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS: &[&str] = &["sent_to",
                                                                                      "sent_by"];
impl TeamMergeRequestCanceledShownToSecondaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestCanceledShownToSecondaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestCanceledShownToSecondaryTeamDetails>, V::Error> {
        let mut field_sent_to = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestCanceledShownToSecondaryTeamDetails {
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sent_to", &self.sent_to)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestCanceledShownToSecondaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestCanceledShownToSecondaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestCanceledShownToSecondaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestCanceledShownToSecondaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestCanceledShownToSecondaryTeamDetails", TEAM_MERGE_REQUEST_CANCELED_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestCanceledShownToSecondaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestCanceledShownToSecondaryTeamDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestCanceledShownToSecondaryTeamType {
    pub description: String,
}

impl TeamMergeRequestCanceledShownToSecondaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestCanceledShownToSecondaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_CANCELED_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestCanceledShownToSecondaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestCanceledShownToSecondaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestCanceledShownToSecondaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestCanceledShownToSecondaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestCanceledShownToSecondaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestCanceledShownToSecondaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestCanceledShownToSecondaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestCanceledShownToSecondaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestCanceledShownToSecondaryTeamType", TEAM_MERGE_REQUEST_CANCELED_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestCanceledShownToSecondaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestCanceledShownToSecondaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestCanceledType {
    pub description: String,
}

impl TeamMergeRequestCanceledType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestCanceledType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_CANCELED_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestCanceledType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestCanceledType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestCanceledType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestCanceledType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestCanceledType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestCanceledType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestCanceledType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestCanceledType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestCanceledType", TEAM_MERGE_REQUEST_CANCELED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestCanceledType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestCanceledType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request expired.
#[derive(Debug)]
pub struct TeamMergeRequestExpiredDetails {
    /// Team merge request expiration details.
    pub request_expired_details: TeamMergeRequestExpiredExtraDetails,
}

impl TeamMergeRequestExpiredDetails {
    pub fn new(request_expired_details: TeamMergeRequestExpiredExtraDetails) -> Self {
        TeamMergeRequestExpiredDetails {
            request_expired_details,
        }
    }

}

const TEAM_MERGE_REQUEST_EXPIRED_DETAILS_FIELDS: &[&str] = &["request_expired_details"];
impl TeamMergeRequestExpiredDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestExpiredDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestExpiredDetails>, V::Error> {
        let mut field_request_expired_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "request_expired_details" => {
                    if field_request_expired_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("request_expired_details"));
                    }
                    field_request_expired_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestExpiredDetails {
            request_expired_details: field_request_expired_details.ok_or_else(|| ::serde::de::Error::missing_field("request_expired_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_expired_details", &self.request_expired_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestExpiredDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestExpiredDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestExpiredDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestExpiredDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestExpiredDetails", TEAM_MERGE_REQUEST_EXPIRED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestExpiredDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestExpiredDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request expiration details
#[derive(Debug)]
pub enum TeamMergeRequestExpiredExtraDetails {
    /// Team merge request canceled details shown to the primary team.
    PrimaryTeam(PrimaryTeamRequestExpiredDetails),
    /// Team merge request canceled details shown to the secondary team.
    SecondaryTeam(SecondaryTeamRequestExpiredDetails),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestExpiredExtraDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamMergeRequestExpiredExtraDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestExpiredExtraDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "primary_team" => Ok(TeamMergeRequestExpiredExtraDetails::PrimaryTeam(PrimaryTeamRequestExpiredDetails::internal_deserialize(map)?)),
                    "secondary_team" => Ok(TeamMergeRequestExpiredExtraDetails::SecondaryTeam(SecondaryTeamRequestExpiredDetails::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamMergeRequestExpiredExtraDetails::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["primary_team",
                                    "secondary_team",
                                    "other"];
        deserializer.deserialize_struct("TeamMergeRequestExpiredExtraDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestExpiredExtraDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamMergeRequestExpiredExtraDetails::PrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamMergeRequestExpiredExtraDetails", 3)?;
                s.serialize_field(".tag", "primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            TeamMergeRequestExpiredExtraDetails::SecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamMergeRequestExpiredExtraDetails", 2)?;
                s.serialize_field(".tag", "secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            TeamMergeRequestExpiredExtraDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Team merge request expired.
#[derive(Debug)]
pub struct TeamMergeRequestExpiredShownToPrimaryTeamDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl TeamMergeRequestExpiredShownToPrimaryTeamDetails {
    pub fn new(secondary_team: String, sent_by: String) -> Self {
        TeamMergeRequestExpiredShownToPrimaryTeamDetails {
            secondary_team,
            sent_by,
        }
    }

}

const TEAM_MERGE_REQUEST_EXPIRED_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                                                   "sent_by"];
impl TeamMergeRequestExpiredShownToPrimaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestExpiredShownToPrimaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestExpiredShownToPrimaryTeamDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestExpiredShownToPrimaryTeamDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestExpiredShownToPrimaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestExpiredShownToPrimaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestExpiredShownToPrimaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestExpiredShownToPrimaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestExpiredShownToPrimaryTeamDetails", TEAM_MERGE_REQUEST_EXPIRED_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestExpiredShownToPrimaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestExpiredShownToPrimaryTeamDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestExpiredShownToPrimaryTeamType {
    pub description: String,
}

impl TeamMergeRequestExpiredShownToPrimaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestExpiredShownToPrimaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_EXPIRED_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestExpiredShownToPrimaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestExpiredShownToPrimaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestExpiredShownToPrimaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestExpiredShownToPrimaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestExpiredShownToPrimaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestExpiredShownToPrimaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestExpiredShownToPrimaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestExpiredShownToPrimaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestExpiredShownToPrimaryTeamType", TEAM_MERGE_REQUEST_EXPIRED_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestExpiredShownToPrimaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestExpiredShownToPrimaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request expired.
#[derive(Debug)]
pub struct TeamMergeRequestExpiredShownToSecondaryTeamDetails {
    /// The email of the primary team admin the request was sent to.
    pub sent_to: String,
}

impl TeamMergeRequestExpiredShownToSecondaryTeamDetails {
    pub fn new(sent_to: String) -> Self {
        TeamMergeRequestExpiredShownToSecondaryTeamDetails {
            sent_to,
        }
    }

}

const TEAM_MERGE_REQUEST_EXPIRED_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS: &[&str] = &["sent_to"];
impl TeamMergeRequestExpiredShownToSecondaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestExpiredShownToSecondaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestExpiredShownToSecondaryTeamDetails>, V::Error> {
        let mut field_sent_to = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestExpiredShownToSecondaryTeamDetails {
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sent_to", &self.sent_to)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestExpiredShownToSecondaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestExpiredShownToSecondaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestExpiredShownToSecondaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestExpiredShownToSecondaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestExpiredShownToSecondaryTeamDetails", TEAM_MERGE_REQUEST_EXPIRED_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestExpiredShownToSecondaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestExpiredShownToSecondaryTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestExpiredShownToSecondaryTeamType {
    pub description: String,
}

impl TeamMergeRequestExpiredShownToSecondaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestExpiredShownToSecondaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_EXPIRED_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestExpiredShownToSecondaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestExpiredShownToSecondaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestExpiredShownToSecondaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestExpiredShownToSecondaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestExpiredShownToSecondaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestExpiredShownToSecondaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestExpiredShownToSecondaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestExpiredShownToSecondaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestExpiredShownToSecondaryTeamType", TEAM_MERGE_REQUEST_EXPIRED_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestExpiredShownToSecondaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestExpiredShownToSecondaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestExpiredType {
    pub description: String,
}

impl TeamMergeRequestExpiredType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestExpiredType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_EXPIRED_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestExpiredType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestExpiredType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestExpiredType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestExpiredType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestExpiredType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestExpiredType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestExpiredType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestExpiredType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestExpiredType", TEAM_MERGE_REQUEST_EXPIRED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestExpiredType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestExpiredType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Rejected a team merge request.
#[derive(Debug)]
pub struct TeamMergeRequestRejectedShownToPrimaryTeamDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl TeamMergeRequestRejectedShownToPrimaryTeamDetails {
    pub fn new(secondary_team: String, sent_by: String) -> Self {
        TeamMergeRequestRejectedShownToPrimaryTeamDetails {
            secondary_team,
            sent_by,
        }
    }

}

const TEAM_MERGE_REQUEST_REJECTED_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                                                    "sent_by"];
impl TeamMergeRequestRejectedShownToPrimaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestRejectedShownToPrimaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestRejectedShownToPrimaryTeamDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestRejectedShownToPrimaryTeamDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestRejectedShownToPrimaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestRejectedShownToPrimaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestRejectedShownToPrimaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestRejectedShownToPrimaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestRejectedShownToPrimaryTeamDetails", TEAM_MERGE_REQUEST_REJECTED_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestRejectedShownToPrimaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestRejectedShownToPrimaryTeamDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestRejectedShownToPrimaryTeamType {
    pub description: String,
}

impl TeamMergeRequestRejectedShownToPrimaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestRejectedShownToPrimaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_REJECTED_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestRejectedShownToPrimaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestRejectedShownToPrimaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestRejectedShownToPrimaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestRejectedShownToPrimaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestRejectedShownToPrimaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestRejectedShownToPrimaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestRejectedShownToPrimaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestRejectedShownToPrimaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestRejectedShownToPrimaryTeamType", TEAM_MERGE_REQUEST_REJECTED_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestRejectedShownToPrimaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestRejectedShownToPrimaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Rejected a team merge request.
#[derive(Debug)]
pub struct TeamMergeRequestRejectedShownToSecondaryTeamDetails {
    /// The name of the secondary team admin who sent the request originally.
    pub sent_by: String,
}

impl TeamMergeRequestRejectedShownToSecondaryTeamDetails {
    pub fn new(sent_by: String) -> Self {
        TeamMergeRequestRejectedShownToSecondaryTeamDetails {
            sent_by,
        }
    }

}

const TEAM_MERGE_REQUEST_REJECTED_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS: &[&str] = &["sent_by"];
impl TeamMergeRequestRejectedShownToSecondaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestRejectedShownToSecondaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestRejectedShownToSecondaryTeamDetails>, V::Error> {
        let mut field_sent_by = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "sent_by" => {
                    if field_sent_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_by"));
                    }
                    field_sent_by = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestRejectedShownToSecondaryTeamDetails {
            sent_by: field_sent_by.ok_or_else(|| ::serde::de::Error::missing_field("sent_by"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sent_by", &self.sent_by)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestRejectedShownToSecondaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestRejectedShownToSecondaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestRejectedShownToSecondaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestRejectedShownToSecondaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestRejectedShownToSecondaryTeamDetails", TEAM_MERGE_REQUEST_REJECTED_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestRejectedShownToSecondaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestRejectedShownToSecondaryTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestRejectedShownToSecondaryTeamType {
    pub description: String,
}

impl TeamMergeRequestRejectedShownToSecondaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestRejectedShownToSecondaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_REJECTED_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestRejectedShownToSecondaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestRejectedShownToSecondaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestRejectedShownToSecondaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestRejectedShownToSecondaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestRejectedShownToSecondaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestRejectedShownToSecondaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestRejectedShownToSecondaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestRejectedShownToSecondaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestRejectedShownToSecondaryTeamType", TEAM_MERGE_REQUEST_REJECTED_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestRejectedShownToSecondaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestRejectedShownToSecondaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sent a team merge request reminder.
#[derive(Debug)]
pub struct TeamMergeRequestReminderDetails {
    /// Team merge request reminder details.
    pub request_reminder_details: TeamMergeRequestReminderExtraDetails,
}

impl TeamMergeRequestReminderDetails {
    pub fn new(request_reminder_details: TeamMergeRequestReminderExtraDetails) -> Self {
        TeamMergeRequestReminderDetails {
            request_reminder_details,
        }
    }

}

const TEAM_MERGE_REQUEST_REMINDER_DETAILS_FIELDS: &[&str] = &["request_reminder_details"];
impl TeamMergeRequestReminderDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestReminderDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestReminderDetails>, V::Error> {
        let mut field_request_reminder_details = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "request_reminder_details" => {
                    if field_request_reminder_details.is_some() {
                        return Err(::serde::de::Error::duplicate_field("request_reminder_details"));
                    }
                    field_request_reminder_details = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestReminderDetails {
            request_reminder_details: field_request_reminder_details.ok_or_else(|| ::serde::de::Error::missing_field("request_reminder_details"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("request_reminder_details", &self.request_reminder_details)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestReminderDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestReminderDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestReminderDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestReminderDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestReminderDetails", TEAM_MERGE_REQUEST_REMINDER_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestReminderDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestReminderDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team merge request reminder details
#[derive(Debug)]
pub enum TeamMergeRequestReminderExtraDetails {
    /// Team merge request reminder details shown to the primary team.
    PrimaryTeam(PrimaryTeamRequestReminderDetails),
    /// Team merge request reminder details shown to the secondary team.
    SecondaryTeam(SecondaryTeamRequestReminderDetails),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestReminderExtraDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamMergeRequestReminderExtraDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestReminderExtraDetails structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "primary_team" => Ok(TeamMergeRequestReminderExtraDetails::PrimaryTeam(PrimaryTeamRequestReminderDetails::internal_deserialize(map)?)),
                    "secondary_team" => Ok(TeamMergeRequestReminderExtraDetails::SecondaryTeam(SecondaryTeamRequestReminderDetails::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamMergeRequestReminderExtraDetails::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["primary_team",
                                    "secondary_team",
                                    "other"];
        deserializer.deserialize_struct("TeamMergeRequestReminderExtraDetails", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestReminderExtraDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamMergeRequestReminderExtraDetails::PrimaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamMergeRequestReminderExtraDetails", 3)?;
                s.serialize_field(".tag", "primary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            TeamMergeRequestReminderExtraDetails::SecondaryTeam(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamMergeRequestReminderExtraDetails", 2)?;
                s.serialize_field(".tag", "secondary_team")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            TeamMergeRequestReminderExtraDetails::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Sent a team merge request reminder.
#[derive(Debug)]
pub struct TeamMergeRequestReminderShownToPrimaryTeamDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the primary team admin the request was sent to.
    pub sent_to: String,
}

impl TeamMergeRequestReminderShownToPrimaryTeamDetails {
    pub fn new(secondary_team: String, sent_to: String) -> Self {
        TeamMergeRequestReminderShownToPrimaryTeamDetails {
            secondary_team,
            sent_to,
        }
    }

}

const TEAM_MERGE_REQUEST_REMINDER_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                                                    "sent_to"];
impl TeamMergeRequestReminderShownToPrimaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestReminderShownToPrimaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestReminderShownToPrimaryTeamDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_to = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestReminderShownToPrimaryTeamDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_to", &self.sent_to)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestReminderShownToPrimaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestReminderShownToPrimaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestReminderShownToPrimaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestReminderShownToPrimaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestReminderShownToPrimaryTeamDetails", TEAM_MERGE_REQUEST_REMINDER_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestReminderShownToPrimaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestReminderShownToPrimaryTeamDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestReminderShownToPrimaryTeamType {
    pub description: String,
}

impl TeamMergeRequestReminderShownToPrimaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestReminderShownToPrimaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_REMINDER_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestReminderShownToPrimaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestReminderShownToPrimaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestReminderShownToPrimaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestReminderShownToPrimaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestReminderShownToPrimaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestReminderShownToPrimaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestReminderShownToPrimaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestReminderShownToPrimaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestReminderShownToPrimaryTeamType", TEAM_MERGE_REQUEST_REMINDER_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestReminderShownToPrimaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestReminderShownToPrimaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Sent a team merge request reminder.
#[derive(Debug)]
pub struct TeamMergeRequestReminderShownToSecondaryTeamDetails {
    /// The email of the primary team admin the request was sent to.
    pub sent_to: String,
}

impl TeamMergeRequestReminderShownToSecondaryTeamDetails {
    pub fn new(sent_to: String) -> Self {
        TeamMergeRequestReminderShownToSecondaryTeamDetails {
            sent_to,
        }
    }

}

const TEAM_MERGE_REQUEST_REMINDER_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS: &[&str] = &["sent_to"];
impl TeamMergeRequestReminderShownToSecondaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestReminderShownToSecondaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestReminderShownToSecondaryTeamDetails>, V::Error> {
        let mut field_sent_to = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestReminderShownToSecondaryTeamDetails {
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sent_to", &self.sent_to)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestReminderShownToSecondaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestReminderShownToSecondaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestReminderShownToSecondaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestReminderShownToSecondaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestReminderShownToSecondaryTeamDetails", TEAM_MERGE_REQUEST_REMINDER_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestReminderShownToSecondaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestReminderShownToSecondaryTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestReminderShownToSecondaryTeamType {
    pub description: String,
}

impl TeamMergeRequestReminderShownToSecondaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestReminderShownToSecondaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_REMINDER_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestReminderShownToSecondaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestReminderShownToSecondaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestReminderShownToSecondaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestReminderShownToSecondaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestReminderShownToSecondaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestReminderShownToSecondaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestReminderShownToSecondaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestReminderShownToSecondaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestReminderShownToSecondaryTeamType", TEAM_MERGE_REQUEST_REMINDER_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestReminderShownToSecondaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestReminderShownToSecondaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestReminderType {
    pub description: String,
}

impl TeamMergeRequestReminderType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestReminderType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_REMINDER_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestReminderType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestReminderType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestReminderType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestReminderType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestReminderType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestReminderType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestReminderType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestReminderType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestReminderType", TEAM_MERGE_REQUEST_REMINDER_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestReminderType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestReminderType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Canceled the team merge.
#[derive(Debug)]
pub struct TeamMergeRequestRevokedDetails {
    /// The name of the other team.
    pub team: String,
}

impl TeamMergeRequestRevokedDetails {
    pub fn new(team: String) -> Self {
        TeamMergeRequestRevokedDetails {
            team,
        }
    }

}

const TEAM_MERGE_REQUEST_REVOKED_DETAILS_FIELDS: &[&str] = &["team"];
impl TeamMergeRequestRevokedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestRevokedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestRevokedDetails>, V::Error> {
        let mut field_team = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "team" => {
                    if field_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team"));
                    }
                    field_team = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestRevokedDetails {
            team: field_team.ok_or_else(|| ::serde::de::Error::missing_field("team"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team", &self.team)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestRevokedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestRevokedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestRevokedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestRevokedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestRevokedDetails", TEAM_MERGE_REQUEST_REVOKED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestRevokedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestRevokedDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestRevokedType {
    pub description: String,
}

impl TeamMergeRequestRevokedType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestRevokedType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_REVOKED_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestRevokedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestRevokedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestRevokedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestRevokedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestRevokedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestRevokedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestRevokedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestRevokedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestRevokedType", TEAM_MERGE_REQUEST_REVOKED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestRevokedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestRevokedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested to merge their Dropbox team into yours.
#[derive(Debug)]
pub struct TeamMergeRequestSentShownToPrimaryTeamDetails {
    /// The secondary team name.
    pub secondary_team: String,
    /// The name of the primary team admin the request was sent to.
    pub sent_to: String,
}

impl TeamMergeRequestSentShownToPrimaryTeamDetails {
    pub fn new(secondary_team: String, sent_to: String) -> Self {
        TeamMergeRequestSentShownToPrimaryTeamDetails {
            secondary_team,
            sent_to,
        }
    }

}

const TEAM_MERGE_REQUEST_SENT_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS: &[&str] = &["secondary_team",
                                                                                "sent_to"];
impl TeamMergeRequestSentShownToPrimaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestSentShownToPrimaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestSentShownToPrimaryTeamDetails>, V::Error> {
        let mut field_secondary_team = None;
        let mut field_sent_to = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "secondary_team" => {
                    if field_secondary_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("secondary_team"));
                    }
                    field_secondary_team = Some(map.next_value()?);
                }
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestSentShownToPrimaryTeamDetails {
            secondary_team: field_secondary_team.ok_or_else(|| ::serde::de::Error::missing_field("secondary_team"))?,
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("secondary_team", &self.secondary_team)?;
        s.serialize_field("sent_to", &self.sent_to)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestSentShownToPrimaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestSentShownToPrimaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestSentShownToPrimaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestSentShownToPrimaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestSentShownToPrimaryTeamDetails", TEAM_MERGE_REQUEST_SENT_SHOWN_TO_PRIMARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestSentShownToPrimaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestSentShownToPrimaryTeamDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestSentShownToPrimaryTeamType {
    pub description: String,
}

impl TeamMergeRequestSentShownToPrimaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestSentShownToPrimaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_SENT_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestSentShownToPrimaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestSentShownToPrimaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestSentShownToPrimaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestSentShownToPrimaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestSentShownToPrimaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestSentShownToPrimaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestSentShownToPrimaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestSentShownToPrimaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestSentShownToPrimaryTeamType", TEAM_MERGE_REQUEST_SENT_SHOWN_TO_PRIMARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestSentShownToPrimaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestSentShownToPrimaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Requested to merge your team into another Dropbox team.
#[derive(Debug)]
pub struct TeamMergeRequestSentShownToSecondaryTeamDetails {
    /// The email of the primary team admin the request was sent to.
    pub sent_to: String,
}

impl TeamMergeRequestSentShownToSecondaryTeamDetails {
    pub fn new(sent_to: String) -> Self {
        TeamMergeRequestSentShownToSecondaryTeamDetails {
            sent_to,
        }
    }

}

const TEAM_MERGE_REQUEST_SENT_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS: &[&str] = &["sent_to"];
impl TeamMergeRequestSentShownToSecondaryTeamDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestSentShownToSecondaryTeamDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestSentShownToSecondaryTeamDetails>, V::Error> {
        let mut field_sent_to = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "sent_to" => {
                    if field_sent_to.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sent_to"));
                    }
                    field_sent_to = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestSentShownToSecondaryTeamDetails {
            sent_to: field_sent_to.ok_or_else(|| ::serde::de::Error::missing_field("sent_to"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("sent_to", &self.sent_to)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestSentShownToSecondaryTeamDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestSentShownToSecondaryTeamDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestSentShownToSecondaryTeamDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestSentShownToSecondaryTeamDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestSentShownToSecondaryTeamDetails", TEAM_MERGE_REQUEST_SENT_SHOWN_TO_SECONDARY_TEAM_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestSentShownToSecondaryTeamDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestSentShownToSecondaryTeamDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeRequestSentShownToSecondaryTeamType {
    pub description: String,
}

impl TeamMergeRequestSentShownToSecondaryTeamType {
    pub fn new(description: String) -> Self {
        TeamMergeRequestSentShownToSecondaryTeamType {
            description,
        }
    }

}

const TEAM_MERGE_REQUEST_SENT_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeRequestSentShownToSecondaryTeamType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeRequestSentShownToSecondaryTeamType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeRequestSentShownToSecondaryTeamType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeRequestSentShownToSecondaryTeamType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeRequestSentShownToSecondaryTeamType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeRequestSentShownToSecondaryTeamType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeRequestSentShownToSecondaryTeamType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeRequestSentShownToSecondaryTeamType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeRequestSentShownToSecondaryTeamType", TEAM_MERGE_REQUEST_SENT_SHOWN_TO_SECONDARY_TEAM_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeRequestSentShownToSecondaryTeamType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeRequestSentShownToSecondaryTeamType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Merged this team into another team.
#[derive(Debug)]
pub struct TeamMergeToDetails {
    /// The name of the team that this team was merged into.
    pub team_name: String,
}

impl TeamMergeToDetails {
    pub fn new(team_name: String) -> Self {
        TeamMergeToDetails {
            team_name,
        }
    }

}

const TEAM_MERGE_TO_DETAILS_FIELDS: &[&str] = &["team_name"];
impl TeamMergeToDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeToDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeToDetails>, V::Error> {
        let mut field_team_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "team_name" => {
                    if field_team_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_name"));
                    }
                    field_team_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeToDetails {
            team_name: field_team_name.ok_or_else(|| ::serde::de::Error::missing_field("team_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_name", &self.team_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeToDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeToDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeToDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeToDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeToDetails", TEAM_MERGE_TO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeToDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeToDetails", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamMergeToType {
    pub description: String,
}

impl TeamMergeToType {
    pub fn new(description: String) -> Self {
        TeamMergeToType {
            description,
        }
    }

}

const TEAM_MERGE_TO_TYPE_FIELDS: &[&str] = &["description"];
impl TeamMergeToType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMergeToType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMergeToType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMergeToType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMergeToType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMergeToType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamMergeToType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMergeToType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMergeToType", TEAM_MERGE_TO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMergeToType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMergeToType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Team name details
#[derive(Debug)]
pub struct TeamName {
    /// Team's display name.
    pub team_display_name: String,
    /// Team's legal name.
    pub team_legal_name: String,
}

impl TeamName {
    pub fn new(team_display_name: String, team_legal_name: String) -> Self {
        TeamName {
            team_display_name,
            team_legal_name,
        }
    }

}

const TEAM_NAME_FIELDS: &[&str] = &["team_display_name",
                                    "team_legal_name"];
impl TeamName {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamName, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamName>, V::Error> {
        let mut field_team_display_name = None;
        let mut field_team_legal_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "team_display_name" => {
                    if field_team_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_display_name"));
                    }
                    field_team_display_name = Some(map.next_value()?);
                }
                "team_legal_name" => {
                    if field_team_legal_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team_legal_name"));
                    }
                    field_team_legal_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamName {
            team_display_name: field_team_display_name.ok_or_else(|| ::serde::de::Error::missing_field("team_display_name"))?,
            team_legal_name: field_team_legal_name.ok_or_else(|| ::serde::de::Error::missing_field("team_legal_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_display_name", &self.team_display_name)?;
        s.serialize_field("team_legal_name", &self.team_legal_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamName {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamName;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamName struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamName::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamName", TEAM_NAME_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamName {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamName", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added team logo to display on shared link headers.
#[derive(Debug)]
pub struct TeamProfileAddLogoDetails {
}

impl Default for TeamProfileAddLogoDetails {
    fn default() -> Self {
        TeamProfileAddLogoDetails {
        }
    }
}

const TEAM_PROFILE_ADD_LOGO_DETAILS_FIELDS: &[&str] = &[];
impl TeamProfileAddLogoDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileAddLogoDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TeamProfileAddLogoDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileAddLogoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileAddLogoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileAddLogoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileAddLogoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileAddLogoDetails", TEAM_PROFILE_ADD_LOGO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileAddLogoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamProfileAddLogoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileAddLogoType {
    pub description: String,
}

impl TeamProfileAddLogoType {
    pub fn new(description: String) -> Self {
        TeamProfileAddLogoType {
            description,
        }
    }

}

const TEAM_PROFILE_ADD_LOGO_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileAddLogoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamProfileAddLogoType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamProfileAddLogoType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamProfileAddLogoType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileAddLogoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileAddLogoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileAddLogoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileAddLogoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileAddLogoType", TEAM_PROFILE_ADD_LOGO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileAddLogoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileAddLogoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed default language for team.
#[derive(Debug)]
pub struct TeamProfileChangeDefaultLanguageDetails {
    /// New team's default language.
    pub new_value: super::common::LanguageCode,
    /// Previous team's default language.
    pub previous_value: super::common::LanguageCode,
}

impl TeamProfileChangeDefaultLanguageDetails {
    pub fn new(
        new_value: super::common::LanguageCode,
        previous_value: super::common::LanguageCode,
    ) -> Self {
        TeamProfileChangeDefaultLanguageDetails {
            new_value,
            previous_value,
        }
    }

}

const TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                       "previous_value"];
impl TeamProfileChangeDefaultLanguageDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamProfileChangeDefaultLanguageDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamProfileChangeDefaultLanguageDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamProfileChangeDefaultLanguageDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeDefaultLanguageDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeDefaultLanguageDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeDefaultLanguageDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeDefaultLanguageDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeDefaultLanguageDetails", TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeDefaultLanguageDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeDefaultLanguageDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileChangeDefaultLanguageType {
    pub description: String,
}

impl TeamProfileChangeDefaultLanguageType {
    pub fn new(description: String) -> Self {
        TeamProfileChangeDefaultLanguageType {
            description,
        }
    }

}

const TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileChangeDefaultLanguageType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamProfileChangeDefaultLanguageType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamProfileChangeDefaultLanguageType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamProfileChangeDefaultLanguageType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeDefaultLanguageType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeDefaultLanguageType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeDefaultLanguageType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeDefaultLanguageType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeDefaultLanguageType", TEAM_PROFILE_CHANGE_DEFAULT_LANGUAGE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeDefaultLanguageType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeDefaultLanguageType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team logo displayed on shared link headers.
#[derive(Debug)]
pub struct TeamProfileChangeLogoDetails {
}

impl Default for TeamProfileChangeLogoDetails {
    fn default() -> Self {
        TeamProfileChangeLogoDetails {
        }
    }
}

const TEAM_PROFILE_CHANGE_LOGO_DETAILS_FIELDS: &[&str] = &[];
impl TeamProfileChangeLogoDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileChangeLogoDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TeamProfileChangeLogoDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeLogoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeLogoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeLogoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeLogoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeLogoDetails", TEAM_PROFILE_CHANGE_LOGO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeLogoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamProfileChangeLogoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileChangeLogoType {
    pub description: String,
}

impl TeamProfileChangeLogoType {
    pub fn new(description: String) -> Self {
        TeamProfileChangeLogoType {
            description,
        }
    }

}

const TEAM_PROFILE_CHANGE_LOGO_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileChangeLogoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamProfileChangeLogoType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamProfileChangeLogoType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamProfileChangeLogoType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeLogoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeLogoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeLogoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeLogoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeLogoType", TEAM_PROFILE_CHANGE_LOGO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeLogoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeLogoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team name.
#[derive(Debug)]
pub struct TeamProfileChangeNameDetails {
    /// New team name.
    pub new_value: TeamName,
    /// Previous teams name. Might be missing due to historical data gap.
    pub previous_value: Option<TeamName>,
}

impl TeamProfileChangeNameDetails {
    pub fn new(new_value: TeamName) -> Self {
        TeamProfileChangeNameDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TeamName>) -> Self {
        self.previous_value = value;
        self
    }

}

const TEAM_PROFILE_CHANGE_NAME_DETAILS_FIELDS: &[&str] = &["new_value",
                                                           "previous_value"];
impl TeamProfileChangeNameDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamProfileChangeNameDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamProfileChangeNameDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamProfileChangeNameDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeNameDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeNameDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeNameDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeNameDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeNameDetails", TEAM_PROFILE_CHANGE_NAME_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeNameDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeNameDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileChangeNameType {
    pub description: String,
}

impl TeamProfileChangeNameType {
    pub fn new(description: String) -> Self {
        TeamProfileChangeNameType {
            description,
        }
    }

}

const TEAM_PROFILE_CHANGE_NAME_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileChangeNameType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamProfileChangeNameType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamProfileChangeNameType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamProfileChangeNameType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileChangeNameType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileChangeNameType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileChangeNameType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileChangeNameType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileChangeNameType", TEAM_PROFILE_CHANGE_NAME_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileChangeNameType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileChangeNameType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed team logo displayed on shared link headers.
#[derive(Debug)]
pub struct TeamProfileRemoveLogoDetails {
}

impl Default for TeamProfileRemoveLogoDetails {
    fn default() -> Self {
        TeamProfileRemoveLogoDetails {
        }
    }
}

const TEAM_PROFILE_REMOVE_LOGO_DETAILS_FIELDS: &[&str] = &[];
impl TeamProfileRemoveLogoDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamProfileRemoveLogoDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TeamProfileRemoveLogoDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileRemoveLogoDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileRemoveLogoDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileRemoveLogoDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileRemoveLogoDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileRemoveLogoDetails", TEAM_PROFILE_REMOVE_LOGO_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileRemoveLogoDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TeamProfileRemoveLogoDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TeamProfileRemoveLogoType {
    pub description: String,
}

impl TeamProfileRemoveLogoType {
    pub fn new(description: String) -> Self {
        TeamProfileRemoveLogoType {
            description,
        }
    }

}

const TEAM_PROFILE_REMOVE_LOGO_TYPE_FIELDS: &[&str] = &["description"];
impl TeamProfileRemoveLogoType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamProfileRemoveLogoType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamProfileRemoveLogoType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamProfileRemoveLogoType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamProfileRemoveLogoType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamProfileRemoveLogoType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamProfileRemoveLogoType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamProfileRemoveLogoType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamProfileRemoveLogoType", TEAM_PROFILE_REMOVE_LOGO_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamProfileRemoveLogoType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamProfileRemoveLogoType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling whether team selective sync is enabled for team.
#[derive(Debug)]
pub enum TeamSelectiveSyncPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamSelectiveSyncPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamSelectiveSyncPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamSelectiveSyncPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamSelectiveSyncPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamSelectiveSyncPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TeamSelectiveSyncPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("TeamSelectiveSyncPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamSelectiveSyncPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamSelectiveSyncPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("TeamSelectiveSyncPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            TeamSelectiveSyncPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("TeamSelectiveSyncPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            TeamSelectiveSyncPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Enabled/disabled Team Selective Sync for team.
#[derive(Debug)]
pub struct TeamSelectiveSyncPolicyChangedDetails {
    /// New Team Selective Sync policy.
    pub new_value: TeamSelectiveSyncPolicy,
    /// Previous Team Selective Sync policy.
    pub previous_value: TeamSelectiveSyncPolicy,
}

impl TeamSelectiveSyncPolicyChangedDetails {
    pub fn new(
        new_value: TeamSelectiveSyncPolicy,
        previous_value: TeamSelectiveSyncPolicy,
    ) -> Self {
        TeamSelectiveSyncPolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const TEAM_SELECTIVE_SYNC_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                     "previous_value"];
impl TeamSelectiveSyncPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamSelectiveSyncPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamSelectiveSyncPolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamSelectiveSyncPolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamSelectiveSyncPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamSelectiveSyncPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamSelectiveSyncPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamSelectiveSyncPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamSelectiveSyncPolicyChangedDetails", TEAM_SELECTIVE_SYNC_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamSelectiveSyncPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamSelectiveSyncPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamSelectiveSyncPolicyChangedType {
    pub description: String,
}

impl TeamSelectiveSyncPolicyChangedType {
    pub fn new(description: String) -> Self {
        TeamSelectiveSyncPolicyChangedType {
            description,
        }
    }

}

const TEAM_SELECTIVE_SYNC_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl TeamSelectiveSyncPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamSelectiveSyncPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamSelectiveSyncPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamSelectiveSyncPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamSelectiveSyncPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamSelectiveSyncPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamSelectiveSyncPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamSelectiveSyncPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamSelectiveSyncPolicyChangedType", TEAM_SELECTIVE_SYNC_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamSelectiveSyncPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamSelectiveSyncPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed sync default.
#[derive(Debug)]
pub struct TeamSelectiveSyncSettingsChangedDetails {
    /// Previous value.
    pub previous_value: super::files::SyncSetting,
    /// New value.
    pub new_value: super::files::SyncSetting,
}

impl TeamSelectiveSyncSettingsChangedDetails {
    pub fn new(
        previous_value: super::files::SyncSetting,
        new_value: super::files::SyncSetting,
    ) -> Self {
        TeamSelectiveSyncSettingsChangedDetails {
            previous_value,
            new_value,
        }
    }

}

const TEAM_SELECTIVE_SYNC_SETTINGS_CHANGED_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                       "new_value"];
impl TeamSelectiveSyncSettingsChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamSelectiveSyncSettingsChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamSelectiveSyncSettingsChangedDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamSelectiveSyncSettingsChangedDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamSelectiveSyncSettingsChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamSelectiveSyncSettingsChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamSelectiveSyncSettingsChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamSelectiveSyncSettingsChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamSelectiveSyncSettingsChangedDetails", TEAM_SELECTIVE_SYNC_SETTINGS_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamSelectiveSyncSettingsChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamSelectiveSyncSettingsChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamSelectiveSyncSettingsChangedType {
    pub description: String,
}

impl TeamSelectiveSyncSettingsChangedType {
    pub fn new(description: String) -> Self {
        TeamSelectiveSyncSettingsChangedType {
            description,
        }
    }

}

const TEAM_SELECTIVE_SYNC_SETTINGS_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl TeamSelectiveSyncSettingsChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamSelectiveSyncSettingsChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamSelectiveSyncSettingsChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamSelectiveSyncSettingsChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamSelectiveSyncSettingsChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamSelectiveSyncSettingsChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamSelectiveSyncSettingsChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamSelectiveSyncSettingsChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamSelectiveSyncSettingsChangedType", TEAM_SELECTIVE_SYNC_SETTINGS_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamSelectiveSyncSettingsChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamSelectiveSyncSettingsChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Edited the approved list for sharing externally.
#[derive(Debug)]
pub struct TeamSharingWhitelistSubjectsChangedDetails {
    /// Domains or emails added to the approved list for sharing externally.
    pub added_whitelist_subjects: Vec<String>,
    /// Domains or emails removed from the approved list for sharing externally.
    pub removed_whitelist_subjects: Vec<String>,
}

impl TeamSharingWhitelistSubjectsChangedDetails {
    pub fn new(
        added_whitelist_subjects: Vec<String>,
        removed_whitelist_subjects: Vec<String>,
    ) -> Self {
        TeamSharingWhitelistSubjectsChangedDetails {
            added_whitelist_subjects,
            removed_whitelist_subjects,
        }
    }

}

const TEAM_SHARING_WHITELIST_SUBJECTS_CHANGED_DETAILS_FIELDS: &[&str] = &["added_whitelist_subjects",
                                                                          "removed_whitelist_subjects"];
impl TeamSharingWhitelistSubjectsChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamSharingWhitelistSubjectsChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamSharingWhitelistSubjectsChangedDetails>, V::Error> {
        let mut field_added_whitelist_subjects = None;
        let mut field_removed_whitelist_subjects = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "added_whitelist_subjects" => {
                    if field_added_whitelist_subjects.is_some() {
                        return Err(::serde::de::Error::duplicate_field("added_whitelist_subjects"));
                    }
                    field_added_whitelist_subjects = Some(map.next_value()?);
                }
                "removed_whitelist_subjects" => {
                    if field_removed_whitelist_subjects.is_some() {
                        return Err(::serde::de::Error::duplicate_field("removed_whitelist_subjects"));
                    }
                    field_removed_whitelist_subjects = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamSharingWhitelistSubjectsChangedDetails {
            added_whitelist_subjects: field_added_whitelist_subjects.ok_or_else(|| ::serde::de::Error::missing_field("added_whitelist_subjects"))?,
            removed_whitelist_subjects: field_removed_whitelist_subjects.ok_or_else(|| ::serde::de::Error::missing_field("removed_whitelist_subjects"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("added_whitelist_subjects", &self.added_whitelist_subjects)?;
        s.serialize_field("removed_whitelist_subjects", &self.removed_whitelist_subjects)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamSharingWhitelistSubjectsChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamSharingWhitelistSubjectsChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamSharingWhitelistSubjectsChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamSharingWhitelistSubjectsChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamSharingWhitelistSubjectsChangedDetails", TEAM_SHARING_WHITELIST_SUBJECTS_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamSharingWhitelistSubjectsChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamSharingWhitelistSubjectsChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamSharingWhitelistSubjectsChangedType {
    pub description: String,
}

impl TeamSharingWhitelistSubjectsChangedType {
    pub fn new(description: String) -> Self {
        TeamSharingWhitelistSubjectsChangedType {
            description,
        }
    }

}

const TEAM_SHARING_WHITELIST_SUBJECTS_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl TeamSharingWhitelistSubjectsChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamSharingWhitelistSubjectsChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamSharingWhitelistSubjectsChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamSharingWhitelistSubjectsChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamSharingWhitelistSubjectsChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamSharingWhitelistSubjectsChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TeamSharingWhitelistSubjectsChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamSharingWhitelistSubjectsChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamSharingWhitelistSubjectsChangedType", TEAM_SHARING_WHITELIST_SUBJECTS_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamSharingWhitelistSubjectsChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamSharingWhitelistSubjectsChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added backup phone for two-step verification.
#[derive(Debug)]
pub struct TfaAddBackupPhoneDetails {
}

impl Default for TfaAddBackupPhoneDetails {
    fn default() -> Self {
        TfaAddBackupPhoneDetails {
        }
    }
}

const TFA_ADD_BACKUP_PHONE_DETAILS_FIELDS: &[&str] = &[];
impl TfaAddBackupPhoneDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaAddBackupPhoneDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TfaAddBackupPhoneDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddBackupPhoneDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddBackupPhoneDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaAddBackupPhoneDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddBackupPhoneDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddBackupPhoneDetails", TFA_ADD_BACKUP_PHONE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddBackupPhoneDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaAddBackupPhoneDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaAddBackupPhoneType {
    pub description: String,
}

impl TfaAddBackupPhoneType {
    pub fn new(description: String) -> Self {
        TfaAddBackupPhoneType {
            description,
        }
    }

}

const TFA_ADD_BACKUP_PHONE_TYPE_FIELDS: &[&str] = &["description"];
impl TfaAddBackupPhoneType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaAddBackupPhoneType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaAddBackupPhoneType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaAddBackupPhoneType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddBackupPhoneType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddBackupPhoneType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaAddBackupPhoneType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddBackupPhoneType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddBackupPhoneType", TFA_ADD_BACKUP_PHONE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddBackupPhoneType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaAddBackupPhoneType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added members to two factor authentication exception list.
#[derive(Debug)]
pub struct TfaAddExceptionDetails {
}

impl Default for TfaAddExceptionDetails {
    fn default() -> Self {
        TfaAddExceptionDetails {
        }
    }
}

const TFA_ADD_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl TfaAddExceptionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaAddExceptionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TfaAddExceptionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaAddExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddExceptionDetails", TFA_ADD_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaAddExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaAddExceptionType {
    pub description: String,
}

impl TfaAddExceptionType {
    pub fn new(description: String) -> Self {
        TfaAddExceptionType {
            description,
        }
    }

}

const TFA_ADD_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl TfaAddExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaAddExceptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaAddExceptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaAddExceptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaAddExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddExceptionType", TFA_ADD_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaAddExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Added security key for two-step verification.
#[derive(Debug)]
pub struct TfaAddSecurityKeyDetails {
}

impl Default for TfaAddSecurityKeyDetails {
    fn default() -> Self {
        TfaAddSecurityKeyDetails {
        }
    }
}

const TFA_ADD_SECURITY_KEY_DETAILS_FIELDS: &[&str] = &[];
impl TfaAddSecurityKeyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaAddSecurityKeyDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TfaAddSecurityKeyDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddSecurityKeyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddSecurityKeyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaAddSecurityKeyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddSecurityKeyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddSecurityKeyDetails", TFA_ADD_SECURITY_KEY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddSecurityKeyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaAddSecurityKeyDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaAddSecurityKeyType {
    pub description: String,
}

impl TfaAddSecurityKeyType {
    pub fn new(description: String) -> Self {
        TfaAddSecurityKeyType {
            description,
        }
    }

}

const TFA_ADD_SECURITY_KEY_TYPE_FIELDS: &[&str] = &["description"];
impl TfaAddSecurityKeyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaAddSecurityKeyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaAddSecurityKeyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaAddSecurityKeyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaAddSecurityKeyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaAddSecurityKeyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaAddSecurityKeyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaAddSecurityKeyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaAddSecurityKeyType", TFA_ADD_SECURITY_KEY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaAddSecurityKeyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaAddSecurityKeyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed backup phone for two-step verification.
#[derive(Debug)]
pub struct TfaChangeBackupPhoneDetails {
}

impl Default for TfaChangeBackupPhoneDetails {
    fn default() -> Self {
        TfaChangeBackupPhoneDetails {
        }
    }
}

const TFA_CHANGE_BACKUP_PHONE_DETAILS_FIELDS: &[&str] = &[];
impl TfaChangeBackupPhoneDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaChangeBackupPhoneDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TfaChangeBackupPhoneDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeBackupPhoneDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeBackupPhoneDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaChangeBackupPhoneDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeBackupPhoneDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeBackupPhoneDetails", TFA_CHANGE_BACKUP_PHONE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeBackupPhoneDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaChangeBackupPhoneDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaChangeBackupPhoneType {
    pub description: String,
}

impl TfaChangeBackupPhoneType {
    pub fn new(description: String) -> Self {
        TfaChangeBackupPhoneType {
            description,
        }
    }

}

const TFA_CHANGE_BACKUP_PHONE_TYPE_FIELDS: &[&str] = &["description"];
impl TfaChangeBackupPhoneType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaChangeBackupPhoneType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaChangeBackupPhoneType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaChangeBackupPhoneType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeBackupPhoneType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeBackupPhoneType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaChangeBackupPhoneType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeBackupPhoneType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeBackupPhoneType", TFA_CHANGE_BACKUP_PHONE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeBackupPhoneType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangeBackupPhoneType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed two-step verification setting for team.
#[derive(Debug)]
pub struct TfaChangePolicyDetails {
    /// New change policy.
    pub new_value: super::team_policies::TwoStepVerificationPolicy,
    /// Previous change policy. Might be missing due to historical data gap.
    pub previous_value: Option<super::team_policies::TwoStepVerificationPolicy>,
}

impl TfaChangePolicyDetails {
    pub fn new(new_value: super::team_policies::TwoStepVerificationPolicy) -> Self {
        TfaChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(
        mut self,
        value: Option<super::team_policies::TwoStepVerificationPolicy>,
    ) -> Self {
        self.previous_value = value;
        self
    }

}

const TFA_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                    "previous_value"];
impl TfaChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangePolicyDetails", TFA_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TfaChangePolicyType {
    pub description: String,
}

impl TfaChangePolicyType {
    pub fn new(description: String) -> Self {
        TfaChangePolicyType {
            description,
        }
    }

}

const TFA_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl TfaChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangePolicyType", TFA_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Enabled/disabled/changed two-step verification setting.
#[derive(Debug)]
pub struct TfaChangeStatusDetails {
    /// The new two factor authentication configuration.
    pub new_value: TfaConfiguration,
    /// The previous two factor authentication configuration. Might be missing due to historical
    /// data gap.
    pub previous_value: Option<TfaConfiguration>,
    /// Used two factor authentication rescue code. This flag is relevant when the two factor
    /// authentication configuration is disabled.
    pub used_rescue_code: Option<bool>,
}

impl TfaChangeStatusDetails {
    pub fn new(new_value: TfaConfiguration) -> Self {
        TfaChangeStatusDetails {
            new_value,
            previous_value: None,
            used_rescue_code: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TfaConfiguration>) -> Self {
        self.previous_value = value;
        self
    }

    pub fn with_used_rescue_code(mut self, value: Option<bool>) -> Self {
        self.used_rescue_code = value;
        self
    }

}

const TFA_CHANGE_STATUS_DETAILS_FIELDS: &[&str] = &["new_value",
                                                    "previous_value",
                                                    "used_rescue_code"];
impl TfaChangeStatusDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaChangeStatusDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaChangeStatusDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut field_used_rescue_code = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "used_rescue_code" => {
                    if field_used_rescue_code.is_some() {
                        return Err(::serde::de::Error::duplicate_field("used_rescue_code"));
                    }
                    field_used_rescue_code = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaChangeStatusDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
            used_rescue_code: field_used_rescue_code,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("used_rescue_code", &self.used_rescue_code)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeStatusDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeStatusDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaChangeStatusDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeStatusDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeStatusDetails", TFA_CHANGE_STATUS_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeStatusDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangeStatusDetails", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TfaChangeStatusType {
    pub description: String,
}

impl TfaChangeStatusType {
    pub fn new(description: String) -> Self {
        TfaChangeStatusType {
            description,
        }
    }

}

const TFA_CHANGE_STATUS_TYPE_FIELDS: &[&str] = &["description"];
impl TfaChangeStatusType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaChangeStatusType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaChangeStatusType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaChangeStatusType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaChangeStatusType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaChangeStatusType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaChangeStatusType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaChangeStatusType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaChangeStatusType", TFA_CHANGE_STATUS_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaChangeStatusType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaChangeStatusType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Two factor authentication configuration. Note: the enabled option is deprecated.
#[derive(Debug)]
pub enum TfaConfiguration {
    Disabled,
    Enabled,
    Sms,
    Authenticator,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TfaConfiguration {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TfaConfiguration;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaConfiguration structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TfaConfiguration::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TfaConfiguration::Enabled)
                    }
                    "sms" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TfaConfiguration::Sms)
                    }
                    "authenticator" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TfaConfiguration::Authenticator)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TfaConfiguration::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "sms",
                                    "authenticator",
                                    "other"];
        deserializer.deserialize_struct("TfaConfiguration", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TfaConfiguration {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TfaConfiguration::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            TfaConfiguration::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            TfaConfiguration::Sms => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "sms")?;
                s.end()
            }
            TfaConfiguration::Authenticator => {
                // unit
                let mut s = serializer.serialize_struct("TfaConfiguration", 1)?;
                s.serialize_field(".tag", "authenticator")?;
                s.end()
            }
            TfaConfiguration::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Removed backup phone for two-step verification.
#[derive(Debug)]
pub struct TfaRemoveBackupPhoneDetails {
}

impl Default for TfaRemoveBackupPhoneDetails {
    fn default() -> Self {
        TfaRemoveBackupPhoneDetails {
        }
    }
}

const TFA_REMOVE_BACKUP_PHONE_DETAILS_FIELDS: &[&str] = &[];
impl TfaRemoveBackupPhoneDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaRemoveBackupPhoneDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TfaRemoveBackupPhoneDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveBackupPhoneDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveBackupPhoneDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveBackupPhoneDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveBackupPhoneDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveBackupPhoneDetails", TFA_REMOVE_BACKUP_PHONE_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveBackupPhoneDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaRemoveBackupPhoneDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaRemoveBackupPhoneType {
    pub description: String,
}

impl TfaRemoveBackupPhoneType {
    pub fn new(description: String) -> Self {
        TfaRemoveBackupPhoneType {
            description,
        }
    }

}

const TFA_REMOVE_BACKUP_PHONE_TYPE_FIELDS: &[&str] = &["description"];
impl TfaRemoveBackupPhoneType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaRemoveBackupPhoneType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaRemoveBackupPhoneType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaRemoveBackupPhoneType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveBackupPhoneType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveBackupPhoneType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveBackupPhoneType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveBackupPhoneType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveBackupPhoneType", TFA_REMOVE_BACKUP_PHONE_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveBackupPhoneType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaRemoveBackupPhoneType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed members from two factor authentication exception list.
#[derive(Debug)]
pub struct TfaRemoveExceptionDetails {
}

impl Default for TfaRemoveExceptionDetails {
    fn default() -> Self {
        TfaRemoveExceptionDetails {
        }
    }
}

const TFA_REMOVE_EXCEPTION_DETAILS_FIELDS: &[&str] = &[];
impl TfaRemoveExceptionDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaRemoveExceptionDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TfaRemoveExceptionDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveExceptionDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveExceptionDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveExceptionDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveExceptionDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveExceptionDetails", TFA_REMOVE_EXCEPTION_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveExceptionDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaRemoveExceptionDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaRemoveExceptionType {
    pub description: String,
}

impl TfaRemoveExceptionType {
    pub fn new(description: String) -> Self {
        TfaRemoveExceptionType {
            description,
        }
    }

}

const TFA_REMOVE_EXCEPTION_TYPE_FIELDS: &[&str] = &["description"];
impl TfaRemoveExceptionType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaRemoveExceptionType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaRemoveExceptionType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaRemoveExceptionType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveExceptionType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveExceptionType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveExceptionType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveExceptionType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveExceptionType", TFA_REMOVE_EXCEPTION_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveExceptionType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaRemoveExceptionType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Removed security key for two-step verification.
#[derive(Debug)]
pub struct TfaRemoveSecurityKeyDetails {
}

impl Default for TfaRemoveSecurityKeyDetails {
    fn default() -> Self {
        TfaRemoveSecurityKeyDetails {
        }
    }
}

const TFA_REMOVE_SECURITY_KEY_DETAILS_FIELDS: &[&str] = &[];
impl TfaRemoveSecurityKeyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaRemoveSecurityKeyDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TfaRemoveSecurityKeyDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveSecurityKeyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveSecurityKeyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveSecurityKeyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveSecurityKeyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveSecurityKeyDetails", TFA_REMOVE_SECURITY_KEY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveSecurityKeyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaRemoveSecurityKeyDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaRemoveSecurityKeyType {
    pub description: String,
}

impl TfaRemoveSecurityKeyType {
    pub fn new(description: String) -> Self {
        TfaRemoveSecurityKeyType {
            description,
        }
    }

}

const TFA_REMOVE_SECURITY_KEY_TYPE_FIELDS: &[&str] = &["description"];
impl TfaRemoveSecurityKeyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaRemoveSecurityKeyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaRemoveSecurityKeyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaRemoveSecurityKeyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaRemoveSecurityKeyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaRemoveSecurityKeyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaRemoveSecurityKeyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaRemoveSecurityKeyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaRemoveSecurityKeyType", TFA_REMOVE_SECURITY_KEY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaRemoveSecurityKeyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaRemoveSecurityKeyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Reset two-step verification for team member.
#[derive(Debug)]
pub struct TfaResetDetails {
}

impl Default for TfaResetDetails {
    fn default() -> Self {
        TfaResetDetails {
        }
    }
}

const TFA_RESET_DETAILS_FIELDS: &[&str] = &[];
impl TfaResetDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TfaResetDetails, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(TfaResetDetails {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaResetDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaResetDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaResetDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaResetDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaResetDetails", TFA_RESET_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaResetDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("TfaResetDetails", 0)?.end()
    }
}

#[derive(Debug)]
pub struct TfaResetType {
    pub description: String,
}

impl TfaResetType {
    pub fn new(description: String) -> Self {
        TfaResetType {
            description,
        }
    }

}

const TFA_RESET_TYPE_FIELDS: &[&str] = &["description"];
impl TfaResetType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TfaResetType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TfaResetType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TfaResetType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TfaResetType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TfaResetType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TfaResetType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TfaResetType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TfaResetType", TFA_RESET_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TfaResetType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TfaResetType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TimeUnit {
    Milliseconds,
    Seconds,
    Minutes,
    Hours,
    Days,
    Weeks,
    Months,
    Years,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TimeUnit {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TimeUnit;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TimeUnit structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "milliseconds" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TimeUnit::Milliseconds)
                    }
                    "seconds" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TimeUnit::Seconds)
                    }
                    "minutes" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TimeUnit::Minutes)
                    }
                    "hours" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TimeUnit::Hours)
                    }
                    "days" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TimeUnit::Days)
                    }
                    "weeks" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TimeUnit::Weeks)
                    }
                    "months" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TimeUnit::Months)
                    }
                    "years" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TimeUnit::Years)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TimeUnit::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["milliseconds",
                                    "seconds",
                                    "minutes",
                                    "hours",
                                    "days",
                                    "weeks",
                                    "months",
                                    "years",
                                    "other"];
        deserializer.deserialize_struct("TimeUnit", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TimeUnit {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TimeUnit::Milliseconds => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "milliseconds")?;
                s.end()
            }
            TimeUnit::Seconds => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "seconds")?;
                s.end()
            }
            TimeUnit::Minutes => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "minutes")?;
                s.end()
            }
            TimeUnit::Hours => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "hours")?;
                s.end()
            }
            TimeUnit::Days => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "days")?;
                s.end()
            }
            TimeUnit::Weeks => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "weeks")?;
                s.end()
            }
            TimeUnit::Months => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "months")?;
                s.end()
            }
            TimeUnit::Years => {
                // unit
                let mut s = serializer.serialize_struct("TimeUnit", 1)?;
                s.serialize_field(".tag", "years")?;
                s.end()
            }
            TimeUnit::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// User that is not a member of the team but considered trusted.
#[derive(Debug)]
pub struct TrustedNonTeamMemberLogInfo {
    /// Indicates the type of the member of a trusted team.
    pub trusted_non_team_member_type: TrustedNonTeamMemberType,
    /// User unique ID. Might be missing due to historical data gap.
    pub account_id: Option<super::users_common::AccountId>,
    /// User display name. Might be missing due to historical data gap.
    pub display_name: Option<super::common::DisplayNameLegacy>,
    /// User email address. Might be missing due to historical data gap.
    pub email: Option<EmailAddress>,
    /// Details about this useru2019s trusted team.
    pub team: Option<TeamLogInfo>,
}

impl TrustedNonTeamMemberLogInfo {
    pub fn new(trusted_non_team_member_type: TrustedNonTeamMemberType) -> Self {
        TrustedNonTeamMemberLogInfo {
            trusted_non_team_member_type,
            account_id: None,
            display_name: None,
            email: None,
            team: None,
        }
    }

    pub fn with_account_id(mut self, value: Option<super::users_common::AccountId>) -> Self {
        self.account_id = value;
        self
    }

    pub fn with_display_name(mut self, value: Option<super::common::DisplayNameLegacy>) -> Self {
        self.display_name = value;
        self
    }

    pub fn with_email(mut self, value: Option<EmailAddress>) -> Self {
        self.email = value;
        self
    }

    pub fn with_team(mut self, value: Option<TeamLogInfo>) -> Self {
        self.team = value;
        self
    }

}

const TRUSTED_NON_TEAM_MEMBER_LOG_INFO_FIELDS: &[&str] = &["trusted_non_team_member_type",
                                                           "account_id",
                                                           "display_name",
                                                           "email",
                                                           "team"];
impl TrustedNonTeamMemberLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TrustedNonTeamMemberLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TrustedNonTeamMemberLogInfo>, V::Error> {
        let mut field_trusted_non_team_member_type = None;
        let mut field_account_id = None;
        let mut field_display_name = None;
        let mut field_email = None;
        let mut field_team = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "trusted_non_team_member_type" => {
                    if field_trusted_non_team_member_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("trusted_non_team_member_type"));
                    }
                    field_trusted_non_team_member_type = Some(map.next_value()?);
                }
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "team" => {
                    if field_team.is_some() {
                        return Err(::serde::de::Error::duplicate_field("team"));
                    }
                    field_team = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TrustedNonTeamMemberLogInfo {
            trusted_non_team_member_type: field_trusted_non_team_member_type.ok_or_else(|| ::serde::de::Error::missing_field("trusted_non_team_member_type"))?,
            account_id: field_account_id,
            display_name: field_display_name,
            email: field_email,
            team: field_team,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("trusted_non_team_member_type", &self.trusted_non_team_member_type)?;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("display_name", &self.display_name)?;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("team", &self.team)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TrustedNonTeamMemberLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TrustedNonTeamMemberLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TrustedNonTeamMemberLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TrustedNonTeamMemberLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TrustedNonTeamMemberLogInfo", TRUSTED_NON_TEAM_MEMBER_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TrustedNonTeamMemberLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TrustedNonTeamMemberLogInfo", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TrustedNonTeamMemberType {
    MultiInstanceAdmin,
    EnterpriseAdmin,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TrustedNonTeamMemberType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TrustedNonTeamMemberType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TrustedNonTeamMemberType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "multi_instance_admin" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedNonTeamMemberType::MultiInstanceAdmin)
                    }
                    "enterprise_admin" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedNonTeamMemberType::EnterpriseAdmin)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedNonTeamMemberType::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["multi_instance_admin",
                                    "enterprise_admin",
                                    "other"];
        deserializer.deserialize_struct("TrustedNonTeamMemberType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TrustedNonTeamMemberType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TrustedNonTeamMemberType::MultiInstanceAdmin => {
                // unit
                let mut s = serializer.serialize_struct("TrustedNonTeamMemberType", 1)?;
                s.serialize_field(".tag", "multi_instance_admin")?;
                s.end()
            }
            TrustedNonTeamMemberType::EnterpriseAdmin => {
                // unit
                let mut s = serializer.serialize_struct("TrustedNonTeamMemberType", 1)?;
                s.serialize_field(".tag", "enterprise_admin")?;
                s.end()
            }
            TrustedNonTeamMemberType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum TrustedTeamsRequestAction {
    Invited,
    Expired,
    Revoked,
    Accepted,
    Declined,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TrustedTeamsRequestAction {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TrustedTeamsRequestAction;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TrustedTeamsRequestAction structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestAction::Invited)
                    }
                    "expired" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestAction::Expired)
                    }
                    "revoked" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestAction::Revoked)
                    }
                    "accepted" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestAction::Accepted)
                    }
                    "declined" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestAction::Declined)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestAction::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["invited",
                                    "expired",
                                    "revoked",
                                    "accepted",
                                    "declined",
                                    "other"];
        deserializer.deserialize_struct("TrustedTeamsRequestAction", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TrustedTeamsRequestAction {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TrustedTeamsRequestAction::Invited => {
                // unit
                let mut s = serializer.serialize_struct("TrustedTeamsRequestAction", 1)?;
                s.serialize_field(".tag", "invited")?;
                s.end()
            }
            TrustedTeamsRequestAction::Expired => {
                // unit
                let mut s = serializer.serialize_struct("TrustedTeamsRequestAction", 1)?;
                s.serialize_field(".tag", "expired")?;
                s.end()
            }
            TrustedTeamsRequestAction::Revoked => {
                // unit
                let mut s = serializer.serialize_struct("TrustedTeamsRequestAction", 1)?;
                s.serialize_field(".tag", "revoked")?;
                s.end()
            }
            TrustedTeamsRequestAction::Accepted => {
                // unit
                let mut s = serializer.serialize_struct("TrustedTeamsRequestAction", 1)?;
                s.serialize_field(".tag", "accepted")?;
                s.end()
            }
            TrustedTeamsRequestAction::Declined => {
                // unit
                let mut s = serializer.serialize_struct("TrustedTeamsRequestAction", 1)?;
                s.serialize_field(".tag", "declined")?;
                s.end()
            }
            TrustedTeamsRequestAction::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum TrustedTeamsRequestState {
    Invited,
    Linked,
    Unlinked,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TrustedTeamsRequestState {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TrustedTeamsRequestState;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TrustedTeamsRequestState structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invited" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestState::Invited)
                    }
                    "linked" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestState::Linked)
                    }
                    "unlinked" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestState::Unlinked)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TrustedTeamsRequestState::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["invited",
                                    "linked",
                                    "unlinked",
                                    "other"];
        deserializer.deserialize_struct("TrustedTeamsRequestState", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TrustedTeamsRequestState {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TrustedTeamsRequestState::Invited => {
                // unit
                let mut s = serializer.serialize_struct("TrustedTeamsRequestState", 1)?;
                s.serialize_field(".tag", "invited")?;
                s.end()
            }
            TrustedTeamsRequestState::Linked => {
                // unit
                let mut s = serializer.serialize_struct("TrustedTeamsRequestState", 1)?;
                s.serialize_field(".tag", "linked")?;
                s.end()
            }
            TrustedTeamsRequestState::Unlinked => {
                // unit
                let mut s = serializer.serialize_struct("TrustedTeamsRequestState", 1)?;
                s.serialize_field(".tag", "unlinked")?;
                s.end()
            }
            TrustedTeamsRequestState::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Enabled/disabled option for members to link personal Dropbox account and team account to same
/// computer.
#[derive(Debug)]
pub struct TwoAccountChangePolicyDetails {
    /// New two account policy.
    pub new_value: TwoAccountPolicy,
    /// Previous two account policy. Might be missing due to historical data gap.
    pub previous_value: Option<TwoAccountPolicy>,
}

impl TwoAccountChangePolicyDetails {
    pub fn new(new_value: TwoAccountPolicy) -> Self {
        TwoAccountChangePolicyDetails {
            new_value,
            previous_value: None,
        }
    }

    pub fn with_previous_value(mut self, value: Option<TwoAccountPolicy>) -> Self {
        self.previous_value = value;
        self
    }

}

const TWO_ACCOUNT_CHANGE_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                            "previous_value"];
impl TwoAccountChangePolicyDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TwoAccountChangePolicyDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TwoAccountChangePolicyDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TwoAccountChangePolicyDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TwoAccountChangePolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TwoAccountChangePolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TwoAccountChangePolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TwoAccountChangePolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TwoAccountChangePolicyDetails", TWO_ACCOUNT_CHANGE_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TwoAccountChangePolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TwoAccountChangePolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TwoAccountChangePolicyType {
    pub description: String,
}

impl TwoAccountChangePolicyType {
    pub fn new(description: String) -> Self {
        TwoAccountChangePolicyType {
            description,
        }
    }

}

const TWO_ACCOUNT_CHANGE_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl TwoAccountChangePolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TwoAccountChangePolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TwoAccountChangePolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TwoAccountChangePolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TwoAccountChangePolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TwoAccountChangePolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TwoAccountChangePolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TwoAccountChangePolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TwoAccountChangePolicyType", TWO_ACCOUNT_CHANGE_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TwoAccountChangePolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TwoAccountChangePolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for pairing personal account to work account
#[derive(Debug)]
pub enum TwoAccountPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TwoAccountPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TwoAccountPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TwoAccountPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TwoAccountPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TwoAccountPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(TwoAccountPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("TwoAccountPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TwoAccountPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TwoAccountPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("TwoAccountPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            TwoAccountPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("TwoAccountPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            TwoAccountPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// User linked app
#[derive(Debug)]
pub struct UserLinkedAppLogInfo {
    /// App unique ID. Might be missing due to historical data gap.
    pub app_id: Option<AppId>,
    /// App display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for UserLinkedAppLogInfo {
    fn default() -> Self {
        UserLinkedAppLogInfo {
            app_id: None,
            display_name: None,
        }
    }
}

const USER_LINKED_APP_LOG_INFO_FIELDS: &[&str] = &["app_id",
                                                   "display_name"];
impl UserLinkedAppLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserLinkedAppLogInfo, V::Error> {
        let mut field_app_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = UserLinkedAppLogInfo {
            app_id: field_app_id,
            display_name: field_display_name,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserLinkedAppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserLinkedAppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UserLinkedAppLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserLinkedAppLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserLinkedAppLogInfo", USER_LINKED_APP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserLinkedAppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserLinkedAppLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// User's logged information.
#[derive(Debug)]
pub enum UserLogInfo {
    TeamMember(TeamMemberLogInfo),
    TrustedNonTeamMember(TrustedNonTeamMemberLogInfo),
    NonTeamMember(NonTeamMemberLogInfo),
    _Unknown
}

impl<'de> ::serde::de::Deserialize<'de> for UserLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // polymorphic struct deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UserLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UserLogInfo structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_member" => Ok(UserLogInfo::TeamMember(TeamMemberLogInfo::internal_deserialize(map)?)),
                    "trusted_non_team_member" => Ok(UserLogInfo::TrustedNonTeamMember(TrustedNonTeamMemberLogInfo::internal_deserialize(map)?)),
                    "non_team_member" => Ok(UserLogInfo::NonTeamMember(NonTeamMemberLogInfo::internal_deserialize(map)?)),
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(UserLogInfo::_Unknown)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["non_team_member",
                                    "non_team_member",
                                    "non_team_member"];
        deserializer.deserialize_struct("UserLogInfo", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UserLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // polymorphic struct serializer
        use serde::ser::SerializeStruct;
        match *self {
            UserLogInfo::TeamMember(ref x) => {
                let mut s = serializer.serialize_struct("UserLogInfo", 7)?;
                s.serialize_field(".tag", "team_member")?;
                s.serialize_field("account_id", &x.account_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.serialize_field("email", &x.email)?;
                s.serialize_field("team_member_id", &x.team_member_id)?;
                s.serialize_field("member_external_id", &x.member_external_id)?;
                s.serialize_field("team", &x.team)?;
                s.end()
            }
            UserLogInfo::TrustedNonTeamMember(ref x) => {
                let mut s = serializer.serialize_struct("UserLogInfo", 6)?;
                s.serialize_field(".tag", "trusted_non_team_member")?;
                s.serialize_field("trusted_non_team_member_type", &x.trusted_non_team_member_type)?;
                s.serialize_field("account_id", &x.account_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.serialize_field("email", &x.email)?;
                s.serialize_field("team", &x.team)?;
                s.end()
            }
            UserLogInfo::NonTeamMember(ref x) => {
                let mut s = serializer.serialize_struct("UserLogInfo", 4)?;
                s.serialize_field(".tag", "non_team_member")?;
                s.serialize_field("account_id", &x.account_id)?;
                s.serialize_field("display_name", &x.display_name)?;
                s.serialize_field("email", &x.email)?;
                s.end()
            }
            UserLogInfo::_Unknown => Err(::serde::ser::Error::custom("cannot serialize unknown variant"))
        }
    }
}

/// User's name logged information
#[derive(Debug)]
pub struct UserNameLogInfo {
    /// Given name.
    pub given_name: String,
    /// Surname.
    pub surname: String,
    /// Locale. Might be missing due to historical data gap.
    pub locale: Option<String>,
}

impl UserNameLogInfo {
    pub fn new(given_name: String, surname: String) -> Self {
        UserNameLogInfo {
            given_name,
            surname,
            locale: None,
        }
    }

    pub fn with_locale(mut self, value: Option<String>) -> Self {
        self.locale = value;
        self
    }

}

const USER_NAME_LOG_INFO_FIELDS: &[&str] = &["given_name",
                                             "surname",
                                             "locale"];
impl UserNameLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<UserNameLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<UserNameLogInfo>, V::Error> {
        let mut field_given_name = None;
        let mut field_surname = None;
        let mut field_locale = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "given_name" => {
                    if field_given_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("given_name"));
                    }
                    field_given_name = Some(map.next_value()?);
                }
                "surname" => {
                    if field_surname.is_some() {
                        return Err(::serde::de::Error::duplicate_field("surname"));
                    }
                    field_surname = Some(map.next_value()?);
                }
                "locale" => {
                    if field_locale.is_some() {
                        return Err(::serde::de::Error::duplicate_field("locale"));
                    }
                    field_locale = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = UserNameLogInfo {
            given_name: field_given_name.ok_or_else(|| ::serde::de::Error::missing_field("given_name"))?,
            surname: field_surname.ok_or_else(|| ::serde::de::Error::missing_field("surname"))?,
            locale: field_locale,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("given_name", &self.given_name)?;
        s.serialize_field("surname", &self.surname)?;
        s.serialize_field("locale", &self.locale)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserNameLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserNameLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UserNameLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserNameLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserNameLogInfo", USER_NAME_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserNameLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserNameLogInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// User or team linked app. Used when linked type is missing due to historical data gap.
#[derive(Debug)]
pub struct UserOrTeamLinkedAppLogInfo {
    /// App unique ID. Might be missing due to historical data gap.
    pub app_id: Option<AppId>,
    /// App display name. Might be missing due to historical data gap.
    pub display_name: Option<String>,
}

impl Default for UserOrTeamLinkedAppLogInfo {
    fn default() -> Self {
        UserOrTeamLinkedAppLogInfo {
            app_id: None,
            display_name: None,
        }
    }
}

const USER_OR_TEAM_LINKED_APP_LOG_INFO_FIELDS: &[&str] = &["app_id",
                                                           "display_name"];
impl UserOrTeamLinkedAppLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserOrTeamLinkedAppLogInfo, V::Error> {
        let mut field_app_id = None;
        let mut field_display_name = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "display_name" => {
                    if field_display_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("display_name"));
                    }
                    field_display_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = UserOrTeamLinkedAppLogInfo {
            app_id: field_app_id,
            display_name: field_display_name,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("display_name", &self.display_name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserOrTeamLinkedAppLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserOrTeamLinkedAppLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UserOrTeamLinkedAppLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserOrTeamLinkedAppLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserOrTeamLinkedAppLogInfo", USER_OR_TEAM_LINKED_APP_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserOrTeamLinkedAppLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserOrTeamLinkedAppLogInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed team policy for viewer info.
#[derive(Debug)]
pub struct ViewerInfoPolicyChangedDetails {
    /// Previous Viewer Info policy.
    pub previous_value: PassPolicy,
    /// New Viewer Info policy.
    pub new_value: PassPolicy,
}

impl ViewerInfoPolicyChangedDetails {
    pub fn new(previous_value: PassPolicy, new_value: PassPolicy) -> Self {
        ViewerInfoPolicyChangedDetails {
            previous_value,
            new_value,
        }
    }

}

const VIEWER_INFO_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                             "new_value"];
impl ViewerInfoPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ViewerInfoPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ViewerInfoPolicyChangedDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ViewerInfoPolicyChangedDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ViewerInfoPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ViewerInfoPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ViewerInfoPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ViewerInfoPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ViewerInfoPolicyChangedDetails", VIEWER_INFO_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ViewerInfoPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ViewerInfoPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ViewerInfoPolicyChangedType {
    pub description: String,
}

impl ViewerInfoPolicyChangedType {
    pub fn new(description: String) -> Self {
        ViewerInfoPolicyChangedType {
            description,
        }
    }

}

const VIEWER_INFO_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl ViewerInfoPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ViewerInfoPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ViewerInfoPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ViewerInfoPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ViewerInfoPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ViewerInfoPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ViewerInfoPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ViewerInfoPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ViewerInfoPolicyChangedType", VIEWER_INFO_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ViewerInfoPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ViewerInfoPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Policy for controlling team access to watermarking feature
#[derive(Debug)]
pub enum WatermarkingPolicy {
    Disabled,
    Enabled,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for WatermarkingPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = WatermarkingPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WatermarkingPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(WatermarkingPolicy::Disabled)
                    }
                    "enabled" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(WatermarkingPolicy::Enabled)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(WatermarkingPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["disabled",
                                    "enabled",
                                    "other"];
        deserializer.deserialize_struct("WatermarkingPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for WatermarkingPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            WatermarkingPolicy::Disabled => {
                // unit
                let mut s = serializer.serialize_struct("WatermarkingPolicy", 1)?;
                s.serialize_field(".tag", "disabled")?;
                s.end()
            }
            WatermarkingPolicy::Enabled => {
                // unit
                let mut s = serializer.serialize_struct("WatermarkingPolicy", 1)?;
                s.serialize_field(".tag", "enabled")?;
                s.end()
            }
            WatermarkingPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Changed watermarking policy for team.
#[derive(Debug)]
pub struct WatermarkingPolicyChangedDetails {
    /// New watermarking policy.
    pub new_value: WatermarkingPolicy,
    /// Previous watermarking policy.
    pub previous_value: WatermarkingPolicy,
}

impl WatermarkingPolicyChangedDetails {
    pub fn new(new_value: WatermarkingPolicy, previous_value: WatermarkingPolicy) -> Self {
        WatermarkingPolicyChangedDetails {
            new_value,
            previous_value,
        }
    }

}

const WATERMARKING_POLICY_CHANGED_DETAILS_FIELDS: &[&str] = &["new_value",
                                                              "previous_value"];
impl WatermarkingPolicyChangedDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<WatermarkingPolicyChangedDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<WatermarkingPolicyChangedDetails>, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = WatermarkingPolicyChangedDetails {
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WatermarkingPolicyChangedDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WatermarkingPolicyChangedDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WatermarkingPolicyChangedDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WatermarkingPolicyChangedDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WatermarkingPolicyChangedDetails", WATERMARKING_POLICY_CHANGED_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WatermarkingPolicyChangedDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WatermarkingPolicyChangedDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct WatermarkingPolicyChangedType {
    pub description: String,
}

impl WatermarkingPolicyChangedType {
    pub fn new(description: String) -> Self {
        WatermarkingPolicyChangedType {
            description,
        }
    }

}

const WATERMARKING_POLICY_CHANGED_TYPE_FIELDS: &[&str] = &["description"];
impl WatermarkingPolicyChangedType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<WatermarkingPolicyChangedType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<WatermarkingPolicyChangedType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = WatermarkingPolicyChangedType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WatermarkingPolicyChangedType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WatermarkingPolicyChangedType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WatermarkingPolicyChangedType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WatermarkingPolicyChangedType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WatermarkingPolicyChangedType", WATERMARKING_POLICY_CHANGED_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WatermarkingPolicyChangedType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WatermarkingPolicyChangedType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information on active web sessions
#[derive(Debug)]
pub struct WebDeviceSessionLogInfo {
    /// Information on the hosting device.
    pub user_agent: String,
    /// Information on the hosting operating system.
    pub os: String,
    /// Information on the browser used for this web session.
    pub browser: String,
    /// The IP address of the last activity from this session. Might be missing due to historical
    /// data gap.
    pub ip_address: Option<IpAddress>,
    /// The time this session was created. Might be missing due to historical data gap.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session. Might be missing due to historical data
    /// gap.
    pub updated: Option<super::common::DropboxTimestamp>,
    /// Web session unique id. Might be missing due to historical data gap.
    pub session_info: Option<WebSessionLogInfo>,
}

impl WebDeviceSessionLogInfo {
    pub fn new(user_agent: String, os: String, browser: String) -> Self {
        WebDeviceSessionLogInfo {
            user_agent,
            os,
            browser,
            ip_address: None,
            created: None,
            updated: None,
            session_info: None,
        }
    }

    pub fn with_ip_address(mut self, value: Option<IpAddress>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

    pub fn with_session_info(mut self, value: Option<WebSessionLogInfo>) -> Self {
        self.session_info = value;
        self
    }

}

const WEB_DEVICE_SESSION_LOG_INFO_FIELDS: &[&str] = &["user_agent",
                                                      "os",
                                                      "browser",
                                                      "ip_address",
                                                      "created",
                                                      "updated",
                                                      "session_info"];
impl WebDeviceSessionLogInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<WebDeviceSessionLogInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<WebDeviceSessionLogInfo>, V::Error> {
        let mut field_user_agent = None;
        let mut field_os = None;
        let mut field_browser = None;
        let mut field_ip_address = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut field_session_info = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "user_agent" => {
                    if field_user_agent.is_some() {
                        return Err(::serde::de::Error::duplicate_field("user_agent"));
                    }
                    field_user_agent = Some(map.next_value()?);
                }
                "os" => {
                    if field_os.is_some() {
                        return Err(::serde::de::Error::duplicate_field("os"));
                    }
                    field_os = Some(map.next_value()?);
                }
                "browser" => {
                    if field_browser.is_some() {
                        return Err(::serde::de::Error::duplicate_field("browser"));
                    }
                    field_browser = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(::serde::de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(::serde::de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(::serde::de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                "session_info" => {
                    if field_session_info.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_info"));
                    }
                    field_session_info = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = WebDeviceSessionLogInfo {
            user_agent: field_user_agent.ok_or_else(|| ::serde::de::Error::missing_field("user_agent"))?,
            os: field_os.ok_or_else(|| ::serde::de::Error::missing_field("os"))?,
            browser: field_browser.ok_or_else(|| ::serde::de::Error::missing_field("browser"))?,
            ip_address: field_ip_address,
            created: field_created,
            updated: field_updated,
            session_info: field_session_info,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_agent", &self.user_agent)?;
        s.serialize_field("os", &self.os)?;
        s.serialize_field("browser", &self.browser)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)?;
        s.serialize_field("session_info", &self.session_info)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebDeviceSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebDeviceSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebDeviceSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebDeviceSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebDeviceSessionLogInfo", WEB_DEVICE_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebDeviceSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebDeviceSessionLogInfo", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Web session.
#[derive(Debug)]
pub struct WebSessionLogInfo {
    /// Session ID. Might be missing due to historical data gap.
    pub session_id: Option<super::common::SessionId>,
}

impl Default for WebSessionLogInfo {
    fn default() -> Self {
        WebSessionLogInfo {
            session_id: None,
        }
    }
}

const WEB_SESSION_LOG_INFO_FIELDS: &[&str] = &["session_id"];
impl WebSessionLogInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<WebSessionLogInfo, V::Error> {
        let mut field_session_id = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = WebSessionLogInfo {
            session_id: field_session_id,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionLogInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionLogInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebSessionLogInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionLogInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionLogInfo", WEB_SESSION_LOG_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionLogInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionLogInfo", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed limit on active sessions per member.
#[derive(Debug)]
pub struct WebSessionsChangeActiveSessionLimitDetails {
    /// Previous max number of concurrent active sessions policy.
    pub previous_value: String,
    /// New max number of concurrent active sessions policy.
    pub new_value: String,
}

impl WebSessionsChangeActiveSessionLimitDetails {
    pub fn new(previous_value: String, new_value: String) -> Self {
        WebSessionsChangeActiveSessionLimitDetails {
            previous_value,
            new_value,
        }
    }

}

const WEB_SESSIONS_CHANGE_ACTIVE_SESSION_LIMIT_DETAILS_FIELDS: &[&str] = &["previous_value",
                                                                           "new_value"];
impl WebSessionsChangeActiveSessionLimitDetails {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<WebSessionsChangeActiveSessionLimitDetails, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<WebSessionsChangeActiveSessionLimitDetails>, V::Error> {
        let mut field_previous_value = None;
        let mut field_new_value = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = WebSessionsChangeActiveSessionLimitDetails {
            previous_value: field_previous_value.ok_or_else(|| ::serde::de::Error::missing_field("previous_value"))?,
            new_value: field_new_value.ok_or_else(|| ::serde::de::Error::missing_field("new_value"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("previous_value", &self.previous_value)?;
        s.serialize_field("new_value", &self.new_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeActiveSessionLimitDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeActiveSessionLimitDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeActiveSessionLimitDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeActiveSessionLimitDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeActiveSessionLimitDetails", WEB_SESSIONS_CHANGE_ACTIVE_SESSION_LIMIT_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeActiveSessionLimitDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeActiveSessionLimitDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct WebSessionsChangeActiveSessionLimitType {
    pub description: String,
}

impl WebSessionsChangeActiveSessionLimitType {
    pub fn new(description: String) -> Self {
        WebSessionsChangeActiveSessionLimitType {
            description,
        }
    }

}

const WEB_SESSIONS_CHANGE_ACTIVE_SESSION_LIMIT_TYPE_FIELDS: &[&str] = &["description"];
impl WebSessionsChangeActiveSessionLimitType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<WebSessionsChangeActiveSessionLimitType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<WebSessionsChangeActiveSessionLimitType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = WebSessionsChangeActiveSessionLimitType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeActiveSessionLimitType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeActiveSessionLimitType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeActiveSessionLimitType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeActiveSessionLimitType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeActiveSessionLimitType", WEB_SESSIONS_CHANGE_ACTIVE_SESSION_LIMIT_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeActiveSessionLimitType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeActiveSessionLimitType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed how long members can stay signed in to Dropbox.com.
#[derive(Debug)]
pub struct WebSessionsChangeFixedLengthPolicyDetails {
    /// New session length policy. Might be missing due to historical data gap.
    pub new_value: Option<WebSessionsFixedLengthPolicy>,
    /// Previous session length policy. Might be missing due to historical data gap.
    pub previous_value: Option<WebSessionsFixedLengthPolicy>,
}

impl Default for WebSessionsChangeFixedLengthPolicyDetails {
    fn default() -> Self {
        WebSessionsChangeFixedLengthPolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                          "previous_value"];
impl WebSessionsChangeFixedLengthPolicyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<WebSessionsChangeFixedLengthPolicyDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = WebSessionsChangeFixedLengthPolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeFixedLengthPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeFixedLengthPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeFixedLengthPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeFixedLengthPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeFixedLengthPolicyDetails", WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeFixedLengthPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeFixedLengthPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct WebSessionsChangeFixedLengthPolicyType {
    pub description: String,
}

impl WebSessionsChangeFixedLengthPolicyType {
    pub fn new(description: String) -> Self {
        WebSessionsChangeFixedLengthPolicyType {
            description,
        }
    }

}

const WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl WebSessionsChangeFixedLengthPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<WebSessionsChangeFixedLengthPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<WebSessionsChangeFixedLengthPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = WebSessionsChangeFixedLengthPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeFixedLengthPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeFixedLengthPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeFixedLengthPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeFixedLengthPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeFixedLengthPolicyType", WEB_SESSIONS_CHANGE_FIXED_LENGTH_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeFixedLengthPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeFixedLengthPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Changed how long team members can be idle while signed in to Dropbox.com.
#[derive(Debug)]
pub struct WebSessionsChangeIdleLengthPolicyDetails {
    /// New idle length policy. Might be missing due to historical data gap.
    pub new_value: Option<WebSessionsIdleLengthPolicy>,
    /// Previous idle length policy. Might be missing due to historical data gap.
    pub previous_value: Option<WebSessionsIdleLengthPolicy>,
}

impl Default for WebSessionsChangeIdleLengthPolicyDetails {
    fn default() -> Self {
        WebSessionsChangeIdleLengthPolicyDetails {
            new_value: None,
            previous_value: None,
        }
    }
}

const WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_DETAILS_FIELDS: &[&str] = &["new_value",
                                                                         "previous_value"];
impl WebSessionsChangeIdleLengthPolicyDetails {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<WebSessionsChangeIdleLengthPolicyDetails, V::Error> {
        let mut field_new_value = None;
        let mut field_previous_value = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "new_value" => {
                    if field_new_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("new_value"));
                    }
                    field_new_value = Some(map.next_value()?);
                }
                "previous_value" => {
                    if field_previous_value.is_some() {
                        return Err(::serde::de::Error::duplicate_field("previous_value"));
                    }
                    field_previous_value = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = WebSessionsChangeIdleLengthPolicyDetails {
            new_value: field_new_value,
            previous_value: field_previous_value,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_value", &self.new_value)?;
        s.serialize_field("previous_value", &self.previous_value)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeIdleLengthPolicyDetails {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeIdleLengthPolicyDetails;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeIdleLengthPolicyDetails struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeIdleLengthPolicyDetails::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeIdleLengthPolicyDetails", WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_DETAILS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeIdleLengthPolicyDetails {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeIdleLengthPolicyDetails", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct WebSessionsChangeIdleLengthPolicyType {
    pub description: String,
}

impl WebSessionsChangeIdleLengthPolicyType {
    pub fn new(description: String) -> Self {
        WebSessionsChangeIdleLengthPolicyType {
            description,
        }
    }

}

const WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_TYPE_FIELDS: &[&str] = &["description"];
impl WebSessionsChangeIdleLengthPolicyType {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<WebSessionsChangeIdleLengthPolicyType, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<WebSessionsChangeIdleLengthPolicyType>, V::Error> {
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = WebSessionsChangeIdleLengthPolicyType {
            description: field_description.ok_or_else(|| ::serde::de::Error::missing_field("description"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("description", &self.description)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsChangeIdleLengthPolicyType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = WebSessionsChangeIdleLengthPolicyType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebSessionsChangeIdleLengthPolicyType struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                WebSessionsChangeIdleLengthPolicyType::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("WebSessionsChangeIdleLengthPolicyType", WEB_SESSIONS_CHANGE_IDLE_LENGTH_POLICY_TYPE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsChangeIdleLengthPolicyType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("WebSessionsChangeIdleLengthPolicyType", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Web sessions fixed length policy.
#[derive(Debug)]
pub enum WebSessionsFixedLengthPolicy {
    /// Defined fixed session length.
    Defined(DurationLogInfo),
    /// Undefined fixed session length.
    Undefined,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsFixedLengthPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = WebSessionsFixedLengthPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebSessionsFixedLengthPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "defined" => Ok(WebSessionsFixedLengthPolicy::Defined(DurationLogInfo::internal_deserialize(map)?)),
                    "undefined" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(WebSessionsFixedLengthPolicy::Undefined)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(WebSessionsFixedLengthPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["defined",
                                    "undefined",
                                    "other"];
        deserializer.deserialize_struct("WebSessionsFixedLengthPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsFixedLengthPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            WebSessionsFixedLengthPolicy::Defined(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("WebSessionsFixedLengthPolicy", 3)?;
                s.serialize_field(".tag", "defined")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            WebSessionsFixedLengthPolicy::Undefined => {
                // unit
                let mut s = serializer.serialize_struct("WebSessionsFixedLengthPolicy", 1)?;
                s.serialize_field(".tag", "undefined")?;
                s.end()
            }
            WebSessionsFixedLengthPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Web sessions idle length policy.
#[derive(Debug)]
pub enum WebSessionsIdleLengthPolicy {
    /// Defined idle session length.
    Defined(DurationLogInfo),
    /// Undefined idle session length.
    Undefined,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for WebSessionsIdleLengthPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = WebSessionsIdleLengthPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a WebSessionsIdleLengthPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "defined" => Ok(WebSessionsIdleLengthPolicy::Defined(DurationLogInfo::internal_deserialize(map)?)),
                    "undefined" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(WebSessionsIdleLengthPolicy::Undefined)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(WebSessionsIdleLengthPolicy::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["defined",
                                    "undefined",
                                    "other"];
        deserializer.deserialize_struct("WebSessionsIdleLengthPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for WebSessionsIdleLengthPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            WebSessionsIdleLengthPolicy::Defined(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("WebSessionsIdleLengthPolicy", 3)?;
                s.serialize_field(".tag", "defined")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            WebSessionsIdleLengthPolicy::Undefined => {
                // unit
                let mut s = serializer.serialize_struct("WebSessionsIdleLengthPolicy", 1)?;
                s.serialize_field(".tag", "undefined")?;
                s.end()
            }
            WebSessionsIdleLengthPolicy::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

