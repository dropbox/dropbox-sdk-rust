// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::result_large_err,
    clippy::doc_markdown,
)]

#[allow(unused_imports)]
pub use crate::generated::types::files::*;

/// Returns the metadata for a file or folder. This is an alpha endpoint compatible with the
/// properties API. Note: Metadata for the root folder is unsupported.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
#[deprecated(note = "replaced by get_metadata")]
pub fn alpha_get_metadata<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a AlphaGetMetadataArg,
) -> impl std::future::Future<Output=Result<Metadata, crate::Error<AlphaGetMetadataError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/alpha/get_metadata",
        arg,
        None)
}

/// Create a new file with the contents provided in the request. Note that the behavior of this
/// alpha endpoint is unstable and subject to change. Do not use this to upload a file larger than
/// 150 MB. Instead, create an upload session with
/// [`upload_session_start()`](crate::files::upload_session_start).
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
#[deprecated(note = "replaced by upload")]
pub fn alpha_upload<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UploadArg,
    body: bytes::Bytes,
) -> impl std::future::Future<Output=Result<FileMetadata, crate::Error<UploadError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Upload,
        "files/alpha/upload",
        arg,
        Some(crate::client_helpers::Body::from(body)))
}

/// Copy a file or folder to a different location in the user's Dropbox. If the source path is a
/// folder all its contents will be copied.
pub fn copy_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a RelocationArg,
) -> impl std::future::Future<Output=Result<RelocationResult, crate::Error<RelocationError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/copy_v2",
        arg,
        None)
}

/// Copy a file or folder to a different location in the user's Dropbox. If the source path is a
/// folder all its contents will be copied.
#[deprecated(note = "replaced by copy_v2")]
pub fn copy<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a RelocationArg,
) -> impl std::future::Future<Output=Result<Metadata, crate::Error<RelocationError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/copy",
        arg,
        None)
}

/// Copy multiple files or folders to different locations at once in the user's Dropbox. This route
/// will replace [`copy_batch()`](crate::files::copy_batch). The main difference is this route will
/// return status for each entry, while [`copy_batch()`](crate::files::copy_batch) raises failure if
/// any entry fails. This route will either finish synchronously, or return a job ID and do the
/// async copy job in background. Please use
/// [`copy_batch_check_v2()`](crate::files::copy_batch_check_v2) to check the job status.
pub fn copy_batch_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a CopyBatchArg,
) -> impl std::future::Future<Output=Result<RelocationBatchV2Launch, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/copy_batch_v2",
        arg,
        None)
}

/// Copy multiple files or folders to different locations at once in the user's Dropbox. This route
/// will return job ID immediately and do the async copy job in background. Please use
/// [`copy_batch_check()`](crate::files::copy_batch_check) to check the job status.
#[deprecated(note = "replaced by copy_batch_v2")]
pub fn copy_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a RelocationBatchArg,
) -> impl std::future::Future<Output=Result<RelocationBatchLaunch, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/copy_batch",
        arg,
        None)
}

/// Returns the status of an asynchronous job for [`copy_batch_v2()`](crate::files::copy_batch_v2).
/// It returns list of results for each entry.
pub fn copy_batch_check_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::dbx_async::PollArg,
) -> impl std::future::Future<Output=Result<RelocationBatchV2JobStatus, crate::Error<crate::types::dbx_async::PollError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/copy_batch/check_v2",
        arg,
        None)
}

/// Returns the status of an asynchronous job for [`copy_batch()`](crate::files::copy_batch). If
/// success, it returns list of results for each entry.
#[deprecated(note = "replaced by copy_batch_check_v2")]
pub fn copy_batch_check<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::dbx_async::PollArg,
) -> impl std::future::Future<Output=Result<RelocationBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/copy_batch/check",
        arg,
        None)
}

/// Get a copy reference to a file or folder. This reference string can be used to save that file or
/// folder to another user's Dropbox by passing it to
/// [`copy_reference_save()`](crate::files::copy_reference_save).
pub fn copy_reference_get<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a GetCopyReferenceArg,
) -> impl std::future::Future<Output=Result<GetCopyReferenceResult, crate::Error<GetCopyReferenceError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/copy_reference/get",
        arg,
        None)
}

/// Save a copy reference returned by [`copy_reference_get()`](crate::files::copy_reference_get) to
/// the user's Dropbox.
pub fn copy_reference_save<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a SaveCopyReferenceArg,
) -> impl std::future::Future<Output=Result<SaveCopyReferenceResult, crate::Error<SaveCopyReferenceError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/copy_reference/save",
        arg,
        None)
}

/// Create a folder at a given path.
pub fn create_folder_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a CreateFolderArg,
) -> impl std::future::Future<Output=Result<CreateFolderResult, crate::Error<CreateFolderError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/create_folder_v2",
        arg,
        None)
}

/// Create a folder at a given path.
#[deprecated(note = "replaced by create_folder_v2")]
pub fn create_folder<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a CreateFolderArg,
) -> impl std::future::Future<Output=Result<FolderMetadata, crate::Error<CreateFolderError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/create_folder",
        arg,
        None)
}

/// Create multiple folders at once. This route is asynchronous for large batches, which returns a
/// job ID immediately and runs the create folder batch asynchronously. Otherwise, creates the
/// folders and returns the result synchronously for smaller inputs. You can force asynchronous
/// behaviour by using the [`CreateFolderBatchArg::force_async`](CreateFolderBatchArg) flag.  Use
/// [`create_folder_batch_check()`](crate::files::create_folder_batch_check) to check the job
/// status.
pub fn create_folder_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a CreateFolderBatchArg,
) -> impl std::future::Future<Output=Result<CreateFolderBatchLaunch, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/create_folder_batch",
        arg,
        None)
}

/// Returns the status of an asynchronous job for
/// [`create_folder_batch()`](crate::files::create_folder_batch). If success, it returns list of
/// result for each entry.
pub fn create_folder_batch_check<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::dbx_async::PollArg,
) -> impl std::future::Future<Output=Result<CreateFolderBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/create_folder_batch/check",
        arg,
        None)
}

/// Delete the file or folder at a given path. If the path is a folder, all its contents will be
/// deleted too. A successful response indicates that the file or folder was deleted. The returned
/// metadata will be the corresponding [`FileMetadata`](FileMetadata) or
/// [`FolderMetadata`](FolderMetadata) for the item at time of deletion, and not a
/// [`DeletedMetadata`](DeletedMetadata) object.
pub fn delete_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a DeleteArg,
) -> impl std::future::Future<Output=Result<DeleteResult, crate::Error<DeleteError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/delete_v2",
        arg,
        None)
}

/// Delete the file or folder at a given path. If the path is a folder, all its contents will be
/// deleted too. A successful response indicates that the file or folder was deleted. The returned
/// metadata will be the corresponding [`FileMetadata`](FileMetadata) or
/// [`FolderMetadata`](FolderMetadata) for the item at time of deletion, and not a
/// [`DeletedMetadata`](DeletedMetadata) object.
#[deprecated(note = "replaced by delete_v2")]
pub fn delete<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a DeleteArg,
) -> impl std::future::Future<Output=Result<Metadata, crate::Error<DeleteError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/delete",
        arg,
        None)
}

/// Delete multiple files/folders at once. This route is asynchronous, which returns a job ID
/// immediately and runs the delete batch asynchronously. Use
/// [`delete_batch_check()`](crate::files::delete_batch_check) to check the job status.
pub fn delete_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a DeleteBatchArg,
) -> impl std::future::Future<Output=Result<DeleteBatchLaunch, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/delete_batch",
        arg,
        None)
}

/// Returns the status of an asynchronous job for [`delete_batch()`](crate::files::delete_batch). If
/// success, it returns list of result for each entry.
pub fn delete_batch_check<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::dbx_async::PollArg,
) -> impl std::future::Future<Output=Result<DeleteBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/delete_batch/check",
        arg,
        None)
}

/// Download a file from a user's Dropbox.
pub fn download<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a DownloadArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> impl std::future::Future<Output=Result<crate::async_client_trait::HttpRequestResult<FileMetadata>, crate::Error<DownloadError>>> + Send + 'a {
    crate::client_helpers::request_with_body(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Download,
        "files/download",
        arg,
        None,
        range_start,
        range_end)
}

/// Download a folder from the user's Dropbox, as a zip file. The folder must be less than 20 GB in
/// size and any single file within must be less than 4 GB in size. The resulting zip must have
/// fewer than 10,000 total file and folder entries, including the top level folder. The input
/// cannot be a single file. Note: this endpoint does not support HTTP range requests.
pub fn download_zip<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a DownloadZipArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> impl std::future::Future<Output=Result<crate::async_client_trait::HttpRequestResult<DownloadZipResult>, crate::Error<DownloadZipError>>> + Send + 'a {
    crate::client_helpers::request_with_body(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Download,
        "files/download_zip",
        arg,
        None,
        range_start,
        range_end)
}

/// Export a file from a user's Dropbox. This route only supports exporting files that cannot be
/// downloaded directly  and whose [`ExportResult::file_metadata`](ExportResult) has
/// [`ExportInfo::export_as`](ExportInfo) populated.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn export<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a ExportArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> impl std::future::Future<Output=Result<crate::async_client_trait::HttpRequestResult<ExportResult>, crate::Error<ExportError>>> + Send + 'a {
    crate::client_helpers::request_with_body(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Download,
        "files/export",
        arg,
        None,
        range_start,
        range_end)
}

/// Return the lock metadata for the given list of paths.
pub fn get_file_lock_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a LockFileBatchArg,
) -> impl std::future::Future<Output=Result<LockFileBatchResult, crate::Error<LockFileError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/get_file_lock_batch",
        arg,
        None)
}

/// Returns the metadata for a file or folder. Note: Metadata for the root folder is unsupported.
pub fn get_metadata<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a GetMetadataArg,
) -> impl std::future::Future<Output=Result<Metadata, crate::Error<GetMetadataError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/get_metadata",
        arg,
        None)
}

/// Get a preview for a file. Currently, PDF previews are generated for files with the following
/// extensions: .ai, .doc, .docm, .docx, .eps, .gdoc, .gslides, .odp, .odt, .pps, .ppsm, .ppsx,
/// .ppt, .pptm, .pptx, .rtf. HTML previews are generated for files with the following extensions:
/// .csv, .ods, .xls, .xlsm, .gsheet, .xlsx. Other formats will return an unsupported extension
/// error.
pub fn get_preview<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a PreviewArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> impl std::future::Future<Output=Result<crate::async_client_trait::HttpRequestResult<FileMetadata>, crate::Error<PreviewError>>> + Send + 'a {
    crate::client_helpers::request_with_body(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Download,
        "files/get_preview",
        arg,
        None,
        range_start,
        range_end)
}

/// Get a temporary link to stream content of a file. This link will expire in four hours and
/// afterwards you will get 410 Gone. This URL should not be used to display content directly in the
/// browser. The Content-Type of the link is determined automatically by the file's mime type.
pub fn get_temporary_link<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a GetTemporaryLinkArg,
) -> impl std::future::Future<Output=Result<GetTemporaryLinkResult, crate::Error<GetTemporaryLinkError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/get_temporary_link",
        arg,
        None)
}

/// Get a one-time use temporary upload link to upload a file to a Dropbox location.
///
/// This endpoint acts as a delayed [`upload()`](crate::files::upload). The returned temporary
/// upload link may be used to make a POST request with the data to be uploaded. The upload will
/// then be perfomed with the [`CommitInfo`](CommitInfo) previously provided to
/// [`get_temporary_upload_link()`](crate::files::get_temporary_upload_link) but evaluated only upon
/// consumption. Hence, errors stemming from invalid [`CommitInfo`](CommitInfo) with respect to the
/// state of the user's Dropbox will only be communicated at consumption time. Additionally, these
/// errors are surfaced as generic HTTP 409 Conflict responses, potentially hiding issue details.
/// The maximum temporary upload link duration is 4 hours. Upon consumption or expiration, a new
/// link will have to be generated. Multiple links may exist for a specific upload path at any given
/// time.
///
/// The POST request on the temporary upload link must have its Content-Type set to
/// "application/octet-stream".
///
/// Example temporary upload link consumption request:
///
/// curl -X POST https://content.dropboxapi.com/apitul/1/bNi2uIYF51cVBND --header "Content-Type:
/// application/octet-stream" --data-binary @local_file.txt
///
/// A successful temporary upload link consumption request returns the content hash of the uploaded
/// data in JSON format.
///
/// Example successful temporary upload link consumption response: {"content-hash":
/// "599d71033d700ac892a0e48fa61b125d2f5994"}
///
/// An unsuccessful temporary upload link consumption request returns any of the following status
/// codes:
///
/// HTTP 400 Bad Request: Content-Type is not one of application/octet-stream and text/plain or
/// request is invalid. HTTP 409 Conflict: The temporary upload link does not exist or is currently
/// unavailable, the upload failed, or another error happened. HTTP 410 Gone: The temporary upload
/// link is expired or consumed.
///
/// Example unsuccessful temporary upload link consumption response: Temporary upload link has been
/// recently consumed.
pub fn get_temporary_upload_link<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a GetTemporaryUploadLinkArg,
) -> impl std::future::Future<Output=Result<GetTemporaryUploadLinkResult, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/get_temporary_upload_link",
        arg,
        None)
}

/// Get a thumbnail for an image. This method currently supports files with the following file
/// extensions: jpg, jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB
/// in size won't be converted to a thumbnail.
pub fn get_thumbnail<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a ThumbnailArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> impl std::future::Future<Output=Result<crate::async_client_trait::HttpRequestResult<FileMetadata>, crate::Error<ThumbnailError>>> + Send + 'a {
    crate::client_helpers::request_with_body(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Download,
        "files/get_thumbnail",
        arg,
        None,
        range_start,
        range_end)
}

/// Get a thumbnail for an image. This method currently supports files with the following file
/// extensions: jpg, jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB
/// in size won't be converted to a thumbnail.
pub fn get_thumbnail_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a ThumbnailV2Arg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> impl std::future::Future<Output=Result<crate::async_client_trait::HttpRequestResult<PreviewResult>, crate::Error<ThumbnailV2Error>>> + Send + 'a {
    crate::client_helpers::request_with_body(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Download,
        "files/get_thumbnail_v2",
        arg,
        None,
        range_start,
        range_end)
}

/// Get a thumbnail for an image. This method currently supports files with the following file
/// extensions: jpg, jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB
/// in size won't be converted to a thumbnail.
pub fn get_thumbnail_v2_app_auth<'a>(
    client: &'a impl crate::async_client_trait::AppAuthClient,
    arg: &'a ThumbnailV2Arg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> impl std::future::Future<Output=Result<crate::async_client_trait::HttpRequestResult<PreviewResult>, crate::Error<ThumbnailV2Error>>> + Send + 'a {
    crate::client_helpers::request_with_body(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Download,
        "files/get_thumbnail_v2",
        arg,
        None,
        range_start,
        range_end)
}

/// Get thumbnails for a list of images. We allow up to 25 thumbnails in a single batch. This method
/// currently supports files with the following file extensions: jpg, jpeg, png, tiff, tif, gif,
/// webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to a thumbnail.
pub fn get_thumbnail_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a GetThumbnailBatchArg,
) -> impl std::future::Future<Output=Result<GetThumbnailBatchResult, crate::Error<GetThumbnailBatchError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Rpc,
        "files/get_thumbnail_batch",
        arg,
        None)
}

/// Starts returning the contents of a folder. If the result's
/// [`ListFolderResult::has_more`](ListFolderResult) field is `true`, call
/// [`list_folder_continue()`](crate::files::list_folder_continue) with the returned
/// [`ListFolderResult::cursor`](ListFolderResult) to retrieve more entries. If you're using
/// [`ListFolderArg::recursive`](ListFolderArg) set to `true` to keep a local cache of the contents
/// of a Dropbox account, iterate through each entry in order and process them as follows to keep
/// your local state in sync: For each [`FileMetadata`](FileMetadata), store the new entry at the
/// given path in your local state. If the required parent folders don't exist yet, create them. If
/// there's already something else at the given path, replace it and remove all its children. For
/// each [`FolderMetadata`](FolderMetadata), store the new entry at the given path in your local
/// state. If the required parent folders don't exist yet, create them. If there's already something
/// else at the given path, replace it but leave the children as they are. Check the new entry's
/// [`FolderSharingInfo::read_only`](FolderSharingInfo) and set all its children's read-only
/// statuses to match. For each [`DeletedMetadata`](DeletedMetadata), if your local state has
/// something at the given path, remove it and all its children. If there's nothing at the given
/// path, ignore this entry. Note: [`auth::RateLimitError`](crate::types::auth::RateLimitError) may
/// be returned if multiple [`list_folder()`](crate::files::list_folder) or
/// [`list_folder_continue()`](crate::files::list_folder_continue) calls with same parameters are
/// made simultaneously by same API app for same user. If your app implements retry logic, please
/// hold off the retry until the previous request finishes.
pub fn list_folder<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a ListFolderArg,
) -> impl std::future::Future<Output=Result<ListFolderResult, crate::Error<ListFolderError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/list_folder",
        arg,
        None)
}

/// Starts returning the contents of a folder. If the result's
/// [`ListFolderResult::has_more`](ListFolderResult) field is `true`, call
/// [`list_folder_continue()`](crate::files::list_folder_continue) with the returned
/// [`ListFolderResult::cursor`](ListFolderResult) to retrieve more entries. If you're using
/// [`ListFolderArg::recursive`](ListFolderArg) set to `true` to keep a local cache of the contents
/// of a Dropbox account, iterate through each entry in order and process them as follows to keep
/// your local state in sync: For each [`FileMetadata`](FileMetadata), store the new entry at the
/// given path in your local state. If the required parent folders don't exist yet, create them. If
/// there's already something else at the given path, replace it and remove all its children. For
/// each [`FolderMetadata`](FolderMetadata), store the new entry at the given path in your local
/// state. If the required parent folders don't exist yet, create them. If there's already something
/// else at the given path, replace it but leave the children as they are. Check the new entry's
/// [`FolderSharingInfo::read_only`](FolderSharingInfo) and set all its children's read-only
/// statuses to match. For each [`DeletedMetadata`](DeletedMetadata), if your local state has
/// something at the given path, remove it and all its children. If there's nothing at the given
/// path, ignore this entry. Note: [`auth::RateLimitError`](crate::types::auth::RateLimitError) may
/// be returned if multiple [`list_folder()`](crate::files::list_folder) or
/// [`list_folder_continue()`](crate::files::list_folder_continue) calls with same parameters are
/// made simultaneously by same API app for same user. If your app implements retry logic, please
/// hold off the retry until the previous request finishes.
pub fn list_folder_app_auth<'a>(
    client: &'a impl crate::async_client_trait::AppAuthClient,
    arg: &'a ListFolderArg,
) -> impl std::future::Future<Output=Result<ListFolderResult, crate::Error<ListFolderError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/list_folder",
        arg,
        None)
}

/// Once a cursor has been retrieved from [`list_folder()`](crate::files::list_folder), use this to
/// paginate through all files and retrieve updates to the folder, following the same rules as
/// documented for [`list_folder()`](crate::files::list_folder).
pub fn list_folder_continue<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a ListFolderContinueArg,
) -> impl std::future::Future<Output=Result<ListFolderResult, crate::Error<ListFolderContinueError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/list_folder/continue",
        arg,
        None)
}

/// Once a cursor has been retrieved from [`list_folder()`](crate::files::list_folder), use this to
/// paginate through all files and retrieve updates to the folder, following the same rules as
/// documented for [`list_folder()`](crate::files::list_folder).
pub fn list_folder_continue_app_auth<'a>(
    client: &'a impl crate::async_client_trait::AppAuthClient,
    arg: &'a ListFolderContinueArg,
) -> impl std::future::Future<Output=Result<ListFolderResult, crate::Error<ListFolderContinueError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/list_folder/continue",
        arg,
        None)
}

/// A way to quickly get a cursor for the folder's state. Unlike
/// [`list_folder()`](crate::files::list_folder),
/// [`list_folder_get_latest_cursor()`](crate::files::list_folder_get_latest_cursor) doesn't return
/// any entries. This endpoint is for app which only needs to know about new files and modifications
/// and doesn't need to know about files that already exist in Dropbox.
pub fn list_folder_get_latest_cursor<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a ListFolderArg,
) -> impl std::future::Future<Output=Result<ListFolderGetLatestCursorResult, crate::Error<ListFolderError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/list_folder/get_latest_cursor",
        arg,
        None)
}

/// A longpoll endpoint to wait for changes on an account. In conjunction with
/// [`list_folder_continue()`](crate::files::list_folder_continue), this call gives you a
/// low-latency way to monitor an account for file changes. The connection will block until there
/// are changes available or a timeout occurs. This endpoint is useful mostly for client-side apps.
/// If you're looking for server-side notifications, check out our [webhooks
/// documentation](https://www.dropbox.com/developers/reference/webhooks).
pub fn list_folder_longpoll<'a>(
    client: &'a impl crate::async_client_trait::NoauthClient,
    arg: &'a ListFolderLongpollArg,
) -> impl std::future::Future<Output=Result<ListFolderLongpollResult, crate::Error<ListFolderLongpollError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Notify,
        crate::client_trait_common::Style::Rpc,
        "files/list_folder/longpoll",
        arg,
        None)
}

/// Returns revisions for files based on a file path or a file id. The file path or file id is
/// identified from the latest file entry at the given file path or id. This end point allows your
/// app to query either by file path or file id by setting the mode parameter appropriately. In the
/// [`ListRevisionsMode::Path`](ListRevisionsMode::Path) (default) mode, all revisions at the same
/// file path as the latest file entry are returned. If revisions with the same file id are desired,
/// then mode must be set to [`ListRevisionsMode::Id`](ListRevisionsMode::Id). The
/// [`ListRevisionsMode::Id`](ListRevisionsMode::Id) mode is useful to retrieve revisions for a
/// given file across moves or renames.
pub fn list_revisions<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a ListRevisionsArg,
) -> impl std::future::Future<Output=Result<ListRevisionsResult, crate::Error<ListRevisionsError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/list_revisions",
        arg,
        None)
}

/// Lock the files at the given paths. A locked file will be writable only by the lock holder. A
/// successful response indicates that the file has been locked. Returns a list of the locked file
/// paths and their metadata after this operation.
pub fn lock_file_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a LockFileBatchArg,
) -> impl std::future::Future<Output=Result<LockFileBatchResult, crate::Error<LockFileError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/lock_file_batch",
        arg,
        None)
}

/// Move a file or folder to a different location in the user's Dropbox. If the source path is a
/// folder all its contents will be moved. Note that we do not currently support case-only renaming.
pub fn move_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a RelocationArg,
) -> impl std::future::Future<Output=Result<RelocationResult, crate::Error<RelocationError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/move_v2",
        arg,
        None)
}

/// Move a file or folder to a different location in the user's Dropbox. If the source path is a
/// folder all its contents will be moved.
#[deprecated(note = "replaced by move_v2")]
pub fn do_move<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a RelocationArg,
) -> impl std::future::Future<Output=Result<Metadata, crate::Error<RelocationError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/move",
        arg,
        None)
}

/// Move multiple files or folders to different locations at once in the user's Dropbox. Note that
/// we do not currently support case-only renaming. This route will replace
/// [`move_batch()`](crate::files::move_batch). The main difference is this route will return status
/// for each entry, while [`move_batch()`](crate::files::move_batch) raises failure if any entry
/// fails. This route will either finish synchronously, or return a job ID and do the async move job
/// in background. Please use [`move_batch_check_v2()`](crate::files::move_batch_check_v2) to check
/// the job status.
pub fn move_batch_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a MoveBatchArg,
) -> impl std::future::Future<Output=Result<RelocationBatchV2Launch, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/move_batch_v2",
        arg,
        None)
}

/// Move multiple files or folders to different locations at once in the user's Dropbox. This route
/// will return job ID immediately and do the async moving job in background. Please use
/// [`move_batch_check()`](crate::files::move_batch_check) to check the job status.
#[deprecated(note = "replaced by move_batch_v2")]
pub fn move_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a RelocationBatchArg,
) -> impl std::future::Future<Output=Result<RelocationBatchLaunch, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/move_batch",
        arg,
        None)
}

/// Returns the status of an asynchronous job for [`move_batch_v2()`](crate::files::move_batch_v2).
/// It returns list of results for each entry.
pub fn move_batch_check_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::dbx_async::PollArg,
) -> impl std::future::Future<Output=Result<RelocationBatchV2JobStatus, crate::Error<crate::types::dbx_async::PollError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/move_batch/check_v2",
        arg,
        None)
}

/// Returns the status of an asynchronous job for [`move_batch()`](crate::files::move_batch). If
/// success, it returns list of results for each entry.
#[deprecated(note = "replaced by move_batch_check_v2")]
pub fn move_batch_check<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::dbx_async::PollArg,
) -> impl std::future::Future<Output=Result<RelocationBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/move_batch/check",
        arg,
        None)
}

/// Creates a new Paper doc with the provided content.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn paper_create<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a PaperCreateArg,
    body: bytes::Bytes,
) -> impl std::future::Future<Output=Result<PaperCreateResult, crate::Error<PaperCreateError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Upload,
        "files/paper/create",
        arg,
        Some(crate::client_helpers::Body::from(body)))
}

/// Updates an existing Paper doc with the provided content.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn paper_update<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a PaperUpdateArg,
    body: bytes::Bytes,
) -> impl std::future::Future<Output=Result<PaperUpdateResult, crate::Error<PaperUpdateError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Upload,
        "files/paper/update",
        arg,
        Some(crate::client_helpers::Body::from(body)))
}

/// Permanently delete the file or folder at a given path (see https://www.dropbox.com/en/help/40).
/// If the given file or folder is not yet deleted, this route will first delete it. It is possible
/// for this route to successfully delete, then fail to permanently delete. Note: This endpoint is
/// only available for Dropbox Business apps.
pub fn permanently_delete<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a DeleteArg,
) -> impl std::future::Future<Output=Result<(), crate::Error<DeleteError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/permanently_delete",
        arg,
        None)
}

#[deprecated]
pub fn properties_add<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::file_properties::AddPropertiesArg,
) -> impl std::future::Future<Output=Result<(), crate::Error<crate::types::file_properties::AddPropertiesError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/properties/add",
        arg,
        None)
}

#[deprecated]
pub fn properties_overwrite<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::file_properties::OverwritePropertyGroupArg,
) -> impl std::future::Future<Output=Result<(), crate::Error<crate::types::file_properties::InvalidPropertyGroupError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/properties/overwrite",
        arg,
        None)
}

#[deprecated]
pub fn properties_remove<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::file_properties::RemovePropertiesArg,
) -> impl std::future::Future<Output=Result<(), crate::Error<crate::types::file_properties::RemovePropertiesError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/properties/remove",
        arg,
        None)
}

#[deprecated]
pub fn properties_template_get<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::file_properties::GetTemplateArg,
) -> impl std::future::Future<Output=Result<crate::types::file_properties::GetTemplateResult, crate::Error<crate::types::file_properties::TemplateError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/properties/template/get",
        arg,
        None)
}

#[deprecated]
pub fn properties_template_list(
    client: &impl crate::async_client_trait::UserAuthClient,
) -> impl std::future::Future<Output=Result<crate::types::file_properties::ListTemplateResult, crate::Error<crate::types::file_properties::TemplateError>>> + Send + '_ {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/properties/template/list",
        &(),
        None)
}

#[deprecated]
pub fn properties_update<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::file_properties::UpdatePropertiesArg,
) -> impl std::future::Future<Output=Result<(), crate::Error<crate::types::file_properties::UpdatePropertiesError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/properties/update",
        arg,
        None)
}

/// Restore a specific revision of a file to the given path.
pub fn restore<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a RestoreArg,
) -> impl std::future::Future<Output=Result<FileMetadata, crate::Error<RestoreError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/restore",
        arg,
        None)
}

/// Save the data from a specified URL into a file in user's Dropbox. Note that the transfer from
/// the URL must complete within 15 minutes, or the operation will time out and the job will fail.
/// If the given path already exists, the file will be renamed to avoid the conflict (e.g. myfile
/// (1).txt).
pub fn save_url<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a SaveUrlArg,
) -> impl std::future::Future<Output=Result<SaveUrlResult, crate::Error<SaveUrlError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/save_url",
        arg,
        None)
}

/// Check the status of a [`save_url()`](crate::files::save_url) job.
pub fn save_url_check_job_status<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::dbx_async::PollArg,
) -> impl std::future::Future<Output=Result<SaveUrlJobStatus, crate::Error<crate::types::dbx_async::PollError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/save_url/check_job_status",
        arg,
        None)
}

/// Searches for files and folders. Note: Recent changes will be reflected in search results within
/// a few seconds and older revisions of existing files may still match your query for up to a few
/// days.
#[deprecated(note = "replaced by search_v2")]
pub fn search<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a SearchArg,
) -> impl std::future::Future<Output=Result<SearchResult, crate::Error<SearchError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/search",
        arg,
        None)
}

/// Searches for files and folders. Note: [`search_v2()`](crate::files::search_v2) along with
/// [`search_continue_v2()`](crate::files::search_continue_v2) can only be used to retrieve a
/// maximum of 10,000 matches. Recent changes may not immediately be reflected in search results due
/// to a short delay in indexing. Duplicate results may be returned across pages. Some results may
/// not be returned.
pub fn search_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a SearchV2Arg,
) -> impl std::future::Future<Output=Result<SearchV2Result, crate::Error<SearchError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/search_v2",
        arg,
        None)
}

/// Fetches the next page of search results returned from [`search_v2()`](crate::files::search_v2).
/// Note: [`search_v2()`](crate::files::search_v2) along with
/// [`search_continue_v2()`](crate::files::search_continue_v2) can only be used to retrieve a
/// maximum of 10,000 matches. Recent changes may not immediately be reflected in search results due
/// to a short delay in indexing. Duplicate results may be returned across pages. Some results may
/// not be returned.
pub fn search_continue_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a SearchV2ContinueArg,
) -> impl std::future::Future<Output=Result<SearchV2Result, crate::Error<SearchError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/search/continue_v2",
        arg,
        None)
}

/// Add a tag to an item. A tag is a string. The strings are automatically converted to lowercase
/// letters. No more than 20 tags can be added to a given item.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn tags_add<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a AddTagArg,
) -> impl std::future::Future<Output=Result<(), crate::Error<AddTagError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/tags/add",
        arg,
        None)
}

/// Get list of tags assigned to items.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn tags_get<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a GetTagsArg,
) -> impl std::future::Future<Output=Result<GetTagsResult, crate::Error<BaseTagError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/tags/get",
        arg,
        None)
}

/// Remove a tag from an item.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn tags_remove<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a RemoveTagArg,
) -> impl std::future::Future<Output=Result<(), crate::Error<RemoveTagError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/tags/remove",
        arg,
        None)
}

/// Unlock the files at the given paths. A locked file can only be unlocked by the lock holder or,
/// if a business account, a team admin. A successful response indicates that the file has been
/// unlocked. Returns a list of the unlocked file paths and their metadata after this operation.
pub fn unlock_file_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UnlockFileBatchArg,
) -> impl std::future::Future<Output=Result<LockFileBatchResult, crate::Error<LockFileError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/unlock_file_batch",
        arg,
        None)
}

/// Create a new file with the contents provided in the request. Do not use this to upload a file
/// larger than 150 MB. Instead, create an upload session with
/// [`upload_session_start()`](crate::files::upload_session_start). Calls to this endpoint will
/// count as data transport calls for any Dropbox Business teams with a limit on the number of data
/// transport calls allowed per month. For more information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UploadArg,
    body: bytes::Bytes,
) -> impl std::future::Future<Output=Result<FileMetadata, crate::Error<UploadError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Upload,
        "files/upload",
        arg,
        Some(crate::client_helpers::Body::from(body)))
}

/// Append more data to an upload session. When the parameter close is set, this call will close the
/// session. A single request should not upload more than 150 MB. The maximum size of a file one can
/// upload to an upload session is 350 GB. Calls to this endpoint will count as data transport calls
/// for any Dropbox Business teams with a limit on the number of data transport calls allowed per
/// month. For more information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload_session_append_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UploadSessionAppendArg,
    body: bytes::Bytes,
) -> impl std::future::Future<Output=Result<(), crate::Error<UploadSessionAppendError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Upload,
        "files/upload_session/append_v2",
        arg,
        Some(crate::client_helpers::Body::from(body)))
}

/// Append more data to an upload session. A single request should not upload more than 150 MB. The
/// maximum size of a file one can upload to an upload session is 350 GB. Calls to this endpoint
/// will count as data transport calls for any Dropbox Business teams with a limit on the number of
/// data transport calls allowed per month. For more information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
#[deprecated(note = "replaced by upload_session_append_v2")]
pub fn upload_session_append<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UploadSessionCursor,
    body: bytes::Bytes,
) -> impl std::future::Future<Output=Result<(), crate::Error<UploadSessionAppendError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Upload,
        "files/upload_session/append",
        arg,
        Some(crate::client_helpers::Body::from(body)))
}

/// Finish an upload session and save the uploaded data to the given file path. A single request
/// should not upload more than 150 MB. The maximum size of a file one can upload to an upload
/// session is 350 GB. Calls to this endpoint will count as data transport calls for any Dropbox
/// Business teams with a limit on the number of data transport calls allowed per month. For more
/// information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload_session_finish<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UploadSessionFinishArg,
    body: bytes::Bytes,
) -> impl std::future::Future<Output=Result<FileMetadata, crate::Error<UploadSessionFinishError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Upload,
        "files/upload_session/finish",
        arg,
        Some(crate::client_helpers::Body::from(body)))
}

/// This route helps you commit many files at once into a user's Dropbox. Use
/// [`upload_session_start()`](crate::files::upload_session_start) and
/// [`upload_session_append_v2()`](crate::files::upload_session_append_v2) to upload file contents.
/// We recommend uploading many files in parallel to increase throughput. Once the file contents
/// have been uploaded, rather than calling
/// [`upload_session_finish()`](crate::files::upload_session_finish), use this route to finish all
/// your upload sessions in a single request.
/// [`UploadSessionStartArg::close`](UploadSessionStartArg) or
/// [`UploadSessionAppendArg::close`](UploadSessionAppendArg) needs to be true for the last
/// [`upload_session_start()`](crate::files::upload_session_start) or
/// [`upload_session_append_v2()`](crate::files::upload_session_append_v2) call. The maximum size of
/// a file one can upload to an upload session is 350 GB. This route will return a job_id
/// immediately and do the async commit job in background. Use
/// [`upload_session_finish_batch_check()`](crate::files::upload_session_finish_batch_check) to
/// check the job status. For the same account, this route should be executed serially. That means
/// you should not start the next job before current job finishes. We allow up to 1000 entries in a
/// single request. Calls to this endpoint will count as data transport calls for any Dropbox
/// Business teams with a limit on the number of data transport calls allowed per month. For more
/// information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
#[deprecated(note = "replaced by upload_session_finish_batch_v2")]
pub fn upload_session_finish_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UploadSessionFinishBatchArg,
) -> impl std::future::Future<Output=Result<UploadSessionFinishBatchLaunch, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/upload_session/finish_batch",
        arg,
        None)
}

/// This route helps you commit many files at once into a user's Dropbox. Use
/// [`upload_session_start()`](crate::files::upload_session_start) and
/// [`upload_session_append_v2()`](crate::files::upload_session_append_v2) to upload file contents.
/// We recommend uploading many files in parallel to increase throughput. Once the file contents
/// have been uploaded, rather than calling
/// [`upload_session_finish()`](crate::files::upload_session_finish), use this route to finish all
/// your upload sessions in a single request.
/// [`UploadSessionStartArg::close`](UploadSessionStartArg) or
/// [`UploadSessionAppendArg::close`](UploadSessionAppendArg) needs to be true for the last
/// [`upload_session_start()`](crate::files::upload_session_start) or
/// [`upload_session_append_v2()`](crate::files::upload_session_append_v2) call of each upload
/// session. The maximum size of a file one can upload to an upload session is 350 GB. We allow up
/// to 1000 entries in a single request. Calls to this endpoint will count as data transport calls
/// for any Dropbox Business teams with a limit on the number of data transport calls allowed per
/// month. For more information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload_session_finish_batch_v2<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UploadSessionFinishBatchArg,
) -> impl std::future::Future<Output=Result<UploadSessionFinishBatchResult, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/upload_session/finish_batch_v2",
        arg,
        None)
}

/// Returns the status of an asynchronous job for
/// [`upload_session_finish_batch()`](crate::files::upload_session_finish_batch). If success, it
/// returns list of result for each entry.
pub fn upload_session_finish_batch_check<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a crate::types::dbx_async::PollArg,
) -> impl std::future::Future<Output=Result<UploadSessionFinishBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/upload_session/finish_batch/check",
        arg,
        None)
}

/// Upload sessions allow you to upload a single file in one or more requests, for example where the
/// size of the file is greater than 150 MB.  This call starts a new upload session with the given
/// data. You can then use [`upload_session_append_v2()`](crate::files::upload_session_append_v2) to
/// add more data and [`upload_session_finish()`](crate::files::upload_session_finish) to save all
/// the data to a file in Dropbox. A single request should not upload more than 150 MB. The maximum
/// size of a file one can upload to an upload session is 350 GB. An upload session can be used for
/// a maximum of 7 days. Attempting to use an
/// [`UploadSessionStartResult::session_id`](UploadSessionStartResult) with
/// [`upload_session_append_v2()`](crate::files::upload_session_append_v2) or
/// [`upload_session_finish()`](crate::files::upload_session_finish) more than 7 days after its
/// creation will return a
/// [`UploadSessionLookupError::NotFound`](UploadSessionLookupError::NotFound). Calls to this
/// endpoint will count as data transport calls for any Dropbox Business teams with a limit on the
/// number of data transport calls allowed per month. For more information, see the [Data transport
/// limit page](https://www.dropbox.com/developers/reference/data-transport-limit). By default,
/// upload sessions require you to send content of the file in sequential order via consecutive
/// [`upload_session_start()`](crate::files::upload_session_start),
/// [`upload_session_append_v2()`](crate::files::upload_session_append_v2),
/// [`upload_session_finish()`](crate::files::upload_session_finish) calls. For better performance,
/// you can instead optionally use a
/// [`UploadSessionType::Concurrent`](UploadSessionType::Concurrent) upload session. To start a new
/// concurrent session, set [`UploadSessionStartArg::session_type`](UploadSessionStartArg) to
/// [`UploadSessionType::Concurrent`](UploadSessionType::Concurrent). After that, you can send file
/// data in concurrent [`upload_session_append_v2()`](crate::files::upload_session_append_v2)
/// requests. Finally finish the session with
/// [`upload_session_finish()`](crate::files::upload_session_finish). There are couple of
/// constraints with concurrent sessions to make them work. You can not send data with
/// [`upload_session_start()`](crate::files::upload_session_start) or
/// [`upload_session_finish()`](crate::files::upload_session_finish) call, only with
/// [`upload_session_append_v2()`](crate::files::upload_session_append_v2) call. Also data uploaded
/// in [`upload_session_append_v2()`](crate::files::upload_session_append_v2) call must be multiple
/// of 4194304 bytes (except for last
/// [`upload_session_append_v2()`](crate::files::upload_session_append_v2) with
/// [`UploadSessionStartArg::close`](UploadSessionStartArg) to `true`, that may contain any
/// remaining data).
pub fn upload_session_start<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UploadSessionStartArg,
    body: bytes::Bytes,
) -> impl std::future::Future<Output=Result<UploadSessionStartResult, crate::Error<UploadSessionStartError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Content,
        crate::client_trait_common::Style::Upload,
        "files/upload_session/start",
        arg,
        Some(crate::client_helpers::Body::from(body)))
}

/// This route starts batch of upload_sessions. Please refer to `upload_session/start` usage. Calls
/// to this endpoint will count as data transport calls for any Dropbox Business teams with a limit
/// on the number of data transport calls allowed per month. For more information, see the [Data
/// transport limit page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload_session_start_batch<'a>(
    client: &'a impl crate::async_client_trait::UserAuthClient,
    arg: &'a UploadSessionStartBatchArg,
) -> impl std::future::Future<Output=Result<UploadSessionStartBatchResult, crate::Error<crate::NoError>>> + Send + 'a {
    crate::client_helpers::request(
        client,
        crate::client_trait_common::Endpoint::Api,
        crate::client_trait_common::Style::Rpc,
        "files/upload_session/start_batch",
        arg,
        None)
}

