// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::doc_markdown,
)]

#[derive(Debug, Clone, PartialEq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct SecondaryEmail {
    /// Secondary email address.
    pub email: super::common::EmailAddress,
    /// Whether or not the secondary email address is verified to be owned by a user.
    pub is_verified: bool,
}

impl SecondaryEmail {
    pub fn new(email: super::common::EmailAddress, is_verified: bool) -> Self {
        SecondaryEmail {
            email,
            is_verified,
        }
    }
}

const SECONDARY_EMAIL_FIELDS: &[&str] = &["email",
                                          "is_verified"];
impl SecondaryEmail {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SecondaryEmail, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SecondaryEmail>, V::Error> {
        let mut field_email = None;
        let mut field_is_verified = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "is_verified" => {
                    if field_is_verified.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_verified"));
                    }
                    field_is_verified = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SecondaryEmail {
            email: field_email.ok_or_else(|| ::serde::de::Error::missing_field("email"))?,
            is_verified: field_is_verified.ok_or_else(|| ::serde::de::Error::missing_field("is_verified"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("is_verified", &self.is_verified)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SecondaryEmail {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SecondaryEmail;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a SecondaryEmail struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SecondaryEmail::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SecondaryEmail", SECONDARY_EMAIL_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SecondaryEmail {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SecondaryEmail", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

