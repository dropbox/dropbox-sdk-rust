// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::doc_markdown,
)]

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AuthError {
    InvalidToken,
    NoOpenidAuth,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AuthError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AuthError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AuthError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                let value = match tag {
                    "invalid_token" => AuthError::InvalidToken,
                    "no_openid_auth" => AuthError::NoOpenidAuth,
                    _ => AuthError::Other,
                };
                crate::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["invalid_token",
                                    "no_openid_auth",
                                    "other"];
        deserializer.deserialize_struct("AuthError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AuthError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AuthError::InvalidToken => {
                // unit
                let mut s = serializer.serialize_struct("AuthError", 1)?;
                s.serialize_field(".tag", "invalid_token")?;
                s.end()
            }
            AuthError::NoOpenidAuth => {
                // unit
                let mut s = serializer.serialize_struct("AuthError", 1)?;
                s.serialize_field(".tag", "no_openid_auth")?;
                s.end()
            }
            AuthError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for AuthError {
}

impl ::std::fmt::Display for AuthError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// This struct is empty. The comment here is intentionally emitted to avoid indentation issues with
/// Stone.
#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct UserInfoArgs {
}

const USER_INFO_ARGS_FIELDS: &[&str] = &[];
impl UserInfoArgs {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserInfoArgs, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(UserInfoArgs {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserInfoArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserInfoArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UserInfoArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserInfoArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserInfoArgs", USER_INFO_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserInfoArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("UserInfoArgs", 0)?.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct UserInfoError {
    pub err: Option<ErrUnion>,
    pub error_message: String,
}

impl UserInfoError {
    pub fn with_err(mut self, value: ErrUnion) -> Self {
        self.err = Some(value);
        self
    }

    pub fn with_error_message(mut self, value: String) -> Self {
        self.error_message = value;
        self
    }
}

const USER_INFO_ERROR_FIELDS: &[&str] = &["err",
                                          "error_message"];
impl UserInfoError {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserInfoError, V::Error> {
        let mut field_err = None;
        let mut field_error_message = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "err" => {
                    if field_err.is_some() {
                        return Err(::serde::de::Error::duplicate_field("err"));
                    }
                    field_err = Some(map.next_value()?);
                }
                "error_message" => {
                    if field_error_message.is_some() {
                        return Err(::serde::de::Error::duplicate_field("error_message"));
                    }
                    field_error_message = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = UserInfoError {
            err: field_err,
            error_message: field_error_message.unwrap_or_default(),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        if let Some(val) = &self.err {
            s.serialize_field("err", val)?;
        }
        s.serialize_field("error_message", &self.error_message)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserInfoError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserInfoError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UserInfoError struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserInfoError::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserInfoError", USER_INFO_ERROR_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserInfoError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserInfoError", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct UserInfoResult {
    pub family_name: Option<String>,
    pub given_name: Option<String>,
    pub email: Option<String>,
    pub email_verified: Option<bool>,
    pub iss: String,
    pub sub: String,
}

impl UserInfoResult {
    pub fn with_family_name(mut self, value: String) -> Self {
        self.family_name = Some(value);
        self
    }

    pub fn with_given_name(mut self, value: String) -> Self {
        self.given_name = Some(value);
        self
    }

    pub fn with_email(mut self, value: String) -> Self {
        self.email = Some(value);
        self
    }

    pub fn with_email_verified(mut self, value: bool) -> Self {
        self.email_verified = Some(value);
        self
    }

    pub fn with_iss(mut self, value: String) -> Self {
        self.iss = value;
        self
    }

    pub fn with_sub(mut self, value: String) -> Self {
        self.sub = value;
        self
    }
}

const USER_INFO_RESULT_FIELDS: &[&str] = &["family_name",
                                           "given_name",
                                           "email",
                                           "email_verified",
                                           "iss",
                                           "sub"];
impl UserInfoResult {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserInfoResult, V::Error> {
        let mut field_family_name = None;
        let mut field_given_name = None;
        let mut field_email = None;
        let mut field_email_verified = None;
        let mut field_iss = None;
        let mut field_sub = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "family_name" => {
                    if field_family_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("family_name"));
                    }
                    field_family_name = Some(map.next_value()?);
                }
                "given_name" => {
                    if field_given_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("given_name"));
                    }
                    field_given_name = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "email_verified" => {
                    if field_email_verified.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email_verified"));
                    }
                    field_email_verified = Some(map.next_value()?);
                }
                "iss" => {
                    if field_iss.is_some() {
                        return Err(::serde::de::Error::duplicate_field("iss"));
                    }
                    field_iss = Some(map.next_value()?);
                }
                "sub" => {
                    if field_sub.is_some() {
                        return Err(::serde::de::Error::duplicate_field("sub"));
                    }
                    field_sub = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = UserInfoResult {
            family_name: field_family_name,
            given_name: field_given_name,
            email: field_email,
            email_verified: field_email_verified,
            iss: field_iss.unwrap_or_default(),
            sub: field_sub.unwrap_or_default(),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        if let Some(val) = &self.family_name {
            s.serialize_field("family_name", val)?;
        }
        if let Some(val) = &self.given_name {
            s.serialize_field("given_name", val)?;
        }
        if let Some(val) = &self.email {
            s.serialize_field("email", val)?;
        }
        if let Some(val) = &self.email_verified {
            s.serialize_field("email_verified", val)?;
        }
        s.serialize_field("iss", &self.iss)?;
        s.serialize_field("sub", &self.sub)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserInfoResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserInfoResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UserInfoResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserInfoResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserInfoResult", USER_INFO_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserInfoResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserInfoResult", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum ErrUnion {
    AuthError(AuthError),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ErrUnion {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ErrUnion;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a err_union structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                let value = match tag {
                    "auth_error" => {
                        match map.next_key()? {
                            Some("auth_error") => ErrUnion::AuthError(map.next_value()?),
                            None => return Err(de::Error::missing_field("auth_error")),
                            _ => return Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => ErrUnion::Other,
                };
                crate::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["auth_error",
                                    "other"];
        deserializer.deserialize_struct("err_union", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ErrUnion {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ErrUnion::AuthError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("err_union", 2)?;
                s.serialize_field(".tag", "auth_error")?;
                s.serialize_field("auth_error", x)?;
                s.end()
            }
            ErrUnion::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

