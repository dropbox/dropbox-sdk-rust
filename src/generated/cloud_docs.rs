// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::doc_markdown,
)]

//! Endpoints and datatypes for Cloud Docs.

/// Fetch the binary content of the requested document. This route requires Cloud Docs auth. Please
/// make a request to cloud_docs/authorize and supply that token in the Authorization header.
pub fn get_content(
    client: &dyn crate::client_trait::HttpClient,
    arg: &GetContentArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> crate::Result<Result<crate::client_trait::HttpRequestResult<()>, CloudDocsAccessError>> {
    crate::client_helpers::request_with_body(
        client,
        crate::client_trait::Endpoint::Content,
        crate::client_trait::Style::Download,
        "cloud_docs/get_content",
        arg,
        None,
        range_start,
        range_end)
}

/// Fetches metadata associated with a Cloud Doc and user. This route requires Cloud Docs auth.
/// Please make a request to cloud_docs/authorize and supply that token in the Authorization header.
pub fn get_metadata(
    client: &dyn crate::client_trait::HttpClient,
    arg: &GetMetadataArg,
) -> crate::Result<Result<GetMetadataResult, GetMetadataError>> {
    crate::client_helpers::request(
        client,
        crate::client_trait::Endpoint::Api,
        crate::client_trait::Style::Rpc,
        "cloud_docs/get_metadata",
        arg,
        None)
}

/// Lock a Cloud Doc. This route requires Cloud Docs auth. Please make a request to
/// cloud_docs/authorize and supply that token in the Authorization header.
pub fn lock(
    client: &dyn crate::client_trait::HttpClient,
    arg: &LockArg,
) -> crate::Result<Result<LockResult, LockingError>> {
    crate::client_helpers::request(
        client,
        crate::client_trait::Endpoint::Api,
        crate::client_trait::Style::Rpc,
        "cloud_docs/lock",
        arg,
        None)
}

/// Update the title of a Cloud Doc. This route requires Cloud Docs auth. Please make a request to
/// cloud_docs/authorize and supply that token in the Authorization header.
pub fn rename(
    client: &dyn crate::client_trait::HttpClient,
    arg: &RenameArg,
) -> crate::Result<Result<RenameResult, RenameError>> {
    crate::client_helpers::request(
        client,
        crate::client_trait::Endpoint::Api,
        crate::client_trait::Style::Rpc,
        "cloud_docs/rename",
        arg,
        None)
}

/// Unlock a Cloud Doc. This route requires Cloud Docs auth. Please make a request to
/// cloud_docs/authorize and supply that token in the Authorization header.
pub fn unlock(
    client: &dyn crate::client_trait::HttpClient,
    arg: &UnlockArg,
) -> crate::Result<Result<UnlockResult, LockingError>> {
    crate::client_helpers::request(
        client,
        crate::client_trait::Endpoint::Api,
        crate::client_trait::Style::Rpc,
        "cloud_docs/unlock",
        arg,
        None)
}

/// Update the contents of a Cloud Doc. This should be called for files with a max size of 150MB.
/// This route requires Cloud Docs auth. Please make a request to cloud_docs/authorize and supply
/// that token in the Authorization header.
pub fn update_content(
    client: &dyn crate::client_trait::HttpClient,
    arg: &UpdateContentArg,
    body: &[u8],
) -> crate::Result<Result<UpdateContentResult, UpdateContentError>> {
    crate::client_helpers::request(
        client,
        crate::client_trait::Endpoint::Content,
        crate::client_trait::Style::Upload,
        "cloud_docs/update_content",
        arg,
        Some(body))
}

#[derive(Debug)]
pub enum CloudDocsAccessError {
    /// The Cloud Doc ID is invalid.
    InvalidDocId,
    /// A Cloud Doc could not be found for the given ID.
    NotFound,
    /// Permission denied for the Cloud Doc with the given ID.
    PermissionDenied,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for CloudDocsAccessError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = CloudDocsAccessError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a CloudDocsAccessError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_doc_id" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(CloudDocsAccessError::InvalidDocId)
                    }
                    "not_found" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(CloudDocsAccessError::NotFound)
                    }
                    "permission_denied" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(CloudDocsAccessError::PermissionDenied)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(CloudDocsAccessError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_doc_id",
                                    "not_found",
                                    "permission_denied",
                                    "other"];
        deserializer.deserialize_struct("CloudDocsAccessError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for CloudDocsAccessError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            CloudDocsAccessError::InvalidDocId => {
                // unit
                let mut s = serializer.serialize_struct("CloudDocsAccessError", 1)?;
                s.serialize_field(".tag", "invalid_doc_id")?;
                s.end()
            }
            CloudDocsAccessError::NotFound => {
                // unit
                let mut s = serializer.serialize_struct("CloudDocsAccessError", 1)?;
                s.serialize_field(".tag", "not_found")?;
                s.end()
            }
            CloudDocsAccessError::PermissionDenied => {
                // unit
                let mut s = serializer.serialize_struct("CloudDocsAccessError", 1)?;
                s.serialize_field(".tag", "permission_denied")?;
                s.end()
            }
            CloudDocsAccessError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for CloudDocsAccessError {
    fn description(&self) -> &str {
        "CloudDocsAccessError"
    }
}

impl ::std::fmt::Display for CloudDocsAccessError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct Content {
    pub purpose: ContentPurpose,
    /// The key returned from an upload_additional_content response.
    pub content_key: String,
}

impl Content {
    pub fn new(purpose: ContentPurpose, content_key: String) -> Self {
        Content {
            purpose,
            content_key,
        }
    }

}

const CONTENT_FIELDS: &[&str] = &["purpose",
                                  "content_key"];
impl Content {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<Content, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<Content>, V::Error> {
        let mut field_purpose = None;
        let mut field_content_key = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "purpose" => {
                    if field_purpose.is_some() {
                        return Err(::serde::de::Error::duplicate_field("purpose"));
                    }
                    field_purpose = Some(map.next_value()?);
                }
                "content_key" => {
                    if field_content_key.is_some() {
                        return Err(::serde::de::Error::duplicate_field("content_key"));
                    }
                    field_content_key = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = Content {
            purpose: field_purpose.ok_or_else(|| ::serde::de::Error::missing_field("purpose"))?,
            content_key: field_content_key.ok_or_else(|| ::serde::de::Error::missing_field("content_key"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("purpose", &self.purpose)?;
        s.serialize_field("content_key", &self.content_key)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for Content {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = Content;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a Content struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                Content::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("Content", CONTENT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for Content {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("Content", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ContentPurpose {
    Search,
    Preview,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ContentPurpose {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ContentPurpose;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ContentPurpose structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "search" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ContentPurpose::Search)
                    }
                    "preview" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ContentPurpose::Preview)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(ContentPurpose::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["search",
                                    "preview",
                                    "other"];
        deserializer.deserialize_struct("ContentPurpose", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ContentPurpose {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ContentPurpose::Search => {
                // unit
                let mut s = serializer.serialize_struct("ContentPurpose", 1)?;
                s.serialize_field(".tag", "search")?;
                s.end()
            }
            ContentPurpose::Preview => {
                // unit
                let mut s = serializer.serialize_struct("ContentPurpose", 1)?;
                s.serialize_field(".tag", "preview")?;
                s.end()
            }
            ContentPurpose::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum GenericErrorTag {
    /// Invalid argument supplied.
    InvalidArgument,
    /// User is unauthenticated.
    Unauthenticated,
    /// User does not have access to the specified doc.
    PermissionDenied,
    /// Doc could not be found based on the supplied doc ID.
    DocNotFound,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GenericErrorTag {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GenericErrorTag;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GenericErrorTag structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_argument" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GenericErrorTag::InvalidArgument)
                    }
                    "unauthenticated" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GenericErrorTag::Unauthenticated)
                    }
                    "permission_denied" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GenericErrorTag::PermissionDenied)
                    }
                    "doc_not_found" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GenericErrorTag::DocNotFound)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GenericErrorTag::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_argument",
                                    "unauthenticated",
                                    "permission_denied",
                                    "doc_not_found",
                                    "other"];
        deserializer.deserialize_struct("GenericErrorTag", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GenericErrorTag {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GenericErrorTag::InvalidArgument => {
                // unit
                let mut s = serializer.serialize_struct("GenericErrorTag", 1)?;
                s.serialize_field(".tag", "invalid_argument")?;
                s.end()
            }
            GenericErrorTag::Unauthenticated => {
                // unit
                let mut s = serializer.serialize_struct("GenericErrorTag", 1)?;
                s.serialize_field(".tag", "unauthenticated")?;
                s.end()
            }
            GenericErrorTag::PermissionDenied => {
                // unit
                let mut s = serializer.serialize_struct("GenericErrorTag", 1)?;
                s.serialize_field(".tag", "permission_denied")?;
                s.end()
            }
            GenericErrorTag::DocNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GenericErrorTag", 1)?;
                s.serialize_field(".tag", "doc_not_found")?;
                s.end()
            }
            GenericErrorTag::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct GetContentArg {
    pub file_id: super::files::FileId,
}

impl GetContentArg {
    pub fn new(file_id: super::files::FileId) -> Self {
        GetContentArg {
            file_id,
        }
    }

}

const GET_CONTENT_ARG_FIELDS: &[&str] = &["file_id"];
impl GetContentArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GetContentArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GetContentArg>, V::Error> {
        let mut field_file_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GetContentArg {
            file_id: field_file_id.ok_or_else(|| ::serde::de::Error::missing_field("file_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetContentArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetContentArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GetContentArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetContentArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetContentArg", GET_CONTENT_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetContentArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetContentArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetMetadataArg {
    /// API ID ("id:...") associated with the Cloud Doc.
    pub file_id: String,
}

impl Default for GetMetadataArg {
    fn default() -> Self {
        GetMetadataArg {
            file_id: String::new(),
        }
    }
}

const GET_METADATA_ARG_FIELDS: &[&str] = &["file_id"];
impl GetMetadataArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GetMetadataArg, V::Error> {
        let mut field_file_id = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = GetMetadataArg {
            file_id: field_file_id.unwrap_or_else(String::new),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetMetadataArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetMetadataArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GetMetadataArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetMetadataArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetMetadataArg", GET_METADATA_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetMetadataArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetMetadataArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetMetadataError {
    pub get_metadata_error_tag: Option<GetMetadataErrorTagUnion>,
}

impl Default for GetMetadataError {
    fn default() -> Self {
        GetMetadataError {
            get_metadata_error_tag: None,
        }
    }
}

const GET_METADATA_ERROR_FIELDS: &[&str] = &["get_metadata_error_tag"];
impl GetMetadataError {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GetMetadataError, V::Error> {
        let mut field_get_metadata_error_tag = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "get_metadata_error_tag" => {
                    if field_get_metadata_error_tag.is_some() {
                        return Err(::serde::de::Error::duplicate_field("get_metadata_error_tag"));
                    }
                    field_get_metadata_error_tag = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = GetMetadataError {
            get_metadata_error_tag: field_get_metadata_error_tag,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("get_metadata_error_tag", &self.get_metadata_error_tag)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetMetadataError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetMetadataError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GetMetadataError struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetMetadataError::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetMetadataError", GET_METADATA_ERROR_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetMetadataError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetMetadataError", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GetMetadataResult {
    pub file_id: String,
    /// Title of the Cloud Doc without extension.
    pub title: String,
    /// MIME type of the Cloud Doc.
    pub mime_type: String,
    /// Opaque string representing the version of the document stored in Dropbox (only set for
    /// Dropbox-stored Documents).
    pub version: String,
    /// Application specific string representing the revision of a document (only set for App-stored
    /// Documents).
    pub provider_version: String,
    /// User identified by the auth token.
    pub user: Option<UserInfo>,
    /// true if the document is deleted or purged.
    pub is_deleted: bool,
    /// Actions that the user identified by the auth token can performn. This message will not be
    /// populated for deleted documents.
    pub user_permissions: Option<UserPermissions>,
}

impl Default for GetMetadataResult {
    fn default() -> Self {
        GetMetadataResult {
            file_id: String::new(),
            title: String::new(),
            mime_type: String::new(),
            version: String::new(),
            provider_version: String::new(),
            user: None,
            is_deleted: false,
            user_permissions: None,
        }
    }
}

const GET_METADATA_RESULT_FIELDS: &[&str] = &["file_id",
                                              "title",
                                              "mime_type",
                                              "version",
                                              "provider_version",
                                              "user",
                                              "is_deleted",
                                              "user_permissions"];
impl GetMetadataResult {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GetMetadataResult, V::Error> {
        let mut field_file_id = None;
        let mut field_title = None;
        let mut field_mime_type = None;
        let mut field_version = None;
        let mut field_provider_version = None;
        let mut field_user = None;
        let mut field_is_deleted = None;
        let mut field_user_permissions = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                "title" => {
                    if field_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("title"));
                    }
                    field_title = Some(map.next_value()?);
                }
                "mime_type" => {
                    if field_mime_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("mime_type"));
                    }
                    field_mime_type = Some(map.next_value()?);
                }
                "version" => {
                    if field_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("version"));
                    }
                    field_version = Some(map.next_value()?);
                }
                "provider_version" => {
                    if field_provider_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("provider_version"));
                    }
                    field_provider_version = Some(map.next_value()?);
                }
                "user" => {
                    if field_user.is_some() {
                        return Err(::serde::de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "is_deleted" => {
                    if field_is_deleted.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_deleted"));
                    }
                    field_is_deleted = Some(map.next_value()?);
                }
                "user_permissions" => {
                    if field_user_permissions.is_some() {
                        return Err(::serde::de::Error::duplicate_field("user_permissions"));
                    }
                    field_user_permissions = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = GetMetadataResult {
            file_id: field_file_id.unwrap_or_else(String::new),
            title: field_title.unwrap_or_else(String::new),
            mime_type: field_mime_type.unwrap_or_else(String::new),
            version: field_version.unwrap_or_else(String::new),
            provider_version: field_provider_version.unwrap_or_else(String::new),
            user: field_user,
            is_deleted: field_is_deleted.unwrap_or(false),
            user_permissions: field_user_permissions,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_id", &self.file_id)?;
        s.serialize_field("title", &self.title)?;
        s.serialize_field("mime_type", &self.mime_type)?;
        s.serialize_field("version", &self.version)?;
        s.serialize_field("provider_version", &self.provider_version)?;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("is_deleted", &self.is_deleted)?;
        s.serialize_field("user_permissions", &self.user_permissions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetMetadataResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetMetadataResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a GetMetadataResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetMetadataResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetMetadataResult", GET_METADATA_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetMetadataResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetMetadataResult", 8)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LockArg {
    /// The API ID ("id:...") associated with the Cloud Doc
    pub file_id: String,
}

impl Default for LockArg {
    fn default() -> Self {
        LockArg {
            file_id: String::new(),
        }
    }
}

const LOCK_ARG_FIELDS: &[&str] = &["file_id"];
impl LockArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LockArg, V::Error> {
        let mut field_file_id = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = LockArg {
            file_id: field_file_id.unwrap_or_else(String::new),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LockArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LockArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LockArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LockArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LockArg", LOCK_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LockArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LockArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LockResult {
    pub file_id: String,
    /// The timestamp after which the lock will expire, measured in seconds since 1970-01-01
    /// 00:00:00 UTC
    pub expires_at: i64,
}

impl Default for LockResult {
    fn default() -> Self {
        LockResult {
            file_id: String::new(),
            expires_at: 0,
        }
    }
}

const LOCK_RESULT_FIELDS: &[&str] = &["file_id",
                                      "expires_at"];
impl LockResult {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LockResult, V::Error> {
        let mut field_file_id = None;
        let mut field_expires_at = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                "expires_at" => {
                    if field_expires_at.is_some() {
                        return Err(::serde::de::Error::duplicate_field("expires_at"));
                    }
                    field_expires_at = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = LockResult {
            file_id: field_file_id.unwrap_or_else(String::new),
            expires_at: field_expires_at.unwrap_or(0),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_id", &self.file_id)?;
        s.serialize_field("expires_at", &self.expires_at)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LockResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LockResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LockResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LockResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LockResult", LOCK_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LockResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LockResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct LockingError {
    pub locking_error_tag: Option<LockingErrorTagUnion>,
}

impl Default for LockingError {
    fn default() -> Self {
        LockingError {
            locking_error_tag: None,
        }
    }
}

const LOCKING_ERROR_FIELDS: &[&str] = &["locking_error_tag"];
impl LockingError {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<LockingError, V::Error> {
        let mut field_locking_error_tag = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "locking_error_tag" => {
                    if field_locking_error_tag.is_some() {
                        return Err(::serde::de::Error::duplicate_field("locking_error_tag"));
                    }
                    field_locking_error_tag = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = LockingError {
            locking_error_tag: field_locking_error_tag,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("locking_error_tag", &self.locking_error_tag)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for LockingError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = LockingError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LockingError struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                LockingError::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("LockingError", LOCKING_ERROR_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for LockingError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("LockingError", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum LockingErrorTag {
    /// A lock on the doc is held by another editor
    Conflict,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LockingErrorTag {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LockingErrorTag;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a LockingErrorTag structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "conflict" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LockingErrorTag::Conflict)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LockingErrorTag::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["conflict",
                                    "other"];
        deserializer.deserialize_struct("LockingErrorTag", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LockingErrorTag {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LockingErrorTag::Conflict => {
                // unit
                let mut s = serializer.serialize_struct("LockingErrorTag", 1)?;
                s.serialize_field(".tag", "conflict")?;
                s.end()
            }
            LockingErrorTag::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct RenameArg {
    /// The API ID ("id:...") associated with the Cloud Doc
    pub file_id: String,
    /// The new title of the doc, excluding extension
    pub title: String,
}

impl Default for RenameArg {
    fn default() -> Self {
        RenameArg {
            file_id: String::new(),
            title: String::new(),
        }
    }
}

const RENAME_ARG_FIELDS: &[&str] = &["file_id",
                                     "title"];
impl RenameArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<RenameArg, V::Error> {
        let mut field_file_id = None;
        let mut field_title = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                "title" => {
                    if field_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("title"));
                    }
                    field_title = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = RenameArg {
            file_id: field_file_id.unwrap_or_else(String::new),
            title: field_title.unwrap_or_else(String::new),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_id", &self.file_id)?;
        s.serialize_field("title", &self.title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RenameArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RenameArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RenameArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RenameArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RenameArg", RENAME_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RenameArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RenameArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct RenameError {
    pub rename_error_tag: Option<RenameErrorTagUnion>,
}

impl Default for RenameError {
    fn default() -> Self {
        RenameError {
            rename_error_tag: None,
        }
    }
}

const RENAME_ERROR_FIELDS: &[&str] = &["rename_error_tag"];
impl RenameError {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<RenameError, V::Error> {
        let mut field_rename_error_tag = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "rename_error_tag" => {
                    if field_rename_error_tag.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rename_error_tag"));
                    }
                    field_rename_error_tag = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = RenameError {
            rename_error_tag: field_rename_error_tag,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("rename_error_tag", &self.rename_error_tag)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RenameError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RenameError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RenameError struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RenameError::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RenameError", RENAME_ERROR_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RenameError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RenameError", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum RenameErrorTag {
    /// The supplied title is invalid, e.g. the length of the title is longer than max length (255
    /// characters); the title contains illegal characters.
    InvalidTitle,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RenameErrorTag {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RenameErrorTag;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RenameErrorTag structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_title" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(RenameErrorTag::InvalidTitle)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(RenameErrorTag::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_title",
                                    "other"];
        deserializer.deserialize_struct("RenameErrorTag", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RenameErrorTag {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RenameErrorTag::InvalidTitle => {
                // unit
                let mut s = serializer.serialize_struct("RenameErrorTag", 1)?;
                s.serialize_field(".tag", "invalid_title")?;
                s.end()
            }
            RenameErrorTag::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct RenameResult {
    /// The updated title of the doc without extension, which could be different from the supplied
    /// title in the request because Dropbox may remove/replace charaters that are not supported in
    /// Dropbox Filesystem.
    pub title: String,
}

impl Default for RenameResult {
    fn default() -> Self {
        RenameResult {
            title: String::new(),
        }
    }
}

const RENAME_RESULT_FIELDS: &[&str] = &["title"];
impl RenameResult {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<RenameResult, V::Error> {
        let mut field_title = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "title" => {
                    if field_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("title"));
                    }
                    field_title = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = RenameResult {
            title: field_title.unwrap_or_else(String::new),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("title", &self.title)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RenameResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RenameResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RenameResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RenameResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RenameResult", RENAME_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RenameResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RenameResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct UnlockArg {
    /// The API ID ("id:...") associated with the Cloud Doc
    pub file_id: String,
}

impl Default for UnlockArg {
    fn default() -> Self {
        UnlockArg {
            file_id: String::new(),
        }
    }
}

const UNLOCK_ARG_FIELDS: &[&str] = &["file_id"];
impl UnlockArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UnlockArg, V::Error> {
        let mut field_file_id = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = UnlockArg {
            file_id: field_file_id.unwrap_or_else(String::new),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_id", &self.file_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UnlockArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UnlockArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UnlockArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UnlockArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UnlockArg", UNLOCK_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UnlockArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UnlockArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Empty message for unlock
#[derive(Debug)]
pub struct UnlockResult {
}

impl Default for UnlockResult {
    fn default() -> Self {
        UnlockResult {
        }
    }
}

const UNLOCK_RESULT_FIELDS: &[&str] = &[];
impl UnlockResult {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UnlockResult, V::Error> {
        // ignore any fields found; none are presently recognized
        crate::eat_json_fields(&mut map)?;
        Ok(UnlockResult {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UnlockResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UnlockResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UnlockResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UnlockResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UnlockResult", UNLOCK_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UnlockResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer.serialize_struct("UnlockResult", 0)?.end()
    }
}

#[derive(Debug)]
pub struct UpdateContentArg {
    pub file_id: super::files::FileId,
    /// A list of auth_tokens, one for each editor who made changes to the document since the last
    /// call to update_content.
    pub actor_tokens: Vec<String>,
    /// Currently, this will always be empty until we implement upload_additional_content.
    pub additional_contents: Option<Vec<Content>>,
}

impl UpdateContentArg {
    pub fn new(file_id: super::files::FileId, actor_tokens: Vec<String>) -> Self {
        UpdateContentArg {
            file_id,
            actor_tokens,
            additional_contents: None,
        }
    }

    pub fn with_additional_contents(mut self, value: Option<Vec<Content>>) -> Self {
        self.additional_contents = value;
        self
    }

}

const UPDATE_CONTENT_ARG_FIELDS: &[&str] = &["file_id",
                                             "actor_tokens",
                                             "additional_contents"];
impl UpdateContentArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<UpdateContentArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<UpdateContentArg>, V::Error> {
        let mut field_file_id = None;
        let mut field_actor_tokens = None;
        let mut field_additional_contents = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "file_id" => {
                    if field_file_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("file_id"));
                    }
                    field_file_id = Some(map.next_value()?);
                }
                "actor_tokens" => {
                    if field_actor_tokens.is_some() {
                        return Err(::serde::de::Error::duplicate_field("actor_tokens"));
                    }
                    field_actor_tokens = Some(map.next_value()?);
                }
                "additional_contents" => {
                    if field_additional_contents.is_some() {
                        return Err(::serde::de::Error::duplicate_field("additional_contents"));
                    }
                    field_additional_contents = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = UpdateContentArg {
            file_id: field_file_id.ok_or_else(|| ::serde::de::Error::missing_field("file_id"))?,
            actor_tokens: field_actor_tokens.ok_or_else(|| ::serde::de::Error::missing_field("actor_tokens"))?,
            additional_contents: field_additional_contents,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("file_id", &self.file_id)?;
        s.serialize_field("actor_tokens", &self.actor_tokens)?;
        s.serialize_field("additional_contents", &self.additional_contents)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateContentArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UpdateContentArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UpdateContentArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UpdateContentArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UpdateContentArg", UPDATE_CONTENT_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateContentArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UpdateContentArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum UpdateContentError {
    /// The Cloud Doc ID is invalid.
    InvalidDocId,
    /// A Cloud Doc could not be found for the given ID.
    NotFound,
    /// Permission denied for the Cloud Doc with the given ID.
    PermissionDenied,
    /// Upload payload exceeds maximum allowed size of 150MB.
    UploadSizeTooLarge,
    /// A lock on the document identified by path_or_id is held by another editor.
    Conflict,
    /// A lock is not held on the document identified by path_or_id. Acquire lock before uploading
    /// content for the document.
    Unlocked,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateContentError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UpdateContentError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UpdateContentError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_doc_id" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(UpdateContentError::InvalidDocId)
                    }
                    "not_found" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(UpdateContentError::NotFound)
                    }
                    "permission_denied" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(UpdateContentError::PermissionDenied)
                    }
                    "upload_size_too_large" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(UpdateContentError::UploadSizeTooLarge)
                    }
                    "conflict" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(UpdateContentError::Conflict)
                    }
                    "unlocked" => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(UpdateContentError::Unlocked)
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(UpdateContentError::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_doc_id",
                                    "not_found",
                                    "permission_denied",
                                    "other",
                                    "upload_size_too_large",
                                    "conflict",
                                    "unlocked"];
        deserializer.deserialize_struct("UpdateContentError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateContentError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UpdateContentError::InvalidDocId => {
                // unit
                let mut s = serializer.serialize_struct("UpdateContentError", 1)?;
                s.serialize_field(".tag", "invalid_doc_id")?;
                s.end()
            }
            UpdateContentError::NotFound => {
                // unit
                let mut s = serializer.serialize_struct("UpdateContentError", 1)?;
                s.serialize_field(".tag", "not_found")?;
                s.end()
            }
            UpdateContentError::PermissionDenied => {
                // unit
                let mut s = serializer.serialize_struct("UpdateContentError", 1)?;
                s.serialize_field(".tag", "permission_denied")?;
                s.end()
            }
            UpdateContentError::UploadSizeTooLarge => {
                // unit
                let mut s = serializer.serialize_struct("UpdateContentError", 1)?;
                s.serialize_field(".tag", "upload_size_too_large")?;
                s.end()
            }
            UpdateContentError::Conflict => {
                // unit
                let mut s = serializer.serialize_struct("UpdateContentError", 1)?;
                s.serialize_field(".tag", "conflict")?;
                s.end()
            }
            UpdateContentError::Unlocked => {
                // unit
                let mut s = serializer.serialize_struct("UpdateContentError", 1)?;
                s.serialize_field(".tag", "unlocked")?;
                s.end()
            }
            UpdateContentError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for UpdateContentError {
    fn description(&self) -> &str {
        "UpdateContentError"
    }
}

impl ::std::fmt::Display for UpdateContentError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct UpdateContentResult {
    /// Version of the document stored in Dropbox.
    pub version: String,
}

impl UpdateContentResult {
    pub fn new(version: String) -> Self {
        UpdateContentResult {
            version,
        }
    }

}

const UPDATE_CONTENT_RESULT_FIELDS: &[&str] = &["version"];
impl UpdateContentResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<UpdateContentResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<UpdateContentResult>, V::Error> {
        let mut field_version = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "version" => {
                    if field_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("version"));
                    }
                    field_version = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = UpdateContentResult {
            version: field_version.ok_or_else(|| ::serde::de::Error::missing_field("version"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("version", &self.version)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UpdateContentResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UpdateContentResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UpdateContentResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UpdateContentResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UpdateContentResult", UPDATE_CONTENT_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UpdateContentResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UpdateContentResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct UserInfo {
    /// ID associated with the user.
    pub id: String,
    /// Email associated with the user.
    pub email: String,
}

impl Default for UserInfo {
    fn default() -> Self {
        UserInfo {
            id: String::new(),
            email: String::new(),
        }
    }
}

const USER_INFO_FIELDS: &[&str] = &["id",
                                    "email"];
impl UserInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserInfo, V::Error> {
        let mut field_id = None;
        let mut field_email = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "id" => {
                    if field_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("id"));
                    }
                    field_id = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = UserInfo {
            id: field_id.unwrap_or_else(String::new),
            email: field_email.unwrap_or_else(String::new),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("id", &self.id)?;
        s.serialize_field("email", &self.email)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UserInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserInfo", USER_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct UserPermissions {
    /// true if the user can edit the content of this document
    pub can_edit: bool,
    /// true if the user can edit the title of this document
    pub can_rename: bool,
    /// true if the user can comment on this document
    pub can_comment: bool,
    /// true if the user can download the contents of this document. currently always true if the
    /// user has view access to the document.
    pub can_download: bool,
}

impl Default for UserPermissions {
    fn default() -> Self {
        UserPermissions {
            can_edit: false,
            can_rename: false,
            can_comment: false,
            can_download: false,
        }
    }
}

const USER_PERMISSIONS_FIELDS: &[&str] = &["can_edit",
                                           "can_rename",
                                           "can_comment",
                                           "can_download"];
impl UserPermissions {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<UserPermissions, V::Error> {
        let mut field_can_edit = None;
        let mut field_can_rename = None;
        let mut field_can_comment = None;
        let mut field_can_download = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "can_edit" => {
                    if field_can_edit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("can_edit"));
                    }
                    field_can_edit = Some(map.next_value()?);
                }
                "can_rename" => {
                    if field_can_rename.is_some() {
                        return Err(::serde::de::Error::duplicate_field("can_rename"));
                    }
                    field_can_rename = Some(map.next_value()?);
                }
                "can_comment" => {
                    if field_can_comment.is_some() {
                        return Err(::serde::de::Error::duplicate_field("can_comment"));
                    }
                    field_can_comment = Some(map.next_value()?);
                }
                "can_download" => {
                    if field_can_download.is_some() {
                        return Err(::serde::de::Error::duplicate_field("can_download"));
                    }
                    field_can_download = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = UserPermissions {
            can_edit: field_can_edit.unwrap_or(false),
            can_rename: field_can_rename.unwrap_or(false),
            can_comment: field_can_comment.unwrap_or(false),
            can_download: field_can_download.unwrap_or(false),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("can_edit", &self.can_edit)?;
        s.serialize_field("can_rename", &self.can_rename)?;
        s.serialize_field("can_comment", &self.can_comment)?;
        s.serialize_field("can_download", &self.can_download)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserPermissions {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserPermissions;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a UserPermissions struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserPermissions::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserPermissions", USER_PERMISSIONS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserPermissions {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserPermissions", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GetMetadataErrorTagUnion {
    GenericError(GenericErrorTag),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GetMetadataErrorTagUnion {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GetMetadataErrorTagUnion;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a get_metadata_error_tag_union structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "generic_error" => {
                        match map.next_key()? {
                            Some("generic_error") => Ok(GetMetadataErrorTagUnion::GenericError(map.next_value()?)),
                            None => Err(de::Error::missing_field("generic_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(GetMetadataErrorTagUnion::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["generic_error",
                                    "other"];
        deserializer.deserialize_struct("get_metadata_error_tag_union", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GetMetadataErrorTagUnion {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GetMetadataErrorTagUnion::GenericError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("get_metadata_error_tag_union", 2)?;
                s.serialize_field(".tag", "generic_error")?;
                s.serialize_field("generic_error", x)?;
                s.end()
            }
            GetMetadataErrorTagUnion::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum LockingErrorTagUnion {
    LockingError(LockingErrorTag),
    GenericError(GenericErrorTag),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for LockingErrorTagUnion {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = LockingErrorTagUnion;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a locking_error_tag_union structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "locking_error" => {
                        match map.next_key()? {
                            Some("locking_error") => Ok(LockingErrorTagUnion::LockingError(map.next_value()?)),
                            None => Err(de::Error::missing_field("locking_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "generic_error" => {
                        match map.next_key()? {
                            Some("generic_error") => Ok(LockingErrorTagUnion::GenericError(map.next_value()?)),
                            None => Err(de::Error::missing_field("generic_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(LockingErrorTagUnion::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["locking_error",
                                    "generic_error",
                                    "other"];
        deserializer.deserialize_struct("locking_error_tag_union", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for LockingErrorTagUnion {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            LockingErrorTagUnion::LockingError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("locking_error_tag_union", 2)?;
                s.serialize_field(".tag", "locking_error")?;
                s.serialize_field("locking_error", x)?;
                s.end()
            }
            LockingErrorTagUnion::GenericError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("locking_error_tag_union", 2)?;
                s.serialize_field(".tag", "generic_error")?;
                s.serialize_field("generic_error", x)?;
                s.end()
            }
            LockingErrorTagUnion::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum RenameErrorTagUnion {
    RenameError(RenameErrorTag),
    GenericError(GenericErrorTag),
    LockingError(LockingErrorTag),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RenameErrorTagUnion {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RenameErrorTagUnion;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a rename_error_tag_union structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "rename_error" => {
                        match map.next_key()? {
                            Some("rename_error") => Ok(RenameErrorTagUnion::RenameError(map.next_value()?)),
                            None => Err(de::Error::missing_field("rename_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "generic_error" => {
                        match map.next_key()? {
                            Some("generic_error") => Ok(RenameErrorTagUnion::GenericError(map.next_value()?)),
                            None => Err(de::Error::missing_field("generic_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "locking_error" => {
                        match map.next_key()? {
                            Some("locking_error") => Ok(RenameErrorTagUnion::LockingError(map.next_value()?)),
                            None => Err(de::Error::missing_field("locking_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => {
                        crate::eat_json_fields(&mut map)?;
                        Ok(RenameErrorTagUnion::Other)
                    }
                }
            }
        }
        const VARIANTS: &[&str] = &["rename_error",
                                    "generic_error",
                                    "locking_error",
                                    "other"];
        deserializer.deserialize_struct("rename_error_tag_union", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RenameErrorTagUnion {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RenameErrorTagUnion::RenameError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("rename_error_tag_union", 2)?;
                s.serialize_field(".tag", "rename_error")?;
                s.serialize_field("rename_error", x)?;
                s.end()
            }
            RenameErrorTagUnion::GenericError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("rename_error_tag_union", 2)?;
                s.serialize_field(".tag", "generic_error")?;
                s.serialize_field("generic_error", x)?;
                s.end()
            }
            RenameErrorTagUnion::LockingError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("rename_error_tag_union", 2)?;
                s.serialize_field(".tag", "locking_error")?;
                s.serialize_field("locking_error", x)?;
                s.end()
            }
            RenameErrorTagUnion::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

