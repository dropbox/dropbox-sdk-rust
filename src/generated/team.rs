// DO NOT EDIT
// This file was generated by Stone

#![allow(
    unknown_lints,  // keep rustc from complaining about clippy lints
    too_many_arguments,
    large_enum_variant,
    doc_markdown,
)]

pub type GroupsGetInfoResult = Vec<GroupsGetInfoItem>;
pub type MembersGetInfoResult = Vec<MembersGetInfoItem>;
pub type NumberPerDay = Vec<Option<u64>>;
pub type UserQuota = u32;

/// List all device sessions of a team's member.
pub fn devices_list_member_devices(
    client: &::client_trait::HttpClient,
    arg: &ListMemberDevicesArg,
) -> ::Result<Result<ListMemberDevicesResult, ListMemberDevicesError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/devices/list_member_devices",
        arg,
        None)
}

/// List all device sessions of a team.
pub fn devices_list_members_devices(
    client: &::client_trait::HttpClient,
    arg: &ListMembersDevicesArg,
) -> ::Result<Result<ListMembersDevicesResult, ListMembersDevicesError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/devices/list_members_devices",
        arg,
        None)
}

/// List all device sessions of a team.
pub fn devices_list_team_devices(
    client: &::client_trait::HttpClient,
    arg: &ListTeamDevicesArg,
) -> ::Result<Result<ListTeamDevicesResult, ListTeamDevicesError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/devices/list_team_devices",
        arg,
        None)
}

/// Revoke a device session of a team's member.
pub fn devices_revoke_device_session(
    client: &::client_trait::HttpClient,
    arg: &RevokeDeviceSessionArg,
) -> ::Result<Result<(), RevokeDeviceSessionError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/devices/revoke_device_session",
        arg,
        None)
}

/// Revoke a list of device sessions of team members.
pub fn devices_revoke_device_session_batch(
    client: &::client_trait::HttpClient,
    arg: &RevokeDeviceSessionBatchArg,
) -> ::Result<Result<RevokeDeviceSessionBatchResult, RevokeDeviceSessionBatchError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/devices/revoke_device_session_batch",
        arg,
        None)
}

/// Get the values for one or more featues. This route allows you to check your account's capability
/// for what feature you can access or what value you have for certain features. Permission : Team
/// information.
pub fn features_get_values(
    client: &::client_trait::HttpClient,
    arg: &FeaturesGetValuesBatchArg,
) -> ::Result<Result<FeaturesGetValuesBatchResult, FeaturesGetValuesBatchError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/features/get_values",
        arg,
        None)
}

/// Retrieves information about a team.
pub fn get_info(
    client: &::client_trait::HttpClient,
    arg: &(),
) -> ::Result<Result<TeamGetInfoResult, ()>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "team/get_info", arg, None)
}

/// Creates a new, empty group, with a requested name. Permission : Team member management.
pub fn groups_create(
    client: &::client_trait::HttpClient,
    arg: &GroupCreateArg,
) -> ::Result<Result<GroupFullInfo, GroupCreateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/create",
        arg,
        None)
}

/// Deletes a group. The group is deleted immediately. However the revoking of group-owned resources
/// may take additional time. Use the [`groups_job_status_get()`](groups_job_status_get) to
/// determine whether this process has completed. Permission : Team member management.
pub fn groups_delete(
    client: &::client_trait::HttpClient,
    arg: &GroupSelector,
) -> ::Result<Result<super::async::LaunchEmptyResult, GroupDeleteError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/delete",
        arg,
        None)
}

/// Retrieves information about one or more groups. Note that the optional field
/// [`GroupFullInfo::members`](GroupFullInfo) is not returned for system-managed groups. Permission
/// : Team Information.
pub fn groups_get_info(
    client: &::client_trait::HttpClient,
    arg: &GroupsSelector,
) -> ::Result<Result<GroupsGetInfoResult, GroupsGetInfoError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/get_info",
        arg,
        None)
}

/// Once an async_job_id is returned from [`groups_delete()`](groups_delete),
/// [`groups_members_add()`](groups_members_add) , or
/// [`groups_members_remove()`](groups_members_remove) use this method to poll the status of
/// granting/revoking group members' access to group-owned resources. Permission : Team member
/// management.
pub fn groups_job_status_get(
    client: &::client_trait::HttpClient,
    arg: &super::async::PollArg,
) -> ::Result<Result<super::async::PollEmptyResult, GroupsPollError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/job_status/get",
        arg,
        None)
}

/// Lists groups on a team. Permission : Team Information.
pub fn groups_list(
    client: &::client_trait::HttpClient,
    arg: &GroupsListArg,
) -> ::Result<Result<GroupsListResult, ()>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "team/groups/list", arg, None)
}

/// Once a cursor has been retrieved from [`groups_list()`](groups_list), use this to paginate
/// through all groups. Permission : Team Information.
pub fn groups_list_continue(
    client: &::client_trait::HttpClient,
    arg: &GroupsListContinueArg,
) -> ::Result<Result<GroupsListResult, GroupsListContinueError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/list/continue",
        arg,
        None)
}

/// Adds members to a group. The members are added immediately. However the granting of group-owned
/// resources may take additional time. Use the [`groups_job_status_get()`](groups_job_status_get)
/// to determine whether this process has completed. Permission : Team member management.
pub fn groups_members_add(
    client: &::client_trait::HttpClient,
    arg: &GroupMembersAddArg,
) -> ::Result<Result<GroupMembersChangeResult, GroupMembersAddError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/members/add",
        arg,
        None)
}

/// Lists members of a group. Permission : Team Information.
pub fn groups_members_list(
    client: &::client_trait::HttpClient,
    arg: &GroupsMembersListArg,
) -> ::Result<Result<GroupsMembersListResult, GroupSelectorError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/members/list",
        arg,
        None)
}

/// Once a cursor has been retrieved from [`groups_members_list()`](groups_members_list), use this
/// to paginate through all members of the group. Permission : Team information.
pub fn groups_members_list_continue(
    client: &::client_trait::HttpClient,
    arg: &GroupsMembersListContinueArg,
) -> ::Result<Result<GroupsMembersListResult, GroupsMembersListContinueError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/members/list/continue",
        arg,
        None)
}

/// Removes members from a group. The members are removed immediately. However the revoking of
/// group-owned resources may take additional time. Use the
/// [`groups_job_status_get()`](groups_job_status_get) to determine whether this process has
/// completed. This method permits removing the only owner of a group, even in cases where this is
/// not possible via the web client. Permission : Team member management.
pub fn groups_members_remove(
    client: &::client_trait::HttpClient,
    arg: &GroupMembersRemoveArg,
) -> ::Result<Result<GroupMembersChangeResult, GroupMembersRemoveError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/members/remove",
        arg,
        None)
}

/// Sets a member's access type in a group. Permission : Team member management.
pub fn groups_members_set_access_type(
    client: &::client_trait::HttpClient,
    arg: &GroupMembersSetAccessTypeArg,
) -> ::Result<Result<GroupsGetInfoResult, GroupMemberSetAccessTypeError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/members/set_access_type",
        arg,
        None)
}

/// Updates a group's name and/or external ID. Permission : Team member management.
pub fn groups_update(
    client: &::client_trait::HttpClient,
    arg: &GroupUpdateArgs,
) -> ::Result<Result<GroupFullInfo, GroupUpdateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/groups/update",
        arg,
        None)
}

/// List all linked applications of the team member. Note, this endpoint does not list any
/// team-linked applications.
pub fn linked_apps_list_member_linked_apps(
    client: &::client_trait::HttpClient,
    arg: &ListMemberAppsArg,
) -> ::Result<Result<ListMemberAppsResult, ListMemberAppsError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/linked_apps/list_member_linked_apps",
        arg,
        None)
}

/// List all applications linked to the team members' accounts. Note, this endpoint does not list
/// any team-linked applications.
pub fn linked_apps_list_members_linked_apps(
    client: &::client_trait::HttpClient,
    arg: &ListMembersAppsArg,
) -> ::Result<Result<ListMembersAppsResult, ListMembersAppsError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/linked_apps/list_members_linked_apps",
        arg,
        None)
}

/// List all applications linked to the team members' accounts. Note, this endpoint doesn't list any
/// team-linked applications.
pub fn linked_apps_list_team_linked_apps(
    client: &::client_trait::HttpClient,
    arg: &ListTeamAppsArg,
) -> ::Result<Result<ListTeamAppsResult, ListTeamAppsError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/linked_apps/list_team_linked_apps",
        arg,
        None)
}

/// Revoke a linked application of the team member.
pub fn linked_apps_revoke_linked_app(
    client: &::client_trait::HttpClient,
    arg: &RevokeLinkedApiAppArg,
) -> ::Result<Result<(), RevokeLinkedAppError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/linked_apps/revoke_linked_app",
        arg,
        None)
}

/// Revoke a list of linked applications of the team members.
pub fn linked_apps_revoke_linked_app_batch(
    client: &::client_trait::HttpClient,
    arg: &RevokeLinkedApiAppBatchArg,
) -> ::Result<Result<RevokeLinkedAppBatchResult, RevokeLinkedAppBatchError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/linked_apps/revoke_linked_app_batch",
        arg,
        None)
}

/// Add users to member space limits excluded users list.
pub fn member_space_limits_excluded_users_add(
    client: &::client_trait::HttpClient,
    arg: &ExcludedUsersUpdateArg,
) -> ::Result<Result<ExcludedUsersUpdateResult, ExcludedUsersUpdateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/member_space_limits/excluded_users/add",
        arg,
        None)
}

/// List member space limits excluded users.
pub fn member_space_limits_excluded_users_list(
    client: &::client_trait::HttpClient,
    arg: &ExcludedUsersListArg,
) -> ::Result<Result<ExcludedUsersListResult, ExcludedUsersListError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/member_space_limits/excluded_users/list",
        arg,
        None)
}

/// Continue listing member space limits excluded users.
pub fn member_space_limits_excluded_users_list_continue(
    client: &::client_trait::HttpClient,
    arg: &ExcludedUsersListContinueArg,
) -> ::Result<Result<ExcludedUsersListResult, ExcludedUsersListContinueError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/member_space_limits/excluded_users/list/continue",
        arg,
        None)
}

/// Remove users from member space limits excluded users list.
pub fn member_space_limits_excluded_users_remove(
    client: &::client_trait::HttpClient,
    arg: &ExcludedUsersUpdateArg,
) -> ::Result<Result<ExcludedUsersUpdateResult, ExcludedUsersUpdateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/member_space_limits/excluded_users/remove",
        arg,
        None)
}

/// Get users custom quota. Returns none as the custom quota if none was set. A maximum of 1000
/// members can be specified in a single call.
pub fn member_space_limits_get_custom_quota(
    client: &::client_trait::HttpClient,
    arg: &CustomQuotaUsersArg,
) -> ::Result<Result<Vec<CustomQuotaResult>, CustomQuotaError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/member_space_limits/get_custom_quota",
        arg,
        None)
}

/// Remove users custom quota. A maximum of 1000 members can be specified in a single call.
pub fn member_space_limits_remove_custom_quota(
    client: &::client_trait::HttpClient,
    arg: &CustomQuotaUsersArg,
) -> ::Result<Result<Vec<RemoveCustomQuotaResult>, CustomQuotaError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/member_space_limits/remove_custom_quota",
        arg,
        None)
}

/// Set users custom quota. Custom quota has to be at least 15GB. A maximum of 1000 members can be
/// specified in a single call.
pub fn member_space_limits_set_custom_quota(
    client: &::client_trait::HttpClient,
    arg: &SetCustomQuotaArg,
) -> ::Result<Result<Vec<CustomQuotaResult>, SetCustomQuotaError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/member_space_limits/set_custom_quota",
        arg,
        None)
}

/// Adds members to a team. Permission : Team member management A maximum of 20 members can be
/// specified in a single call. If no Dropbox account exists with the email address specified, a new
/// Dropbox account will be created with the given email address, and that account will be invited
/// to the team. If a personal Dropbox account exists with the email address specified in the call,
/// this call will create a placeholder Dropbox account for the user on the team and send an email
/// inviting the user to migrate their existing personal account onto the team. Team member
/// management apps are required to set an initial given_name and surname for a user to use in the
/// team invitation and for 'Perform as team member' actions taken on the user before they become
/// 'active'.
pub fn members_add(
    client: &::client_trait::HttpClient,
    arg: &MembersAddArg,
) -> ::Result<Result<MembersAddLaunch, ()>> {
    ::client_helpers::request(client, ::client_trait::Endpoint::Api, "team/members/add", arg, None)
}

/// Once an async_job_id is returned from [`members_add()`](members_add) , use this to poll the
/// status of the asynchronous request. Permission : Team member management.
pub fn members_add_job_status_get(
    client: &::client_trait::HttpClient,
    arg: &super::async::PollArg,
) -> ::Result<Result<MembersAddJobStatus, super::async::PollError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/add/job_status/get",
        arg,
        None)
}

/// Returns information about multiple team members. Permission : Team information This endpoint
/// will return [`MembersGetInfoItem::IdNotFound`](MembersGetInfoItem::IdNotFound), for IDs (or
/// emails) that cannot be matched to a valid team member.
pub fn members_get_info(
    client: &::client_trait::HttpClient,
    arg: &MembersGetInfoArgs,
) -> ::Result<Result<MembersGetInfoResult, MembersGetInfoError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/get_info",
        arg,
        None)
}

/// Lists members of a team. Permission : Team information.
pub fn members_list(
    client: &::client_trait::HttpClient,
    arg: &MembersListArg,
) -> ::Result<Result<MembersListResult, MembersListError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/list",
        arg,
        None)
}

/// Once a cursor has been retrieved from [`members_list()`](members_list), use this to paginate
/// through all team members. Permission : Team information.
pub fn members_list_continue(
    client: &::client_trait::HttpClient,
    arg: &MembersListContinueArg,
) -> ::Result<Result<MembersListResult, MembersListContinueError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/list/continue",
        arg,
        None)
}

/// Recover a deleted member. Permission : Team member management Exactly one of team_member_id,
/// email, or external_id must be provided to identify the user account.
pub fn members_recover(
    client: &::client_trait::HttpClient,
    arg: &MembersRecoverArg,
) -> ::Result<Result<(), MembersRecoverError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/recover",
        arg,
        None)
}

/// Removes a member from a team. Permission : Team member management Exactly one of team_member_id,
/// email, or external_id must be provided to identify the user account. Accounts can be recovered
/// via [`members_recover()`](members_recover) for a 7 day period or until the account has been
/// permanently deleted or transferred to another account (whichever comes first). Calling
/// [`members_add()`](members_add) while a user is still recoverable on your team will return with
/// [`MemberAddResult::UserAlreadyOnTeam`](MemberAddResult::UserAlreadyOnTeam). Accounts can have
/// their files transferred via the admin console for a limited time, based on the version history
/// length associated with the team (120 days for most teams). This endpoint may initiate an
/// asynchronous job. To obtain the final result of the job, the client should periodically poll
/// [`members_remove_job_status_get()`](members_remove_job_status_get).
pub fn members_remove(
    client: &::client_trait::HttpClient,
    arg: &MembersRemoveArg,
) -> ::Result<Result<super::async::LaunchEmptyResult, MembersRemoveError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/remove",
        arg,
        None)
}

/// Once an async_job_id is returned from [`members_remove()`](members_remove) , use this to poll
/// the status of the asynchronous request. Permission : Team member management.
pub fn members_remove_job_status_get(
    client: &::client_trait::HttpClient,
    arg: &super::async::PollArg,
) -> ::Result<Result<super::async::PollEmptyResult, super::async::PollError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/remove/job_status/get",
        arg,
        None)
}

/// Sends welcome email to pending team member. Permission : Team member management Exactly one of
/// team_member_id, email, or external_id must be provided to identify the user account. No-op if
/// team member is not pending.
pub fn members_send_welcome_email(
    client: &::client_trait::HttpClient,
    arg: &UserSelectorArg,
) -> ::Result<Result<(), MembersSendWelcomeError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/send_welcome_email",
        arg,
        None)
}

/// Updates a team member's permissions. Permission : Team member management.
pub fn members_set_admin_permissions(
    client: &::client_trait::HttpClient,
    arg: &MembersSetPermissionsArg,
) -> ::Result<Result<MembersSetPermissionsResult, MembersSetPermissionsError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/set_admin_permissions",
        arg,
        None)
}

/// Updates a team member's profile. Permission : Team member management.
pub fn members_set_profile(
    client: &::client_trait::HttpClient,
    arg: &MembersSetProfileArg,
) -> ::Result<Result<TeamMemberInfo, MembersSetProfileError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/set_profile",
        arg,
        None)
}

/// Suspend a member from a team. Permission : Team member management Exactly one of team_member_id,
/// email, or external_id must be provided to identify the user account.
pub fn members_suspend(
    client: &::client_trait::HttpClient,
    arg: &MembersDeactivateArg,
) -> ::Result<Result<(), MembersSuspendError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/suspend",
        arg,
        None)
}

/// Unsuspend a member from a team. Permission : Team member management Exactly one of
/// team_member_id, email, or external_id must be provided to identify the user account.
pub fn members_unsuspend(
    client: &::client_trait::HttpClient,
    arg: &MembersUnsuspendArg,
) -> ::Result<Result<(), MembersUnsuspendError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/members/unsuspend",
        arg,
        None)
}

/// Returns a list of all team-accessible namespaces. This list includes team folders, shared
/// folders containing team members, team members' home namespaces, and team members' app folders.
/// Home namespaces and app folders are always owned by this team or members of the team, but shared
/// folders may be owned by other users or other teams. Duplicates may occur in the list.
pub fn namespaces_list(
    client: &::client_trait::HttpClient,
    arg: &TeamNamespacesListArg,
) -> ::Result<Result<TeamNamespacesListResult, ()>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/namespaces/list",
        arg,
        None)
}

/// Once a cursor has been retrieved from [`namespaces_list()`](namespaces_list), use this to
/// paginate through all team-accessible namespaces. Duplicates may occur in the list.
pub fn namespaces_list_continue(
    client: &::client_trait::HttpClient,
    arg: &TeamNamespacesListContinueArg,
) -> ::Result<Result<TeamNamespacesListResult, TeamNamespacesListContinueError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/namespaces/list/continue",
        arg,
        None)
}

pub fn properties_template_add(
    client: &::client_trait::HttpClient,
    arg: &super::file_properties::AddTemplateArg,
) -> ::Result<Result<super::file_properties::AddTemplateResult, super::file_properties::ModifyTemplateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/properties/template/add",
        arg,
        None)
}

pub fn properties_template_get(
    client: &::client_trait::HttpClient,
    arg: &super::file_properties::GetTemplateArg,
) -> ::Result<Result<super::file_properties::GetTemplateResult, super::file_properties::TemplateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/properties/template/get",
        arg,
        None)
}

pub fn properties_template_list(
    client: &::client_trait::HttpClient,
    arg: &(),
) -> ::Result<Result<super::file_properties::ListTemplateResult, super::file_properties::TemplateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/properties/template/list",
        arg,
        None)
}

pub fn properties_template_update(
    client: &::client_trait::HttpClient,
    arg: &super::file_properties::UpdateTemplateArg,
) -> ::Result<Result<super::file_properties::UpdateTemplateResult, super::file_properties::ModifyTemplateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/properties/template/update",
        arg,
        None)
}

/// Retrieves reporting data about a team's user activity.
pub fn reports_get_activity(
    client: &::client_trait::HttpClient,
    arg: &DateRange,
) -> ::Result<Result<GetActivityReport, DateRangeError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/reports/get_activity",
        arg,
        None)
}

/// Retrieves reporting data about a team's linked devices.
pub fn reports_get_devices(
    client: &::client_trait::HttpClient,
    arg: &DateRange,
) -> ::Result<Result<GetDevicesReport, DateRangeError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/reports/get_devices",
        arg,
        None)
}

/// Retrieves reporting data about a team's membership.
pub fn reports_get_membership(
    client: &::client_trait::HttpClient,
    arg: &DateRange,
) -> ::Result<Result<GetMembershipReport, DateRangeError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/reports/get_membership",
        arg,
        None)
}

/// Retrieves reporting data about a team's storage usage.
pub fn reports_get_storage(
    client: &::client_trait::HttpClient,
    arg: &DateRange,
) -> ::Result<Result<GetStorageReport, DateRangeError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/reports/get_storage",
        arg,
        None)
}

/// Sets an archived team folder's status to active. Permission : Team member file access.
pub fn team_folder_activate(
    client: &::client_trait::HttpClient,
    arg: &TeamFolderIdArg,
) -> ::Result<Result<TeamFolderMetadata, TeamFolderActivateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/activate",
        arg,
        None)
}

/// Sets an active team folder's status to archived and removes all folder and file members.
/// Permission : Team member file access.
pub fn team_folder_archive(
    client: &::client_trait::HttpClient,
    arg: &TeamFolderArchiveArg,
) -> ::Result<Result<TeamFolderArchiveLaunch, TeamFolderArchiveError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/archive",
        arg,
        None)
}

/// Returns the status of an asynchronous job for archiving a team folder. Permission : Team member
/// file access.
pub fn team_folder_archive_check(
    client: &::client_trait::HttpClient,
    arg: &super::async::PollArg,
) -> ::Result<Result<TeamFolderArchiveJobStatus, super::async::PollError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/archive/check",
        arg,
        None)
}

/// Creates a new, active, team folder with no members. Permission : Team member file access.
pub fn team_folder_create(
    client: &::client_trait::HttpClient,
    arg: &TeamFolderCreateArg,
) -> ::Result<Result<TeamFolderMetadata, TeamFolderCreateError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/create",
        arg,
        None)
}

/// Retrieves metadata for team folders. Permission : Team member file access.
pub fn team_folder_get_info(
    client: &::client_trait::HttpClient,
    arg: &TeamFolderIdListArg,
) -> ::Result<Result<Vec<TeamFolderGetInfoItem>, ()>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/get_info",
        arg,
        None)
}

/// Lists all team folders. Permission : Team member file access.
pub fn team_folder_list(
    client: &::client_trait::HttpClient,
    arg: &TeamFolderListArg,
) -> ::Result<Result<TeamFolderListResult, TeamFolderListError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/list",
        arg,
        None)
}

/// Once a cursor has been retrieved from [`team_folder_list()`](team_folder_list), use this to
/// paginate through all team folders. Permission : Team member file access.
pub fn team_folder_list_continue(
    client: &::client_trait::HttpClient,
    arg: &TeamFolderListContinueArg,
) -> ::Result<Result<TeamFolderListResult, TeamFolderListContinueError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/list/continue",
        arg,
        None)
}

/// Permanently deletes an archived team folder. Permission : Team member file access.
pub fn team_folder_permanently_delete(
    client: &::client_trait::HttpClient,
    arg: &TeamFolderIdArg,
) -> ::Result<Result<(), TeamFolderPermanentlyDeleteError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/permanently_delete",
        arg,
        None)
}

/// Changes an active team folder's name. Permission : Team member file access.
pub fn team_folder_rename(
    client: &::client_trait::HttpClient,
    arg: &TeamFolderRenameArg,
) -> ::Result<Result<TeamFolderMetadata, TeamFolderRenameError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/rename",
        arg,
        None)
}

/// Updates the sync settings on a team folder or its contents.  Use of this endpoint requires that
/// the team has team selective sync enabled.
pub fn team_folder_update_sync_settings(
    client: &::client_trait::HttpClient,
    arg: &TeamFolderUpdateSyncSettingsArg,
) -> ::Result<Result<TeamFolderMetadata, TeamFolderUpdateSyncSettingsError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/team_folder/update_sync_settings",
        arg,
        None)
}

/// Returns the member profile of the admin who generated the team access token used to make the
/// call.
pub fn token_get_authenticated_admin(
    client: &::client_trait::HttpClient,
    arg: &(),
) -> ::Result<Result<TokenGetAuthenticatedAdminResult, TokenGetAuthenticatedAdminError>> {
    ::client_helpers::request(
        client,
        ::client_trait::Endpoint::Api,
        "team/token/get_authenticated_admin",
        arg,
        None)
}

/// Information on active web sessions.
#[derive(Debug)]
pub struct ActiveWebSession {
    /// The session id.
    pub session_id: String,
    /// Information on the hosting device.
    pub user_agent: String,
    /// Information on the hosting operating system.
    pub os: String,
    /// Information on the browser used for this web session.
    pub browser: String,
    /// The IP address of the last activity from this session.
    pub ip_address: Option<String>,
    /// The country from which the last activity from this session was made.
    pub country: Option<String>,
    /// The time this session was created.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session.
    pub updated: Option<super::common::DropboxTimestamp>,
    /// The time this session expires.
    pub expires: Option<super::common::DropboxTimestamp>,
}

impl ActiveWebSession {
    pub fn new(session_id: String, user_agent: String, os: String, browser: String) -> Self {
        ActiveWebSession {
            session_id,
            user_agent,
            os,
            browser,
            ip_address: None,
            country: None,
            created: None,
            updated: None,
            expires: None,
        }
    }

    pub fn with_ip_address(mut self, value: Option<String>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_country(mut self, value: Option<String>) -> Self {
        self.country = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

    pub fn with_expires(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.expires = value;
        self
    }

}

const ACTIVE_WEB_SESSION_FIELDS: &[&str] = &["session_id",
                                             "user_agent",
                                             "os",
                                             "browser",
                                             "ip_address",
                                             "country",
                                             "created",
                                             "updated",
                                             "expires"];
impl ActiveWebSession {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ActiveWebSession, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ActiveWebSession>, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        let mut field_user_agent = None;
        let mut field_os = None;
        let mut field_browser = None;
        let mut field_ip_address = None;
        let mut field_country = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut field_expires = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "user_agent" => {
                    if field_user_agent.is_some() {
                        return Err(de::Error::duplicate_field("user_agent"));
                    }
                    field_user_agent = Some(map.next_value()?);
                }
                "os" => {
                    if field_os.is_some() {
                        return Err(de::Error::duplicate_field("os"));
                    }
                    field_os = Some(map.next_value()?);
                }
                "browser" => {
                    if field_browser.is_some() {
                        return Err(de::Error::duplicate_field("browser"));
                    }
                    field_browser = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "country" => {
                    if field_country.is_some() {
                        return Err(de::Error::duplicate_field("country"));
                    }
                    field_country = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                "expires" => {
                    if field_expires.is_some() {
                        return Err(de::Error::duplicate_field("expires"));
                    }
                    field_expires = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, ACTIVE_WEB_SESSION_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ActiveWebSession {
            session_id: field_session_id.ok_or_else(|| de::Error::missing_field("session_id"))?,
            user_agent: field_user_agent.ok_or_else(|| de::Error::missing_field("user_agent"))?,
            os: field_os.ok_or_else(|| de::Error::missing_field("os"))?,
            browser: field_browser.ok_or_else(|| de::Error::missing_field("browser"))?,
            ip_address: field_ip_address,
            country: field_country,
            created: field_created,
            updated: field_updated,
            expires: field_expires,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("user_agent", &self.user_agent)?;
        s.serialize_field("os", &self.os)?;
        s.serialize_field("browser", &self.browser)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("country", &self.country)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)?;
        s.serialize_field("expires", &self.expires)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ActiveWebSession {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ActiveWebSession;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ActiveWebSession struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ActiveWebSession::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ActiveWebSession", ACTIVE_WEB_SESSION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ActiveWebSession {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ActiveWebSession", 9)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Describes which team-related admin permissions a user has.
#[derive(Debug)]
pub enum AdminTier {
    /// User is an administrator of the team - has all permissions.
    TeamAdmin,
    /// User can do most user provisioning, de-provisioning and management.
    UserManagementAdmin,
    /// User can do a limited set of common support tasks for existing users.
    SupportAdmin,
    /// User is not an admin of the team.
    MemberOnly,
}

impl<'de> ::serde::de::Deserialize<'de> for AdminTier {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AdminTier;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a AdminTier structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_admin" => Ok(AdminTier::TeamAdmin),
                    "user_management_admin" => Ok(AdminTier::UserManagementAdmin),
                    "support_admin" => Ok(AdminTier::SupportAdmin),
                    "member_only" => Ok(AdminTier::MemberOnly),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["team_admin",
                                    "user_management_admin",
                                    "support_admin",
                                    "member_only"];
        deserializer.deserialize_struct("AdminTier", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AdminTier {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AdminTier::TeamAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminTier", 1)?;
                s.serialize_field(".tag", "team_admin")?;
                s.end()
            }
            AdminTier::UserManagementAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminTier", 1)?;
                s.serialize_field(".tag", "user_management_admin")?;
                s.end()
            }
            AdminTier::SupportAdmin => {
                // unit
                let mut s = serializer.serialize_struct("AdminTier", 1)?;
                s.serialize_field(".tag", "support_admin")?;
                s.end()
            }
            AdminTier::MemberOnly => {
                // unit
                let mut s = serializer.serialize_struct("AdminTier", 1)?;
                s.serialize_field(".tag", "member_only")?;
                s.end()
            }
        }
    }
}

/// Information on linked third party applications.
#[derive(Debug)]
pub struct ApiApp {
    /// The application unique id.
    pub app_id: String,
    /// The application name.
    pub app_name: String,
    /// Whether the linked application uses a dedicated folder.
    pub is_app_folder: bool,
    /// The application publisher name.
    pub publisher: Option<String>,
    /// The publisher's URL.
    pub publisher_url: Option<String>,
    /// The time this application was linked.
    pub linked: Option<super::common::DropboxTimestamp>,
}

impl ApiApp {
    pub fn new(app_id: String, app_name: String, is_app_folder: bool) -> Self {
        ApiApp {
            app_id,
            app_name,
            is_app_folder,
            publisher: None,
            publisher_url: None,
            linked: None,
        }
    }

    pub fn with_publisher(mut self, value: Option<String>) -> Self {
        self.publisher = value;
        self
    }

    pub fn with_publisher_url(mut self, value: Option<String>) -> Self {
        self.publisher_url = value;
        self
    }

    pub fn with_linked(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.linked = value;
        self
    }

}

const API_APP_FIELDS: &[&str] = &["app_id",
                                  "app_name",
                                  "is_app_folder",
                                  "publisher",
                                  "publisher_url",
                                  "linked"];
impl ApiApp {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ApiApp, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ApiApp>, V::Error> {
        use serde::de;
        let mut field_app_id = None;
        let mut field_app_name = None;
        let mut field_is_app_folder = None;
        let mut field_publisher = None;
        let mut field_publisher_url = None;
        let mut field_linked = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "app_name" => {
                    if field_app_name.is_some() {
                        return Err(de::Error::duplicate_field("app_name"));
                    }
                    field_app_name = Some(map.next_value()?);
                }
                "is_app_folder" => {
                    if field_is_app_folder.is_some() {
                        return Err(de::Error::duplicate_field("is_app_folder"));
                    }
                    field_is_app_folder = Some(map.next_value()?);
                }
                "publisher" => {
                    if field_publisher.is_some() {
                        return Err(de::Error::duplicate_field("publisher"));
                    }
                    field_publisher = Some(map.next_value()?);
                }
                "publisher_url" => {
                    if field_publisher_url.is_some() {
                        return Err(de::Error::duplicate_field("publisher_url"));
                    }
                    field_publisher_url = Some(map.next_value()?);
                }
                "linked" => {
                    if field_linked.is_some() {
                        return Err(de::Error::duplicate_field("linked"));
                    }
                    field_linked = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, API_APP_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ApiApp {
            app_id: field_app_id.ok_or_else(|| de::Error::missing_field("app_id"))?,
            app_name: field_app_name.ok_or_else(|| de::Error::missing_field("app_name"))?,
            is_app_folder: field_is_app_folder.ok_or_else(|| de::Error::missing_field("is_app_folder"))?,
            publisher: field_publisher,
            publisher_url: field_publisher_url,
            linked: field_linked,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("app_name", &self.app_name)?;
        s.serialize_field("is_app_folder", &self.is_app_folder)?;
        s.serialize_field("publisher", &self.publisher)?;
        s.serialize_field("publisher_url", &self.publisher_url)?;
        s.serialize_field("linked", &self.linked)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ApiApp {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ApiApp;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ApiApp struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ApiApp::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ApiApp", API_APP_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ApiApp {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ApiApp", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Base report structure.
#[derive(Debug)]
pub struct BaseDfbReport {
    /// First date present in the results as 'YYYY-MM-DD' or None.
    pub start_date: String,
}

impl BaseDfbReport {
    pub fn new(start_date: String) -> Self {
        BaseDfbReport {
            start_date,
        }
    }

}

const BASE_DFB_REPORT_FIELDS: &[&str] = &["start_date"];
impl BaseDfbReport {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<BaseDfbReport, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<BaseDfbReport>, V::Error> {
        use serde::de;
        let mut field_start_date = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, BASE_DFB_REPORT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = BaseDfbReport {
            start_date: field_start_date.ok_or_else(|| de::Error::missing_field("start_date"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for BaseDfbReport {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = BaseDfbReport;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a BaseDfbReport struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                BaseDfbReport::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("BaseDfbReport", BASE_DFB_REPORT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for BaseDfbReport {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("BaseDfbReport", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Base error that all errors for existing team folders should extend.
#[derive(Debug)]
pub enum BaseTeamFolderError {
    AccessError(TeamFolderAccessError),
    StatusError(TeamFolderInvalidStatusError),
    TeamSharedDropboxError(TeamFolderTeamSharedDropboxError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for BaseTeamFolderError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = BaseTeamFolderError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a BaseTeamFolderError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        match map.next_key()? {
                            Some("access_error") => Ok(BaseTeamFolderError::AccessError(map.next_value()?)),
                            None => Err(de::Error::missing_field("access_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "status_error" => {
                        match map.next_key()? {
                            Some("status_error") => Ok(BaseTeamFolderError::StatusError(map.next_value()?)),
                            None => Err(de::Error::missing_field("status_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "team_shared_dropbox_error" => {
                        match map.next_key()? {
                            Some("team_shared_dropbox_error") => Ok(BaseTeamFolderError::TeamSharedDropboxError(map.next_value()?)),
                            None => Err(de::Error::missing_field("team_shared_dropbox_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(BaseTeamFolderError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["access_error",
                                    "status_error",
                                    "team_shared_dropbox_error",
                                    "other"];
        deserializer.deserialize_struct("BaseTeamFolderError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for BaseTeamFolderError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            BaseTeamFolderError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("BaseTeamFolderError", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            BaseTeamFolderError::StatusError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("BaseTeamFolderError", 2)?;
                s.serialize_field(".tag", "status_error")?;
                s.serialize_field("status_error", x)?;
                s.end()
            }
            BaseTeamFolderError::TeamSharedDropboxError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("BaseTeamFolderError", 2)?;
                s.serialize_field(".tag", "team_shared_dropbox_error")?;
                s.serialize_field("team_shared_dropbox_error", x)?;
                s.end()
            }
            BaseTeamFolderError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for BaseTeamFolderError {
    fn description(&self) -> &str {
        "BaseTeamFolderError"
    }
}

impl ::std::fmt::Display for BaseTeamFolderError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Error returned when getting member custom quota.
#[derive(Debug)]
pub enum CustomQuotaError {
    /// A maximum of 1000 users can be set for a single call.
    TooManyUsers,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for CustomQuotaError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = CustomQuotaError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CustomQuotaError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "too_many_users" => Ok(CustomQuotaError::TooManyUsers),
                    _ => Ok(CustomQuotaError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["too_many_users",
                                    "other"];
        deserializer.deserialize_struct("CustomQuotaError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for CustomQuotaError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            CustomQuotaError::TooManyUsers => {
                // unit
                let mut s = serializer.serialize_struct("CustomQuotaError", 1)?;
                s.serialize_field(".tag", "too_many_users")?;
                s.end()
            }
            CustomQuotaError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for CustomQuotaError {
    fn description(&self) -> &str {
        "CustomQuotaError"
    }
}

impl ::std::fmt::Display for CustomQuotaError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// User custom quota.
#[derive(Debug)]
pub enum CustomQuotaResult {
    /// User's custom quota.
    Success(UserCustomQuotaResult),
    /// Invalid user (not in team).
    InvalidUser(UserSelectorArg),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for CustomQuotaResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = CustomQuotaResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CustomQuotaResult structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "success" => Ok(CustomQuotaResult::Success(UserCustomQuotaResult::internal_deserialize(map)?)),
                    "invalid_user" => {
                        match map.next_key()? {
                            Some("invalid_user") => Ok(CustomQuotaResult::InvalidUser(map.next_value()?)),
                            None => Err(de::Error::missing_field("invalid_user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(CustomQuotaResult::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["success",
                                    "invalid_user",
                                    "other"];
        deserializer.deserialize_struct("CustomQuotaResult", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for CustomQuotaResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            CustomQuotaResult::Success(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("CustomQuotaResult", 3)?;
                s.serialize_field(".tag", "success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            CustomQuotaResult::InvalidUser(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("CustomQuotaResult", 2)?;
                s.serialize_field(".tag", "invalid_user")?;
                s.serialize_field("invalid_user", x)?;
                s.end()
            }
            CustomQuotaResult::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct CustomQuotaUsersArg {
    /// List of users.
    pub users: Vec<UserSelectorArg>,
}

impl CustomQuotaUsersArg {
    pub fn new(users: Vec<UserSelectorArg>) -> Self {
        CustomQuotaUsersArg {
            users,
        }
    }

}

const CUSTOM_QUOTA_USERS_ARG_FIELDS: &[&str] = &["users"];
impl CustomQuotaUsersArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<CustomQuotaUsersArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<CustomQuotaUsersArg>, V::Error> {
        use serde::de;
        let mut field_users = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "users" => {
                    if field_users.is_some() {
                        return Err(de::Error::duplicate_field("users"));
                    }
                    field_users = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, CUSTOM_QUOTA_USERS_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = CustomQuotaUsersArg {
            users: field_users.ok_or_else(|| de::Error::missing_field("users"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("users", &self.users)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for CustomQuotaUsersArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = CustomQuotaUsersArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a CustomQuotaUsersArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                CustomQuotaUsersArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("CustomQuotaUsersArg", CUSTOM_QUOTA_USERS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for CustomQuotaUsersArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("CustomQuotaUsersArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Input arguments that can be provided for most reports.
#[derive(Debug)]
pub struct DateRange {
    /// Optional starting date (inclusive).
    pub start_date: Option<super::common::Date>,
    /// Optional ending date (exclusive).
    pub end_date: Option<super::common::Date>,
}

impl Default for DateRange {
    fn default() -> Self {
        DateRange {
            start_date: None,
            end_date: None,
        }
    }
}

const DATE_RANGE_FIELDS: &[&str] = &["start_date",
                                     "end_date"];
impl DateRange {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<DateRange, V::Error> {
        use serde::de;
        let mut field_start_date = None;
        let mut field_end_date = None;
        while let Some(key) = map.next_key()? {
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "end_date" => {
                    if field_end_date.is_some() {
                        return Err(de::Error::duplicate_field("end_date"));
                    }
                    field_end_date = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DATE_RANGE_FIELDS))
            }
        }
        let result = DateRange {
            start_date: field_start_date,
            end_date: field_end_date,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("end_date", &self.end_date)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DateRange {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DateRange;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DateRange struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DateRange::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DateRange", DATE_RANGE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DateRange {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DateRange", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Errors that can originate from problems in input arguments to reports.
#[derive(Debug)]
pub enum DateRangeError {
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DateRangeError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DateRangeError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DateRangeError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    _ => Ok(DateRangeError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["other"];
        deserializer.deserialize_struct("DateRangeError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DateRangeError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        #![allow(unused_variables)]
        Err(::serde::ser::Error::custom("cannot serialize an open union with no defined variants"))
    }
}

impl ::std::error::Error for DateRangeError {
    fn description(&self) -> &str {
        "DateRangeError"
    }
}

impl ::std::fmt::Display for DateRangeError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Information about linked Dropbox desktop client sessions.
#[derive(Debug)]
pub struct DesktopClientSession {
    /// The session id.
    pub session_id: String,
    /// Name of the hosting desktop.
    pub host_name: String,
    /// The Dropbox desktop client type.
    pub client_type: DesktopPlatform,
    /// The Dropbox client version.
    pub client_version: String,
    /// Information on the hosting platform.
    pub platform: String,
    /// Whether it's possible to delete all of the account files upon unlinking.
    pub is_delete_on_unlink_supported: bool,
    /// The IP address of the last activity from this session.
    pub ip_address: Option<String>,
    /// The country from which the last activity from this session was made.
    pub country: Option<String>,
    /// The time this session was created.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session.
    pub updated: Option<super::common::DropboxTimestamp>,
}

impl DesktopClientSession {
    pub fn new(
        session_id: String,
        host_name: String,
        client_type: DesktopPlatform,
        client_version: String,
        platform: String,
        is_delete_on_unlink_supported: bool,
    ) -> Self {
        DesktopClientSession {
            session_id,
            host_name,
            client_type,
            client_version,
            platform,
            is_delete_on_unlink_supported,
            ip_address: None,
            country: None,
            created: None,
            updated: None,
        }
    }

    pub fn with_ip_address(mut self, value: Option<String>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_country(mut self, value: Option<String>) -> Self {
        self.country = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

}

const DESKTOP_CLIENT_SESSION_FIELDS: &[&str] = &["session_id",
                                                 "host_name",
                                                 "client_type",
                                                 "client_version",
                                                 "platform",
                                                 "is_delete_on_unlink_supported",
                                                 "ip_address",
                                                 "country",
                                                 "created",
                                                 "updated"];
impl DesktopClientSession {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DesktopClientSession, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DesktopClientSession>, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        let mut field_host_name = None;
        let mut field_client_type = None;
        let mut field_client_version = None;
        let mut field_platform = None;
        let mut field_is_delete_on_unlink_supported = None;
        let mut field_ip_address = None;
        let mut field_country = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "host_name" => {
                    if field_host_name.is_some() {
                        return Err(de::Error::duplicate_field("host_name"));
                    }
                    field_host_name = Some(map.next_value()?);
                }
                "client_type" => {
                    if field_client_type.is_some() {
                        return Err(de::Error::duplicate_field("client_type"));
                    }
                    field_client_type = Some(map.next_value()?);
                }
                "client_version" => {
                    if field_client_version.is_some() {
                        return Err(de::Error::duplicate_field("client_version"));
                    }
                    field_client_version = Some(map.next_value()?);
                }
                "platform" => {
                    if field_platform.is_some() {
                        return Err(de::Error::duplicate_field("platform"));
                    }
                    field_platform = Some(map.next_value()?);
                }
                "is_delete_on_unlink_supported" => {
                    if field_is_delete_on_unlink_supported.is_some() {
                        return Err(de::Error::duplicate_field("is_delete_on_unlink_supported"));
                    }
                    field_is_delete_on_unlink_supported = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "country" => {
                    if field_country.is_some() {
                        return Err(de::Error::duplicate_field("country"));
                    }
                    field_country = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DESKTOP_CLIENT_SESSION_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DesktopClientSession {
            session_id: field_session_id.ok_or_else(|| de::Error::missing_field("session_id"))?,
            host_name: field_host_name.ok_or_else(|| de::Error::missing_field("host_name"))?,
            client_type: field_client_type.ok_or_else(|| de::Error::missing_field("client_type"))?,
            client_version: field_client_version.ok_or_else(|| de::Error::missing_field("client_version"))?,
            platform: field_platform.ok_or_else(|| de::Error::missing_field("platform"))?,
            is_delete_on_unlink_supported: field_is_delete_on_unlink_supported.ok_or_else(|| de::Error::missing_field("is_delete_on_unlink_supported"))?,
            ip_address: field_ip_address,
            country: field_country,
            created: field_created,
            updated: field_updated,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("host_name", &self.host_name)?;
        s.serialize_field("client_type", &self.client_type)?;
        s.serialize_field("client_version", &self.client_version)?;
        s.serialize_field("platform", &self.platform)?;
        s.serialize_field("is_delete_on_unlink_supported", &self.is_delete_on_unlink_supported)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("country", &self.country)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DesktopClientSession {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DesktopClientSession;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DesktopClientSession struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DesktopClientSession::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DesktopClientSession", DESKTOP_CLIENT_SESSION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DesktopClientSession {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DesktopClientSession", 10)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum DesktopPlatform {
    /// Official Windows Dropbox desktop client.
    Windows,
    /// Official Mac Dropbox desktop client.
    Mac,
    /// Official Linux Dropbox desktop client.
    Linux,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for DesktopPlatform {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = DesktopPlatform;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DesktopPlatform structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "windows" => Ok(DesktopPlatform::Windows),
                    "mac" => Ok(DesktopPlatform::Mac),
                    "linux" => Ok(DesktopPlatform::Linux),
                    _ => Ok(DesktopPlatform::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["windows",
                                    "mac",
                                    "linux",
                                    "other"];
        deserializer.deserialize_struct("DesktopPlatform", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for DesktopPlatform {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            DesktopPlatform::Windows => {
                // unit
                let mut s = serializer.serialize_struct("DesktopPlatform", 1)?;
                s.serialize_field(".tag", "windows")?;
                s.end()
            }
            DesktopPlatform::Mac => {
                // unit
                let mut s = serializer.serialize_struct("DesktopPlatform", 1)?;
                s.serialize_field(".tag", "mac")?;
                s.end()
            }
            DesktopPlatform::Linux => {
                // unit
                let mut s = serializer.serialize_struct("DesktopPlatform", 1)?;
                s.serialize_field(".tag", "linux")?;
                s.end()
            }
            DesktopPlatform::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct DeviceSession {
    /// The session id.
    pub session_id: String,
    /// The IP address of the last activity from this session.
    pub ip_address: Option<String>,
    /// The country from which the last activity from this session was made.
    pub country: Option<String>,
    /// The time this session was created.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session.
    pub updated: Option<super::common::DropboxTimestamp>,
}

impl DeviceSession {
    pub fn new(session_id: String) -> Self {
        DeviceSession {
            session_id,
            ip_address: None,
            country: None,
            created: None,
            updated: None,
        }
    }

    pub fn with_ip_address(mut self, value: Option<String>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_country(mut self, value: Option<String>) -> Self {
        self.country = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

}

const DEVICE_SESSION_FIELDS: &[&str] = &["session_id",
                                         "ip_address",
                                         "country",
                                         "created",
                                         "updated"];
impl DeviceSession {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceSession, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceSession>, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        let mut field_ip_address = None;
        let mut field_country = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "country" => {
                    if field_country.is_some() {
                        return Err(de::Error::duplicate_field("country"));
                    }
                    field_country = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_SESSION_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceSession {
            session_id: field_session_id.ok_or_else(|| de::Error::missing_field("session_id"))?,
            ip_address: field_ip_address,
            country: field_country,
            created: field_created,
            updated: field_updated,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("country", &self.country)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceSession {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceSession;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceSession struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceSession::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceSession", DEVICE_SESSION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceSession {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceSession", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct DeviceSessionArg {
    /// The session id.
    pub session_id: String,
    /// The unique id of the member owning the device.
    pub team_member_id: String,
}

impl DeviceSessionArg {
    pub fn new(session_id: String, team_member_id: String) -> Self {
        DeviceSessionArg {
            session_id,
            team_member_id,
        }
    }

}

const DEVICE_SESSION_ARG_FIELDS: &[&str] = &["session_id",
                                             "team_member_id"];
impl DeviceSessionArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DeviceSessionArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DeviceSessionArg>, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        let mut field_team_member_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICE_SESSION_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DeviceSessionArg {
            session_id: field_session_id.ok_or_else(|| de::Error::missing_field("session_id"))?,
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("team_member_id", &self.team_member_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DeviceSessionArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DeviceSessionArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DeviceSessionArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DeviceSessionArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DeviceSessionArg", DEVICE_SESSION_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DeviceSessionArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DeviceSessionArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Each of the items is an array of values, one value per day. The value is the number of devices
/// active within a time window, ending with that day. If there is no data for a day, then the value
/// will be None.
#[derive(Debug)]
pub struct DevicesActive {
    /// Array of number of linked windows (desktop) clients with activity.
    pub windows: NumberPerDay,
    /// Array of number of linked mac (desktop) clients with activity.
    pub macos: NumberPerDay,
    /// Array of number of linked linus (desktop) clients with activity.
    pub linux: NumberPerDay,
    /// Array of number of linked ios devices with activity.
    pub ios: NumberPerDay,
    /// Array of number of linked android devices with activity.
    pub android: NumberPerDay,
    /// Array of number of other linked devices (blackberry, windows phone, etc)  with activity.
    pub other: NumberPerDay,
    /// Array of total number of linked clients with activity.
    pub total: NumberPerDay,
}

impl DevicesActive {
    pub fn new(
        windows: NumberPerDay,
        macos: NumberPerDay,
        linux: NumberPerDay,
        ios: NumberPerDay,
        android: NumberPerDay,
        other: NumberPerDay,
        total: NumberPerDay,
    ) -> Self {
        DevicesActive {
            windows,
            macos,
            linux,
            ios,
            android,
            other,
            total,
        }
    }

}

const DEVICES_ACTIVE_FIELDS: &[&str] = &["windows",
                                         "macos",
                                         "linux",
                                         "ios",
                                         "android",
                                         "other",
                                         "total"];
impl DevicesActive {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<DevicesActive, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<DevicesActive>, V::Error> {
        use serde::de;
        let mut field_windows = None;
        let mut field_macos = None;
        let mut field_linux = None;
        let mut field_ios = None;
        let mut field_android = None;
        let mut field_other = None;
        let mut field_total = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "windows" => {
                    if field_windows.is_some() {
                        return Err(de::Error::duplicate_field("windows"));
                    }
                    field_windows = Some(map.next_value()?);
                }
                "macos" => {
                    if field_macos.is_some() {
                        return Err(de::Error::duplicate_field("macos"));
                    }
                    field_macos = Some(map.next_value()?);
                }
                "linux" => {
                    if field_linux.is_some() {
                        return Err(de::Error::duplicate_field("linux"));
                    }
                    field_linux = Some(map.next_value()?);
                }
                "ios" => {
                    if field_ios.is_some() {
                        return Err(de::Error::duplicate_field("ios"));
                    }
                    field_ios = Some(map.next_value()?);
                }
                "android" => {
                    if field_android.is_some() {
                        return Err(de::Error::duplicate_field("android"));
                    }
                    field_android = Some(map.next_value()?);
                }
                "other" => {
                    if field_other.is_some() {
                        return Err(de::Error::duplicate_field("other"));
                    }
                    field_other = Some(map.next_value()?);
                }
                "total" => {
                    if field_total.is_some() {
                        return Err(de::Error::duplicate_field("total"));
                    }
                    field_total = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, DEVICES_ACTIVE_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = DevicesActive {
            windows: field_windows.ok_or_else(|| de::Error::missing_field("windows"))?,
            macos: field_macos.ok_or_else(|| de::Error::missing_field("macos"))?,
            linux: field_linux.ok_or_else(|| de::Error::missing_field("linux"))?,
            ios: field_ios.ok_or_else(|| de::Error::missing_field("ios"))?,
            android: field_android.ok_or_else(|| de::Error::missing_field("android"))?,
            other: field_other.ok_or_else(|| de::Error::missing_field("other"))?,
            total: field_total.ok_or_else(|| de::Error::missing_field("total"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("windows", &self.windows)?;
        s.serialize_field("macos", &self.macos)?;
        s.serialize_field("linux", &self.linux)?;
        s.serialize_field("ios", &self.ios)?;
        s.serialize_field("android", &self.android)?;
        s.serialize_field("other", &self.other)?;
        s.serialize_field("total", &self.total)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for DevicesActive {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = DevicesActive;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a DevicesActive struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                DevicesActive::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("DevicesActive", DEVICES_ACTIVE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for DevicesActive {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("DevicesActive", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Excluded users list argument.
#[derive(Debug)]
pub struct ExcludedUsersListArg {
    /// Number of results to return per call.
    pub limit: u32,
}

impl Default for ExcludedUsersListArg {
    fn default() -> Self {
        ExcludedUsersListArg {
            limit: 1000,
        }
    }
}

const EXCLUDED_USERS_LIST_ARG_FIELDS: &[&str] = &["limit"];
impl ExcludedUsersListArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ExcludedUsersListArg, V::Error> {
        use serde::de;
        let mut field_limit = None;
        while let Some(key) = map.next_key()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXCLUDED_USERS_LIST_ARG_FIELDS))
            }
        }
        let result = ExcludedUsersListArg {
            limit: field_limit.unwrap_or(1000),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExcludedUsersListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExcludedUsersListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExcludedUsersListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExcludedUsersListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExcludedUsersListArg", EXCLUDED_USERS_LIST_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExcludedUsersListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExcludedUsersListArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Excluded users list continue argument.
#[derive(Debug)]
pub struct ExcludedUsersListContinueArg {
    /// Indicates from what point to get the next set of users.
    pub cursor: String,
}

impl ExcludedUsersListContinueArg {
    pub fn new(cursor: String) -> Self {
        ExcludedUsersListContinueArg {
            cursor,
        }
    }

}

const EXCLUDED_USERS_LIST_CONTINUE_ARG_FIELDS: &[&str] = &["cursor"];
impl ExcludedUsersListContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ExcludedUsersListContinueArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ExcludedUsersListContinueArg>, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXCLUDED_USERS_LIST_CONTINUE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ExcludedUsersListContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExcludedUsersListContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExcludedUsersListContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExcludedUsersListContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExcludedUsersListContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExcludedUsersListContinueArg", EXCLUDED_USERS_LIST_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExcludedUsersListContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExcludedUsersListContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Excluded users list continue error.
#[derive(Debug)]
pub enum ExcludedUsersListContinueError {
    /// The cursor is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ExcludedUsersListContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ExcludedUsersListContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExcludedUsersListContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_cursor" => Ok(ExcludedUsersListContinueError::InvalidCursor),
                    _ => Ok(ExcludedUsersListContinueError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_cursor",
                                    "other"];
        deserializer.deserialize_struct("ExcludedUsersListContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ExcludedUsersListContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ExcludedUsersListContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("ExcludedUsersListContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            ExcludedUsersListContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ExcludedUsersListContinueError {
    fn description(&self) -> &str {
        "ExcludedUsersListContinueError"
    }
}

impl ::std::fmt::Display for ExcludedUsersListContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Excluded users list error.
#[derive(Debug)]
pub enum ExcludedUsersListError {
    /// An error occurred.
    ListError,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ExcludedUsersListError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ExcludedUsersListError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExcludedUsersListError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "list_error" => Ok(ExcludedUsersListError::ListError),
                    _ => Ok(ExcludedUsersListError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["list_error",
                                    "other"];
        deserializer.deserialize_struct("ExcludedUsersListError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ExcludedUsersListError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ExcludedUsersListError::ListError => {
                // unit
                let mut s = serializer.serialize_struct("ExcludedUsersListError", 1)?;
                s.serialize_field(".tag", "list_error")?;
                s.end()
            }
            ExcludedUsersListError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ExcludedUsersListError {
    fn description(&self) -> &str {
        "ExcludedUsersListError"
    }
}

impl ::std::fmt::Display for ExcludedUsersListError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Excluded users list result.
#[derive(Debug)]
pub struct ExcludedUsersListResult {
    pub users: Vec<MemberProfile>,
    /// Is true if there are additional excluded users that have not been returned yet. An
    /// additional call to
    /// [`member_space_limits_excluded_users_list_continue()`](member_space_limits_excluded_users_list_continue)
    /// can retrieve them.
    pub has_more: bool,
    /// Pass the cursor into
    /// [`member_space_limits_excluded_users_list_continue()`](member_space_limits_excluded_users_list_continue)
    /// to obtain additional excluded users.
    pub cursor: Option<String>,
}

impl ExcludedUsersListResult {
    pub fn new(users: Vec<MemberProfile>, has_more: bool) -> Self {
        ExcludedUsersListResult {
            users,
            has_more,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const EXCLUDED_USERS_LIST_RESULT_FIELDS: &[&str] = &["users",
                                                     "has_more",
                                                     "cursor"];
impl ExcludedUsersListResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ExcludedUsersListResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ExcludedUsersListResult>, V::Error> {
        use serde::de;
        let mut field_users = None;
        let mut field_has_more = None;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "users" => {
                    if field_users.is_some() {
                        return Err(de::Error::duplicate_field("users"));
                    }
                    field_users = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXCLUDED_USERS_LIST_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ExcludedUsersListResult {
            users: field_users.ok_or_else(|| de::Error::missing_field("users"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
            cursor: field_cursor,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("users", &self.users)?;
        s.serialize_field("has_more", &self.has_more)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExcludedUsersListResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExcludedUsersListResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExcludedUsersListResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExcludedUsersListResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExcludedUsersListResult", EXCLUDED_USERS_LIST_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExcludedUsersListResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExcludedUsersListResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Argument of excluded users update operation. Should include a list of users to add/remove
/// (according to endpoint), Maximum size of the list is 1000 users.
#[derive(Debug)]
pub struct ExcludedUsersUpdateArg {
    /// List of users to be added/removed.
    pub users: Option<Vec<UserSelectorArg>>,
}

impl Default for ExcludedUsersUpdateArg {
    fn default() -> Self {
        ExcludedUsersUpdateArg {
            users: None,
        }
    }
}

const EXCLUDED_USERS_UPDATE_ARG_FIELDS: &[&str] = &["users"];
impl ExcludedUsersUpdateArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ExcludedUsersUpdateArg, V::Error> {
        use serde::de;
        let mut field_users = None;
        while let Some(key) = map.next_key()? {
            match key {
                "users" => {
                    if field_users.is_some() {
                        return Err(de::Error::duplicate_field("users"));
                    }
                    field_users = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXCLUDED_USERS_UPDATE_ARG_FIELDS))
            }
        }
        let result = ExcludedUsersUpdateArg {
            users: field_users,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("users", &self.users)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExcludedUsersUpdateArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExcludedUsersUpdateArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExcludedUsersUpdateArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExcludedUsersUpdateArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExcludedUsersUpdateArg", EXCLUDED_USERS_UPDATE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExcludedUsersUpdateArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExcludedUsersUpdateArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Excluded users update error.
#[derive(Debug)]
pub enum ExcludedUsersUpdateError {
    /// At least one of the users is not part of your team.
    UsersNotInTeam,
    /// A maximum of 1000 users for each of addition/removal can be supplied.
    TooManyUsers,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ExcludedUsersUpdateError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ExcludedUsersUpdateError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExcludedUsersUpdateError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "users_not_in_team" => Ok(ExcludedUsersUpdateError::UsersNotInTeam),
                    "too_many_users" => Ok(ExcludedUsersUpdateError::TooManyUsers),
                    _ => Ok(ExcludedUsersUpdateError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["users_not_in_team",
                                    "too_many_users",
                                    "other"];
        deserializer.deserialize_struct("ExcludedUsersUpdateError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ExcludedUsersUpdateError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ExcludedUsersUpdateError::UsersNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("ExcludedUsersUpdateError", 1)?;
                s.serialize_field(".tag", "users_not_in_team")?;
                s.end()
            }
            ExcludedUsersUpdateError::TooManyUsers => {
                // unit
                let mut s = serializer.serialize_struct("ExcludedUsersUpdateError", 1)?;
                s.serialize_field(".tag", "too_many_users")?;
                s.end()
            }
            ExcludedUsersUpdateError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ExcludedUsersUpdateError {
    fn description(&self) -> &str {
        "ExcludedUsersUpdateError"
    }
}

impl ::std::fmt::Display for ExcludedUsersUpdateError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Excluded users update result.
#[derive(Debug)]
pub struct ExcludedUsersUpdateResult {
    /// Update status.
    pub status: ExcludedUsersUpdateStatus,
}

impl ExcludedUsersUpdateResult {
    pub fn new(status: ExcludedUsersUpdateStatus) -> Self {
        ExcludedUsersUpdateResult {
            status,
        }
    }

}

const EXCLUDED_USERS_UPDATE_RESULT_FIELDS: &[&str] = &["status"];
impl ExcludedUsersUpdateResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ExcludedUsersUpdateResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ExcludedUsersUpdateResult>, V::Error> {
        use serde::de;
        let mut field_status = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "status" => {
                    if field_status.is_some() {
                        return Err(de::Error::duplicate_field("status"));
                    }
                    field_status = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, EXCLUDED_USERS_UPDATE_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ExcludedUsersUpdateResult {
            status: field_status.ok_or_else(|| de::Error::missing_field("status"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("status", &self.status)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ExcludedUsersUpdateResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ExcludedUsersUpdateResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExcludedUsersUpdateResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ExcludedUsersUpdateResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ExcludedUsersUpdateResult", EXCLUDED_USERS_UPDATE_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ExcludedUsersUpdateResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ExcludedUsersUpdateResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Excluded users update operation status.
#[derive(Debug)]
pub enum ExcludedUsersUpdateStatus {
    /// Update successful.
    Success,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ExcludedUsersUpdateStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ExcludedUsersUpdateStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ExcludedUsersUpdateStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "success" => Ok(ExcludedUsersUpdateStatus::Success),
                    _ => Ok(ExcludedUsersUpdateStatus::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["success",
                                    "other"];
        deserializer.deserialize_struct("ExcludedUsersUpdateStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ExcludedUsersUpdateStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ExcludedUsersUpdateStatus::Success => {
                // unit
                let mut s = serializer.serialize_struct("ExcludedUsersUpdateStatus", 1)?;
                s.serialize_field(".tag", "success")?;
                s.end()
            }
            ExcludedUsersUpdateStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// A set of features that a Dropbox Business account may support.
#[derive(Debug)]
pub enum Feature {
    /// The number of upload API calls allowed per month.
    UploadApiRateLimit,
    /// Does this team have a shared team root.
    HasTeamSharedDropbox,
    /// Does this team have file events.
    HasTeamFileEvents,
    /// Does this team have team selective sync enabled.
    HasTeamSelectiveSync,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for Feature {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = Feature;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a Feature structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "upload_api_rate_limit" => Ok(Feature::UploadApiRateLimit),
                    "has_team_shared_dropbox" => Ok(Feature::HasTeamSharedDropbox),
                    "has_team_file_events" => Ok(Feature::HasTeamFileEvents),
                    "has_team_selective_sync" => Ok(Feature::HasTeamSelectiveSync),
                    _ => Ok(Feature::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["upload_api_rate_limit",
                                    "has_team_shared_dropbox",
                                    "has_team_file_events",
                                    "has_team_selective_sync",
                                    "other"];
        deserializer.deserialize_struct("Feature", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for Feature {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            Feature::UploadApiRateLimit => {
                // unit
                let mut s = serializer.serialize_struct("Feature", 1)?;
                s.serialize_field(".tag", "upload_api_rate_limit")?;
                s.end()
            }
            Feature::HasTeamSharedDropbox => {
                // unit
                let mut s = serializer.serialize_struct("Feature", 1)?;
                s.serialize_field(".tag", "has_team_shared_dropbox")?;
                s.end()
            }
            Feature::HasTeamFileEvents => {
                // unit
                let mut s = serializer.serialize_struct("Feature", 1)?;
                s.serialize_field(".tag", "has_team_file_events")?;
                s.end()
            }
            Feature::HasTeamSelectiveSync => {
                // unit
                let mut s = serializer.serialize_struct("Feature", 1)?;
                s.serialize_field(".tag", "has_team_selective_sync")?;
                s.end()
            }
            Feature::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The values correspond to entries in [`Feature`](Feature). You may get different value according
/// to your Dropbox Business plan.
#[derive(Debug)]
pub enum FeatureValue {
    UploadApiRateLimit(UploadApiRateLimitValue),
    HasTeamSharedDropbox(HasTeamSharedDropboxValue),
    HasTeamFileEvents(HasTeamFileEventsValue),
    HasTeamSelectiveSync(HasTeamSelectiveSyncValue),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FeatureValue {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FeatureValue;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FeatureValue structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "upload_api_rate_limit" => {
                        match map.next_key()? {
                            Some("upload_api_rate_limit") => Ok(FeatureValue::UploadApiRateLimit(map.next_value()?)),
                            None => Err(de::Error::missing_field("upload_api_rate_limit")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "has_team_shared_dropbox" => {
                        match map.next_key()? {
                            Some("has_team_shared_dropbox") => Ok(FeatureValue::HasTeamSharedDropbox(map.next_value()?)),
                            None => Err(de::Error::missing_field("has_team_shared_dropbox")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "has_team_file_events" => {
                        match map.next_key()? {
                            Some("has_team_file_events") => Ok(FeatureValue::HasTeamFileEvents(map.next_value()?)),
                            None => Err(de::Error::missing_field("has_team_file_events")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "has_team_selective_sync" => {
                        match map.next_key()? {
                            Some("has_team_selective_sync") => Ok(FeatureValue::HasTeamSelectiveSync(map.next_value()?)),
                            None => Err(de::Error::missing_field("has_team_selective_sync")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(FeatureValue::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["upload_api_rate_limit",
                                    "has_team_shared_dropbox",
                                    "has_team_file_events",
                                    "has_team_selective_sync",
                                    "other"];
        deserializer.deserialize_struct("FeatureValue", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FeatureValue {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FeatureValue::UploadApiRateLimit(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("FeatureValue", 2)?;
                s.serialize_field(".tag", "upload_api_rate_limit")?;
                s.serialize_field("upload_api_rate_limit", x)?;
                s.end()
            }
            FeatureValue::HasTeamSharedDropbox(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("FeatureValue", 2)?;
                s.serialize_field(".tag", "has_team_shared_dropbox")?;
                s.serialize_field("has_team_shared_dropbox", x)?;
                s.end()
            }
            FeatureValue::HasTeamFileEvents(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("FeatureValue", 2)?;
                s.serialize_field(".tag", "has_team_file_events")?;
                s.serialize_field("has_team_file_events", x)?;
                s.end()
            }
            FeatureValue::HasTeamSelectiveSync(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("FeatureValue", 2)?;
                s.serialize_field(".tag", "has_team_selective_sync")?;
                s.serialize_field("has_team_selective_sync", x)?;
                s.end()
            }
            FeatureValue::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct FeaturesGetValuesBatchArg {
    /// A list of features in [`Feature`](Feature). If the list is empty, this route will return
    /// [`FeaturesGetValuesBatchError`](FeaturesGetValuesBatchError).
    pub features: Vec<Feature>,
}

impl FeaturesGetValuesBatchArg {
    pub fn new(features: Vec<Feature>) -> Self {
        FeaturesGetValuesBatchArg {
            features,
        }
    }

}

const FEATURES_GET_VALUES_BATCH_ARG_FIELDS: &[&str] = &["features"];
impl FeaturesGetValuesBatchArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FeaturesGetValuesBatchArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FeaturesGetValuesBatchArg>, V::Error> {
        use serde::de;
        let mut field_features = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "features" => {
                    if field_features.is_some() {
                        return Err(de::Error::duplicate_field("features"));
                    }
                    field_features = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FEATURES_GET_VALUES_BATCH_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FeaturesGetValuesBatchArg {
            features: field_features.ok_or_else(|| de::Error::missing_field("features"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("features", &self.features)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FeaturesGetValuesBatchArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FeaturesGetValuesBatchArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FeaturesGetValuesBatchArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FeaturesGetValuesBatchArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FeaturesGetValuesBatchArg", FEATURES_GET_VALUES_BATCH_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FeaturesGetValuesBatchArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FeaturesGetValuesBatchArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum FeaturesGetValuesBatchError {
    /// At least one [`Feature`](Feature) must be included in the
    /// [`FeaturesGetValuesBatchArg`](FeaturesGetValuesBatchArg).features list.
    EmptyFeaturesList,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for FeaturesGetValuesBatchError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = FeaturesGetValuesBatchError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FeaturesGetValuesBatchError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "empty_features_list" => Ok(FeaturesGetValuesBatchError::EmptyFeaturesList),
                    _ => Ok(FeaturesGetValuesBatchError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["empty_features_list",
                                    "other"];
        deserializer.deserialize_struct("FeaturesGetValuesBatchError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for FeaturesGetValuesBatchError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            FeaturesGetValuesBatchError::EmptyFeaturesList => {
                // unit
                let mut s = serializer.serialize_struct("FeaturesGetValuesBatchError", 1)?;
                s.serialize_field(".tag", "empty_features_list")?;
                s.end()
            }
            FeaturesGetValuesBatchError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for FeaturesGetValuesBatchError {
    fn description(&self) -> &str {
        "FeaturesGetValuesBatchError"
    }
}

impl ::std::fmt::Display for FeaturesGetValuesBatchError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct FeaturesGetValuesBatchResult {
    pub values: Vec<FeatureValue>,
}

impl FeaturesGetValuesBatchResult {
    pub fn new(values: Vec<FeatureValue>) -> Self {
        FeaturesGetValuesBatchResult {
            values,
        }
    }

}

const FEATURES_GET_VALUES_BATCH_RESULT_FIELDS: &[&str] = &["values"];
impl FeaturesGetValuesBatchResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<FeaturesGetValuesBatchResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<FeaturesGetValuesBatchResult>, V::Error> {
        use serde::de;
        let mut field_values = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "values" => {
                    if field_values.is_some() {
                        return Err(de::Error::duplicate_field("values"));
                    }
                    field_values = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, FEATURES_GET_VALUES_BATCH_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = FeaturesGetValuesBatchResult {
            values: field_values.ok_or_else(|| de::Error::missing_field("values"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("values", &self.values)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for FeaturesGetValuesBatchResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = FeaturesGetValuesBatchResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a FeaturesGetValuesBatchResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                FeaturesGetValuesBatchResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("FeaturesGetValuesBatchResult", FEATURES_GET_VALUES_BATCH_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for FeaturesGetValuesBatchResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("FeaturesGetValuesBatchResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Activity Report Result. Each of the items in the storage report is an array of values, one value
/// per day. If there is no data for a day, then the value will be None.
#[derive(Debug)]
pub struct GetActivityReport {
    /// First date present in the results as 'YYYY-MM-DD' or None.
    pub start_date: String,
    /// Array of total number of adds by team members.
    pub adds: NumberPerDay,
    /// Array of number of edits by team members. If the same user edits the same file multiple
    /// times this is counted as a single edit.
    pub edits: NumberPerDay,
    /// Array of total number of deletes by team members.
    pub deletes: NumberPerDay,
    /// Array of the number of users who have been active in the last 28 days.
    pub active_users_28_day: NumberPerDay,
    /// Array of the number of users who have been active in the last week.
    pub active_users_7_day: NumberPerDay,
    /// Array of the number of users who have been active in the last day.
    pub active_users_1_day: NumberPerDay,
    /// Array of the number of shared folders with some activity in the last 28 days.
    pub active_shared_folders_28_day: NumberPerDay,
    /// Array of the number of shared folders with some activity in the last week.
    pub active_shared_folders_7_day: NumberPerDay,
    /// Array of the number of shared folders with some activity in the last day.
    pub active_shared_folders_1_day: NumberPerDay,
    /// Array of the number of shared links created.
    pub shared_links_created: NumberPerDay,
    /// Array of the number of views by team users to shared links created by the team.
    pub shared_links_viewed_by_team: NumberPerDay,
    /// Array of the number of views by users outside of the team to shared links created by the
    /// team.
    pub shared_links_viewed_by_outside_user: NumberPerDay,
    /// Array of the number of views by non-logged-in users to shared links created by the team.
    pub shared_links_viewed_by_not_logged_in: NumberPerDay,
    /// Array of the total number of views to shared links created by the team.
    pub shared_links_viewed_total: NumberPerDay,
}

impl GetActivityReport {
    pub fn new(
        start_date: String,
        adds: NumberPerDay,
        edits: NumberPerDay,
        deletes: NumberPerDay,
        active_users_28_day: NumberPerDay,
        active_users_7_day: NumberPerDay,
        active_users_1_day: NumberPerDay,
        active_shared_folders_28_day: NumberPerDay,
        active_shared_folders_7_day: NumberPerDay,
        active_shared_folders_1_day: NumberPerDay,
        shared_links_created: NumberPerDay,
        shared_links_viewed_by_team: NumberPerDay,
        shared_links_viewed_by_outside_user: NumberPerDay,
        shared_links_viewed_by_not_logged_in: NumberPerDay,
        shared_links_viewed_total: NumberPerDay,
    ) -> Self {
        GetActivityReport {
            start_date,
            adds,
            edits,
            deletes,
            active_users_28_day,
            active_users_7_day,
            active_users_1_day,
            active_shared_folders_28_day,
            active_shared_folders_7_day,
            active_shared_folders_1_day,
            shared_links_created,
            shared_links_viewed_by_team,
            shared_links_viewed_by_outside_user,
            shared_links_viewed_by_not_logged_in,
            shared_links_viewed_total,
        }
    }

}

const GET_ACTIVITY_REPORT_FIELDS: &[&str] = &["start_date",
                                              "adds",
                                              "edits",
                                              "deletes",
                                              "active_users_28_day",
                                              "active_users_7_day",
                                              "active_users_1_day",
                                              "active_shared_folders_28_day",
                                              "active_shared_folders_7_day",
                                              "active_shared_folders_1_day",
                                              "shared_links_created",
                                              "shared_links_viewed_by_team",
                                              "shared_links_viewed_by_outside_user",
                                              "shared_links_viewed_by_not_logged_in",
                                              "shared_links_viewed_total"];
impl GetActivityReport {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GetActivityReport, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GetActivityReport>, V::Error> {
        use serde::de;
        let mut field_start_date = None;
        let mut field_adds = None;
        let mut field_edits = None;
        let mut field_deletes = None;
        let mut field_active_users_28_day = None;
        let mut field_active_users_7_day = None;
        let mut field_active_users_1_day = None;
        let mut field_active_shared_folders_28_day = None;
        let mut field_active_shared_folders_7_day = None;
        let mut field_active_shared_folders_1_day = None;
        let mut field_shared_links_created = None;
        let mut field_shared_links_viewed_by_team = None;
        let mut field_shared_links_viewed_by_outside_user = None;
        let mut field_shared_links_viewed_by_not_logged_in = None;
        let mut field_shared_links_viewed_total = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "adds" => {
                    if field_adds.is_some() {
                        return Err(de::Error::duplicate_field("adds"));
                    }
                    field_adds = Some(map.next_value()?);
                }
                "edits" => {
                    if field_edits.is_some() {
                        return Err(de::Error::duplicate_field("edits"));
                    }
                    field_edits = Some(map.next_value()?);
                }
                "deletes" => {
                    if field_deletes.is_some() {
                        return Err(de::Error::duplicate_field("deletes"));
                    }
                    field_deletes = Some(map.next_value()?);
                }
                "active_users_28_day" => {
                    if field_active_users_28_day.is_some() {
                        return Err(de::Error::duplicate_field("active_users_28_day"));
                    }
                    field_active_users_28_day = Some(map.next_value()?);
                }
                "active_users_7_day" => {
                    if field_active_users_7_day.is_some() {
                        return Err(de::Error::duplicate_field("active_users_7_day"));
                    }
                    field_active_users_7_day = Some(map.next_value()?);
                }
                "active_users_1_day" => {
                    if field_active_users_1_day.is_some() {
                        return Err(de::Error::duplicate_field("active_users_1_day"));
                    }
                    field_active_users_1_day = Some(map.next_value()?);
                }
                "active_shared_folders_28_day" => {
                    if field_active_shared_folders_28_day.is_some() {
                        return Err(de::Error::duplicate_field("active_shared_folders_28_day"));
                    }
                    field_active_shared_folders_28_day = Some(map.next_value()?);
                }
                "active_shared_folders_7_day" => {
                    if field_active_shared_folders_7_day.is_some() {
                        return Err(de::Error::duplicate_field("active_shared_folders_7_day"));
                    }
                    field_active_shared_folders_7_day = Some(map.next_value()?);
                }
                "active_shared_folders_1_day" => {
                    if field_active_shared_folders_1_day.is_some() {
                        return Err(de::Error::duplicate_field("active_shared_folders_1_day"));
                    }
                    field_active_shared_folders_1_day = Some(map.next_value()?);
                }
                "shared_links_created" => {
                    if field_shared_links_created.is_some() {
                        return Err(de::Error::duplicate_field("shared_links_created"));
                    }
                    field_shared_links_created = Some(map.next_value()?);
                }
                "shared_links_viewed_by_team" => {
                    if field_shared_links_viewed_by_team.is_some() {
                        return Err(de::Error::duplicate_field("shared_links_viewed_by_team"));
                    }
                    field_shared_links_viewed_by_team = Some(map.next_value()?);
                }
                "shared_links_viewed_by_outside_user" => {
                    if field_shared_links_viewed_by_outside_user.is_some() {
                        return Err(de::Error::duplicate_field("shared_links_viewed_by_outside_user"));
                    }
                    field_shared_links_viewed_by_outside_user = Some(map.next_value()?);
                }
                "shared_links_viewed_by_not_logged_in" => {
                    if field_shared_links_viewed_by_not_logged_in.is_some() {
                        return Err(de::Error::duplicate_field("shared_links_viewed_by_not_logged_in"));
                    }
                    field_shared_links_viewed_by_not_logged_in = Some(map.next_value()?);
                }
                "shared_links_viewed_total" => {
                    if field_shared_links_viewed_total.is_some() {
                        return Err(de::Error::duplicate_field("shared_links_viewed_total"));
                    }
                    field_shared_links_viewed_total = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_ACTIVITY_REPORT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GetActivityReport {
            start_date: field_start_date.ok_or_else(|| de::Error::missing_field("start_date"))?,
            adds: field_adds.ok_or_else(|| de::Error::missing_field("adds"))?,
            edits: field_edits.ok_or_else(|| de::Error::missing_field("edits"))?,
            deletes: field_deletes.ok_or_else(|| de::Error::missing_field("deletes"))?,
            active_users_28_day: field_active_users_28_day.ok_or_else(|| de::Error::missing_field("active_users_28_day"))?,
            active_users_7_day: field_active_users_7_day.ok_or_else(|| de::Error::missing_field("active_users_7_day"))?,
            active_users_1_day: field_active_users_1_day.ok_or_else(|| de::Error::missing_field("active_users_1_day"))?,
            active_shared_folders_28_day: field_active_shared_folders_28_day.ok_or_else(|| de::Error::missing_field("active_shared_folders_28_day"))?,
            active_shared_folders_7_day: field_active_shared_folders_7_day.ok_or_else(|| de::Error::missing_field("active_shared_folders_7_day"))?,
            active_shared_folders_1_day: field_active_shared_folders_1_day.ok_or_else(|| de::Error::missing_field("active_shared_folders_1_day"))?,
            shared_links_created: field_shared_links_created.ok_or_else(|| de::Error::missing_field("shared_links_created"))?,
            shared_links_viewed_by_team: field_shared_links_viewed_by_team.ok_or_else(|| de::Error::missing_field("shared_links_viewed_by_team"))?,
            shared_links_viewed_by_outside_user: field_shared_links_viewed_by_outside_user.ok_or_else(|| de::Error::missing_field("shared_links_viewed_by_outside_user"))?,
            shared_links_viewed_by_not_logged_in: field_shared_links_viewed_by_not_logged_in.ok_or_else(|| de::Error::missing_field("shared_links_viewed_by_not_logged_in"))?,
            shared_links_viewed_total: field_shared_links_viewed_total.ok_or_else(|| de::Error::missing_field("shared_links_viewed_total"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("adds", &self.adds)?;
        s.serialize_field("edits", &self.edits)?;
        s.serialize_field("deletes", &self.deletes)?;
        s.serialize_field("active_users_28_day", &self.active_users_28_day)?;
        s.serialize_field("active_users_7_day", &self.active_users_7_day)?;
        s.serialize_field("active_users_1_day", &self.active_users_1_day)?;
        s.serialize_field("active_shared_folders_28_day", &self.active_shared_folders_28_day)?;
        s.serialize_field("active_shared_folders_7_day", &self.active_shared_folders_7_day)?;
        s.serialize_field("active_shared_folders_1_day", &self.active_shared_folders_1_day)?;
        s.serialize_field("shared_links_created", &self.shared_links_created)?;
        s.serialize_field("shared_links_viewed_by_team", &self.shared_links_viewed_by_team)?;
        s.serialize_field("shared_links_viewed_by_outside_user", &self.shared_links_viewed_by_outside_user)?;
        s.serialize_field("shared_links_viewed_by_not_logged_in", &self.shared_links_viewed_by_not_logged_in)?;
        s.serialize_field("shared_links_viewed_total", &self.shared_links_viewed_total)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetActivityReport {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetActivityReport;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetActivityReport struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetActivityReport::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetActivityReport", GET_ACTIVITY_REPORT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetActivityReport {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetActivityReport", 15)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Devices Report Result. Contains subsections for different time ranges of activity. Each of the
/// items in each subsection of the storage report is an array of values, one value per day. If
/// there is no data for a day, then the value will be None.
#[derive(Debug)]
pub struct GetDevicesReport {
    /// First date present in the results as 'YYYY-MM-DD' or None.
    pub start_date: String,
    /// Report of the number of devices active in the last day.
    pub active_1_day: DevicesActive,
    /// Report of the number of devices active in the last 7 days.
    pub active_7_day: DevicesActive,
    /// Report of the number of devices active in the last 28 days.
    pub active_28_day: DevicesActive,
}

impl GetDevicesReport {
    pub fn new(
        start_date: String,
        active_1_day: DevicesActive,
        active_7_day: DevicesActive,
        active_28_day: DevicesActive,
    ) -> Self {
        GetDevicesReport {
            start_date,
            active_1_day,
            active_7_day,
            active_28_day,
        }
    }

}

const GET_DEVICES_REPORT_FIELDS: &[&str] = &["start_date",
                                             "active_1_day",
                                             "active_7_day",
                                             "active_28_day"];
impl GetDevicesReport {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GetDevicesReport, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GetDevicesReport>, V::Error> {
        use serde::de;
        let mut field_start_date = None;
        let mut field_active_1_day = None;
        let mut field_active_7_day = None;
        let mut field_active_28_day = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "active_1_day" => {
                    if field_active_1_day.is_some() {
                        return Err(de::Error::duplicate_field("active_1_day"));
                    }
                    field_active_1_day = Some(map.next_value()?);
                }
                "active_7_day" => {
                    if field_active_7_day.is_some() {
                        return Err(de::Error::duplicate_field("active_7_day"));
                    }
                    field_active_7_day = Some(map.next_value()?);
                }
                "active_28_day" => {
                    if field_active_28_day.is_some() {
                        return Err(de::Error::duplicate_field("active_28_day"));
                    }
                    field_active_28_day = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_DEVICES_REPORT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GetDevicesReport {
            start_date: field_start_date.ok_or_else(|| de::Error::missing_field("start_date"))?,
            active_1_day: field_active_1_day.ok_or_else(|| de::Error::missing_field("active_1_day"))?,
            active_7_day: field_active_7_day.ok_or_else(|| de::Error::missing_field("active_7_day"))?,
            active_28_day: field_active_28_day.ok_or_else(|| de::Error::missing_field("active_28_day"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("active_1_day", &self.active_1_day)?;
        s.serialize_field("active_7_day", &self.active_7_day)?;
        s.serialize_field("active_28_day", &self.active_28_day)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetDevicesReport {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetDevicesReport;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetDevicesReport struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetDevicesReport::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetDevicesReport", GET_DEVICES_REPORT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetDevicesReport {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetDevicesReport", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Membership Report Result. Each of the items in the storage report is an array of values, one
/// value per day. If there is no data for a day, then the value will be None.
#[derive(Debug)]
pub struct GetMembershipReport {
    /// First date present in the results as 'YYYY-MM-DD' or None.
    pub start_date: String,
    /// Team size, for each day.
    pub team_size: NumberPerDay,
    /// The number of pending invites to the team, for each day.
    pub pending_invites: NumberPerDay,
    /// The number of members that joined the team, for each day.
    pub members_joined: NumberPerDay,
    /// The number of suspended team members, for each day.
    pub suspended_members: NumberPerDay,
    /// The total number of licenses the team has, for each day.
    pub licenses: NumberPerDay,
}

impl GetMembershipReport {
    pub fn new(
        start_date: String,
        team_size: NumberPerDay,
        pending_invites: NumberPerDay,
        members_joined: NumberPerDay,
        suspended_members: NumberPerDay,
        licenses: NumberPerDay,
    ) -> Self {
        GetMembershipReport {
            start_date,
            team_size,
            pending_invites,
            members_joined,
            suspended_members,
            licenses,
        }
    }

}

const GET_MEMBERSHIP_REPORT_FIELDS: &[&str] = &["start_date",
                                                "team_size",
                                                "pending_invites",
                                                "members_joined",
                                                "suspended_members",
                                                "licenses"];
impl GetMembershipReport {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GetMembershipReport, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GetMembershipReport>, V::Error> {
        use serde::de;
        let mut field_start_date = None;
        let mut field_team_size = None;
        let mut field_pending_invites = None;
        let mut field_members_joined = None;
        let mut field_suspended_members = None;
        let mut field_licenses = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "team_size" => {
                    if field_team_size.is_some() {
                        return Err(de::Error::duplicate_field("team_size"));
                    }
                    field_team_size = Some(map.next_value()?);
                }
                "pending_invites" => {
                    if field_pending_invites.is_some() {
                        return Err(de::Error::duplicate_field("pending_invites"));
                    }
                    field_pending_invites = Some(map.next_value()?);
                }
                "members_joined" => {
                    if field_members_joined.is_some() {
                        return Err(de::Error::duplicate_field("members_joined"));
                    }
                    field_members_joined = Some(map.next_value()?);
                }
                "suspended_members" => {
                    if field_suspended_members.is_some() {
                        return Err(de::Error::duplicate_field("suspended_members"));
                    }
                    field_suspended_members = Some(map.next_value()?);
                }
                "licenses" => {
                    if field_licenses.is_some() {
                        return Err(de::Error::duplicate_field("licenses"));
                    }
                    field_licenses = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_MEMBERSHIP_REPORT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GetMembershipReport {
            start_date: field_start_date.ok_or_else(|| de::Error::missing_field("start_date"))?,
            team_size: field_team_size.ok_or_else(|| de::Error::missing_field("team_size"))?,
            pending_invites: field_pending_invites.ok_or_else(|| de::Error::missing_field("pending_invites"))?,
            members_joined: field_members_joined.ok_or_else(|| de::Error::missing_field("members_joined"))?,
            suspended_members: field_suspended_members.ok_or_else(|| de::Error::missing_field("suspended_members"))?,
            licenses: field_licenses.ok_or_else(|| de::Error::missing_field("licenses"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("team_size", &self.team_size)?;
        s.serialize_field("pending_invites", &self.pending_invites)?;
        s.serialize_field("members_joined", &self.members_joined)?;
        s.serialize_field("suspended_members", &self.suspended_members)?;
        s.serialize_field("licenses", &self.licenses)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetMembershipReport {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetMembershipReport;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetMembershipReport struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetMembershipReport::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetMembershipReport", GET_MEMBERSHIP_REPORT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetMembershipReport {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetMembershipReport", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Storage Report Result. Each of the items in the storage report is an array of values, one value
/// per day. If there is no data for a day, then the value will be None.
#[derive(Debug)]
pub struct GetStorageReport {
    /// First date present in the results as 'YYYY-MM-DD' or None.
    pub start_date: String,
    /// Sum of the shared, unshared, and datastore usages, for each day.
    pub total_usage: NumberPerDay,
    /// Array of the combined size (bytes) of team members' shared folders, for each day.
    pub shared_usage: NumberPerDay,
    /// Array of the combined size (bytes) of team members' root namespaces, for each day.
    pub unshared_usage: NumberPerDay,
    /// Array of the number of shared folders owned by team members, for each day.
    pub shared_folders: NumberPerDay,
    /// Array of storage summaries of team members' account sizes. Each storage summary is an array
    /// of key, value pairs, where each pair describes a storage bucket. The key indicates the upper
    /// bound of the bucket and the value is the number of users in that bucket. There is one such
    /// summary per day. If there is no data for a day, the storage summary will be empty.
    pub member_storage_map: Vec<Vec<StorageBucket>>,
}

impl GetStorageReport {
    pub fn new(
        start_date: String,
        total_usage: NumberPerDay,
        shared_usage: NumberPerDay,
        unshared_usage: NumberPerDay,
        shared_folders: NumberPerDay,
        member_storage_map: Vec<Vec<StorageBucket>>,
    ) -> Self {
        GetStorageReport {
            start_date,
            total_usage,
            shared_usage,
            unshared_usage,
            shared_folders,
            member_storage_map,
        }
    }

}

const GET_STORAGE_REPORT_FIELDS: &[&str] = &["start_date",
                                             "total_usage",
                                             "shared_usage",
                                             "unshared_usage",
                                             "shared_folders",
                                             "member_storage_map"];
impl GetStorageReport {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GetStorageReport, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GetStorageReport>, V::Error> {
        use serde::de;
        let mut field_start_date = None;
        let mut field_total_usage = None;
        let mut field_shared_usage = None;
        let mut field_unshared_usage = None;
        let mut field_shared_folders = None;
        let mut field_member_storage_map = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "start_date" => {
                    if field_start_date.is_some() {
                        return Err(de::Error::duplicate_field("start_date"));
                    }
                    field_start_date = Some(map.next_value()?);
                }
                "total_usage" => {
                    if field_total_usage.is_some() {
                        return Err(de::Error::duplicate_field("total_usage"));
                    }
                    field_total_usage = Some(map.next_value()?);
                }
                "shared_usage" => {
                    if field_shared_usage.is_some() {
                        return Err(de::Error::duplicate_field("shared_usage"));
                    }
                    field_shared_usage = Some(map.next_value()?);
                }
                "unshared_usage" => {
                    if field_unshared_usage.is_some() {
                        return Err(de::Error::duplicate_field("unshared_usage"));
                    }
                    field_unshared_usage = Some(map.next_value()?);
                }
                "shared_folders" => {
                    if field_shared_folders.is_some() {
                        return Err(de::Error::duplicate_field("shared_folders"));
                    }
                    field_shared_folders = Some(map.next_value()?);
                }
                "member_storage_map" => {
                    if field_member_storage_map.is_some() {
                        return Err(de::Error::duplicate_field("member_storage_map"));
                    }
                    field_member_storage_map = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GET_STORAGE_REPORT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GetStorageReport {
            start_date: field_start_date.ok_or_else(|| de::Error::missing_field("start_date"))?,
            total_usage: field_total_usage.ok_or_else(|| de::Error::missing_field("total_usage"))?,
            shared_usage: field_shared_usage.ok_or_else(|| de::Error::missing_field("shared_usage"))?,
            unshared_usage: field_unshared_usage.ok_or_else(|| de::Error::missing_field("unshared_usage"))?,
            shared_folders: field_shared_folders.ok_or_else(|| de::Error::missing_field("shared_folders"))?,
            member_storage_map: field_member_storage_map.ok_or_else(|| de::Error::missing_field("member_storage_map"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("start_date", &self.start_date)?;
        s.serialize_field("total_usage", &self.total_usage)?;
        s.serialize_field("shared_usage", &self.shared_usage)?;
        s.serialize_field("unshared_usage", &self.unshared_usage)?;
        s.serialize_field("shared_folders", &self.shared_folders)?;
        s.serialize_field("member_storage_map", &self.member_storage_map)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GetStorageReport {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GetStorageReport;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GetStorageReport struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GetStorageReport::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GetStorageReport", GET_STORAGE_REPORT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GetStorageReport {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GetStorageReport", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Role of a user in group.
#[derive(Debug)]
pub enum GroupAccessType {
    /// User is a member of the group, but has no special permissions.
    Member,
    /// User can rename the group, and add/remove members.
    Owner,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupAccessType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupAccessType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupAccessType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "member" => Ok(GroupAccessType::Member),
                    "owner" => Ok(GroupAccessType::Owner),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["member",
                                    "owner"];
        deserializer.deserialize_struct("GroupAccessType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupAccessType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupAccessType::Member => {
                // unit
                let mut s = serializer.serialize_struct("GroupAccessType", 1)?;
                s.serialize_field(".tag", "member")?;
                s.end()
            }
            GroupAccessType::Owner => {
                // unit
                let mut s = serializer.serialize_struct("GroupAccessType", 1)?;
                s.serialize_field(".tag", "owner")?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub struct GroupCreateArg {
    /// Group name.
    pub group_name: String,
    /// The creator of a team can associate an arbitrary external ID to the group.
    pub group_external_id: Option<super::team_common::GroupExternalId>,
    /// Whether the team can be managed by selected users, or only by team admins.
    pub group_management_type: Option<super::team_common::GroupManagementType>,
}

impl GroupCreateArg {
    pub fn new(group_name: String) -> Self {
        GroupCreateArg {
            group_name,
            group_external_id: None,
            group_management_type: None,
        }
    }

    pub fn with_group_external_id(
        mut self,
        value: Option<super::team_common::GroupExternalId>,
    ) -> Self {
        self.group_external_id = value;
        self
    }

    pub fn with_group_management_type(
        mut self,
        value: Option<super::team_common::GroupManagementType>,
    ) -> Self {
        self.group_management_type = value;
        self
    }

}

const GROUP_CREATE_ARG_FIELDS: &[&str] = &["group_name",
                                           "group_external_id",
                                           "group_management_type"];
impl GroupCreateArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupCreateArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupCreateArg>, V::Error> {
        use serde::de;
        let mut field_group_name = None;
        let mut field_group_external_id = None;
        let mut field_group_management_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group_name" => {
                    if field_group_name.is_some() {
                        return Err(de::Error::duplicate_field("group_name"));
                    }
                    field_group_name = Some(map.next_value()?);
                }
                "group_external_id" => {
                    if field_group_external_id.is_some() {
                        return Err(de::Error::duplicate_field("group_external_id"));
                    }
                    field_group_external_id = Some(map.next_value()?);
                }
                "group_management_type" => {
                    if field_group_management_type.is_some() {
                        return Err(de::Error::duplicate_field("group_management_type"));
                    }
                    field_group_management_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_CREATE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupCreateArg {
            group_name: field_group_name.ok_or_else(|| de::Error::missing_field("group_name"))?,
            group_external_id: field_group_external_id,
            group_management_type: field_group_management_type,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group_name", &self.group_name)?;
        s.serialize_field("group_external_id", &self.group_external_id)?;
        s.serialize_field("group_management_type", &self.group_management_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupCreateArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupCreateArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupCreateArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupCreateArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupCreateArg", GROUP_CREATE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupCreateArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupCreateArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupCreateError {
    /// The requested group name is already being used by another group.
    GroupNameAlreadyUsed,
    /// Group name is empty or has invalid characters.
    GroupNameInvalid,
    /// The requested external ID is already being used by another group.
    ExternalIdAlreadyInUse,
    /// System-managed group cannot be manually created.
    SystemManagedGroupDisallowed,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupCreateError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupCreateError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupCreateError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_name_already_used" => Ok(GroupCreateError::GroupNameAlreadyUsed),
                    "group_name_invalid" => Ok(GroupCreateError::GroupNameInvalid),
                    "external_id_already_in_use" => Ok(GroupCreateError::ExternalIdAlreadyInUse),
                    "system_managed_group_disallowed" => Ok(GroupCreateError::SystemManagedGroupDisallowed),
                    _ => Ok(GroupCreateError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_name_already_used",
                                    "group_name_invalid",
                                    "external_id_already_in_use",
                                    "system_managed_group_disallowed",
                                    "other"];
        deserializer.deserialize_struct("GroupCreateError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupCreateError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupCreateError::GroupNameAlreadyUsed => {
                // unit
                let mut s = serializer.serialize_struct("GroupCreateError", 1)?;
                s.serialize_field(".tag", "group_name_already_used")?;
                s.end()
            }
            GroupCreateError::GroupNameInvalid => {
                // unit
                let mut s = serializer.serialize_struct("GroupCreateError", 1)?;
                s.serialize_field(".tag", "group_name_invalid")?;
                s.end()
            }
            GroupCreateError::ExternalIdAlreadyInUse => {
                // unit
                let mut s = serializer.serialize_struct("GroupCreateError", 1)?;
                s.serialize_field(".tag", "external_id_already_in_use")?;
                s.end()
            }
            GroupCreateError::SystemManagedGroupDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("GroupCreateError", 1)?;
                s.serialize_field(".tag", "system_managed_group_disallowed")?;
                s.end()
            }
            GroupCreateError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupCreateError {
    fn description(&self) -> &str {
        "GroupCreateError"
    }
}

impl ::std::fmt::Display for GroupCreateError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum GroupDeleteError {
    /// No matching group found. No groups match the specified group ID.
    GroupNotFound,
    Other,
    /// This operation is not supported on system-managed groups.
    SystemManagedGroupDisallowed,
    /// This group has already been deleted.
    GroupAlreadyDeleted,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupDeleteError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupDeleteError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupDeleteError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_found" => Ok(GroupDeleteError::GroupNotFound),
                    "system_managed_group_disallowed" => Ok(GroupDeleteError::SystemManagedGroupDisallowed),
                    "group_already_deleted" => Ok(GroupDeleteError::GroupAlreadyDeleted),
                    _ => Ok(GroupDeleteError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_found",
                                    "other",
                                    "system_managed_group_disallowed",
                                    "group_already_deleted"];
        deserializer.deserialize_struct("GroupDeleteError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupDeleteError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupDeleteError::GroupNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GroupDeleteError", 1)?;
                s.serialize_field(".tag", "group_not_found")?;
                s.end()
            }
            GroupDeleteError::SystemManagedGroupDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("GroupDeleteError", 1)?;
                s.serialize_field(".tag", "system_managed_group_disallowed")?;
                s.end()
            }
            GroupDeleteError::GroupAlreadyDeleted => {
                // unit
                let mut s = serializer.serialize_struct("GroupDeleteError", 1)?;
                s.serialize_field(".tag", "group_already_deleted")?;
                s.end()
            }
            GroupDeleteError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupDeleteError {
    fn description(&self) -> &str {
        "GroupDeleteError"
    }
}

impl ::std::fmt::Display for GroupDeleteError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Full description of a group.
#[derive(Debug)]
pub struct GroupFullInfo {
    pub group_name: String,
    pub group_id: super::team_common::GroupId,
    /// Who is allowed to manage the group.
    pub group_management_type: super::team_common::GroupManagementType,
    /// The group creation time as a UTC timestamp in milliseconds since the Unix epoch.
    pub created: u64,
    /// External ID of group. This is an arbitrary ID that an admin can attach to a group.
    pub group_external_id: Option<super::team_common::GroupExternalId>,
    /// The number of members in the group.
    pub member_count: Option<u32>,
    /// List of group members.
    pub members: Option<Vec<GroupMemberInfo>>,
}

impl GroupFullInfo {
    pub fn new(
        group_name: String,
        group_id: super::team_common::GroupId,
        group_management_type: super::team_common::GroupManagementType,
        created: u64,
    ) -> Self {
        GroupFullInfo {
            group_name,
            group_id,
            group_management_type,
            created,
            group_external_id: None,
            member_count: None,
            members: None,
        }
    }

    pub fn with_group_external_id(
        mut self,
        value: Option<super::team_common::GroupExternalId>,
    ) -> Self {
        self.group_external_id = value;
        self
    }

    pub fn with_member_count(mut self, value: Option<u32>) -> Self {
        self.member_count = value;
        self
    }

    pub fn with_members(mut self, value: Option<Vec<GroupMemberInfo>>) -> Self {
        self.members = value;
        self
    }

}

const GROUP_FULL_INFO_FIELDS: &[&str] = &["group_name",
                                          "group_id",
                                          "group_management_type",
                                          "created",
                                          "group_external_id",
                                          "member_count",
                                          "members"];
impl GroupFullInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupFullInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupFullInfo>, V::Error> {
        use serde::de;
        let mut field_group_name = None;
        let mut field_group_id = None;
        let mut field_group_management_type = None;
        let mut field_created = None;
        let mut field_group_external_id = None;
        let mut field_member_count = None;
        let mut field_members = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group_name" => {
                    if field_group_name.is_some() {
                        return Err(de::Error::duplicate_field("group_name"));
                    }
                    field_group_name = Some(map.next_value()?);
                }
                "group_id" => {
                    if field_group_id.is_some() {
                        return Err(de::Error::duplicate_field("group_id"));
                    }
                    field_group_id = Some(map.next_value()?);
                }
                "group_management_type" => {
                    if field_group_management_type.is_some() {
                        return Err(de::Error::duplicate_field("group_management_type"));
                    }
                    field_group_management_type = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "group_external_id" => {
                    if field_group_external_id.is_some() {
                        return Err(de::Error::duplicate_field("group_external_id"));
                    }
                    field_group_external_id = Some(map.next_value()?);
                }
                "member_count" => {
                    if field_member_count.is_some() {
                        return Err(de::Error::duplicate_field("member_count"));
                    }
                    field_member_count = Some(map.next_value()?);
                }
                "members" => {
                    if field_members.is_some() {
                        return Err(de::Error::duplicate_field("members"));
                    }
                    field_members = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_FULL_INFO_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupFullInfo {
            group_name: field_group_name.ok_or_else(|| de::Error::missing_field("group_name"))?,
            group_id: field_group_id.ok_or_else(|| de::Error::missing_field("group_id"))?,
            group_management_type: field_group_management_type.ok_or_else(|| de::Error::missing_field("group_management_type"))?,
            created: field_created.ok_or_else(|| de::Error::missing_field("created"))?,
            group_external_id: field_group_external_id,
            member_count: field_member_count,
            members: field_members,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group_name", &self.group_name)?;
        s.serialize_field("group_id", &self.group_id)?;
        s.serialize_field("group_management_type", &self.group_management_type)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("group_external_id", &self.group_external_id)?;
        s.serialize_field("member_count", &self.member_count)?;
        s.serialize_field("members", &self.members)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupFullInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupFullInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupFullInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupFullInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupFullInfo", GROUP_FULL_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupFullInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupFullInfo", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Profile of group member, and role in group.
#[derive(Debug)]
pub struct GroupMemberInfo {
    /// Profile of group member.
    pub profile: MemberProfile,
    /// The role that the user has in the group.
    pub access_type: GroupAccessType,
}

impl GroupMemberInfo {
    pub fn new(profile: MemberProfile, access_type: GroupAccessType) -> Self {
        GroupMemberInfo {
            profile,
            access_type,
        }
    }

}

const GROUP_MEMBER_INFO_FIELDS: &[&str] = &["profile",
                                            "access_type"];
impl GroupMemberInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupMemberInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupMemberInfo>, V::Error> {
        use serde::de;
        let mut field_profile = None;
        let mut field_access_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "profile" => {
                    if field_profile.is_some() {
                        return Err(de::Error::duplicate_field("profile"));
                    }
                    field_profile = Some(map.next_value()?);
                }
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_MEMBER_INFO_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupMemberInfo {
            profile: field_profile.ok_or_else(|| de::Error::missing_field("profile"))?,
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("profile", &self.profile)?;
        s.serialize_field("access_type", &self.access_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMemberInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMemberInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMemberInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMemberInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMemberInfo", GROUP_MEMBER_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMemberInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMemberInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Argument for selecting a group and a single user.
#[derive(Debug)]
pub struct GroupMemberSelector {
    /// Specify a group.
    pub group: GroupSelector,
    /// Identity of a user that is a member of `group`.
    pub user: UserSelectorArg,
}

impl GroupMemberSelector {
    pub fn new(group: GroupSelector, user: UserSelectorArg) -> Self {
        GroupMemberSelector {
            group,
            user,
        }
    }

}

const GROUP_MEMBER_SELECTOR_FIELDS: &[&str] = &["group",
                                                "user"];
impl GroupMemberSelector {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupMemberSelector, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupMemberSelector>, V::Error> {
        use serde::de;
        let mut field_group = None;
        let mut field_user = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group" => {
                    if field_group.is_some() {
                        return Err(de::Error::duplicate_field("group"));
                    }
                    field_group = Some(map.next_value()?);
                }
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_MEMBER_SELECTOR_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupMemberSelector {
            group: field_group.ok_or_else(|| de::Error::missing_field("group"))?,
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group", &self.group)?;
        s.serialize_field("user", &self.user)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMemberSelector {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMemberSelector;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMemberSelector struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMemberSelector::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMemberSelector", GROUP_MEMBER_SELECTOR_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMemberSelector {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMemberSelector", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error that can be raised when [`GroupMemberSelector`](GroupMemberSelector) is used, and the user
/// is required to be a member of the specified group.
#[derive(Debug)]
pub enum GroupMemberSelectorError {
    /// No matching group found. No groups match the specified group ID.
    GroupNotFound,
    Other,
    /// This operation is not supported on system-managed groups.
    SystemManagedGroupDisallowed,
    /// The specified user is not a member of this group.
    MemberNotInGroup,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMemberSelectorError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupMemberSelectorError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMemberSelectorError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_found" => Ok(GroupMemberSelectorError::GroupNotFound),
                    "system_managed_group_disallowed" => Ok(GroupMemberSelectorError::SystemManagedGroupDisallowed),
                    "member_not_in_group" => Ok(GroupMemberSelectorError::MemberNotInGroup),
                    _ => Ok(GroupMemberSelectorError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_found",
                                    "other",
                                    "system_managed_group_disallowed",
                                    "member_not_in_group"];
        deserializer.deserialize_struct("GroupMemberSelectorError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMemberSelectorError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupMemberSelectorError::GroupNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GroupMemberSelectorError", 1)?;
                s.serialize_field(".tag", "group_not_found")?;
                s.end()
            }
            GroupMemberSelectorError::SystemManagedGroupDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("GroupMemberSelectorError", 1)?;
                s.serialize_field(".tag", "system_managed_group_disallowed")?;
                s.end()
            }
            GroupMemberSelectorError::MemberNotInGroup => {
                // unit
                let mut s = serializer.serialize_struct("GroupMemberSelectorError", 1)?;
                s.serialize_field(".tag", "member_not_in_group")?;
                s.end()
            }
            GroupMemberSelectorError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupMemberSelectorError {
    fn description(&self) -> &str {
        "GroupMemberSelectorError"
    }
}

impl ::std::fmt::Display for GroupMemberSelectorError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum GroupMemberSetAccessTypeError {
    /// No matching group found. No groups match the specified group ID.
    GroupNotFound,
    Other,
    /// This operation is not supported on system-managed groups.
    SystemManagedGroupDisallowed,
    /// The specified user is not a member of this group.
    MemberNotInGroup,
    /// A company managed group cannot be managed by a user.
    UserCannotBeManagerOfCompanyManagedGroup,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMemberSetAccessTypeError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupMemberSetAccessTypeError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMemberSetAccessTypeError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_found" => Ok(GroupMemberSetAccessTypeError::GroupNotFound),
                    "system_managed_group_disallowed" => Ok(GroupMemberSetAccessTypeError::SystemManagedGroupDisallowed),
                    "member_not_in_group" => Ok(GroupMemberSetAccessTypeError::MemberNotInGroup),
                    "user_cannot_be_manager_of_company_managed_group" => Ok(GroupMemberSetAccessTypeError::UserCannotBeManagerOfCompanyManagedGroup),
                    _ => Ok(GroupMemberSetAccessTypeError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_found",
                                    "other",
                                    "system_managed_group_disallowed",
                                    "member_not_in_group",
                                    "user_cannot_be_manager_of_company_managed_group"];
        deserializer.deserialize_struct("GroupMemberSetAccessTypeError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMemberSetAccessTypeError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupMemberSetAccessTypeError::GroupNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GroupMemberSetAccessTypeError", 1)?;
                s.serialize_field(".tag", "group_not_found")?;
                s.end()
            }
            GroupMemberSetAccessTypeError::SystemManagedGroupDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("GroupMemberSetAccessTypeError", 1)?;
                s.serialize_field(".tag", "system_managed_group_disallowed")?;
                s.end()
            }
            GroupMemberSetAccessTypeError::MemberNotInGroup => {
                // unit
                let mut s = serializer.serialize_struct("GroupMemberSetAccessTypeError", 1)?;
                s.serialize_field(".tag", "member_not_in_group")?;
                s.end()
            }
            GroupMemberSetAccessTypeError::UserCannotBeManagerOfCompanyManagedGroup => {
                // unit
                let mut s = serializer.serialize_struct("GroupMemberSetAccessTypeError", 1)?;
                s.serialize_field(".tag", "user_cannot_be_manager_of_company_managed_group")?;
                s.end()
            }
            GroupMemberSetAccessTypeError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupMemberSetAccessTypeError {
    fn description(&self) -> &str {
        "GroupMemberSetAccessTypeError"
    }
}

impl ::std::fmt::Display for GroupMemberSetAccessTypeError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GroupMembersAddArg {
    /// Group to which users will be added.
    pub group: GroupSelector,
    /// List of users to be added to the group.
    pub members: Vec<MemberAccess>,
    /// Whether to return the list of members in the group.  Note that the default value will cause
    /// all the group members  to be returned in the response. This may take a long time for large
    /// groups.
    pub return_members: bool,
}

impl GroupMembersAddArg {
    pub fn new(group: GroupSelector, members: Vec<MemberAccess>) -> Self {
        GroupMembersAddArg {
            group,
            members,
            return_members: true,
        }
    }

    pub fn with_return_members(mut self, value: bool) -> Self {
        self.return_members = value;
        self
    }

}

const GROUP_MEMBERS_ADD_ARG_FIELDS: &[&str] = &["group",
                                                "members",
                                                "return_members"];
impl GroupMembersAddArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupMembersAddArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupMembersAddArg>, V::Error> {
        use serde::de;
        let mut field_group = None;
        let mut field_members = None;
        let mut field_return_members = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group" => {
                    if field_group.is_some() {
                        return Err(de::Error::duplicate_field("group"));
                    }
                    field_group = Some(map.next_value()?);
                }
                "members" => {
                    if field_members.is_some() {
                        return Err(de::Error::duplicate_field("members"));
                    }
                    field_members = Some(map.next_value()?);
                }
                "return_members" => {
                    if field_return_members.is_some() {
                        return Err(de::Error::duplicate_field("return_members"));
                    }
                    field_return_members = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_MEMBERS_ADD_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupMembersAddArg {
            group: field_group.ok_or_else(|| de::Error::missing_field("group"))?,
            members: field_members.ok_or_else(|| de::Error::missing_field("members"))?,
            return_members: field_return_members.unwrap_or(true),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group", &self.group)?;
        s.serialize_field("members", &self.members)?;
        s.serialize_field("return_members", &self.return_members)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMembersAddArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMembersAddArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMembersAddArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMembersAddArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMembersAddArg", GROUP_MEMBERS_ADD_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMembersAddArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMembersAddArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupMembersAddError {
    /// No matching group found. No groups match the specified group ID.
    GroupNotFound,
    Other,
    /// This operation is not supported on system-managed groups.
    SystemManagedGroupDisallowed,
    /// You cannot add duplicate users. One or more of the members you are trying to add is already
    /// a member of the group.
    DuplicateUser,
    /// Group is not in this team. You cannot add members to a group that is outside of your team.
    GroupNotInTeam,
    /// These members are not part of your team. Currently, you cannot add members to a group if
    /// they are not part of your team, though this may change in a subsequent version. To add new
    /// members to your Dropbox Business team, use the [`members_add()`](members_add) endpoint.
    MembersNotInTeam(Vec<String>),
    /// These users were not found in Dropbox.
    UsersNotFound(Vec<String>),
    /// A suspended user cannot be added to a group as
    /// [`GroupAccessType::Owner`](GroupAccessType::Owner).
    UserMustBeActiveToBeOwner,
    /// A company-managed group cannot be managed by a user.
    UserCannotBeManagerOfCompanyManagedGroup(Vec<String>),
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMembersAddError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupMembersAddError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMembersAddError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_found" => Ok(GroupMembersAddError::GroupNotFound),
                    "system_managed_group_disallowed" => Ok(GroupMembersAddError::SystemManagedGroupDisallowed),
                    "duplicate_user" => Ok(GroupMembersAddError::DuplicateUser),
                    "group_not_in_team" => Ok(GroupMembersAddError::GroupNotInTeam),
                    "members_not_in_team" => {
                        match map.next_key()? {
                            Some("members_not_in_team") => Ok(GroupMembersAddError::MembersNotInTeam(map.next_value()?)),
                            None => Err(de::Error::missing_field("members_not_in_team")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "users_not_found" => {
                        match map.next_key()? {
                            Some("users_not_found") => Ok(GroupMembersAddError::UsersNotFound(map.next_value()?)),
                            None => Err(de::Error::missing_field("users_not_found")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "user_must_be_active_to_be_owner" => Ok(GroupMembersAddError::UserMustBeActiveToBeOwner),
                    "user_cannot_be_manager_of_company_managed_group" => {
                        match map.next_key()? {
                            Some("user_cannot_be_manager_of_company_managed_group") => Ok(GroupMembersAddError::UserCannotBeManagerOfCompanyManagedGroup(map.next_value()?)),
                            None => Err(de::Error::missing_field("user_cannot_be_manager_of_company_managed_group")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(GroupMembersAddError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_found",
                                    "other",
                                    "system_managed_group_disallowed",
                                    "duplicate_user",
                                    "group_not_in_team",
                                    "members_not_in_team",
                                    "users_not_found",
                                    "user_must_be_active_to_be_owner",
                                    "user_cannot_be_manager_of_company_managed_group"];
        deserializer.deserialize_struct("GroupMembersAddError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMembersAddError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupMembersAddError::GroupNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersAddError", 1)?;
                s.serialize_field(".tag", "group_not_found")?;
                s.end()
            }
            GroupMembersAddError::SystemManagedGroupDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersAddError", 1)?;
                s.serialize_field(".tag", "system_managed_group_disallowed")?;
                s.end()
            }
            GroupMembersAddError::DuplicateUser => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersAddError", 1)?;
                s.serialize_field(".tag", "duplicate_user")?;
                s.end()
            }
            GroupMembersAddError::GroupNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersAddError", 1)?;
                s.serialize_field(".tag", "group_not_in_team")?;
                s.end()
            }
            GroupMembersAddError::MembersNotInTeam(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupMembersAddError", 2)?;
                s.serialize_field(".tag", "members_not_in_team")?;
                s.serialize_field("members_not_in_team", x)?;
                s.end()
            }
            GroupMembersAddError::UsersNotFound(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupMembersAddError", 2)?;
                s.serialize_field(".tag", "users_not_found")?;
                s.serialize_field("users_not_found", x)?;
                s.end()
            }
            GroupMembersAddError::UserMustBeActiveToBeOwner => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersAddError", 1)?;
                s.serialize_field(".tag", "user_must_be_active_to_be_owner")?;
                s.end()
            }
            GroupMembersAddError::UserCannotBeManagerOfCompanyManagedGroup(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupMembersAddError", 2)?;
                s.serialize_field(".tag", "user_cannot_be_manager_of_company_managed_group")?;
                s.serialize_field("user_cannot_be_manager_of_company_managed_group", x)?;
                s.end()
            }
            GroupMembersAddError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupMembersAddError {
    fn description(&self) -> &str {
        "GroupMembersAddError"
    }
}

impl ::std::fmt::Display for GroupMembersAddError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Result returned by [`groups_members_add()`](groups_members_add) and
/// [`groups_members_remove()`](groups_members_remove).
#[derive(Debug)]
pub struct GroupMembersChangeResult {
    /// The group info after member change operation has been performed.
    pub group_info: GroupFullInfo,
    /// An ID that can be used to obtain the status of granting/revoking group-owned resources.
    pub async_job_id: super::async::AsyncJobId,
}

impl GroupMembersChangeResult {
    pub fn new(group_info: GroupFullInfo, async_job_id: super::async::AsyncJobId) -> Self {
        GroupMembersChangeResult {
            group_info,
            async_job_id,
        }
    }

}

const GROUP_MEMBERS_CHANGE_RESULT_FIELDS: &[&str] = &["group_info",
                                                      "async_job_id"];
impl GroupMembersChangeResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupMembersChangeResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupMembersChangeResult>, V::Error> {
        use serde::de;
        let mut field_group_info = None;
        let mut field_async_job_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group_info" => {
                    if field_group_info.is_some() {
                        return Err(de::Error::duplicate_field("group_info"));
                    }
                    field_group_info = Some(map.next_value()?);
                }
                "async_job_id" => {
                    if field_async_job_id.is_some() {
                        return Err(de::Error::duplicate_field("async_job_id"));
                    }
                    field_async_job_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_MEMBERS_CHANGE_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupMembersChangeResult {
            group_info: field_group_info.ok_or_else(|| de::Error::missing_field("group_info"))?,
            async_job_id: field_async_job_id.ok_or_else(|| de::Error::missing_field("async_job_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group_info", &self.group_info)?;
        s.serialize_field("async_job_id", &self.async_job_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMembersChangeResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMembersChangeResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMembersChangeResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMembersChangeResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMembersChangeResult", GROUP_MEMBERS_CHANGE_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMembersChangeResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMembersChangeResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupMembersRemoveArg {
    /// Group from which users will be removed.
    pub group: GroupSelector,
    /// List of users to be removed from the group.
    pub users: Vec<UserSelectorArg>,
    /// Whether to return the list of members in the group.  Note that the default value will cause
    /// all the group members  to be returned in the response. This may take a long time for large
    /// groups.
    pub return_members: bool,
}

impl GroupMembersRemoveArg {
    pub fn new(group: GroupSelector, users: Vec<UserSelectorArg>) -> Self {
        GroupMembersRemoveArg {
            group,
            users,
            return_members: true,
        }
    }

    pub fn with_return_members(mut self, value: bool) -> Self {
        self.return_members = value;
        self
    }

}

const GROUP_MEMBERS_REMOVE_ARG_FIELDS: &[&str] = &["group",
                                                   "users",
                                                   "return_members"];
impl GroupMembersRemoveArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupMembersRemoveArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupMembersRemoveArg>, V::Error> {
        use serde::de;
        let mut field_group = None;
        let mut field_users = None;
        let mut field_return_members = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group" => {
                    if field_group.is_some() {
                        return Err(de::Error::duplicate_field("group"));
                    }
                    field_group = Some(map.next_value()?);
                }
                "users" => {
                    if field_users.is_some() {
                        return Err(de::Error::duplicate_field("users"));
                    }
                    field_users = Some(map.next_value()?);
                }
                "return_members" => {
                    if field_return_members.is_some() {
                        return Err(de::Error::duplicate_field("return_members"));
                    }
                    field_return_members = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_MEMBERS_REMOVE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupMembersRemoveArg {
            group: field_group.ok_or_else(|| de::Error::missing_field("group"))?,
            users: field_users.ok_or_else(|| de::Error::missing_field("users"))?,
            return_members: field_return_members.unwrap_or(true),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group", &self.group)?;
        s.serialize_field("users", &self.users)?;
        s.serialize_field("return_members", &self.return_members)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMembersRemoveArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMembersRemoveArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMembersRemoveArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMembersRemoveArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMembersRemoveArg", GROUP_MEMBERS_REMOVE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMembersRemoveArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMembersRemoveArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupMembersRemoveError {
    /// No matching group found. No groups match the specified group ID.
    GroupNotFound,
    Other,
    /// This operation is not supported on system-managed groups.
    SystemManagedGroupDisallowed,
    /// At least one of the specified users is not a member of the group.
    MemberNotInGroup,
    /// Group is not in this team. You cannot remove members from a group that is outside of your
    /// team.
    GroupNotInTeam,
    /// These members are not part of your team.
    MembersNotInTeam(Vec<String>),
    /// These users were not found in Dropbox.
    UsersNotFound(Vec<String>),
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMembersRemoveError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupMembersRemoveError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMembersRemoveError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_found" => Ok(GroupMembersRemoveError::GroupNotFound),
                    "system_managed_group_disallowed" => Ok(GroupMembersRemoveError::SystemManagedGroupDisallowed),
                    "member_not_in_group" => Ok(GroupMembersRemoveError::MemberNotInGroup),
                    "group_not_in_team" => Ok(GroupMembersRemoveError::GroupNotInTeam),
                    "members_not_in_team" => {
                        match map.next_key()? {
                            Some("members_not_in_team") => Ok(GroupMembersRemoveError::MembersNotInTeam(map.next_value()?)),
                            None => Err(de::Error::missing_field("members_not_in_team")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "users_not_found" => {
                        match map.next_key()? {
                            Some("users_not_found") => Ok(GroupMembersRemoveError::UsersNotFound(map.next_value()?)),
                            None => Err(de::Error::missing_field("users_not_found")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(GroupMembersRemoveError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_found",
                                    "other",
                                    "system_managed_group_disallowed",
                                    "member_not_in_group",
                                    "group_not_in_team",
                                    "members_not_in_team",
                                    "users_not_found"];
        deserializer.deserialize_struct("GroupMembersRemoveError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMembersRemoveError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupMembersRemoveError::GroupNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersRemoveError", 1)?;
                s.serialize_field(".tag", "group_not_found")?;
                s.end()
            }
            GroupMembersRemoveError::SystemManagedGroupDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersRemoveError", 1)?;
                s.serialize_field(".tag", "system_managed_group_disallowed")?;
                s.end()
            }
            GroupMembersRemoveError::MemberNotInGroup => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersRemoveError", 1)?;
                s.serialize_field(".tag", "member_not_in_group")?;
                s.end()
            }
            GroupMembersRemoveError::GroupNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersRemoveError", 1)?;
                s.serialize_field(".tag", "group_not_in_team")?;
                s.end()
            }
            GroupMembersRemoveError::MembersNotInTeam(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupMembersRemoveError", 2)?;
                s.serialize_field(".tag", "members_not_in_team")?;
                s.serialize_field("members_not_in_team", x)?;
                s.end()
            }
            GroupMembersRemoveError::UsersNotFound(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupMembersRemoveError", 2)?;
                s.serialize_field(".tag", "users_not_found")?;
                s.serialize_field("users_not_found", x)?;
                s.end()
            }
            GroupMembersRemoveError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupMembersRemoveError {
    fn description(&self) -> &str {
        "GroupMembersRemoveError"
    }
}

impl ::std::fmt::Display for GroupMembersRemoveError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Argument for selecting a group and a list of users.
#[derive(Debug)]
pub struct GroupMembersSelector {
    /// Specify a group.
    pub group: GroupSelector,
    /// A list of users that are members of `group`.
    pub users: UsersSelectorArg,
}

impl GroupMembersSelector {
    pub fn new(group: GroupSelector, users: UsersSelectorArg) -> Self {
        GroupMembersSelector {
            group,
            users,
        }
    }

}

const GROUP_MEMBERS_SELECTOR_FIELDS: &[&str] = &["group",
                                                 "users"];
impl GroupMembersSelector {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupMembersSelector, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupMembersSelector>, V::Error> {
        use serde::de;
        let mut field_group = None;
        let mut field_users = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group" => {
                    if field_group.is_some() {
                        return Err(de::Error::duplicate_field("group"));
                    }
                    field_group = Some(map.next_value()?);
                }
                "users" => {
                    if field_users.is_some() {
                        return Err(de::Error::duplicate_field("users"));
                    }
                    field_users = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_MEMBERS_SELECTOR_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupMembersSelector {
            group: field_group.ok_or_else(|| de::Error::missing_field("group"))?,
            users: field_users.ok_or_else(|| de::Error::missing_field("users"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group", &self.group)?;
        s.serialize_field("users", &self.users)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMembersSelector {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMembersSelector;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMembersSelector struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMembersSelector::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMembersSelector", GROUP_MEMBERS_SELECTOR_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMembersSelector {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMembersSelector", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error that can be raised when [`GroupMembersSelector`](GroupMembersSelector) is used, and the
/// users are required to be members of the specified group.
#[derive(Debug)]
pub enum GroupMembersSelectorError {
    /// No matching group found. No groups match the specified group ID.
    GroupNotFound,
    Other,
    /// This operation is not supported on system-managed groups.
    SystemManagedGroupDisallowed,
    /// At least one of the specified users is not a member of the group.
    MemberNotInGroup,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMembersSelectorError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupMembersSelectorError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMembersSelectorError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_found" => Ok(GroupMembersSelectorError::GroupNotFound),
                    "system_managed_group_disallowed" => Ok(GroupMembersSelectorError::SystemManagedGroupDisallowed),
                    "member_not_in_group" => Ok(GroupMembersSelectorError::MemberNotInGroup),
                    _ => Ok(GroupMembersSelectorError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_found",
                                    "other",
                                    "system_managed_group_disallowed",
                                    "member_not_in_group"];
        deserializer.deserialize_struct("GroupMembersSelectorError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMembersSelectorError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupMembersSelectorError::GroupNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersSelectorError", 1)?;
                s.serialize_field(".tag", "group_not_found")?;
                s.end()
            }
            GroupMembersSelectorError::SystemManagedGroupDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersSelectorError", 1)?;
                s.serialize_field(".tag", "system_managed_group_disallowed")?;
                s.end()
            }
            GroupMembersSelectorError::MemberNotInGroup => {
                // unit
                let mut s = serializer.serialize_struct("GroupMembersSelectorError", 1)?;
                s.serialize_field(".tag", "member_not_in_group")?;
                s.end()
            }
            GroupMembersSelectorError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupMembersSelectorError {
    fn description(&self) -> &str {
        "GroupMembersSelectorError"
    }
}

impl ::std::fmt::Display for GroupMembersSelectorError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GroupMembersSetAccessTypeArg {
    /// Specify a group.
    pub group: GroupSelector,
    /// Identity of a user that is a member of `group`.
    pub user: UserSelectorArg,
    /// New group access type the user will have.
    pub access_type: GroupAccessType,
    /// Whether to return the list of members in the group.  Note that the default value will cause
    /// all the group members  to be returned in the response. This may take a long time for large
    /// groups.
    pub return_members: bool,
}

impl GroupMembersSetAccessTypeArg {
    pub fn new(group: GroupSelector, user: UserSelectorArg, access_type: GroupAccessType) -> Self {
        GroupMembersSetAccessTypeArg {
            group,
            user,
            access_type,
            return_members: true,
        }
    }

    pub fn with_return_members(mut self, value: bool) -> Self {
        self.return_members = value;
        self
    }

}

const GROUP_MEMBERS_SET_ACCESS_TYPE_ARG_FIELDS: &[&str] = &["group",
                                                            "user",
                                                            "access_type",
                                                            "return_members"];
impl GroupMembersSetAccessTypeArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupMembersSetAccessTypeArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupMembersSetAccessTypeArg>, V::Error> {
        use serde::de;
        let mut field_group = None;
        let mut field_user = None;
        let mut field_access_type = None;
        let mut field_return_members = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group" => {
                    if field_group.is_some() {
                        return Err(de::Error::duplicate_field("group"));
                    }
                    field_group = Some(map.next_value()?);
                }
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                "return_members" => {
                    if field_return_members.is_some() {
                        return Err(de::Error::duplicate_field("return_members"));
                    }
                    field_return_members = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_MEMBERS_SET_ACCESS_TYPE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupMembersSetAccessTypeArg {
            group: field_group.ok_or_else(|| de::Error::missing_field("group"))?,
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
            return_members: field_return_members.unwrap_or(true),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group", &self.group)?;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("access_type", &self.access_type)?;
        s.serialize_field("return_members", &self.return_members)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupMembersSetAccessTypeArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupMembersSetAccessTypeArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupMembersSetAccessTypeArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupMembersSetAccessTypeArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupMembersSetAccessTypeArg", GROUP_MEMBERS_SET_ACCESS_TYPE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupMembersSetAccessTypeArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupMembersSetAccessTypeArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Argument for selecting a single group, either by group_id or by external group ID.
#[derive(Debug)]
pub enum GroupSelector {
    /// Group ID.
    GroupId(super::team_common::GroupId),
    /// External ID of the group.
    GroupExternalId(super::team_common::GroupExternalId),
}

impl<'de> ::serde::de::Deserialize<'de> for GroupSelector {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupSelector;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupSelector structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_id" => {
                        match map.next_key()? {
                            Some("group_id") => Ok(GroupSelector::GroupId(map.next_value()?)),
                            None => Err(de::Error::missing_field("group_id")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "group_external_id" => {
                        match map.next_key()? {
                            Some("group_external_id") => Ok(GroupSelector::GroupExternalId(map.next_value()?)),
                            None => Err(de::Error::missing_field("group_external_id")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["group_id",
                                    "group_external_id"];
        deserializer.deserialize_struct("GroupSelector", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupSelector {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupSelector::GroupId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupSelector", 2)?;
                s.serialize_field(".tag", "group_id")?;
                s.serialize_field("group_id", x)?;
                s.end()
            }
            GroupSelector::GroupExternalId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupSelector", 2)?;
                s.serialize_field(".tag", "group_external_id")?;
                s.serialize_field("group_external_id", x)?;
                s.end()
            }
        }
    }
}

/// Error that can be raised when [`GroupSelector`](GroupSelector) is used.
#[derive(Debug)]
pub enum GroupSelectorError {
    /// No matching group found. No groups match the specified group ID.
    GroupNotFound,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupSelectorError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupSelectorError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupSelectorError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_found" => Ok(GroupSelectorError::GroupNotFound),
                    _ => Ok(GroupSelectorError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_found",
                                    "other"];
        deserializer.deserialize_struct("GroupSelectorError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupSelectorError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupSelectorError::GroupNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GroupSelectorError", 1)?;
                s.serialize_field(".tag", "group_not_found")?;
                s.end()
            }
            GroupSelectorError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupSelectorError {
    fn description(&self) -> &str {
        "GroupSelectorError"
    }
}

impl ::std::fmt::Display for GroupSelectorError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Error that can be raised when [`GroupSelector`](GroupSelector) is used and team groups are
/// disallowed from being used.
#[derive(Debug)]
pub enum GroupSelectorWithTeamGroupError {
    /// No matching group found. No groups match the specified group ID.
    GroupNotFound,
    Other,
    /// This operation is not supported on system-managed groups.
    SystemManagedGroupDisallowed,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupSelectorWithTeamGroupError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupSelectorWithTeamGroupError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupSelectorWithTeamGroupError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_found" => Ok(GroupSelectorWithTeamGroupError::GroupNotFound),
                    "system_managed_group_disallowed" => Ok(GroupSelectorWithTeamGroupError::SystemManagedGroupDisallowed),
                    _ => Ok(GroupSelectorWithTeamGroupError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_found",
                                    "other",
                                    "system_managed_group_disallowed"];
        deserializer.deserialize_struct("GroupSelectorWithTeamGroupError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupSelectorWithTeamGroupError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupSelectorWithTeamGroupError::GroupNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GroupSelectorWithTeamGroupError", 1)?;
                s.serialize_field(".tag", "group_not_found")?;
                s.end()
            }
            GroupSelectorWithTeamGroupError::SystemManagedGroupDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("GroupSelectorWithTeamGroupError", 1)?;
                s.serialize_field(".tag", "system_managed_group_disallowed")?;
                s.end()
            }
            GroupSelectorWithTeamGroupError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupSelectorWithTeamGroupError {
    fn description(&self) -> &str {
        "GroupSelectorWithTeamGroupError"
    }
}

impl ::std::fmt::Display for GroupSelectorWithTeamGroupError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GroupUpdateArgs {
    /// Specify a group.
    pub group: GroupSelector,
    /// Whether to return the list of members in the group.  Note that the default value will cause
    /// all the group members  to be returned in the response. This may take a long time for large
    /// groups.
    pub return_members: bool,
    /// Optional argument. Set group name to this if provided.
    pub new_group_name: Option<String>,
    /// Optional argument. New group external ID. If the argument is None, the group's external_id
    /// won't be updated. If the argument is empty string, the group's external id will be cleared.
    pub new_group_external_id: Option<super::team_common::GroupExternalId>,
    /// Set new group management type, if provided.
    pub new_group_management_type: Option<super::team_common::GroupManagementType>,
}

impl GroupUpdateArgs {
    pub fn new(group: GroupSelector) -> Self {
        GroupUpdateArgs {
            group,
            return_members: true,
            new_group_name: None,
            new_group_external_id: None,
            new_group_management_type: None,
        }
    }

    pub fn with_return_members(mut self, value: bool) -> Self {
        self.return_members = value;
        self
    }

    pub fn with_new_group_name(mut self, value: Option<String>) -> Self {
        self.new_group_name = value;
        self
    }

    pub fn with_new_group_external_id(
        mut self,
        value: Option<super::team_common::GroupExternalId>,
    ) -> Self {
        self.new_group_external_id = value;
        self
    }

    pub fn with_new_group_management_type(
        mut self,
        value: Option<super::team_common::GroupManagementType>,
    ) -> Self {
        self.new_group_management_type = value;
        self
    }

}

const GROUP_UPDATE_ARGS_FIELDS: &[&str] = &["group",
                                            "return_members",
                                            "new_group_name",
                                            "new_group_external_id",
                                            "new_group_management_type"];
impl GroupUpdateArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupUpdateArgs, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupUpdateArgs>, V::Error> {
        use serde::de;
        let mut field_group = None;
        let mut field_return_members = None;
        let mut field_new_group_name = None;
        let mut field_new_group_external_id = None;
        let mut field_new_group_management_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group" => {
                    if field_group.is_some() {
                        return Err(de::Error::duplicate_field("group"));
                    }
                    field_group = Some(map.next_value()?);
                }
                "return_members" => {
                    if field_return_members.is_some() {
                        return Err(de::Error::duplicate_field("return_members"));
                    }
                    field_return_members = Some(map.next_value()?);
                }
                "new_group_name" => {
                    if field_new_group_name.is_some() {
                        return Err(de::Error::duplicate_field("new_group_name"));
                    }
                    field_new_group_name = Some(map.next_value()?);
                }
                "new_group_external_id" => {
                    if field_new_group_external_id.is_some() {
                        return Err(de::Error::duplicate_field("new_group_external_id"));
                    }
                    field_new_group_external_id = Some(map.next_value()?);
                }
                "new_group_management_type" => {
                    if field_new_group_management_type.is_some() {
                        return Err(de::Error::duplicate_field("new_group_management_type"));
                    }
                    field_new_group_management_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUP_UPDATE_ARGS_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupUpdateArgs {
            group: field_group.ok_or_else(|| de::Error::missing_field("group"))?,
            return_members: field_return_members.unwrap_or(true),
            new_group_name: field_new_group_name,
            new_group_external_id: field_new_group_external_id,
            new_group_management_type: field_new_group_management_type,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group", &self.group)?;
        s.serialize_field("return_members", &self.return_members)?;
        s.serialize_field("new_group_name", &self.new_group_name)?;
        s.serialize_field("new_group_external_id", &self.new_group_external_id)?;
        s.serialize_field("new_group_management_type", &self.new_group_management_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupUpdateArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupUpdateArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupUpdateArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupUpdateArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupUpdateArgs", GROUP_UPDATE_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupUpdateArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupUpdateArgs", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupUpdateError {
    /// No matching group found. No groups match the specified group ID.
    GroupNotFound,
    Other,
    /// This operation is not supported on system-managed groups.
    SystemManagedGroupDisallowed,
    /// The requested group name is already being used by another group.
    GroupNameAlreadyUsed,
    /// Group name is empty or has invalid characters.
    GroupNameInvalid,
    /// The requested external ID is already being used by another group.
    ExternalIdAlreadyInUse,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupUpdateError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupUpdateError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupUpdateError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_found" => Ok(GroupUpdateError::GroupNotFound),
                    "system_managed_group_disallowed" => Ok(GroupUpdateError::SystemManagedGroupDisallowed),
                    "group_name_already_used" => Ok(GroupUpdateError::GroupNameAlreadyUsed),
                    "group_name_invalid" => Ok(GroupUpdateError::GroupNameInvalid),
                    "external_id_already_in_use" => Ok(GroupUpdateError::ExternalIdAlreadyInUse),
                    _ => Ok(GroupUpdateError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_found",
                                    "other",
                                    "system_managed_group_disallowed",
                                    "group_name_already_used",
                                    "group_name_invalid",
                                    "external_id_already_in_use"];
        deserializer.deserialize_struct("GroupUpdateError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupUpdateError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupUpdateError::GroupNotFound => {
                // unit
                let mut s = serializer.serialize_struct("GroupUpdateError", 1)?;
                s.serialize_field(".tag", "group_not_found")?;
                s.end()
            }
            GroupUpdateError::SystemManagedGroupDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("GroupUpdateError", 1)?;
                s.serialize_field(".tag", "system_managed_group_disallowed")?;
                s.end()
            }
            GroupUpdateError::GroupNameAlreadyUsed => {
                // unit
                let mut s = serializer.serialize_struct("GroupUpdateError", 1)?;
                s.serialize_field(".tag", "group_name_already_used")?;
                s.end()
            }
            GroupUpdateError::GroupNameInvalid => {
                // unit
                let mut s = serializer.serialize_struct("GroupUpdateError", 1)?;
                s.serialize_field(".tag", "group_name_invalid")?;
                s.end()
            }
            GroupUpdateError::ExternalIdAlreadyInUse => {
                // unit
                let mut s = serializer.serialize_struct("GroupUpdateError", 1)?;
                s.serialize_field(".tag", "external_id_already_in_use")?;
                s.end()
            }
            GroupUpdateError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupUpdateError {
    fn description(&self) -> &str {
        "GroupUpdateError"
    }
}

impl ::std::fmt::Display for GroupUpdateError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum GroupsGetInfoError {
    /// The group is not on your team.
    GroupNotOnTeam,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsGetInfoError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupsGetInfoError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsGetInfoError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_not_on_team" => Ok(GroupsGetInfoError::GroupNotOnTeam),
                    _ => Ok(GroupsGetInfoError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["group_not_on_team",
                                    "other"];
        deserializer.deserialize_struct("GroupsGetInfoError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsGetInfoError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupsGetInfoError::GroupNotOnTeam => {
                // unit
                let mut s = serializer.serialize_struct("GroupsGetInfoError", 1)?;
                s.serialize_field(".tag", "group_not_on_team")?;
                s.end()
            }
            GroupsGetInfoError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupsGetInfoError {
    fn description(&self) -> &str {
        "GroupsGetInfoError"
    }
}

impl ::std::fmt::Display for GroupsGetInfoError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum GroupsGetInfoItem {
    /// An ID that was provided as a parameter to [`groups_get_info()`](groups_get_info), and did
    /// not match a corresponding group. The ID can be a group ID, or an external ID, depending on
    /// how the method was called.
    IdNotFound(String),
    /// Info about a group.
    GroupInfo(GroupFullInfo),
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsGetInfoItem {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupsGetInfoItem;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsGetInfoItem structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "id_not_found" => {
                        match map.next_key()? {
                            Some("id_not_found") => Ok(GroupsGetInfoItem::IdNotFound(map.next_value()?)),
                            None => Err(de::Error::missing_field("id_not_found")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "group_info" => Ok(GroupsGetInfoItem::GroupInfo(GroupFullInfo::internal_deserialize(map)?)),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["id_not_found",
                                    "group_info"];
        deserializer.deserialize_struct("GroupsGetInfoItem", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsGetInfoItem {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupsGetInfoItem::IdNotFound(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupsGetInfoItem", 2)?;
                s.serialize_field(".tag", "id_not_found")?;
                s.serialize_field("id_not_found", x)?;
                s.end()
            }
            GroupsGetInfoItem::GroupInfo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("GroupsGetInfoItem", 8)?;
                s.serialize_field(".tag", "group_info")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub struct GroupsListArg {
    /// Number of results to return per call.
    pub limit: u32,
}

impl Default for GroupsListArg {
    fn default() -> Self {
        GroupsListArg {
            limit: 1000,
        }
    }
}

const GROUPS_LIST_ARG_FIELDS: &[&str] = &["limit"];
impl GroupsListArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<GroupsListArg, V::Error> {
        use serde::de;
        let mut field_limit = None;
        while let Some(key) = map.next_key()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUPS_LIST_ARG_FIELDS))
            }
        }
        let result = GroupsListArg {
            limit: field_limit.unwrap_or(1000),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupsListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupsListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupsListArg", GROUPS_LIST_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupsListArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupsListContinueArg {
    /// Indicates from what point to get the next set of groups.
    pub cursor: String,
}

impl GroupsListContinueArg {
    pub fn new(cursor: String) -> Self {
        GroupsListContinueArg {
            cursor,
        }
    }

}

const GROUPS_LIST_CONTINUE_ARG_FIELDS: &[&str] = &["cursor"];
impl GroupsListContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupsListContinueArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupsListContinueArg>, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUPS_LIST_CONTINUE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupsListContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsListContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupsListContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsListContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupsListContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupsListContinueArg", GROUPS_LIST_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsListContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupsListContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupsListContinueError {
    /// The cursor is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsListContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupsListContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsListContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_cursor" => Ok(GroupsListContinueError::InvalidCursor),
                    _ => Ok(GroupsListContinueError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_cursor",
                                    "other"];
        deserializer.deserialize_struct("GroupsListContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsListContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupsListContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("GroupsListContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            GroupsListContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupsListContinueError {
    fn description(&self) -> &str {
        "GroupsListContinueError"
    }
}

impl ::std::fmt::Display for GroupsListContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GroupsListResult {
    pub groups: Vec<super::team_common::GroupSummary>,
    /// Pass the cursor into [`groups_list_continue()`](groups_list_continue) to obtain the
    /// additional groups.
    pub cursor: String,
    /// Is true if there are additional groups that have not been returned yet. An additional call
    /// to [`groups_list_continue()`](groups_list_continue) can retrieve them.
    pub has_more: bool,
}

impl GroupsListResult {
    pub fn new(
        groups: Vec<super::team_common::GroupSummary>,
        cursor: String,
        has_more: bool,
    ) -> Self {
        GroupsListResult {
            groups,
            cursor,
            has_more,
        }
    }

}

const GROUPS_LIST_RESULT_FIELDS: &[&str] = &["groups",
                                             "cursor",
                                             "has_more"];
impl GroupsListResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupsListResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupsListResult>, V::Error> {
        use serde::de;
        let mut field_groups = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "groups" => {
                    if field_groups.is_some() {
                        return Err(de::Error::duplicate_field("groups"));
                    }
                    field_groups = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUPS_LIST_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupsListResult {
            groups: field_groups.ok_or_else(|| de::Error::missing_field("groups"))?,
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("groups", &self.groups)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsListResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupsListResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsListResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupsListResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupsListResult", GROUPS_LIST_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsListResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupsListResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupsMembersListArg {
    /// The group whose members are to be listed.
    pub group: GroupSelector,
    /// Number of results to return per call.
    pub limit: u32,
}

impl GroupsMembersListArg {
    pub fn new(group: GroupSelector) -> Self {
        GroupsMembersListArg {
            group,
            limit: 1000,
        }
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }

}

const GROUPS_MEMBERS_LIST_ARG_FIELDS: &[&str] = &["group",
                                                  "limit"];
impl GroupsMembersListArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupsMembersListArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupsMembersListArg>, V::Error> {
        use serde::de;
        let mut field_group = None;
        let mut field_limit = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "group" => {
                    if field_group.is_some() {
                        return Err(de::Error::duplicate_field("group"));
                    }
                    field_group = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUPS_MEMBERS_LIST_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupsMembersListArg {
            group: field_group.ok_or_else(|| de::Error::missing_field("group"))?,
            limit: field_limit.unwrap_or(1000),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("group", &self.group)?;
        s.serialize_field("limit", &self.limit)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsMembersListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupsMembersListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsMembersListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupsMembersListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupsMembersListArg", GROUPS_MEMBERS_LIST_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsMembersListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupsMembersListArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct GroupsMembersListContinueArg {
    /// Indicates from what point to get the next set of groups.
    pub cursor: String,
}

impl GroupsMembersListContinueArg {
    pub fn new(cursor: String) -> Self {
        GroupsMembersListContinueArg {
            cursor,
        }
    }

}

const GROUPS_MEMBERS_LIST_CONTINUE_ARG_FIELDS: &[&str] = &["cursor"];
impl GroupsMembersListContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupsMembersListContinueArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupsMembersListContinueArg>, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUPS_MEMBERS_LIST_CONTINUE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupsMembersListContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsMembersListContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupsMembersListContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsMembersListContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupsMembersListContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupsMembersListContinueArg", GROUPS_MEMBERS_LIST_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsMembersListContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupsMembersListContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupsMembersListContinueError {
    /// The cursor is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsMembersListContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupsMembersListContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsMembersListContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_cursor" => Ok(GroupsMembersListContinueError::InvalidCursor),
                    _ => Ok(GroupsMembersListContinueError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_cursor",
                                    "other"];
        deserializer.deserialize_struct("GroupsMembersListContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsMembersListContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupsMembersListContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("GroupsMembersListContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            GroupsMembersListContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupsMembersListContinueError {
    fn description(&self) -> &str {
        "GroupsMembersListContinueError"
    }
}

impl ::std::fmt::Display for GroupsMembersListContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct GroupsMembersListResult {
    pub members: Vec<GroupMemberInfo>,
    /// Pass the cursor into [`groups_members_list_continue()`](groups_members_list_continue) to
    /// obtain additional group members.
    pub cursor: String,
    /// Is true if there are additional group members that have not been returned yet. An additional
    /// call to [`groups_members_list_continue()`](groups_members_list_continue) can retrieve them.
    pub has_more: bool,
}

impl GroupsMembersListResult {
    pub fn new(members: Vec<GroupMemberInfo>, cursor: String, has_more: bool) -> Self {
        GroupsMembersListResult {
            members,
            cursor,
            has_more,
        }
    }

}

const GROUPS_MEMBERS_LIST_RESULT_FIELDS: &[&str] = &["members",
                                                     "cursor",
                                                     "has_more"];
impl GroupsMembersListResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<GroupsMembersListResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<GroupsMembersListResult>, V::Error> {
        use serde::de;
        let mut field_members = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "members" => {
                    if field_members.is_some() {
                        return Err(de::Error::duplicate_field("members"));
                    }
                    field_members = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, GROUPS_MEMBERS_LIST_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = GroupsMembersListResult {
            members: field_members.ok_or_else(|| de::Error::missing_field("members"))?,
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("members", &self.members)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsMembersListResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = GroupsMembersListResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsMembersListResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                GroupsMembersListResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("GroupsMembersListResult", GROUPS_MEMBERS_LIST_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsMembersListResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("GroupsMembersListResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum GroupsPollError {
    /// The job ID is invalid.
    InvalidAsyncJobId,
    /// Something went wrong with the job on Dropbox's end. You'll need to verify that the action
    /// you were taking succeeded, and if not, try again. This should happen very rarely.
    InternalError,
    Other,
    /// You are not allowed to poll this job.
    AccessDenied,
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsPollError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupsPollError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsPollError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_async_job_id" => Ok(GroupsPollError::InvalidAsyncJobId),
                    "internal_error" => Ok(GroupsPollError::InternalError),
                    "access_denied" => Ok(GroupsPollError::AccessDenied),
                    _ => Ok(GroupsPollError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_async_job_id",
                                    "internal_error",
                                    "other",
                                    "access_denied"];
        deserializer.deserialize_struct("GroupsPollError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsPollError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupsPollError::InvalidAsyncJobId => {
                // unit
                let mut s = serializer.serialize_struct("GroupsPollError", 1)?;
                s.serialize_field(".tag", "invalid_async_job_id")?;
                s.end()
            }
            GroupsPollError::InternalError => {
                // unit
                let mut s = serializer.serialize_struct("GroupsPollError", 1)?;
                s.serialize_field(".tag", "internal_error")?;
                s.end()
            }
            GroupsPollError::AccessDenied => {
                // unit
                let mut s = serializer.serialize_struct("GroupsPollError", 1)?;
                s.serialize_field(".tag", "access_denied")?;
                s.end()
            }
            GroupsPollError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for GroupsPollError {
    fn description(&self) -> &str {
        "GroupsPollError"
    }
}

impl ::std::fmt::Display for GroupsPollError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Argument for selecting a list of groups, either by group_ids, or external group IDs.
#[derive(Debug)]
pub enum GroupsSelector {
    /// List of group IDs.
    GroupIds(Vec<super::team_common::GroupId>),
    /// List of external IDs of groups.
    GroupExternalIds(Vec<String>),
}

impl<'de> ::serde::de::Deserialize<'de> for GroupsSelector {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = GroupsSelector;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a GroupsSelector structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "group_ids" => {
                        match map.next_key()? {
                            Some("group_ids") => Ok(GroupsSelector::GroupIds(map.next_value()?)),
                            None => Err(de::Error::missing_field("group_ids")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "group_external_ids" => {
                        match map.next_key()? {
                            Some("group_external_ids") => Ok(GroupsSelector::GroupExternalIds(map.next_value()?)),
                            None => Err(de::Error::missing_field("group_external_ids")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["group_ids",
                                    "group_external_ids"];
        deserializer.deserialize_struct("GroupsSelector", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for GroupsSelector {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            GroupsSelector::GroupIds(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupsSelector", 2)?;
                s.serialize_field(".tag", "group_ids")?;
                s.serialize_field("group_ids", x)?;
                s.end()
            }
            GroupsSelector::GroupExternalIds(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("GroupsSelector", 2)?;
                s.serialize_field(".tag", "group_external_ids")?;
                s.serialize_field("group_external_ids", x)?;
                s.end()
            }
        }
    }
}

/// The value for [`Feature::HasTeamFileEvents`](Feature::HasTeamFileEvents).
#[derive(Debug)]
pub enum HasTeamFileEventsValue {
    /// Does this team have file events.
    Enabled(bool),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for HasTeamFileEventsValue {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = HasTeamFileEventsValue;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a HasTeamFileEventsValue structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "enabled" => {
                        match map.next_key()? {
                            Some("enabled") => Ok(HasTeamFileEventsValue::Enabled(map.next_value()?)),
                            None => Err(de::Error::missing_field("enabled")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(HasTeamFileEventsValue::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["enabled",
                                    "other"];
        deserializer.deserialize_struct("HasTeamFileEventsValue", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for HasTeamFileEventsValue {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            HasTeamFileEventsValue::Enabled(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("HasTeamFileEventsValue", 2)?;
                s.serialize_field(".tag", "enabled")?;
                s.serialize_field("enabled", x)?;
                s.end()
            }
            HasTeamFileEventsValue::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The value for [`Feature::HasTeamSelectiveSync`](Feature::HasTeamSelectiveSync).
#[derive(Debug)]
pub enum HasTeamSelectiveSyncValue {
    /// Does this team have team selective sync enabled.
    HasTeamSelectiveSync(bool),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for HasTeamSelectiveSyncValue {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = HasTeamSelectiveSyncValue;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a HasTeamSelectiveSyncValue structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "has_team_selective_sync" => {
                        match map.next_key()? {
                            Some("has_team_selective_sync") => Ok(HasTeamSelectiveSyncValue::HasTeamSelectiveSync(map.next_value()?)),
                            None => Err(de::Error::missing_field("has_team_selective_sync")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(HasTeamSelectiveSyncValue::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["has_team_selective_sync",
                                    "other"];
        deserializer.deserialize_struct("HasTeamSelectiveSyncValue", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for HasTeamSelectiveSyncValue {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            HasTeamSelectiveSyncValue::HasTeamSelectiveSync(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("HasTeamSelectiveSyncValue", 2)?;
                s.serialize_field(".tag", "has_team_selective_sync")?;
                s.serialize_field("has_team_selective_sync", x)?;
                s.end()
            }
            HasTeamSelectiveSyncValue::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// The value for [`Feature::HasTeamSharedDropbox`](Feature::HasTeamSharedDropbox).
#[derive(Debug)]
pub enum HasTeamSharedDropboxValue {
    /// Does this team have a shared team root.
    HasTeamSharedDropbox(bool),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for HasTeamSharedDropboxValue {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = HasTeamSharedDropboxValue;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a HasTeamSharedDropboxValue structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "has_team_shared_dropbox" => {
                        match map.next_key()? {
                            Some("has_team_shared_dropbox") => Ok(HasTeamSharedDropboxValue::HasTeamSharedDropbox(map.next_value()?)),
                            None => Err(de::Error::missing_field("has_team_shared_dropbox")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(HasTeamSharedDropboxValue::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["has_team_shared_dropbox",
                                    "other"];
        deserializer.deserialize_struct("HasTeamSharedDropboxValue", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for HasTeamSharedDropboxValue {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            HasTeamSharedDropboxValue::HasTeamSharedDropbox(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("HasTeamSharedDropboxValue", 2)?;
                s.serialize_field(".tag", "has_team_shared_dropbox")?;
                s.serialize_field("has_team_shared_dropbox", x)?;
                s.end()
            }
            HasTeamSharedDropboxValue::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct IncludeMembersArg {
    /// Whether to return the list of members in the group.  Note that the default value will cause
    /// all the group members  to be returned in the response. This may take a long time for large
    /// groups.
    pub return_members: bool,
}

impl Default for IncludeMembersArg {
    fn default() -> Self {
        IncludeMembersArg {
            return_members: true,
        }
    }
}

const INCLUDE_MEMBERS_ARG_FIELDS: &[&str] = &["return_members"];
impl IncludeMembersArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<IncludeMembersArg, V::Error> {
        use serde::de;
        let mut field_return_members = None;
        while let Some(key) = map.next_key()? {
            match key {
                "return_members" => {
                    if field_return_members.is_some() {
                        return Err(de::Error::duplicate_field("return_members"));
                    }
                    field_return_members = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, INCLUDE_MEMBERS_ARG_FIELDS))
            }
        }
        let result = IncludeMembersArg {
            return_members: field_return_members.unwrap_or(true),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("return_members", &self.return_members)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for IncludeMembersArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = IncludeMembersArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a IncludeMembersArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                IncludeMembersArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("IncludeMembersArg", INCLUDE_MEMBERS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for IncludeMembersArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("IncludeMembersArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ListMemberAppsArg {
    /// The team member id.
    pub team_member_id: String,
}

impl ListMemberAppsArg {
    pub fn new(team_member_id: String) -> Self {
        ListMemberAppsArg {
            team_member_id,
        }
    }

}

const LIST_MEMBER_APPS_ARG_FIELDS: &[&str] = &["team_member_id"];
impl ListMemberAppsArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListMemberAppsArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListMemberAppsArg>, V::Error> {
        use serde::de;
        let mut field_team_member_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_MEMBER_APPS_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListMemberAppsArg {
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_member_id", &self.team_member_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListMemberAppsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListMemberAppsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMemberAppsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListMemberAppsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListMemberAppsArg", LIST_MEMBER_APPS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListMemberAppsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListMemberAppsArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error returned by
/// [`linked_apps_list_member_linked_apps()`](linked_apps_list_member_linked_apps).
#[derive(Debug)]
pub enum ListMemberAppsError {
    /// Member not found.
    MemberNotFound,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListMemberAppsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListMemberAppsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMemberAppsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "member_not_found" => Ok(ListMemberAppsError::MemberNotFound),
                    _ => Ok(ListMemberAppsError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["member_not_found",
                                    "other"];
        deserializer.deserialize_struct("ListMemberAppsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListMemberAppsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListMemberAppsError::MemberNotFound => {
                // unit
                let mut s = serializer.serialize_struct("ListMemberAppsError", 1)?;
                s.serialize_field(".tag", "member_not_found")?;
                s.end()
            }
            ListMemberAppsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListMemberAppsError {
    fn description(&self) -> &str {
        "ListMemberAppsError"
    }
}

impl ::std::fmt::Display for ListMemberAppsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct ListMemberAppsResult {
    /// List of third party applications linked by this team member.
    pub linked_api_apps: Vec<ApiApp>,
}

impl ListMemberAppsResult {
    pub fn new(linked_api_apps: Vec<ApiApp>) -> Self {
        ListMemberAppsResult {
            linked_api_apps,
        }
    }

}

const LIST_MEMBER_APPS_RESULT_FIELDS: &[&str] = &["linked_api_apps"];
impl ListMemberAppsResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListMemberAppsResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListMemberAppsResult>, V::Error> {
        use serde::de;
        let mut field_linked_api_apps = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "linked_api_apps" => {
                    if field_linked_api_apps.is_some() {
                        return Err(de::Error::duplicate_field("linked_api_apps"));
                    }
                    field_linked_api_apps = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_MEMBER_APPS_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListMemberAppsResult {
            linked_api_apps: field_linked_api_apps.ok_or_else(|| de::Error::missing_field("linked_api_apps"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("linked_api_apps", &self.linked_api_apps)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListMemberAppsResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListMemberAppsResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMemberAppsResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListMemberAppsResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListMemberAppsResult", LIST_MEMBER_APPS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListMemberAppsResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListMemberAppsResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ListMemberDevicesArg {
    /// The team's member id.
    pub team_member_id: String,
    /// Whether to list web sessions of the team's member.
    pub include_web_sessions: bool,
    /// Whether to list linked desktop devices of the team's member.
    pub include_desktop_clients: bool,
    /// Whether to list linked mobile devices of the team's member.
    pub include_mobile_clients: bool,
}

impl ListMemberDevicesArg {
    pub fn new(team_member_id: String) -> Self {
        ListMemberDevicesArg {
            team_member_id,
            include_web_sessions: true,
            include_desktop_clients: true,
            include_mobile_clients: true,
        }
    }

    pub fn with_include_web_sessions(mut self, value: bool) -> Self {
        self.include_web_sessions = value;
        self
    }

    pub fn with_include_desktop_clients(mut self, value: bool) -> Self {
        self.include_desktop_clients = value;
        self
    }

    pub fn with_include_mobile_clients(mut self, value: bool) -> Self {
        self.include_mobile_clients = value;
        self
    }

}

const LIST_MEMBER_DEVICES_ARG_FIELDS: &[&str] = &["team_member_id",
                                                  "include_web_sessions",
                                                  "include_desktop_clients",
                                                  "include_mobile_clients"];
impl ListMemberDevicesArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListMemberDevicesArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListMemberDevicesArg>, V::Error> {
        use serde::de;
        let mut field_team_member_id = None;
        let mut field_include_web_sessions = None;
        let mut field_include_desktop_clients = None;
        let mut field_include_mobile_clients = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "include_web_sessions" => {
                    if field_include_web_sessions.is_some() {
                        return Err(de::Error::duplicate_field("include_web_sessions"));
                    }
                    field_include_web_sessions = Some(map.next_value()?);
                }
                "include_desktop_clients" => {
                    if field_include_desktop_clients.is_some() {
                        return Err(de::Error::duplicate_field("include_desktop_clients"));
                    }
                    field_include_desktop_clients = Some(map.next_value()?);
                }
                "include_mobile_clients" => {
                    if field_include_mobile_clients.is_some() {
                        return Err(de::Error::duplicate_field("include_mobile_clients"));
                    }
                    field_include_mobile_clients = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_MEMBER_DEVICES_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListMemberDevicesArg {
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
            include_web_sessions: field_include_web_sessions.unwrap_or(true),
            include_desktop_clients: field_include_desktop_clients.unwrap_or(true),
            include_mobile_clients: field_include_mobile_clients.unwrap_or(true),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("include_web_sessions", &self.include_web_sessions)?;
        s.serialize_field("include_desktop_clients", &self.include_desktop_clients)?;
        s.serialize_field("include_mobile_clients", &self.include_mobile_clients)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListMemberDevicesArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListMemberDevicesArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMemberDevicesArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListMemberDevicesArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListMemberDevicesArg", LIST_MEMBER_DEVICES_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListMemberDevicesArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListMemberDevicesArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ListMemberDevicesError {
    /// Member not found.
    MemberNotFound,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListMemberDevicesError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListMemberDevicesError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMemberDevicesError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "member_not_found" => Ok(ListMemberDevicesError::MemberNotFound),
                    _ => Ok(ListMemberDevicesError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["member_not_found",
                                    "other"];
        deserializer.deserialize_struct("ListMemberDevicesError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListMemberDevicesError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListMemberDevicesError::MemberNotFound => {
                // unit
                let mut s = serializer.serialize_struct("ListMemberDevicesError", 1)?;
                s.serialize_field(".tag", "member_not_found")?;
                s.end()
            }
            ListMemberDevicesError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListMemberDevicesError {
    fn description(&self) -> &str {
        "ListMemberDevicesError"
    }
}

impl ::std::fmt::Display for ListMemberDevicesError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct ListMemberDevicesResult {
    /// List of web sessions made by this team member.
    pub active_web_sessions: Option<Vec<ActiveWebSession>>,
    /// List of desktop clients used by this team member.
    pub desktop_client_sessions: Option<Vec<DesktopClientSession>>,
    /// List of mobile client used by this team member.
    pub mobile_client_sessions: Option<Vec<MobileClientSession>>,
}

impl Default for ListMemberDevicesResult {
    fn default() -> Self {
        ListMemberDevicesResult {
            active_web_sessions: None,
            desktop_client_sessions: None,
            mobile_client_sessions: None,
        }
    }
}

const LIST_MEMBER_DEVICES_RESULT_FIELDS: &[&str] = &["active_web_sessions",
                                                     "desktop_client_sessions",
                                                     "mobile_client_sessions"];
impl ListMemberDevicesResult {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ListMemberDevicesResult, V::Error> {
        use serde::de;
        let mut field_active_web_sessions = None;
        let mut field_desktop_client_sessions = None;
        let mut field_mobile_client_sessions = None;
        while let Some(key) = map.next_key()? {
            match key {
                "active_web_sessions" => {
                    if field_active_web_sessions.is_some() {
                        return Err(de::Error::duplicate_field("active_web_sessions"));
                    }
                    field_active_web_sessions = Some(map.next_value()?);
                }
                "desktop_client_sessions" => {
                    if field_desktop_client_sessions.is_some() {
                        return Err(de::Error::duplicate_field("desktop_client_sessions"));
                    }
                    field_desktop_client_sessions = Some(map.next_value()?);
                }
                "mobile_client_sessions" => {
                    if field_mobile_client_sessions.is_some() {
                        return Err(de::Error::duplicate_field("mobile_client_sessions"));
                    }
                    field_mobile_client_sessions = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_MEMBER_DEVICES_RESULT_FIELDS))
            }
        }
        let result = ListMemberDevicesResult {
            active_web_sessions: field_active_web_sessions,
            desktop_client_sessions: field_desktop_client_sessions,
            mobile_client_sessions: field_mobile_client_sessions,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("active_web_sessions", &self.active_web_sessions)?;
        s.serialize_field("desktop_client_sessions", &self.desktop_client_sessions)?;
        s.serialize_field("mobile_client_sessions", &self.mobile_client_sessions)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListMemberDevicesResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListMemberDevicesResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMemberDevicesResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListMemberDevicesResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListMemberDevicesResult", LIST_MEMBER_DEVICES_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListMemberDevicesResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListMemberDevicesResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments for [`linked_apps_list_members_linked_apps()`](linked_apps_list_members_linked_apps).
#[derive(Debug)]
pub struct ListMembersAppsArg {
    /// At the first call to the
    /// [`linked_apps_list_members_linked_apps()`](linked_apps_list_members_linked_apps) the cursor
    /// shouldn't be passed. Then, if the result of the call includes a cursor, the following
    /// requests should include the received cursors in order to receive the next sub list of the
    /// team applications.
    pub cursor: Option<String>,
}

impl Default for ListMembersAppsArg {
    fn default() -> Self {
        ListMembersAppsArg {
            cursor: None,
        }
    }
}

const LIST_MEMBERS_APPS_ARG_FIELDS: &[&str] = &["cursor"];
impl ListMembersAppsArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ListMembersAppsArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_MEMBERS_APPS_ARG_FIELDS))
            }
        }
        let result = ListMembersAppsArg {
            cursor: field_cursor,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListMembersAppsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListMembersAppsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMembersAppsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListMembersAppsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListMembersAppsArg", LIST_MEMBERS_APPS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListMembersAppsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListMembersAppsArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error returned by
/// [`linked_apps_list_members_linked_apps()`](linked_apps_list_members_linked_apps).
#[derive(Debug)]
pub enum ListMembersAppsError {
    /// Indicates that the cursor has been invalidated. Call
    /// [`linked_apps_list_members_linked_apps()`](linked_apps_list_members_linked_apps) again with
    /// an empty cursor to obtain a new cursor.
    Reset,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListMembersAppsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListMembersAppsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMembersAppsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "reset" => Ok(ListMembersAppsError::Reset),
                    _ => Ok(ListMembersAppsError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["reset",
                                    "other"];
        deserializer.deserialize_struct("ListMembersAppsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListMembersAppsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListMembersAppsError::Reset => {
                // unit
                let mut s = serializer.serialize_struct("ListMembersAppsError", 1)?;
                s.serialize_field(".tag", "reset")?;
                s.end()
            }
            ListMembersAppsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListMembersAppsError {
    fn description(&self) -> &str {
        "ListMembersAppsError"
    }
}

impl ::std::fmt::Display for ListMembersAppsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Information returned by
/// [`linked_apps_list_members_linked_apps()`](linked_apps_list_members_linked_apps).
#[derive(Debug)]
pub struct ListMembersAppsResult {
    /// The linked applications of each member of the team.
    pub apps: Vec<MemberLinkedApps>,
    /// If true, then there are more apps available. Pass the cursor to
    /// [`linked_apps_list_members_linked_apps()`](linked_apps_list_members_linked_apps) to retrieve
    /// the rest.
    pub has_more: bool,
    /// Pass the cursor into
    /// [`linked_apps_list_members_linked_apps()`](linked_apps_list_members_linked_apps) to receive
    /// the next sub list of team's applications.
    pub cursor: Option<String>,
}

impl ListMembersAppsResult {
    pub fn new(apps: Vec<MemberLinkedApps>, has_more: bool) -> Self {
        ListMembersAppsResult {
            apps,
            has_more,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const LIST_MEMBERS_APPS_RESULT_FIELDS: &[&str] = &["apps",
                                                   "has_more",
                                                   "cursor"];
impl ListMembersAppsResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListMembersAppsResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListMembersAppsResult>, V::Error> {
        use serde::de;
        let mut field_apps = None;
        let mut field_has_more = None;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "apps" => {
                    if field_apps.is_some() {
                        return Err(de::Error::duplicate_field("apps"));
                    }
                    field_apps = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_MEMBERS_APPS_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListMembersAppsResult {
            apps: field_apps.ok_or_else(|| de::Error::missing_field("apps"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
            cursor: field_cursor,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("apps", &self.apps)?;
        s.serialize_field("has_more", &self.has_more)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListMembersAppsResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListMembersAppsResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMembersAppsResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListMembersAppsResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListMembersAppsResult", LIST_MEMBERS_APPS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListMembersAppsResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListMembersAppsResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ListMembersDevicesArg {
    /// At the first call to the [`devices_list_members_devices()`](devices_list_members_devices)
    /// the cursor shouldn't be passed. Then, if the result of the call includes a cursor, the
    /// following requests should include the received cursors in order to receive the next sub list
    /// of team devices.
    pub cursor: Option<String>,
    /// Whether to list web sessions of the team members.
    pub include_web_sessions: bool,
    /// Whether to list desktop clients of the team members.
    pub include_desktop_clients: bool,
    /// Whether to list mobile clients of the team members.
    pub include_mobile_clients: bool,
}

impl Default for ListMembersDevicesArg {
    fn default() -> Self {
        ListMembersDevicesArg {
            cursor: None,
            include_web_sessions: true,
            include_desktop_clients: true,
            include_mobile_clients: true,
        }
    }
}

const LIST_MEMBERS_DEVICES_ARG_FIELDS: &[&str] = &["cursor",
                                                   "include_web_sessions",
                                                   "include_desktop_clients",
                                                   "include_mobile_clients"];
impl ListMembersDevicesArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ListMembersDevicesArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        let mut field_include_web_sessions = None;
        let mut field_include_desktop_clients = None;
        let mut field_include_mobile_clients = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "include_web_sessions" => {
                    if field_include_web_sessions.is_some() {
                        return Err(de::Error::duplicate_field("include_web_sessions"));
                    }
                    field_include_web_sessions = Some(map.next_value()?);
                }
                "include_desktop_clients" => {
                    if field_include_desktop_clients.is_some() {
                        return Err(de::Error::duplicate_field("include_desktop_clients"));
                    }
                    field_include_desktop_clients = Some(map.next_value()?);
                }
                "include_mobile_clients" => {
                    if field_include_mobile_clients.is_some() {
                        return Err(de::Error::duplicate_field("include_mobile_clients"));
                    }
                    field_include_mobile_clients = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_MEMBERS_DEVICES_ARG_FIELDS))
            }
        }
        let result = ListMembersDevicesArg {
            cursor: field_cursor,
            include_web_sessions: field_include_web_sessions.unwrap_or(true),
            include_desktop_clients: field_include_desktop_clients.unwrap_or(true),
            include_mobile_clients: field_include_mobile_clients.unwrap_or(true),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("include_web_sessions", &self.include_web_sessions)?;
        s.serialize_field("include_desktop_clients", &self.include_desktop_clients)?;
        s.serialize_field("include_mobile_clients", &self.include_mobile_clients)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListMembersDevicesArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListMembersDevicesArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMembersDevicesArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListMembersDevicesArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListMembersDevicesArg", LIST_MEMBERS_DEVICES_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListMembersDevicesArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListMembersDevicesArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ListMembersDevicesError {
    /// Indicates that the cursor has been invalidated. Call
    /// [`devices_list_members_devices()`](devices_list_members_devices) again with an empty cursor
    /// to obtain a new cursor.
    Reset,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListMembersDevicesError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListMembersDevicesError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMembersDevicesError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "reset" => Ok(ListMembersDevicesError::Reset),
                    _ => Ok(ListMembersDevicesError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["reset",
                                    "other"];
        deserializer.deserialize_struct("ListMembersDevicesError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListMembersDevicesError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListMembersDevicesError::Reset => {
                // unit
                let mut s = serializer.serialize_struct("ListMembersDevicesError", 1)?;
                s.serialize_field(".tag", "reset")?;
                s.end()
            }
            ListMembersDevicesError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListMembersDevicesError {
    fn description(&self) -> &str {
        "ListMembersDevicesError"
    }
}

impl ::std::fmt::Display for ListMembersDevicesError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct ListMembersDevicesResult {
    /// The devices of each member of the team.
    pub devices: Vec<MemberDevices>,
    /// If true, then there are more devices available. Pass the cursor to
    /// [`devices_list_members_devices()`](devices_list_members_devices) to retrieve the rest.
    pub has_more: bool,
    /// Pass the cursor into [`devices_list_members_devices()`](devices_list_members_devices) to
    /// receive the next sub list of team's devices.
    pub cursor: Option<String>,
}

impl ListMembersDevicesResult {
    pub fn new(devices: Vec<MemberDevices>, has_more: bool) -> Self {
        ListMembersDevicesResult {
            devices,
            has_more,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const LIST_MEMBERS_DEVICES_RESULT_FIELDS: &[&str] = &["devices",
                                                      "has_more",
                                                      "cursor"];
impl ListMembersDevicesResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListMembersDevicesResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListMembersDevicesResult>, V::Error> {
        use serde::de;
        let mut field_devices = None;
        let mut field_has_more = None;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "devices" => {
                    if field_devices.is_some() {
                        return Err(de::Error::duplicate_field("devices"));
                    }
                    field_devices = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_MEMBERS_DEVICES_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListMembersDevicesResult {
            devices: field_devices.ok_or_else(|| de::Error::missing_field("devices"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
            cursor: field_cursor,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("devices", &self.devices)?;
        s.serialize_field("has_more", &self.has_more)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListMembersDevicesResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListMembersDevicesResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListMembersDevicesResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListMembersDevicesResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListMembersDevicesResult", LIST_MEMBERS_DEVICES_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListMembersDevicesResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListMembersDevicesResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Arguments for [`linked_apps_list_team_linked_apps()`](linked_apps_list_team_linked_apps).
#[derive(Debug)]
pub struct ListTeamAppsArg {
    /// At the first call to the
    /// [`linked_apps_list_team_linked_apps()`](linked_apps_list_team_linked_apps) the cursor
    /// shouldn't be passed. Then, if the result of the call includes a cursor, the following
    /// requests should include the received cursors in order to receive the next sub list of the
    /// team applications.
    pub cursor: Option<String>,
}

impl Default for ListTeamAppsArg {
    fn default() -> Self {
        ListTeamAppsArg {
            cursor: None,
        }
    }
}

const LIST_TEAM_APPS_ARG_FIELDS: &[&str] = &["cursor"];
impl ListTeamAppsArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ListTeamAppsArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_TEAM_APPS_ARG_FIELDS))
            }
        }
        let result = ListTeamAppsArg {
            cursor: field_cursor,
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListTeamAppsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListTeamAppsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListTeamAppsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListTeamAppsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListTeamAppsArg", LIST_TEAM_APPS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListTeamAppsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListTeamAppsArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error returned by [`linked_apps_list_team_linked_apps()`](linked_apps_list_team_linked_apps).
#[derive(Debug)]
pub enum ListTeamAppsError {
    /// Indicates that the cursor has been invalidated. Call
    /// [`linked_apps_list_team_linked_apps()`](linked_apps_list_team_linked_apps) again with an
    /// empty cursor to obtain a new cursor.
    Reset,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListTeamAppsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListTeamAppsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListTeamAppsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "reset" => Ok(ListTeamAppsError::Reset),
                    _ => Ok(ListTeamAppsError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["reset",
                                    "other"];
        deserializer.deserialize_struct("ListTeamAppsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListTeamAppsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListTeamAppsError::Reset => {
                // unit
                let mut s = serializer.serialize_struct("ListTeamAppsError", 1)?;
                s.serialize_field(".tag", "reset")?;
                s.end()
            }
            ListTeamAppsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListTeamAppsError {
    fn description(&self) -> &str {
        "ListTeamAppsError"
    }
}

impl ::std::fmt::Display for ListTeamAppsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Information returned by
/// [`linked_apps_list_team_linked_apps()`](linked_apps_list_team_linked_apps).
#[derive(Debug)]
pub struct ListTeamAppsResult {
    /// The linked applications of each member of the team.
    pub apps: Vec<MemberLinkedApps>,
    /// If true, then there are more apps available. Pass the cursor to
    /// [`linked_apps_list_team_linked_apps()`](linked_apps_list_team_linked_apps) to retrieve the
    /// rest.
    pub has_more: bool,
    /// Pass the cursor into
    /// [`linked_apps_list_team_linked_apps()`](linked_apps_list_team_linked_apps) to receive the
    /// next sub list of team's applications.
    pub cursor: Option<String>,
}

impl ListTeamAppsResult {
    pub fn new(apps: Vec<MemberLinkedApps>, has_more: bool) -> Self {
        ListTeamAppsResult {
            apps,
            has_more,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const LIST_TEAM_APPS_RESULT_FIELDS: &[&str] = &["apps",
                                                "has_more",
                                                "cursor"];
impl ListTeamAppsResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListTeamAppsResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListTeamAppsResult>, V::Error> {
        use serde::de;
        let mut field_apps = None;
        let mut field_has_more = None;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "apps" => {
                    if field_apps.is_some() {
                        return Err(de::Error::duplicate_field("apps"));
                    }
                    field_apps = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_TEAM_APPS_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListTeamAppsResult {
            apps: field_apps.ok_or_else(|| de::Error::missing_field("apps"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
            cursor: field_cursor,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("apps", &self.apps)?;
        s.serialize_field("has_more", &self.has_more)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListTeamAppsResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListTeamAppsResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListTeamAppsResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListTeamAppsResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListTeamAppsResult", LIST_TEAM_APPS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListTeamAppsResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListTeamAppsResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct ListTeamDevicesArg {
    /// At the first call to the [`devices_list_team_devices()`](devices_list_team_devices) the
    /// cursor shouldn't be passed. Then, if the result of the call includes a cursor, the following
    /// requests should include the received cursors in order to receive the next sub list of team
    /// devices.
    pub cursor: Option<String>,
    /// Whether to list web sessions of the team members.
    pub include_web_sessions: bool,
    /// Whether to list desktop clients of the team members.
    pub include_desktop_clients: bool,
    /// Whether to list mobile clients of the team members.
    pub include_mobile_clients: bool,
}

impl Default for ListTeamDevicesArg {
    fn default() -> Self {
        ListTeamDevicesArg {
            cursor: None,
            include_web_sessions: true,
            include_desktop_clients: true,
            include_mobile_clients: true,
        }
    }
}

const LIST_TEAM_DEVICES_ARG_FIELDS: &[&str] = &["cursor",
                                                "include_web_sessions",
                                                "include_desktop_clients",
                                                "include_mobile_clients"];
impl ListTeamDevicesArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ListTeamDevicesArg, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        let mut field_include_web_sessions = None;
        let mut field_include_desktop_clients = None;
        let mut field_include_mobile_clients = None;
        while let Some(key) = map.next_key()? {
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "include_web_sessions" => {
                    if field_include_web_sessions.is_some() {
                        return Err(de::Error::duplicate_field("include_web_sessions"));
                    }
                    field_include_web_sessions = Some(map.next_value()?);
                }
                "include_desktop_clients" => {
                    if field_include_desktop_clients.is_some() {
                        return Err(de::Error::duplicate_field("include_desktop_clients"));
                    }
                    field_include_desktop_clients = Some(map.next_value()?);
                }
                "include_mobile_clients" => {
                    if field_include_mobile_clients.is_some() {
                        return Err(de::Error::duplicate_field("include_mobile_clients"));
                    }
                    field_include_mobile_clients = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_TEAM_DEVICES_ARG_FIELDS))
            }
        }
        let result = ListTeamDevicesArg {
            cursor: field_cursor,
            include_web_sessions: field_include_web_sessions.unwrap_or(true),
            include_desktop_clients: field_include_desktop_clients.unwrap_or(true),
            include_mobile_clients: field_include_mobile_clients.unwrap_or(true),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("include_web_sessions", &self.include_web_sessions)?;
        s.serialize_field("include_desktop_clients", &self.include_desktop_clients)?;
        s.serialize_field("include_mobile_clients", &self.include_mobile_clients)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListTeamDevicesArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListTeamDevicesArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListTeamDevicesArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListTeamDevicesArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListTeamDevicesArg", LIST_TEAM_DEVICES_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListTeamDevicesArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListTeamDevicesArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum ListTeamDevicesError {
    /// Indicates that the cursor has been invalidated. Call
    /// [`devices_list_team_devices()`](devices_list_team_devices) again with an empty cursor to
    /// obtain a new cursor.
    Reset,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ListTeamDevicesError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ListTeamDevicesError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListTeamDevicesError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "reset" => Ok(ListTeamDevicesError::Reset),
                    _ => Ok(ListTeamDevicesError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["reset",
                                    "other"];
        deserializer.deserialize_struct("ListTeamDevicesError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ListTeamDevicesError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ListTeamDevicesError::Reset => {
                // unit
                let mut s = serializer.serialize_struct("ListTeamDevicesError", 1)?;
                s.serialize_field(".tag", "reset")?;
                s.end()
            }
            ListTeamDevicesError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for ListTeamDevicesError {
    fn description(&self) -> &str {
        "ListTeamDevicesError"
    }
}

impl ::std::fmt::Display for ListTeamDevicesError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct ListTeamDevicesResult {
    /// The devices of each member of the team.
    pub devices: Vec<MemberDevices>,
    /// If true, then there are more devices available. Pass the cursor to
    /// [`devices_list_team_devices()`](devices_list_team_devices) to retrieve the rest.
    pub has_more: bool,
    /// Pass the cursor into [`devices_list_team_devices()`](devices_list_team_devices) to receive
    /// the next sub list of team's devices.
    pub cursor: Option<String>,
}

impl ListTeamDevicesResult {
    pub fn new(devices: Vec<MemberDevices>, has_more: bool) -> Self {
        ListTeamDevicesResult {
            devices,
            has_more,
            cursor: None,
        }
    }

    pub fn with_cursor(mut self, value: Option<String>) -> Self {
        self.cursor = value;
        self
    }

}

const LIST_TEAM_DEVICES_RESULT_FIELDS: &[&str] = &["devices",
                                                   "has_more",
                                                   "cursor"];
impl ListTeamDevicesResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListTeamDevicesResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListTeamDevicesResult>, V::Error> {
        use serde::de;
        let mut field_devices = None;
        let mut field_has_more = None;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "devices" => {
                    if field_devices.is_some() {
                        return Err(de::Error::duplicate_field("devices"));
                    }
                    field_devices = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, LIST_TEAM_DEVICES_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListTeamDevicesResult {
            devices: field_devices.ok_or_else(|| de::Error::missing_field("devices"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
            cursor: field_cursor,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("devices", &self.devices)?;
        s.serialize_field("has_more", &self.has_more)?;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListTeamDevicesResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListTeamDevicesResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a ListTeamDevicesResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListTeamDevicesResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListTeamDevicesResult", LIST_TEAM_DEVICES_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListTeamDevicesResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListTeamDevicesResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Specify access type a member should have when joined to a group.
#[derive(Debug)]
pub struct MemberAccess {
    /// Identity of a user.
    pub user: UserSelectorArg,
    /// Access type.
    pub access_type: GroupAccessType,
}

impl MemberAccess {
    pub fn new(user: UserSelectorArg, access_type: GroupAccessType) -> Self {
        MemberAccess {
            user,
            access_type,
        }
    }

}

const MEMBER_ACCESS_FIELDS: &[&str] = &["user",
                                        "access_type"];
impl MemberAccess {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberAccess, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberAccess>, V::Error> {
        use serde::de;
        let mut field_user = None;
        let mut field_access_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "access_type" => {
                    if field_access_type.is_some() {
                        return Err(de::Error::duplicate_field("access_type"));
                    }
                    field_access_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_ACCESS_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberAccess {
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
            access_type: field_access_type.ok_or_else(|| de::Error::missing_field("access_type"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("access_type", &self.access_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAccess {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAccess;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberAccess struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAccess::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAccess", MEMBER_ACCESS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAccess {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAccess", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MemberAddArg {
    pub member_email: super::common::EmailAddress,
    /// Member's first name.
    pub member_given_name: Option<super::common::OptionalNamePart>,
    /// Member's last name.
    pub member_surname: Option<super::common::OptionalNamePart>,
    /// External ID for member.
    pub member_external_id: Option<super::team_common::MemberExternalId>,
    /// Persistent ID for member. This field is only available to teams using persistent ID SAML
    /// configuration.
    pub member_persistent_id: Option<String>,
    /// Whether to send a welcome email to the member. If send_welcome_email is false, no email
    /// invitation will be sent to the user. This may be useful for apps using single sign-on (SSO)
    /// flows for onboarding that want to handle announcements themselves.
    pub send_welcome_email: bool,
    pub role: AdminTier,
    /// Whether a user is directory restricted.
    pub is_directory_restricted: Option<bool>,
}

impl MemberAddArg {
    pub fn new(member_email: super::common::EmailAddress) -> Self {
        MemberAddArg {
            member_email,
            member_given_name: None,
            member_surname: None,
            member_external_id: None,
            member_persistent_id: None,
            send_welcome_email: true,
            role: AdminTier::MemberOnly,
            is_directory_restricted: None,
        }
    }

    pub fn with_member_given_name(
        mut self,
        value: Option<super::common::OptionalNamePart>,
    ) -> Self {
        self.member_given_name = value;
        self
    }

    pub fn with_member_surname(mut self, value: Option<super::common::OptionalNamePart>) -> Self {
        self.member_surname = value;
        self
    }

    pub fn with_member_external_id(
        mut self,
        value: Option<super::team_common::MemberExternalId>,
    ) -> Self {
        self.member_external_id = value;
        self
    }

    pub fn with_member_persistent_id(mut self, value: Option<String>) -> Self {
        self.member_persistent_id = value;
        self
    }

    pub fn with_send_welcome_email(mut self, value: bool) -> Self {
        self.send_welcome_email = value;
        self
    }

    pub fn with_role(mut self, value: AdminTier) -> Self {
        self.role = value;
        self
    }

    pub fn with_is_directory_restricted(mut self, value: Option<bool>) -> Self {
        self.is_directory_restricted = value;
        self
    }

}

const MEMBER_ADD_ARG_FIELDS: &[&str] = &["member_email",
                                         "member_given_name",
                                         "member_surname",
                                         "member_external_id",
                                         "member_persistent_id",
                                         "send_welcome_email",
                                         "role",
                                         "is_directory_restricted"];
impl MemberAddArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberAddArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberAddArg>, V::Error> {
        use serde::de;
        let mut field_member_email = None;
        let mut field_member_given_name = None;
        let mut field_member_surname = None;
        let mut field_member_external_id = None;
        let mut field_member_persistent_id = None;
        let mut field_send_welcome_email = None;
        let mut field_role = None;
        let mut field_is_directory_restricted = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "member_email" => {
                    if field_member_email.is_some() {
                        return Err(de::Error::duplicate_field("member_email"));
                    }
                    field_member_email = Some(map.next_value()?);
                }
                "member_given_name" => {
                    if field_member_given_name.is_some() {
                        return Err(de::Error::duplicate_field("member_given_name"));
                    }
                    field_member_given_name = Some(map.next_value()?);
                }
                "member_surname" => {
                    if field_member_surname.is_some() {
                        return Err(de::Error::duplicate_field("member_surname"));
                    }
                    field_member_surname = Some(map.next_value()?);
                }
                "member_external_id" => {
                    if field_member_external_id.is_some() {
                        return Err(de::Error::duplicate_field("member_external_id"));
                    }
                    field_member_external_id = Some(map.next_value()?);
                }
                "member_persistent_id" => {
                    if field_member_persistent_id.is_some() {
                        return Err(de::Error::duplicate_field("member_persistent_id"));
                    }
                    field_member_persistent_id = Some(map.next_value()?);
                }
                "send_welcome_email" => {
                    if field_send_welcome_email.is_some() {
                        return Err(de::Error::duplicate_field("send_welcome_email"));
                    }
                    field_send_welcome_email = Some(map.next_value()?);
                }
                "role" => {
                    if field_role.is_some() {
                        return Err(de::Error::duplicate_field("role"));
                    }
                    field_role = Some(map.next_value()?);
                }
                "is_directory_restricted" => {
                    if field_is_directory_restricted.is_some() {
                        return Err(de::Error::duplicate_field("is_directory_restricted"));
                    }
                    field_is_directory_restricted = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_ADD_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberAddArg {
            member_email: field_member_email.ok_or_else(|| de::Error::missing_field("member_email"))?,
            member_given_name: field_member_given_name,
            member_surname: field_member_surname,
            member_external_id: field_member_external_id,
            member_persistent_id: field_member_persistent_id,
            send_welcome_email: field_send_welcome_email.unwrap_or(true),
            role: field_role.unwrap_or_else(|| AdminTier::MemberOnly),
            is_directory_restricted: field_is_directory_restricted,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("member_email", &self.member_email)?;
        s.serialize_field("member_given_name", &self.member_given_name)?;
        s.serialize_field("member_surname", &self.member_surname)?;
        s.serialize_field("member_external_id", &self.member_external_id)?;
        s.serialize_field("member_persistent_id", &self.member_persistent_id)?;
        s.serialize_field("send_welcome_email", &self.send_welcome_email)?;
        s.serialize_field("role", &self.role)?;
        s.serialize_field("is_directory_restricted", &self.is_directory_restricted)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAddArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberAddArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberAddArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberAddArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberAddArg", MEMBER_ADD_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAddArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberAddArg", 8)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Describes the result of attempting to add a single user to the team. 'success' is the only value
/// indicating that a user was indeed added to the team - the other values explain the type of
/// failure that occurred, and include the email of the user for which the operation has failed.
#[derive(Debug)]
pub enum MemberAddResult {
    /// Describes a user that was successfully added to the team.
    Success(TeamMemberInfo),
    /// Team is already full. The organization has no available licenses.
    TeamLicenseLimit(super::common::EmailAddress),
    /// Team is already full. The free team member limit has been reached.
    FreeTeamMemberLimitReached(super::common::EmailAddress),
    /// User is already on this team. The provided email address is associated with a user who is
    /// already a member of (including in recoverable state) or invited to the team.
    UserAlreadyOnTeam(super::common::EmailAddress),
    /// User is already on another team. The provided email address is associated with a user that
    /// is already a member or invited to another team.
    UserOnAnotherTeam(super::common::EmailAddress),
    /// User is already paired.
    UserAlreadyPaired(super::common::EmailAddress),
    /// User migration has failed.
    UserMigrationFailed(super::common::EmailAddress),
    /// A user with the given external member ID already exists on the team (including in
    /// recoverable state).
    DuplicateExternalMemberId(super::common::EmailAddress),
    /// A user with the given persistent ID already exists on the team (including in recoverable
    /// state).
    DuplicateMemberPersistentId(super::common::EmailAddress),
    /// Persistent ID is only available to teams with persistent ID SAML configuration. Please
    /// contact Dropbox for more information.
    PersistentIdDisabled(super::common::EmailAddress),
    /// User creation has failed.
    UserCreationFailed(super::common::EmailAddress),
}

impl<'de> ::serde::de::Deserialize<'de> for MemberAddResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberAddResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberAddResult structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "success" => Ok(MemberAddResult::Success(TeamMemberInfo::internal_deserialize(map)?)),
                    "team_license_limit" => {
                        match map.next_key()? {
                            Some("team_license_limit") => Ok(MemberAddResult::TeamLicenseLimit(map.next_value()?)),
                            None => Err(de::Error::missing_field("team_license_limit")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "free_team_member_limit_reached" => {
                        match map.next_key()? {
                            Some("free_team_member_limit_reached") => Ok(MemberAddResult::FreeTeamMemberLimitReached(map.next_value()?)),
                            None => Err(de::Error::missing_field("free_team_member_limit_reached")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "user_already_on_team" => {
                        match map.next_key()? {
                            Some("user_already_on_team") => Ok(MemberAddResult::UserAlreadyOnTeam(map.next_value()?)),
                            None => Err(de::Error::missing_field("user_already_on_team")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "user_on_another_team" => {
                        match map.next_key()? {
                            Some("user_on_another_team") => Ok(MemberAddResult::UserOnAnotherTeam(map.next_value()?)),
                            None => Err(de::Error::missing_field("user_on_another_team")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "user_already_paired" => {
                        match map.next_key()? {
                            Some("user_already_paired") => Ok(MemberAddResult::UserAlreadyPaired(map.next_value()?)),
                            None => Err(de::Error::missing_field("user_already_paired")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "user_migration_failed" => {
                        match map.next_key()? {
                            Some("user_migration_failed") => Ok(MemberAddResult::UserMigrationFailed(map.next_value()?)),
                            None => Err(de::Error::missing_field("user_migration_failed")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "duplicate_external_member_id" => {
                        match map.next_key()? {
                            Some("duplicate_external_member_id") => Ok(MemberAddResult::DuplicateExternalMemberId(map.next_value()?)),
                            None => Err(de::Error::missing_field("duplicate_external_member_id")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "duplicate_member_persistent_id" => {
                        match map.next_key()? {
                            Some("duplicate_member_persistent_id") => Ok(MemberAddResult::DuplicateMemberPersistentId(map.next_value()?)),
                            None => Err(de::Error::missing_field("duplicate_member_persistent_id")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "persistent_id_disabled" => {
                        match map.next_key()? {
                            Some("persistent_id_disabled") => Ok(MemberAddResult::PersistentIdDisabled(map.next_value()?)),
                            None => Err(de::Error::missing_field("persistent_id_disabled")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "user_creation_failed" => {
                        match map.next_key()? {
                            Some("user_creation_failed") => Ok(MemberAddResult::UserCreationFailed(map.next_value()?)),
                            None => Err(de::Error::missing_field("user_creation_failed")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["success",
                                    "team_license_limit",
                                    "free_team_member_limit_reached",
                                    "user_already_on_team",
                                    "user_on_another_team",
                                    "user_already_paired",
                                    "user_migration_failed",
                                    "duplicate_external_member_id",
                                    "duplicate_member_persistent_id",
                                    "persistent_id_disabled",
                                    "user_creation_failed"];
        deserializer.deserialize_struct("MemberAddResult", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberAddResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberAddResult::Success(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("MemberAddResult", 3)?;
                s.serialize_field(".tag", "success")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            MemberAddResult::TeamLicenseLimit(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "team_license_limit")?;
                s.serialize_field("team_license_limit", x)?;
                s.end()
            }
            MemberAddResult::FreeTeamMemberLimitReached(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "free_team_member_limit_reached")?;
                s.serialize_field("free_team_member_limit_reached", x)?;
                s.end()
            }
            MemberAddResult::UserAlreadyOnTeam(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "user_already_on_team")?;
                s.serialize_field("user_already_on_team", x)?;
                s.end()
            }
            MemberAddResult::UserOnAnotherTeam(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "user_on_another_team")?;
                s.serialize_field("user_on_another_team", x)?;
                s.end()
            }
            MemberAddResult::UserAlreadyPaired(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "user_already_paired")?;
                s.serialize_field("user_already_paired", x)?;
                s.end()
            }
            MemberAddResult::UserMigrationFailed(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "user_migration_failed")?;
                s.serialize_field("user_migration_failed", x)?;
                s.end()
            }
            MemberAddResult::DuplicateExternalMemberId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "duplicate_external_member_id")?;
                s.serialize_field("duplicate_external_member_id", x)?;
                s.end()
            }
            MemberAddResult::DuplicateMemberPersistentId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "duplicate_member_persistent_id")?;
                s.serialize_field("duplicate_member_persistent_id", x)?;
                s.end()
            }
            MemberAddResult::PersistentIdDisabled(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "persistent_id_disabled")?;
                s.serialize_field("persistent_id_disabled", x)?;
                s.end()
            }
            MemberAddResult::UserCreationFailed(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MemberAddResult", 2)?;
                s.serialize_field(".tag", "user_creation_failed")?;
                s.serialize_field("user_creation_failed", x)?;
                s.end()
            }
        }
    }
}

/// Information on devices of a team's member.
#[derive(Debug)]
pub struct MemberDevices {
    /// The member unique Id.
    pub team_member_id: String,
    /// List of web sessions made by this team member.
    pub web_sessions: Option<Vec<ActiveWebSession>>,
    /// List of desktop clients by this team member.
    pub desktop_clients: Option<Vec<DesktopClientSession>>,
    /// List of mobile clients by this team member.
    pub mobile_clients: Option<Vec<MobileClientSession>>,
}

impl MemberDevices {
    pub fn new(team_member_id: String) -> Self {
        MemberDevices {
            team_member_id,
            web_sessions: None,
            desktop_clients: None,
            mobile_clients: None,
        }
    }

    pub fn with_web_sessions(mut self, value: Option<Vec<ActiveWebSession>>) -> Self {
        self.web_sessions = value;
        self
    }

    pub fn with_desktop_clients(mut self, value: Option<Vec<DesktopClientSession>>) -> Self {
        self.desktop_clients = value;
        self
    }

    pub fn with_mobile_clients(mut self, value: Option<Vec<MobileClientSession>>) -> Self {
        self.mobile_clients = value;
        self
    }

}

const MEMBER_DEVICES_FIELDS: &[&str] = &["team_member_id",
                                         "web_sessions",
                                         "desktop_clients",
                                         "mobile_clients"];
impl MemberDevices {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberDevices, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberDevices>, V::Error> {
        use serde::de;
        let mut field_team_member_id = None;
        let mut field_web_sessions = None;
        let mut field_desktop_clients = None;
        let mut field_mobile_clients = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "web_sessions" => {
                    if field_web_sessions.is_some() {
                        return Err(de::Error::duplicate_field("web_sessions"));
                    }
                    field_web_sessions = Some(map.next_value()?);
                }
                "desktop_clients" => {
                    if field_desktop_clients.is_some() {
                        return Err(de::Error::duplicate_field("desktop_clients"));
                    }
                    field_desktop_clients = Some(map.next_value()?);
                }
                "mobile_clients" => {
                    if field_mobile_clients.is_some() {
                        return Err(de::Error::duplicate_field("mobile_clients"));
                    }
                    field_mobile_clients = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_DEVICES_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberDevices {
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
            web_sessions: field_web_sessions,
            desktop_clients: field_desktop_clients,
            mobile_clients: field_mobile_clients,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("web_sessions", &self.web_sessions)?;
        s.serialize_field("desktop_clients", &self.desktop_clients)?;
        s.serialize_field("mobile_clients", &self.mobile_clients)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberDevices {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberDevices;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberDevices struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberDevices::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberDevices", MEMBER_DEVICES_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberDevices {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberDevices", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information on linked applications of a team member.
#[derive(Debug)]
pub struct MemberLinkedApps {
    /// The member unique Id.
    pub team_member_id: String,
    /// List of third party applications linked by this team member.
    pub linked_api_apps: Vec<ApiApp>,
}

impl MemberLinkedApps {
    pub fn new(team_member_id: String, linked_api_apps: Vec<ApiApp>) -> Self {
        MemberLinkedApps {
            team_member_id,
            linked_api_apps,
        }
    }

}

const MEMBER_LINKED_APPS_FIELDS: &[&str] = &["team_member_id",
                                             "linked_api_apps"];
impl MemberLinkedApps {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberLinkedApps, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberLinkedApps>, V::Error> {
        use serde::de;
        let mut field_team_member_id = None;
        let mut field_linked_api_apps = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "linked_api_apps" => {
                    if field_linked_api_apps.is_some() {
                        return Err(de::Error::duplicate_field("linked_api_apps"));
                    }
                    field_linked_api_apps = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_LINKED_APPS_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberLinkedApps {
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
            linked_api_apps: field_linked_api_apps.ok_or_else(|| de::Error::missing_field("linked_api_apps"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("linked_api_apps", &self.linked_api_apps)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberLinkedApps {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberLinkedApps;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberLinkedApps struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberLinkedApps::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberLinkedApps", MEMBER_LINKED_APPS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberLinkedApps {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberLinkedApps", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Basic member profile.
#[derive(Debug)]
pub struct MemberProfile {
    /// ID of user as a member of a team.
    pub team_member_id: super::team_common::TeamMemberId,
    /// Email address of user.
    pub email: String,
    /// Is true if the user's email is verified to be owned by the user.
    pub email_verified: bool,
    /// The user's status as a member of a specific team.
    pub status: TeamMemberStatus,
    /// Representations for a person's name.
    pub name: super::users::Name,
    /// The user's membership type: full (normal team member) vs limited (does not use a license; no
    /// access to the team's shared quota).
    pub membership_type: TeamMembershipType,
    /// External ID that a team can attach to the user. An application using the API may find it
    /// easier to use their own IDs instead of Dropbox IDs like account_id or team_member_id.
    pub external_id: Option<String>,
    /// A user's account identifier.
    pub account_id: Option<super::users_common::AccountId>,
    /// The date and time the user joined as a member of a specific team.
    pub joined_on: Option<super::common::DropboxTimestamp>,
    /// Persistent ID that a team can attach to the user. The persistent ID is unique ID to be used
    /// for SAML authentication.
    pub persistent_id: Option<String>,
    /// Whether the user is a directory restricted user.
    pub is_directory_restricted: Option<bool>,
}

impl MemberProfile {
    pub fn new(
        team_member_id: super::team_common::TeamMemberId,
        email: String,
        email_verified: bool,
        status: TeamMemberStatus,
        name: super::users::Name,
        membership_type: TeamMembershipType,
    ) -> Self {
        MemberProfile {
            team_member_id,
            email,
            email_verified,
            status,
            name,
            membership_type,
            external_id: None,
            account_id: None,
            joined_on: None,
            persistent_id: None,
            is_directory_restricted: None,
        }
    }

    pub fn with_external_id(mut self, value: Option<String>) -> Self {
        self.external_id = value;
        self
    }

    pub fn with_account_id(mut self, value: Option<super::users_common::AccountId>) -> Self {
        self.account_id = value;
        self
    }

    pub fn with_joined_on(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.joined_on = value;
        self
    }

    pub fn with_persistent_id(mut self, value: Option<String>) -> Self {
        self.persistent_id = value;
        self
    }

    pub fn with_is_directory_restricted(mut self, value: Option<bool>) -> Self {
        self.is_directory_restricted = value;
        self
    }

}

const MEMBER_PROFILE_FIELDS: &[&str] = &["team_member_id",
                                         "email",
                                         "email_verified",
                                         "status",
                                         "name",
                                         "membership_type",
                                         "external_id",
                                         "account_id",
                                         "joined_on",
                                         "persistent_id",
                                         "is_directory_restricted"];
impl MemberProfile {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MemberProfile, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MemberProfile>, V::Error> {
        use serde::de;
        let mut field_team_member_id = None;
        let mut field_email = None;
        let mut field_email_verified = None;
        let mut field_status = None;
        let mut field_name = None;
        let mut field_membership_type = None;
        let mut field_external_id = None;
        let mut field_account_id = None;
        let mut field_joined_on = None;
        let mut field_persistent_id = None;
        let mut field_is_directory_restricted = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "email_verified" => {
                    if field_email_verified.is_some() {
                        return Err(de::Error::duplicate_field("email_verified"));
                    }
                    field_email_verified = Some(map.next_value()?);
                }
                "status" => {
                    if field_status.is_some() {
                        return Err(de::Error::duplicate_field("status"));
                    }
                    field_status = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "membership_type" => {
                    if field_membership_type.is_some() {
                        return Err(de::Error::duplicate_field("membership_type"));
                    }
                    field_membership_type = Some(map.next_value()?);
                }
                "external_id" => {
                    if field_external_id.is_some() {
                        return Err(de::Error::duplicate_field("external_id"));
                    }
                    field_external_id = Some(map.next_value()?);
                }
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "joined_on" => {
                    if field_joined_on.is_some() {
                        return Err(de::Error::duplicate_field("joined_on"));
                    }
                    field_joined_on = Some(map.next_value()?);
                }
                "persistent_id" => {
                    if field_persistent_id.is_some() {
                        return Err(de::Error::duplicate_field("persistent_id"));
                    }
                    field_persistent_id = Some(map.next_value()?);
                }
                "is_directory_restricted" => {
                    if field_is_directory_restricted.is_some() {
                        return Err(de::Error::duplicate_field("is_directory_restricted"));
                    }
                    field_is_directory_restricted = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBER_PROFILE_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MemberProfile {
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
            email: field_email.ok_or_else(|| de::Error::missing_field("email"))?,
            email_verified: field_email_verified.ok_or_else(|| de::Error::missing_field("email_verified"))?,
            status: field_status.ok_or_else(|| de::Error::missing_field("status"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            membership_type: field_membership_type.ok_or_else(|| de::Error::missing_field("membership_type"))?,
            external_id: field_external_id,
            account_id: field_account_id,
            joined_on: field_joined_on,
            persistent_id: field_persistent_id,
            is_directory_restricted: field_is_directory_restricted,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("email_verified", &self.email_verified)?;
        s.serialize_field("status", &self.status)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("membership_type", &self.membership_type)?;
        s.serialize_field("external_id", &self.external_id)?;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("joined_on", &self.joined_on)?;
        s.serialize_field("persistent_id", &self.persistent_id)?;
        s.serialize_field("is_directory_restricted", &self.is_directory_restricted)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MemberProfile {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MemberProfile;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberProfile struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MemberProfile::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MemberProfile", MEMBER_PROFILE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MemberProfile {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MemberProfile", 11)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MemberSelectorError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
    /// The user is not a member of the team.
    UserNotInTeam,
}

impl<'de> ::serde::de::Deserialize<'de> for MemberSelectorError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MemberSelectorError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MemberSelectorError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(MemberSelectorError::UserNotFound),
                    "user_not_in_team" => Ok(MemberSelectorError::UserNotInTeam),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found",
                                    "user_not_in_team"];
        deserializer.deserialize_struct("MemberSelectorError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MemberSelectorError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MemberSelectorError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MemberSelectorError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            MemberSelectorError::UserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MemberSelectorError", 1)?;
                s.serialize_field(".tag", "user_not_in_team")?;
                s.end()
            }
        }
    }
}

impl ::std::error::Error for MemberSelectorError {
    fn description(&self) -> &str {
        "MemberSelectorError"
    }
}

impl ::std::fmt::Display for MemberSelectorError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct MembersAddArg {
    /// Details of new members to be added to the team.
    pub new_members: Vec<MemberAddArg>,
    /// Whether to force the add to happen asynchronously.
    pub force_async: bool,
}

impl MembersAddArg {
    pub fn new(new_members: Vec<MemberAddArg>) -> Self {
        MembersAddArg {
            new_members,
            force_async: false,
        }
    }

    pub fn with_force_async(mut self, value: bool) -> Self {
        self.force_async = value;
        self
    }

}

const MEMBERS_ADD_ARG_FIELDS: &[&str] = &["new_members",
                                          "force_async"];
impl MembersAddArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersAddArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersAddArg>, V::Error> {
        use serde::de;
        let mut field_new_members = None;
        let mut field_force_async = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "new_members" => {
                    if field_new_members.is_some() {
                        return Err(de::Error::duplicate_field("new_members"));
                    }
                    field_new_members = Some(map.next_value()?);
                }
                "force_async" => {
                    if field_force_async.is_some() {
                        return Err(de::Error::duplicate_field("force_async"));
                    }
                    field_force_async = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_ADD_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersAddArg {
            new_members: field_new_members.ok_or_else(|| de::Error::missing_field("new_members"))?,
            force_async: field_force_async.unwrap_or(false),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("new_members", &self.new_members)?;
        s.serialize_field("force_async", &self.force_async)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersAddArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersAddArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersAddArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersAddArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersAddArg", MEMBERS_ADD_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersAddArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersAddArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MembersAddJobStatus {
    /// The asynchronous job is still in progress.
    InProgress,
    /// The asynchronous job has finished. For each member that was specified in the parameter
    /// [`MembersAddArg`](MembersAddArg) that was provided to [`members_add()`](members_add), a
    /// corresponding item is returned in this list.
    Complete(Vec<MemberAddResult>),
    /// The asynchronous job returned an error. The string contains an error message.
    Failed(String),
}

impl<'de> ::serde::de::Deserialize<'de> for MembersAddJobStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersAddJobStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersAddJobStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "in_progress" => Ok(MembersAddJobStatus::InProgress),
                    "complete" => {
                        match map.next_key()? {
                            Some("complete") => Ok(MembersAddJobStatus::Complete(map.next_value()?)),
                            None => Err(de::Error::missing_field("complete")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "failed" => {
                        match map.next_key()? {
                            Some("failed") => Ok(MembersAddJobStatus::Failed(map.next_value()?)),
                            None => Err(de::Error::missing_field("failed")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["in_progress",
                                    "complete",
                                    "failed"];
        deserializer.deserialize_struct("MembersAddJobStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersAddJobStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersAddJobStatus::InProgress => {
                // unit
                let mut s = serializer.serialize_struct("MembersAddJobStatus", 1)?;
                s.serialize_field(".tag", "in_progress")?;
                s.end()
            }
            MembersAddJobStatus::Complete(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MembersAddJobStatus", 2)?;
                s.serialize_field(".tag", "complete")?;
                s.serialize_field("complete", x)?;
                s.end()
            }
            MembersAddJobStatus::Failed(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MembersAddJobStatus", 2)?;
                s.serialize_field(".tag", "failed")?;
                s.serialize_field("failed", x)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub enum MembersAddLaunch {
    /// This response indicates that the processing is asynchronous. The string is an id that can be
    /// used to obtain the status of the asynchronous job.
    AsyncJobId(super::async::AsyncJobId),
    Complete(Vec<MemberAddResult>),
}

impl<'de> ::serde::de::Deserialize<'de> for MembersAddLaunch {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersAddLaunch;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersAddLaunch structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "async_job_id" => {
                        match map.next_key()? {
                            Some("async_job_id") => Ok(MembersAddLaunch::AsyncJobId(map.next_value()?)),
                            None => Err(de::Error::missing_field("async_job_id")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "complete" => {
                        match map.next_key()? {
                            Some("complete") => Ok(MembersAddLaunch::Complete(map.next_value()?)),
                            None => Err(de::Error::missing_field("complete")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["async_job_id",
                                    "complete"];
        deserializer.deserialize_struct("MembersAddLaunch", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersAddLaunch {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersAddLaunch::AsyncJobId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MembersAddLaunch", 2)?;
                s.serialize_field(".tag", "async_job_id")?;
                s.serialize_field("async_job_id", x)?;
                s.end()
            }
            MembersAddLaunch::Complete(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MembersAddLaunch", 2)?;
                s.serialize_field(".tag", "complete")?;
                s.serialize_field("complete", x)?;
                s.end()
            }
        }
    }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user
/// account.
#[derive(Debug)]
pub struct MembersDeactivateArg {
    /// Identity of user to remove/suspend.
    pub user: UserSelectorArg,
    /// If provided, controls if the user's data will be deleted on their linked devices.
    pub wipe_data: bool,
}

impl MembersDeactivateArg {
    pub fn new(user: UserSelectorArg) -> Self {
        MembersDeactivateArg {
            user,
            wipe_data: true,
        }
    }

    pub fn with_wipe_data(mut self, value: bool) -> Self {
        self.wipe_data = value;
        self
    }

}

const MEMBERS_DEACTIVATE_ARG_FIELDS: &[&str] = &["user",
                                                 "wipe_data"];
impl MembersDeactivateArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersDeactivateArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersDeactivateArg>, V::Error> {
        use serde::de;
        let mut field_user = None;
        let mut field_wipe_data = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "wipe_data" => {
                    if field_wipe_data.is_some() {
                        return Err(de::Error::duplicate_field("wipe_data"));
                    }
                    field_wipe_data = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_DEACTIVATE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersDeactivateArg {
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
            wipe_data: field_wipe_data.unwrap_or(true),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("wipe_data", &self.wipe_data)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersDeactivateArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersDeactivateArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersDeactivateArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersDeactivateArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersDeactivateArg", MEMBERS_DEACTIVATE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersDeactivateArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersDeactivateArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MembersDeactivateError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
    /// The user is not a member of the team.
    UserNotInTeam,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersDeactivateError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersDeactivateError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersDeactivateError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(MembersDeactivateError::UserNotFound),
                    "user_not_in_team" => Ok(MembersDeactivateError::UserNotInTeam),
                    _ => Ok(MembersDeactivateError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found",
                                    "user_not_in_team",
                                    "other"];
        deserializer.deserialize_struct("MembersDeactivateError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersDeactivateError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersDeactivateError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersDeactivateError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            MembersDeactivateError::UserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersDeactivateError", 1)?;
                s.serialize_field(".tag", "user_not_in_team")?;
                s.end()
            }
            MembersDeactivateError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MembersDeactivateError {
    fn description(&self) -> &str {
        "MembersDeactivateError"
    }
}

impl ::std::fmt::Display for MembersDeactivateError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct MembersGetInfoArgs {
    /// List of team members.
    pub members: Vec<UserSelectorArg>,
}

impl MembersGetInfoArgs {
    pub fn new(members: Vec<UserSelectorArg>) -> Self {
        MembersGetInfoArgs {
            members,
        }
    }

}

const MEMBERS_GET_INFO_ARGS_FIELDS: &[&str] = &["members"];
impl MembersGetInfoArgs {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersGetInfoArgs, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersGetInfoArgs>, V::Error> {
        use serde::de;
        let mut field_members = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "members" => {
                    if field_members.is_some() {
                        return Err(de::Error::duplicate_field("members"));
                    }
                    field_members = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_GET_INFO_ARGS_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersGetInfoArgs {
            members: field_members.ok_or_else(|| de::Error::missing_field("members"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("members", &self.members)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersGetInfoArgs {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersGetInfoArgs;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersGetInfoArgs struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersGetInfoArgs::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersGetInfoArgs", MEMBERS_GET_INFO_ARGS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersGetInfoArgs {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersGetInfoArgs", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}


#[derive(Debug)]
pub enum MembersGetInfoError {
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersGetInfoError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersGetInfoError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersGetInfoError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    _ => Ok(MembersGetInfoError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["other"];
        deserializer.deserialize_struct("MembersGetInfoError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersGetInfoError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        #![allow(unused_variables)]
        Err(::serde::ser::Error::custom("cannot serialize an open union with no defined variants"))
    }
}

impl ::std::error::Error for MembersGetInfoError {
    fn description(&self) -> &str {
        "MembersGetInfoError"
    }
}

impl ::std::fmt::Display for MembersGetInfoError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Describes a result obtained for a single user whose id was specified in the parameter of
/// [`members_get_info()`](members_get_info).
#[derive(Debug)]
pub enum MembersGetInfoItem {
    /// An ID that was provided as a parameter to [`members_get_info()`](members_get_info), and did
    /// not match a corresponding user. This might be a team_member_id, an email, or an external ID,
    /// depending on how the method was called.
    IdNotFound(String),
    /// Info about a team member.
    MemberInfo(TeamMemberInfo),
}

impl<'de> ::serde::de::Deserialize<'de> for MembersGetInfoItem {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersGetInfoItem;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersGetInfoItem structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "id_not_found" => {
                        match map.next_key()? {
                            Some("id_not_found") => Ok(MembersGetInfoItem::IdNotFound(map.next_value()?)),
                            None => Err(de::Error::missing_field("id_not_found")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "member_info" => Ok(MembersGetInfoItem::MemberInfo(TeamMemberInfo::internal_deserialize(map)?)),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["id_not_found",
                                    "member_info"];
        deserializer.deserialize_struct("MembersGetInfoItem", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersGetInfoItem {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersGetInfoItem::IdNotFound(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("MembersGetInfoItem", 2)?;
                s.serialize_field(".tag", "id_not_found")?;
                s.serialize_field("id_not_found", x)?;
                s.end()
            }
            MembersGetInfoItem::MemberInfo(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("MembersGetInfoItem", 3)?;
                s.serialize_field(".tag", "member_info")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub struct MembersListArg {
    /// Number of results to return per call.
    pub limit: u32,
    /// Whether to return removed members.
    pub include_removed: bool,
}

impl Default for MembersListArg {
    fn default() -> Self {
        MembersListArg {
            limit: 1000,
            include_removed: false,
        }
    }
}

const MEMBERS_LIST_ARG_FIELDS: &[&str] = &["limit",
                                           "include_removed"];
impl MembersListArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<MembersListArg, V::Error> {
        use serde::de;
        let mut field_limit = None;
        let mut field_include_removed = None;
        while let Some(key) = map.next_key()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                "include_removed" => {
                    if field_include_removed.is_some() {
                        return Err(de::Error::duplicate_field("include_removed"));
                    }
                    field_include_removed = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_LIST_ARG_FIELDS))
            }
        }
        let result = MembersListArg {
            limit: field_limit.unwrap_or(1000),
            include_removed: field_include_removed.unwrap_or(false),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)?;
        s.serialize_field("include_removed", &self.include_removed)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersListArg", MEMBERS_LIST_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersListArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct MembersListContinueArg {
    /// Indicates from what point to get the next set of members.
    pub cursor: String,
}

impl MembersListContinueArg {
    pub fn new(cursor: String) -> Self {
        MembersListContinueArg {
            cursor,
        }
    }

}

const MEMBERS_LIST_CONTINUE_ARG_FIELDS: &[&str] = &["cursor"];
impl MembersListContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersListContinueArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersListContinueArg>, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_LIST_CONTINUE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersListContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersListContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersListContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersListContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersListContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersListContinueArg", MEMBERS_LIST_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersListContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersListContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MembersListContinueError {
    /// The cursor is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersListContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersListContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersListContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_cursor" => Ok(MembersListContinueError::InvalidCursor),
                    _ => Ok(MembersListContinueError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_cursor",
                                    "other"];
        deserializer.deserialize_struct("MembersListContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersListContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersListContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("MembersListContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            MembersListContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MembersListContinueError {
    fn description(&self) -> &str {
        "MembersListContinueError"
    }
}

impl ::std::fmt::Display for MembersListContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}


#[derive(Debug)]
pub enum MembersListError {
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersListError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersListError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersListError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    _ => Ok(MembersListError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["other"];
        deserializer.deserialize_struct("MembersListError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersListError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        #![allow(unused_variables)]
        Err(::serde::ser::Error::custom("cannot serialize an open union with no defined variants"))
    }
}

impl ::std::error::Error for MembersListError {
    fn description(&self) -> &str {
        "MembersListError"
    }
}

impl ::std::fmt::Display for MembersListError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct MembersListResult {
    /// List of team members.
    pub members: Vec<TeamMemberInfo>,
    /// Pass the cursor into [`members_list_continue()`](members_list_continue) to obtain the
    /// additional members.
    pub cursor: String,
    /// Is true if there are additional team members that have not been returned yet. An additional
    /// call to [`members_list_continue()`](members_list_continue) can retrieve them.
    pub has_more: bool,
}

impl MembersListResult {
    pub fn new(members: Vec<TeamMemberInfo>, cursor: String, has_more: bool) -> Self {
        MembersListResult {
            members,
            cursor,
            has_more,
        }
    }

}

const MEMBERS_LIST_RESULT_FIELDS: &[&str] = &["members",
                                              "cursor",
                                              "has_more"];
impl MembersListResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersListResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersListResult>, V::Error> {
        use serde::de;
        let mut field_members = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "members" => {
                    if field_members.is_some() {
                        return Err(de::Error::duplicate_field("members"));
                    }
                    field_members = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_LIST_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersListResult {
            members: field_members.ok_or_else(|| de::Error::missing_field("members"))?,
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("members", &self.members)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersListResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersListResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersListResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersListResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersListResult", MEMBERS_LIST_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersListResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersListResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user
/// account.
#[derive(Debug)]
pub struct MembersRecoverArg {
    /// Identity of user to recover.
    pub user: UserSelectorArg,
}

impl MembersRecoverArg {
    pub fn new(user: UserSelectorArg) -> Self {
        MembersRecoverArg {
            user,
        }
    }

}

const MEMBERS_RECOVER_ARG_FIELDS: &[&str] = &["user"];
impl MembersRecoverArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersRecoverArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersRecoverArg>, V::Error> {
        use serde::de;
        let mut field_user = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_RECOVER_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersRecoverArg {
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user", &self.user)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersRecoverArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersRecoverArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersRecoverArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersRecoverArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersRecoverArg", MEMBERS_RECOVER_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersRecoverArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersRecoverArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MembersRecoverError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
    /// The user is not recoverable.
    UserUnrecoverable,
    /// The user is not a member of the team.
    UserNotInTeam,
    /// Team is full. The organization has no available licenses.
    TeamLicenseLimit,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersRecoverError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersRecoverError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersRecoverError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(MembersRecoverError::UserNotFound),
                    "user_unrecoverable" => Ok(MembersRecoverError::UserUnrecoverable),
                    "user_not_in_team" => Ok(MembersRecoverError::UserNotInTeam),
                    "team_license_limit" => Ok(MembersRecoverError::TeamLicenseLimit),
                    _ => Ok(MembersRecoverError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found",
                                    "user_unrecoverable",
                                    "user_not_in_team",
                                    "team_license_limit",
                                    "other"];
        deserializer.deserialize_struct("MembersRecoverError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersRecoverError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersRecoverError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersRecoverError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            MembersRecoverError::UserUnrecoverable => {
                // unit
                let mut s = serializer.serialize_struct("MembersRecoverError", 1)?;
                s.serialize_field(".tag", "user_unrecoverable")?;
                s.end()
            }
            MembersRecoverError::UserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersRecoverError", 1)?;
                s.serialize_field(".tag", "user_not_in_team")?;
                s.end()
            }
            MembersRecoverError::TeamLicenseLimit => {
                // unit
                let mut s = serializer.serialize_struct("MembersRecoverError", 1)?;
                s.serialize_field(".tag", "team_license_limit")?;
                s.end()
            }
            MembersRecoverError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MembersRecoverError {
    fn description(&self) -> &str {
        "MembersRecoverError"
    }
}

impl ::std::fmt::Display for MembersRecoverError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct MembersRemoveArg {
    /// Identity of user to remove/suspend.
    pub user: UserSelectorArg,
    /// If provided, controls if the user's data will be deleted on their linked devices.
    pub wipe_data: bool,
    /// If provided, files from the deleted member account will be transferred to this user.
    pub transfer_dest_id: Option<UserSelectorArg>,
    /// If provided, errors during the transfer process will be sent via email to this user. If the
    /// transfer_dest_id argument was provided, then this argument must be provided as well.
    pub transfer_admin_id: Option<UserSelectorArg>,
    /// Downgrade the member to a Basic account. The user will retain the email address associated
    /// with their Dropbox  account and data in their account that is not restricted to team
    /// members. In order to keep the account the argument wipe_data should be set to False.
    pub keep_account: bool,
}

impl MembersRemoveArg {
    pub fn new(user: UserSelectorArg) -> Self {
        MembersRemoveArg {
            user,
            wipe_data: true,
            transfer_dest_id: None,
            transfer_admin_id: None,
            keep_account: false,
        }
    }

    pub fn with_wipe_data(mut self, value: bool) -> Self {
        self.wipe_data = value;
        self
    }

    pub fn with_transfer_dest_id(mut self, value: Option<UserSelectorArg>) -> Self {
        self.transfer_dest_id = value;
        self
    }

    pub fn with_transfer_admin_id(mut self, value: Option<UserSelectorArg>) -> Self {
        self.transfer_admin_id = value;
        self
    }

    pub fn with_keep_account(mut self, value: bool) -> Self {
        self.keep_account = value;
        self
    }

}

const MEMBERS_REMOVE_ARG_FIELDS: &[&str] = &["user",
                                             "wipe_data",
                                             "transfer_dest_id",
                                             "transfer_admin_id",
                                             "keep_account"];
impl MembersRemoveArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersRemoveArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersRemoveArg>, V::Error> {
        use serde::de;
        let mut field_user = None;
        let mut field_wipe_data = None;
        let mut field_transfer_dest_id = None;
        let mut field_transfer_admin_id = None;
        let mut field_keep_account = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "wipe_data" => {
                    if field_wipe_data.is_some() {
                        return Err(de::Error::duplicate_field("wipe_data"));
                    }
                    field_wipe_data = Some(map.next_value()?);
                }
                "transfer_dest_id" => {
                    if field_transfer_dest_id.is_some() {
                        return Err(de::Error::duplicate_field("transfer_dest_id"));
                    }
                    field_transfer_dest_id = Some(map.next_value()?);
                }
                "transfer_admin_id" => {
                    if field_transfer_admin_id.is_some() {
                        return Err(de::Error::duplicate_field("transfer_admin_id"));
                    }
                    field_transfer_admin_id = Some(map.next_value()?);
                }
                "keep_account" => {
                    if field_keep_account.is_some() {
                        return Err(de::Error::duplicate_field("keep_account"));
                    }
                    field_keep_account = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_REMOVE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersRemoveArg {
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
            wipe_data: field_wipe_data.unwrap_or(true),
            transfer_dest_id: field_transfer_dest_id,
            transfer_admin_id: field_transfer_admin_id,
            keep_account: field_keep_account.unwrap_or(false),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("wipe_data", &self.wipe_data)?;
        s.serialize_field("transfer_dest_id", &self.transfer_dest_id)?;
        s.serialize_field("transfer_admin_id", &self.transfer_admin_id)?;
        s.serialize_field("keep_account", &self.keep_account)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersRemoveArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersRemoveArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersRemoveArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersRemoveArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersRemoveArg", MEMBERS_REMOVE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersRemoveArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersRemoveArg", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MembersRemoveError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
    /// The user is not a member of the team.
    UserNotInTeam,
    Other,
    /// The user is the last admin of the team, so it cannot be removed from it.
    RemoveLastAdmin,
    /// Expected removed user and transfer_dest user to be different.
    RemovedAndTransferDestShouldDiffer,
    /// Expected removed user and transfer_admin user to be different.
    RemovedAndTransferAdminShouldDiffer,
    /// No matching user found for the argument transfer_dest_id.
    TransferDestUserNotFound,
    /// The provided transfer_dest_id does not exist on this team.
    TransferDestUserNotInTeam,
    /// No matching user found for the argument transfer_admin_id.
    TransferAdminUserNotFound,
    /// The provided transfer_admin_id does not exist on this team.
    TransferAdminUserNotInTeam,
    /// The transfer_admin_id argument must be provided when file transfer is requested.
    UnspecifiedTransferAdminId,
    /// Specified transfer_admin user is not a team admin.
    TransferAdminIsNotAdmin,
    /// Cannot keep account and transfer the data to another user at the same time.
    CannotKeepAccountAndTransfer,
    /// Cannot keep account and delete the data at the same time. To keep the account the argument
    /// wipe_data should be set to False.
    CannotKeepAccountAndDeleteData,
    /// The email address of the user is too long to be disabled.
    EmailAddressTooLongToBeDisabled,
    /// Cannot keep account of an invited user.
    CannotKeepInvitedUserAccount,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersRemoveError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersRemoveError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersRemoveError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(MembersRemoveError::UserNotFound),
                    "user_not_in_team" => Ok(MembersRemoveError::UserNotInTeam),
                    "remove_last_admin" => Ok(MembersRemoveError::RemoveLastAdmin),
                    "removed_and_transfer_dest_should_differ" => Ok(MembersRemoveError::RemovedAndTransferDestShouldDiffer),
                    "removed_and_transfer_admin_should_differ" => Ok(MembersRemoveError::RemovedAndTransferAdminShouldDiffer),
                    "transfer_dest_user_not_found" => Ok(MembersRemoveError::TransferDestUserNotFound),
                    "transfer_dest_user_not_in_team" => Ok(MembersRemoveError::TransferDestUserNotInTeam),
                    "transfer_admin_user_not_found" => Ok(MembersRemoveError::TransferAdminUserNotFound),
                    "transfer_admin_user_not_in_team" => Ok(MembersRemoveError::TransferAdminUserNotInTeam),
                    "unspecified_transfer_admin_id" => Ok(MembersRemoveError::UnspecifiedTransferAdminId),
                    "transfer_admin_is_not_admin" => Ok(MembersRemoveError::TransferAdminIsNotAdmin),
                    "cannot_keep_account_and_transfer" => Ok(MembersRemoveError::CannotKeepAccountAndTransfer),
                    "cannot_keep_account_and_delete_data" => Ok(MembersRemoveError::CannotKeepAccountAndDeleteData),
                    "email_address_too_long_to_be_disabled" => Ok(MembersRemoveError::EmailAddressTooLongToBeDisabled),
                    "cannot_keep_invited_user_account" => Ok(MembersRemoveError::CannotKeepInvitedUserAccount),
                    _ => Ok(MembersRemoveError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found",
                                    "user_not_in_team",
                                    "other",
                                    "remove_last_admin",
                                    "removed_and_transfer_dest_should_differ",
                                    "removed_and_transfer_admin_should_differ",
                                    "transfer_dest_user_not_found",
                                    "transfer_dest_user_not_in_team",
                                    "transfer_admin_user_not_found",
                                    "transfer_admin_user_not_in_team",
                                    "unspecified_transfer_admin_id",
                                    "transfer_admin_is_not_admin",
                                    "cannot_keep_account_and_transfer",
                                    "cannot_keep_account_and_delete_data",
                                    "email_address_too_long_to_be_disabled",
                                    "cannot_keep_invited_user_account"];
        deserializer.deserialize_struct("MembersRemoveError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersRemoveError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersRemoveError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            MembersRemoveError::UserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "user_not_in_team")?;
                s.end()
            }
            MembersRemoveError::RemoveLastAdmin => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "remove_last_admin")?;
                s.end()
            }
            MembersRemoveError::RemovedAndTransferDestShouldDiffer => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "removed_and_transfer_dest_should_differ")?;
                s.end()
            }
            MembersRemoveError::RemovedAndTransferAdminShouldDiffer => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "removed_and_transfer_admin_should_differ")?;
                s.end()
            }
            MembersRemoveError::TransferDestUserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "transfer_dest_user_not_found")?;
                s.end()
            }
            MembersRemoveError::TransferDestUserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "transfer_dest_user_not_in_team")?;
                s.end()
            }
            MembersRemoveError::TransferAdminUserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "transfer_admin_user_not_found")?;
                s.end()
            }
            MembersRemoveError::TransferAdminUserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "transfer_admin_user_not_in_team")?;
                s.end()
            }
            MembersRemoveError::UnspecifiedTransferAdminId => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "unspecified_transfer_admin_id")?;
                s.end()
            }
            MembersRemoveError::TransferAdminIsNotAdmin => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "transfer_admin_is_not_admin")?;
                s.end()
            }
            MembersRemoveError::CannotKeepAccountAndTransfer => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "cannot_keep_account_and_transfer")?;
                s.end()
            }
            MembersRemoveError::CannotKeepAccountAndDeleteData => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "cannot_keep_account_and_delete_data")?;
                s.end()
            }
            MembersRemoveError::EmailAddressTooLongToBeDisabled => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "email_address_too_long_to_be_disabled")?;
                s.end()
            }
            MembersRemoveError::CannotKeepInvitedUserAccount => {
                // unit
                let mut s = serializer.serialize_struct("MembersRemoveError", 1)?;
                s.serialize_field(".tag", "cannot_keep_invited_user_account")?;
                s.end()
            }
            MembersRemoveError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MembersRemoveError {
    fn description(&self) -> &str {
        "MembersRemoveError"
    }
}

impl ::std::fmt::Display for MembersRemoveError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}


#[derive(Debug)]
pub enum MembersSendWelcomeError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
    /// The user is not a member of the team.
    UserNotInTeam,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersSendWelcomeError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersSendWelcomeError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersSendWelcomeError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(MembersSendWelcomeError::UserNotFound),
                    "user_not_in_team" => Ok(MembersSendWelcomeError::UserNotInTeam),
                    _ => Ok(MembersSendWelcomeError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found",
                                    "user_not_in_team",
                                    "other"];
        deserializer.deserialize_struct("MembersSendWelcomeError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersSendWelcomeError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersSendWelcomeError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersSendWelcomeError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            MembersSendWelcomeError::UserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersSendWelcomeError", 1)?;
                s.serialize_field(".tag", "user_not_in_team")?;
                s.end()
            }
            MembersSendWelcomeError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MembersSendWelcomeError {
    fn description(&self) -> &str {
        "MembersSendWelcomeError"
    }
}

impl ::std::fmt::Display for MembersSendWelcomeError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user
/// account.
#[derive(Debug)]
pub struct MembersSetPermissionsArg {
    /// Identity of user whose role will be set.
    pub user: UserSelectorArg,
    /// The new role of the member.
    pub new_role: AdminTier,
}

impl MembersSetPermissionsArg {
    pub fn new(user: UserSelectorArg, new_role: AdminTier) -> Self {
        MembersSetPermissionsArg {
            user,
            new_role,
        }
    }

}

const MEMBERS_SET_PERMISSIONS_ARG_FIELDS: &[&str] = &["user",
                                                      "new_role"];
impl MembersSetPermissionsArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersSetPermissionsArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersSetPermissionsArg>, V::Error> {
        use serde::de;
        let mut field_user = None;
        let mut field_new_role = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "new_role" => {
                    if field_new_role.is_some() {
                        return Err(de::Error::duplicate_field("new_role"));
                    }
                    field_new_role = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_SET_PERMISSIONS_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersSetPermissionsArg {
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
            new_role: field_new_role.ok_or_else(|| de::Error::missing_field("new_role"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("new_role", &self.new_role)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersSetPermissionsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersSetPermissionsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersSetPermissionsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersSetPermissionsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersSetPermissionsArg", MEMBERS_SET_PERMISSIONS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersSetPermissionsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersSetPermissionsArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MembersSetPermissionsError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
    /// Cannot remove the admin setting of the last admin.
    LastAdmin,
    /// The user is not a member of the team.
    UserNotInTeam,
    /// Cannot remove/grant permissions.
    CannotSetPermissions,
    /// Team is full. The organization has no available licenses.
    TeamLicenseLimit,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersSetPermissionsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersSetPermissionsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersSetPermissionsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(MembersSetPermissionsError::UserNotFound),
                    "last_admin" => Ok(MembersSetPermissionsError::LastAdmin),
                    "user_not_in_team" => Ok(MembersSetPermissionsError::UserNotInTeam),
                    "cannot_set_permissions" => Ok(MembersSetPermissionsError::CannotSetPermissions),
                    "team_license_limit" => Ok(MembersSetPermissionsError::TeamLicenseLimit),
                    _ => Ok(MembersSetPermissionsError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found",
                                    "last_admin",
                                    "user_not_in_team",
                                    "cannot_set_permissions",
                                    "team_license_limit",
                                    "other"];
        deserializer.deserialize_struct("MembersSetPermissionsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersSetPermissionsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersSetPermissionsError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetPermissionsError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            MembersSetPermissionsError::LastAdmin => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetPermissionsError", 1)?;
                s.serialize_field(".tag", "last_admin")?;
                s.end()
            }
            MembersSetPermissionsError::UserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetPermissionsError", 1)?;
                s.serialize_field(".tag", "user_not_in_team")?;
                s.end()
            }
            MembersSetPermissionsError::CannotSetPermissions => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetPermissionsError", 1)?;
                s.serialize_field(".tag", "cannot_set_permissions")?;
                s.end()
            }
            MembersSetPermissionsError::TeamLicenseLimit => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetPermissionsError", 1)?;
                s.serialize_field(".tag", "team_license_limit")?;
                s.end()
            }
            MembersSetPermissionsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MembersSetPermissionsError {
    fn description(&self) -> &str {
        "MembersSetPermissionsError"
    }
}

impl ::std::fmt::Display for MembersSetPermissionsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct MembersSetPermissionsResult {
    /// The member ID of the user to which the change was applied.
    pub team_member_id: super::team_common::TeamMemberId,
    /// The role after the change.
    pub role: AdminTier,
}

impl MembersSetPermissionsResult {
    pub fn new(team_member_id: super::team_common::TeamMemberId, role: AdminTier) -> Self {
        MembersSetPermissionsResult {
            team_member_id,
            role,
        }
    }

}

const MEMBERS_SET_PERMISSIONS_RESULT_FIELDS: &[&str] = &["team_member_id",
                                                         "role"];
impl MembersSetPermissionsResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersSetPermissionsResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersSetPermissionsResult>, V::Error> {
        use serde::de;
        let mut field_team_member_id = None;
        let mut field_role = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "role" => {
                    if field_role.is_some() {
                        return Err(de::Error::duplicate_field("role"));
                    }
                    field_role = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_SET_PERMISSIONS_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersSetPermissionsResult {
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
            role: field_role.ok_or_else(|| de::Error::missing_field("role"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("role", &self.role)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersSetPermissionsResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersSetPermissionsResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersSetPermissionsResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersSetPermissionsResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersSetPermissionsResult", MEMBERS_SET_PERMISSIONS_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersSetPermissionsResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersSetPermissionsResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user
/// account. At least one of new_email, new_external_id, new_given_name, and/or new_surname must be
/// provided.
#[derive(Debug)]
pub struct MembersSetProfileArg {
    /// Identity of user whose profile will be set.
    pub user: UserSelectorArg,
    /// New email for member.
    pub new_email: Option<super::common::EmailAddress>,
    /// New external ID for member.
    pub new_external_id: Option<super::team_common::MemberExternalId>,
    /// New given name for member.
    pub new_given_name: Option<super::common::OptionalNamePart>,
    /// New surname for member.
    pub new_surname: Option<super::common::OptionalNamePart>,
    /// New persistent ID. This field only available to teams using persistent ID SAML
    /// configuration.
    pub new_persistent_id: Option<String>,
    /// New value for whether the user is a directory restricted user.
    pub new_is_directory_restricted: Option<bool>,
}

impl MembersSetProfileArg {
    pub fn new(user: UserSelectorArg) -> Self {
        MembersSetProfileArg {
            user,
            new_email: None,
            new_external_id: None,
            new_given_name: None,
            new_surname: None,
            new_persistent_id: None,
            new_is_directory_restricted: None,
        }
    }

    pub fn with_new_email(mut self, value: Option<super::common::EmailAddress>) -> Self {
        self.new_email = value;
        self
    }

    pub fn with_new_external_id(
        mut self,
        value: Option<super::team_common::MemberExternalId>,
    ) -> Self {
        self.new_external_id = value;
        self
    }

    pub fn with_new_given_name(mut self, value: Option<super::common::OptionalNamePart>) -> Self {
        self.new_given_name = value;
        self
    }

    pub fn with_new_surname(mut self, value: Option<super::common::OptionalNamePart>) -> Self {
        self.new_surname = value;
        self
    }

    pub fn with_new_persistent_id(mut self, value: Option<String>) -> Self {
        self.new_persistent_id = value;
        self
    }

    pub fn with_new_is_directory_restricted(mut self, value: Option<bool>) -> Self {
        self.new_is_directory_restricted = value;
        self
    }

}

const MEMBERS_SET_PROFILE_ARG_FIELDS: &[&str] = &["user",
                                                  "new_email",
                                                  "new_external_id",
                                                  "new_given_name",
                                                  "new_surname",
                                                  "new_persistent_id",
                                                  "new_is_directory_restricted"];
impl MembersSetProfileArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersSetProfileArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersSetProfileArg>, V::Error> {
        use serde::de;
        let mut field_user = None;
        let mut field_new_email = None;
        let mut field_new_external_id = None;
        let mut field_new_given_name = None;
        let mut field_new_surname = None;
        let mut field_new_persistent_id = None;
        let mut field_new_is_directory_restricted = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "new_email" => {
                    if field_new_email.is_some() {
                        return Err(de::Error::duplicate_field("new_email"));
                    }
                    field_new_email = Some(map.next_value()?);
                }
                "new_external_id" => {
                    if field_new_external_id.is_some() {
                        return Err(de::Error::duplicate_field("new_external_id"));
                    }
                    field_new_external_id = Some(map.next_value()?);
                }
                "new_given_name" => {
                    if field_new_given_name.is_some() {
                        return Err(de::Error::duplicate_field("new_given_name"));
                    }
                    field_new_given_name = Some(map.next_value()?);
                }
                "new_surname" => {
                    if field_new_surname.is_some() {
                        return Err(de::Error::duplicate_field("new_surname"));
                    }
                    field_new_surname = Some(map.next_value()?);
                }
                "new_persistent_id" => {
                    if field_new_persistent_id.is_some() {
                        return Err(de::Error::duplicate_field("new_persistent_id"));
                    }
                    field_new_persistent_id = Some(map.next_value()?);
                }
                "new_is_directory_restricted" => {
                    if field_new_is_directory_restricted.is_some() {
                        return Err(de::Error::duplicate_field("new_is_directory_restricted"));
                    }
                    field_new_is_directory_restricted = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_SET_PROFILE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersSetProfileArg {
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
            new_email: field_new_email,
            new_external_id: field_new_external_id,
            new_given_name: field_new_given_name,
            new_surname: field_new_surname,
            new_persistent_id: field_new_persistent_id,
            new_is_directory_restricted: field_new_is_directory_restricted,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("new_email", &self.new_email)?;
        s.serialize_field("new_external_id", &self.new_external_id)?;
        s.serialize_field("new_given_name", &self.new_given_name)?;
        s.serialize_field("new_surname", &self.new_surname)?;
        s.serialize_field("new_persistent_id", &self.new_persistent_id)?;
        s.serialize_field("new_is_directory_restricted", &self.new_is_directory_restricted)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersSetProfileArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersSetProfileArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersSetProfileArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersSetProfileArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersSetProfileArg", MEMBERS_SET_PROFILE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersSetProfileArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersSetProfileArg", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MembersSetProfileError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
    /// The user is not a member of the team.
    UserNotInTeam,
    /// It is unsafe to use both external_id and new_external_id.
    ExternalIdAndNewExternalIdUnsafe,
    /// None of new_email, new_given_name, new_surname, or new_external_id are specified.
    NoNewDataSpecified,
    /// Email is already reserved for another user.
    EmailReservedForOtherUser,
    /// The external ID is already in use by another team member.
    ExternalIdUsedByOtherUser,
    /// Modifying deleted users is not allowed.
    SetProfileDisallowed,
    /// Parameter new_email cannot be empty.
    ParamCannotBeEmpty,
    /// Persistent ID is only available to teams with persistent ID SAML configuration. Please
    /// contact Dropbox for more information.
    PersistentIdDisabled,
    /// The persistent ID is already in use by another team member.
    PersistentIdUsedByOtherUser,
    /// Directory Restrictions option is not available.
    DirectoryRestrictedOff,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersSetProfileError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersSetProfileError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersSetProfileError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(MembersSetProfileError::UserNotFound),
                    "user_not_in_team" => Ok(MembersSetProfileError::UserNotInTeam),
                    "external_id_and_new_external_id_unsafe" => Ok(MembersSetProfileError::ExternalIdAndNewExternalIdUnsafe),
                    "no_new_data_specified" => Ok(MembersSetProfileError::NoNewDataSpecified),
                    "email_reserved_for_other_user" => Ok(MembersSetProfileError::EmailReservedForOtherUser),
                    "external_id_used_by_other_user" => Ok(MembersSetProfileError::ExternalIdUsedByOtherUser),
                    "set_profile_disallowed" => Ok(MembersSetProfileError::SetProfileDisallowed),
                    "param_cannot_be_empty" => Ok(MembersSetProfileError::ParamCannotBeEmpty),
                    "persistent_id_disabled" => Ok(MembersSetProfileError::PersistentIdDisabled),
                    "persistent_id_used_by_other_user" => Ok(MembersSetProfileError::PersistentIdUsedByOtherUser),
                    "directory_restricted_off" => Ok(MembersSetProfileError::DirectoryRestrictedOff),
                    _ => Ok(MembersSetProfileError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found",
                                    "user_not_in_team",
                                    "external_id_and_new_external_id_unsafe",
                                    "no_new_data_specified",
                                    "email_reserved_for_other_user",
                                    "external_id_used_by_other_user",
                                    "set_profile_disallowed",
                                    "param_cannot_be_empty",
                                    "persistent_id_disabled",
                                    "persistent_id_used_by_other_user",
                                    "directory_restricted_off",
                                    "other"];
        deserializer.deserialize_struct("MembersSetProfileError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersSetProfileError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersSetProfileError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            MembersSetProfileError::UserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "user_not_in_team")?;
                s.end()
            }
            MembersSetProfileError::ExternalIdAndNewExternalIdUnsafe => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "external_id_and_new_external_id_unsafe")?;
                s.end()
            }
            MembersSetProfileError::NoNewDataSpecified => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "no_new_data_specified")?;
                s.end()
            }
            MembersSetProfileError::EmailReservedForOtherUser => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "email_reserved_for_other_user")?;
                s.end()
            }
            MembersSetProfileError::ExternalIdUsedByOtherUser => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "external_id_used_by_other_user")?;
                s.end()
            }
            MembersSetProfileError::SetProfileDisallowed => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "set_profile_disallowed")?;
                s.end()
            }
            MembersSetProfileError::ParamCannotBeEmpty => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "param_cannot_be_empty")?;
                s.end()
            }
            MembersSetProfileError::PersistentIdDisabled => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "persistent_id_disabled")?;
                s.end()
            }
            MembersSetProfileError::PersistentIdUsedByOtherUser => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "persistent_id_used_by_other_user")?;
                s.end()
            }
            MembersSetProfileError::DirectoryRestrictedOff => {
                // unit
                let mut s = serializer.serialize_struct("MembersSetProfileError", 1)?;
                s.serialize_field(".tag", "directory_restricted_off")?;
                s.end()
            }
            MembersSetProfileError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MembersSetProfileError {
    fn description(&self) -> &str {
        "MembersSetProfileError"
    }
}

impl ::std::fmt::Display for MembersSetProfileError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum MembersSuspendError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
    /// The user is not a member of the team.
    UserNotInTeam,
    Other,
    /// The user is not active, so it cannot be suspended.
    SuspendInactiveUser,
    /// The user is the last admin of the team, so it cannot be suspended.
    SuspendLastAdmin,
    /// Team is full. The organization has no available licenses.
    TeamLicenseLimit,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersSuspendError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersSuspendError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersSuspendError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(MembersSuspendError::UserNotFound),
                    "user_not_in_team" => Ok(MembersSuspendError::UserNotInTeam),
                    "suspend_inactive_user" => Ok(MembersSuspendError::SuspendInactiveUser),
                    "suspend_last_admin" => Ok(MembersSuspendError::SuspendLastAdmin),
                    "team_license_limit" => Ok(MembersSuspendError::TeamLicenseLimit),
                    _ => Ok(MembersSuspendError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found",
                                    "user_not_in_team",
                                    "other",
                                    "suspend_inactive_user",
                                    "suspend_last_admin",
                                    "team_license_limit"];
        deserializer.deserialize_struct("MembersSuspendError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersSuspendError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersSuspendError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersSuspendError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            MembersSuspendError::UserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersSuspendError", 1)?;
                s.serialize_field(".tag", "user_not_in_team")?;
                s.end()
            }
            MembersSuspendError::SuspendInactiveUser => {
                // unit
                let mut s = serializer.serialize_struct("MembersSuspendError", 1)?;
                s.serialize_field(".tag", "suspend_inactive_user")?;
                s.end()
            }
            MembersSuspendError::SuspendLastAdmin => {
                // unit
                let mut s = serializer.serialize_struct("MembersSuspendError", 1)?;
                s.serialize_field(".tag", "suspend_last_admin")?;
                s.end()
            }
            MembersSuspendError::TeamLicenseLimit => {
                // unit
                let mut s = serializer.serialize_struct("MembersSuspendError", 1)?;
                s.serialize_field(".tag", "team_license_limit")?;
                s.end()
            }
            MembersSuspendError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MembersSuspendError {
    fn description(&self) -> &str {
        "MembersSuspendError"
    }
}

impl ::std::fmt::Display for MembersSuspendError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Exactly one of team_member_id, email, or external_id must be provided to identify the user
/// account.
#[derive(Debug)]
pub struct MembersUnsuspendArg {
    /// Identity of user to unsuspend.
    pub user: UserSelectorArg,
}

impl MembersUnsuspendArg {
    pub fn new(user: UserSelectorArg) -> Self {
        MembersUnsuspendArg {
            user,
        }
    }

}

const MEMBERS_UNSUSPEND_ARG_FIELDS: &[&str] = &["user"];
impl MembersUnsuspendArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MembersUnsuspendArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MembersUnsuspendArg>, V::Error> {
        use serde::de;
        let mut field_user = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MEMBERS_UNSUSPEND_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MembersUnsuspendArg {
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user", &self.user)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MembersUnsuspendArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MembersUnsuspendArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersUnsuspendArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MembersUnsuspendArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MembersUnsuspendArg", MEMBERS_UNSUSPEND_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MembersUnsuspendArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MembersUnsuspendArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum MembersUnsuspendError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
    /// The user is not a member of the team.
    UserNotInTeam,
    Other,
    /// The user is unsuspended, so it cannot be unsuspended again.
    UnsuspendNonSuspendedMember,
    /// Team is full. The organization has no available licenses.
    TeamLicenseLimit,
}

impl<'de> ::serde::de::Deserialize<'de> for MembersUnsuspendError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MembersUnsuspendError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MembersUnsuspendError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(MembersUnsuspendError::UserNotFound),
                    "user_not_in_team" => Ok(MembersUnsuspendError::UserNotInTeam),
                    "unsuspend_non_suspended_member" => Ok(MembersUnsuspendError::UnsuspendNonSuspendedMember),
                    "team_license_limit" => Ok(MembersUnsuspendError::TeamLicenseLimit),
                    _ => Ok(MembersUnsuspendError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found",
                                    "user_not_in_team",
                                    "other",
                                    "unsuspend_non_suspended_member",
                                    "team_license_limit"];
        deserializer.deserialize_struct("MembersUnsuspendError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MembersUnsuspendError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MembersUnsuspendError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("MembersUnsuspendError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            MembersUnsuspendError::UserNotInTeam => {
                // unit
                let mut s = serializer.serialize_struct("MembersUnsuspendError", 1)?;
                s.serialize_field(".tag", "user_not_in_team")?;
                s.end()
            }
            MembersUnsuspendError::UnsuspendNonSuspendedMember => {
                // unit
                let mut s = serializer.serialize_struct("MembersUnsuspendError", 1)?;
                s.serialize_field(".tag", "unsuspend_non_suspended_member")?;
                s.end()
            }
            MembersUnsuspendError::TeamLicenseLimit => {
                // unit
                let mut s = serializer.serialize_struct("MembersUnsuspendError", 1)?;
                s.serialize_field(".tag", "team_license_limit")?;
                s.end()
            }
            MembersUnsuspendError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for MembersUnsuspendError {
    fn description(&self) -> &str {
        "MembersUnsuspendError"
    }
}

impl ::std::fmt::Display for MembersUnsuspendError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum MobileClientPlatform {
    /// Official Dropbox iPhone client.
    Iphone,
    /// Official Dropbox iPad client.
    Ipad,
    /// Official Dropbox Android client.
    Android,
    /// Official Dropbox Windows phone client.
    WindowsPhone,
    /// Official Dropbox Blackberry client.
    Blackberry,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for MobileClientPlatform {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = MobileClientPlatform;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MobileClientPlatform structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "iphone" => Ok(MobileClientPlatform::Iphone),
                    "ipad" => Ok(MobileClientPlatform::Ipad),
                    "android" => Ok(MobileClientPlatform::Android),
                    "windows_phone" => Ok(MobileClientPlatform::WindowsPhone),
                    "blackberry" => Ok(MobileClientPlatform::Blackberry),
                    _ => Ok(MobileClientPlatform::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["iphone",
                                    "ipad",
                                    "android",
                                    "windows_phone",
                                    "blackberry",
                                    "other"];
        deserializer.deserialize_struct("MobileClientPlatform", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for MobileClientPlatform {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            MobileClientPlatform::Iphone => {
                // unit
                let mut s = serializer.serialize_struct("MobileClientPlatform", 1)?;
                s.serialize_field(".tag", "iphone")?;
                s.end()
            }
            MobileClientPlatform::Ipad => {
                // unit
                let mut s = serializer.serialize_struct("MobileClientPlatform", 1)?;
                s.serialize_field(".tag", "ipad")?;
                s.end()
            }
            MobileClientPlatform::Android => {
                // unit
                let mut s = serializer.serialize_struct("MobileClientPlatform", 1)?;
                s.serialize_field(".tag", "android")?;
                s.end()
            }
            MobileClientPlatform::WindowsPhone => {
                // unit
                let mut s = serializer.serialize_struct("MobileClientPlatform", 1)?;
                s.serialize_field(".tag", "windows_phone")?;
                s.end()
            }
            MobileClientPlatform::Blackberry => {
                // unit
                let mut s = serializer.serialize_struct("MobileClientPlatform", 1)?;
                s.serialize_field(".tag", "blackberry")?;
                s.end()
            }
            MobileClientPlatform::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// Information about linked Dropbox mobile client sessions.
#[derive(Debug)]
pub struct MobileClientSession {
    /// The session id.
    pub session_id: String,
    /// The device name.
    pub device_name: String,
    /// The mobile application type.
    pub client_type: MobileClientPlatform,
    /// The IP address of the last activity from this session.
    pub ip_address: Option<String>,
    /// The country from which the last activity from this session was made.
    pub country: Option<String>,
    /// The time this session was created.
    pub created: Option<super::common::DropboxTimestamp>,
    /// The time of the last activity from this session.
    pub updated: Option<super::common::DropboxTimestamp>,
    /// The dropbox client version.
    pub client_version: Option<String>,
    /// The hosting OS version.
    pub os_version: Option<String>,
    /// last carrier used by the device.
    pub last_carrier: Option<String>,
}

impl MobileClientSession {
    pub fn new(
        session_id: String,
        device_name: String,
        client_type: MobileClientPlatform,
    ) -> Self {
        MobileClientSession {
            session_id,
            device_name,
            client_type,
            ip_address: None,
            country: None,
            created: None,
            updated: None,
            client_version: None,
            os_version: None,
            last_carrier: None,
        }
    }

    pub fn with_ip_address(mut self, value: Option<String>) -> Self {
        self.ip_address = value;
        self
    }

    pub fn with_country(mut self, value: Option<String>) -> Self {
        self.country = value;
        self
    }

    pub fn with_created(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.created = value;
        self
    }

    pub fn with_updated(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.updated = value;
        self
    }

    pub fn with_client_version(mut self, value: Option<String>) -> Self {
        self.client_version = value;
        self
    }

    pub fn with_os_version(mut self, value: Option<String>) -> Self {
        self.os_version = value;
        self
    }

    pub fn with_last_carrier(mut self, value: Option<String>) -> Self {
        self.last_carrier = value;
        self
    }

}

const MOBILE_CLIENT_SESSION_FIELDS: &[&str] = &["session_id",
                                                "device_name",
                                                "client_type",
                                                "ip_address",
                                                "country",
                                                "created",
                                                "updated",
                                                "client_version",
                                                "os_version",
                                                "last_carrier"];
impl MobileClientSession {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<MobileClientSession, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<MobileClientSession>, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        let mut field_device_name = None;
        let mut field_client_type = None;
        let mut field_ip_address = None;
        let mut field_country = None;
        let mut field_created = None;
        let mut field_updated = None;
        let mut field_client_version = None;
        let mut field_os_version = None;
        let mut field_last_carrier = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "device_name" => {
                    if field_device_name.is_some() {
                        return Err(de::Error::duplicate_field("device_name"));
                    }
                    field_device_name = Some(map.next_value()?);
                }
                "client_type" => {
                    if field_client_type.is_some() {
                        return Err(de::Error::duplicate_field("client_type"));
                    }
                    field_client_type = Some(map.next_value()?);
                }
                "ip_address" => {
                    if field_ip_address.is_some() {
                        return Err(de::Error::duplicate_field("ip_address"));
                    }
                    field_ip_address = Some(map.next_value()?);
                }
                "country" => {
                    if field_country.is_some() {
                        return Err(de::Error::duplicate_field("country"));
                    }
                    field_country = Some(map.next_value()?);
                }
                "created" => {
                    if field_created.is_some() {
                        return Err(de::Error::duplicate_field("created"));
                    }
                    field_created = Some(map.next_value()?);
                }
                "updated" => {
                    if field_updated.is_some() {
                        return Err(de::Error::duplicate_field("updated"));
                    }
                    field_updated = Some(map.next_value()?);
                }
                "client_version" => {
                    if field_client_version.is_some() {
                        return Err(de::Error::duplicate_field("client_version"));
                    }
                    field_client_version = Some(map.next_value()?);
                }
                "os_version" => {
                    if field_os_version.is_some() {
                        return Err(de::Error::duplicate_field("os_version"));
                    }
                    field_os_version = Some(map.next_value()?);
                }
                "last_carrier" => {
                    if field_last_carrier.is_some() {
                        return Err(de::Error::duplicate_field("last_carrier"));
                    }
                    field_last_carrier = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, MOBILE_CLIENT_SESSION_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = MobileClientSession {
            session_id: field_session_id.ok_or_else(|| de::Error::missing_field("session_id"))?,
            device_name: field_device_name.ok_or_else(|| de::Error::missing_field("device_name"))?,
            client_type: field_client_type.ok_or_else(|| de::Error::missing_field("client_type"))?,
            ip_address: field_ip_address,
            country: field_country,
            created: field_created,
            updated: field_updated,
            client_version: field_client_version,
            os_version: field_os_version,
            last_carrier: field_last_carrier,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("device_name", &self.device_name)?;
        s.serialize_field("client_type", &self.client_type)?;
        s.serialize_field("ip_address", &self.ip_address)?;
        s.serialize_field("country", &self.country)?;
        s.serialize_field("created", &self.created)?;
        s.serialize_field("updated", &self.updated)?;
        s.serialize_field("client_version", &self.client_version)?;
        s.serialize_field("os_version", &self.os_version)?;
        s.serialize_field("last_carrier", &self.last_carrier)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for MobileClientSession {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = MobileClientSession;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a MobileClientSession struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                MobileClientSession::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("MobileClientSession", MOBILE_CLIENT_SESSION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for MobileClientSession {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("MobileClientSession", 10)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Properties of a namespace.
#[derive(Debug)]
pub struct NamespaceMetadata {
    /// The name of this namespace.
    pub name: String,
    /// The ID of this namespace.
    pub namespace_id: super::common::SharedFolderId,
    /// The type of this namespace.
    pub namespace_type: NamespaceType,
    /// If this is a team member or app folder, the ID of the owning team member. Otherwise, this
    /// field is not present.
    pub team_member_id: Option<super::team_common::TeamMemberId>,
}

impl NamespaceMetadata {
    pub fn new(
        name: String,
        namespace_id: super::common::SharedFolderId,
        namespace_type: NamespaceType,
    ) -> Self {
        NamespaceMetadata {
            name,
            namespace_id,
            namespace_type,
            team_member_id: None,
        }
    }

    pub fn with_team_member_id(mut self, value: Option<super::team_common::TeamMemberId>) -> Self {
        self.team_member_id = value;
        self
    }

}

const NAMESPACE_METADATA_FIELDS: &[&str] = &["name",
                                             "namespace_id",
                                             "namespace_type",
                                             "team_member_id"];
impl NamespaceMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<NamespaceMetadata, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<NamespaceMetadata>, V::Error> {
        use serde::de;
        let mut field_name = None;
        let mut field_namespace_id = None;
        let mut field_namespace_type = None;
        let mut field_team_member_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "namespace_id" => {
                    if field_namespace_id.is_some() {
                        return Err(de::Error::duplicate_field("namespace_id"));
                    }
                    field_namespace_id = Some(map.next_value()?);
                }
                "namespace_type" => {
                    if field_namespace_type.is_some() {
                        return Err(de::Error::duplicate_field("namespace_type"));
                    }
                    field_namespace_type = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, NAMESPACE_METADATA_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = NamespaceMetadata {
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            namespace_id: field_namespace_id.ok_or_else(|| de::Error::missing_field("namespace_id"))?,
            namespace_type: field_namespace_type.ok_or_else(|| de::Error::missing_field("namespace_type"))?,
            team_member_id: field_team_member_id,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("namespace_id", &self.namespace_id)?;
        s.serialize_field("namespace_type", &self.namespace_type)?;
        s.serialize_field("team_member_id", &self.team_member_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for NamespaceMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = NamespaceMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NamespaceMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                NamespaceMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("NamespaceMetadata", NAMESPACE_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for NamespaceMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("NamespaceMetadata", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum NamespaceType {
    /// App sandbox folder.
    AppFolder,
    /// Shared folder.
    SharedFolder,
    /// Top-level team-owned folder.
    TeamFolder,
    /// Team member's home folder.
    TeamMemberFolder,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for NamespaceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = NamespaceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a NamespaceType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "app_folder" => Ok(NamespaceType::AppFolder),
                    "shared_folder" => Ok(NamespaceType::SharedFolder),
                    "team_folder" => Ok(NamespaceType::TeamFolder),
                    "team_member_folder" => Ok(NamespaceType::TeamMemberFolder),
                    _ => Ok(NamespaceType::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["app_folder",
                                    "shared_folder",
                                    "team_folder",
                                    "team_member_folder",
                                    "other"];
        deserializer.deserialize_struct("NamespaceType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for NamespaceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            NamespaceType::AppFolder => {
                // unit
                let mut s = serializer.serialize_struct("NamespaceType", 1)?;
                s.serialize_field(".tag", "app_folder")?;
                s.end()
            }
            NamespaceType::SharedFolder => {
                // unit
                let mut s = serializer.serialize_struct("NamespaceType", 1)?;
                s.serialize_field(".tag", "shared_folder")?;
                s.end()
            }
            NamespaceType::TeamFolder => {
                // unit
                let mut s = serializer.serialize_struct("NamespaceType", 1)?;
                s.serialize_field(".tag", "team_folder")?;
                s.end()
            }
            NamespaceType::TeamMemberFolder => {
                // unit
                let mut s = serializer.serialize_struct("NamespaceType", 1)?;
                s.serialize_field(".tag", "team_member_folder")?;
                s.end()
            }
            NamespaceType::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// User result for setting member custom quota.
#[derive(Debug)]
pub enum RemoveCustomQuotaResult {
    /// Successfully removed user.
    Success(UserSelectorArg),
    /// Invalid user (not in team).
    InvalidUser(UserSelectorArg),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RemoveCustomQuotaResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RemoveCustomQuotaResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RemoveCustomQuotaResult structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "success" => {
                        match map.next_key()? {
                            Some("success") => Ok(RemoveCustomQuotaResult::Success(map.next_value()?)),
                            None => Err(de::Error::missing_field("success")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "invalid_user" => {
                        match map.next_key()? {
                            Some("invalid_user") => Ok(RemoveCustomQuotaResult::InvalidUser(map.next_value()?)),
                            None => Err(de::Error::missing_field("invalid_user")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(RemoveCustomQuotaResult::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["success",
                                    "invalid_user",
                                    "other"];
        deserializer.deserialize_struct("RemoveCustomQuotaResult", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RemoveCustomQuotaResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RemoveCustomQuotaResult::Success(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("RemoveCustomQuotaResult", 2)?;
                s.serialize_field(".tag", "success")?;
                s.serialize_field("success", x)?;
                s.end()
            }
            RemoveCustomQuotaResult::InvalidUser(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("RemoveCustomQuotaResult", 2)?;
                s.serialize_field(".tag", "invalid_user")?;
                s.serialize_field("invalid_user", x)?;
                s.end()
            }
            RemoveCustomQuotaResult::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub struct RemovedStatus {
    /// True if the removed team member is recoverable.
    pub is_recoverable: bool,
}

impl RemovedStatus {
    pub fn new(is_recoverable: bool) -> Self {
        RemovedStatus {
            is_recoverable,
        }
    }

}

const REMOVED_STATUS_FIELDS: &[&str] = &["is_recoverable"];
impl RemovedStatus {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RemovedStatus, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RemovedStatus>, V::Error> {
        use serde::de;
        let mut field_is_recoverable = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "is_recoverable" => {
                    if field_is_recoverable.is_some() {
                        return Err(de::Error::duplicate_field("is_recoverable"));
                    }
                    field_is_recoverable = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REMOVED_STATUS_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RemovedStatus {
            is_recoverable: field_is_recoverable.ok_or_else(|| de::Error::missing_field("is_recoverable"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("is_recoverable", &self.is_recoverable)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RemovedStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RemovedStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RemovedStatus struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RemovedStatus::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RemovedStatus", REMOVED_STATUS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RemovedStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RemovedStatus", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct RevokeDesktopClientArg {
    /// The session id.
    pub session_id: String,
    /// The unique id of the member owning the device.
    pub team_member_id: String,
    /// Whether to delete all files of the account (this is possible only if supported by the
    /// desktop client and  will be made the next time the client access the account).
    pub delete_on_unlink: bool,
}

impl RevokeDesktopClientArg {
    pub fn new(session_id: String, team_member_id: String) -> Self {
        RevokeDesktopClientArg {
            session_id,
            team_member_id,
            delete_on_unlink: false,
        }
    }

    pub fn with_delete_on_unlink(mut self, value: bool) -> Self {
        self.delete_on_unlink = value;
        self
    }

}

const REVOKE_DESKTOP_CLIENT_ARG_FIELDS: &[&str] = &["session_id",
                                                    "team_member_id",
                                                    "delete_on_unlink"];
impl RevokeDesktopClientArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RevokeDesktopClientArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RevokeDesktopClientArg>, V::Error> {
        use serde::de;
        let mut field_session_id = None;
        let mut field_team_member_id = None;
        let mut field_delete_on_unlink = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "session_id" => {
                    if field_session_id.is_some() {
                        return Err(de::Error::duplicate_field("session_id"));
                    }
                    field_session_id = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "delete_on_unlink" => {
                    if field_delete_on_unlink.is_some() {
                        return Err(de::Error::duplicate_field("delete_on_unlink"));
                    }
                    field_delete_on_unlink = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REVOKE_DESKTOP_CLIENT_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RevokeDesktopClientArg {
            session_id: field_session_id.ok_or_else(|| de::Error::missing_field("session_id"))?,
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
            delete_on_unlink: field_delete_on_unlink.unwrap_or(false),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("session_id", &self.session_id)?;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("delete_on_unlink", &self.delete_on_unlink)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeDesktopClientArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RevokeDesktopClientArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeDesktopClientArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RevokeDesktopClientArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RevokeDesktopClientArg", REVOKE_DESKTOP_CLIENT_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeDesktopClientArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RevokeDesktopClientArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum RevokeDeviceSessionArg {
    /// End an active session.
    WebSession(DeviceSessionArg),
    /// Unlink a linked desktop device.
    DesktopClient(RevokeDesktopClientArg),
    /// Unlink a linked mobile device.
    MobileClient(DeviceSessionArg),
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeDeviceSessionArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RevokeDeviceSessionArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeDeviceSessionArg structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "web_session" => Ok(RevokeDeviceSessionArg::WebSession(DeviceSessionArg::internal_deserialize(map)?)),
                    "desktop_client" => Ok(RevokeDeviceSessionArg::DesktopClient(RevokeDesktopClientArg::internal_deserialize(map)?)),
                    "mobile_client" => Ok(RevokeDeviceSessionArg::MobileClient(DeviceSessionArg::internal_deserialize(map)?)),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["web_session",
                                    "desktop_client",
                                    "mobile_client"];
        deserializer.deserialize_struct("RevokeDeviceSessionArg", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeDeviceSessionArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RevokeDeviceSessionArg::WebSession(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("RevokeDeviceSessionArg", 3)?;
                s.serialize_field(".tag", "web_session")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            RevokeDeviceSessionArg::DesktopClient(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("RevokeDeviceSessionArg", 4)?;
                s.serialize_field(".tag", "desktop_client")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            RevokeDeviceSessionArg::MobileClient(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("RevokeDeviceSessionArg", 3)?;
                s.serialize_field(".tag", "mobile_client")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub struct RevokeDeviceSessionBatchArg {
    pub revoke_devices: Vec<RevokeDeviceSessionArg>,
}

impl RevokeDeviceSessionBatchArg {
    pub fn new(revoke_devices: Vec<RevokeDeviceSessionArg>) -> Self {
        RevokeDeviceSessionBatchArg {
            revoke_devices,
        }
    }

}

const REVOKE_DEVICE_SESSION_BATCH_ARG_FIELDS: &[&str] = &["revoke_devices"];
impl RevokeDeviceSessionBatchArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RevokeDeviceSessionBatchArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RevokeDeviceSessionBatchArg>, V::Error> {
        use serde::de;
        let mut field_revoke_devices = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "revoke_devices" => {
                    if field_revoke_devices.is_some() {
                        return Err(de::Error::duplicate_field("revoke_devices"));
                    }
                    field_revoke_devices = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REVOKE_DEVICE_SESSION_BATCH_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RevokeDeviceSessionBatchArg {
            revoke_devices: field_revoke_devices.ok_or_else(|| de::Error::missing_field("revoke_devices"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("revoke_devices", &self.revoke_devices)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeDeviceSessionBatchArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RevokeDeviceSessionBatchArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeDeviceSessionBatchArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RevokeDeviceSessionBatchArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RevokeDeviceSessionBatchArg", REVOKE_DEVICE_SESSION_BATCH_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeDeviceSessionBatchArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RevokeDeviceSessionBatchArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}


#[derive(Debug)]
pub enum RevokeDeviceSessionBatchError {
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeDeviceSessionBatchError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RevokeDeviceSessionBatchError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeDeviceSessionBatchError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    _ => Ok(RevokeDeviceSessionBatchError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["other"];
        deserializer.deserialize_struct("RevokeDeviceSessionBatchError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeDeviceSessionBatchError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        #![allow(unused_variables)]
        Err(::serde::ser::Error::custom("cannot serialize an open union with no defined variants"))
    }
}

impl ::std::error::Error for RevokeDeviceSessionBatchError {
    fn description(&self) -> &str {
        "RevokeDeviceSessionBatchError"
    }
}

impl ::std::fmt::Display for RevokeDeviceSessionBatchError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct RevokeDeviceSessionBatchResult {
    pub revoke_devices_status: Vec<RevokeDeviceSessionStatus>,
}

impl RevokeDeviceSessionBatchResult {
    pub fn new(revoke_devices_status: Vec<RevokeDeviceSessionStatus>) -> Self {
        RevokeDeviceSessionBatchResult {
            revoke_devices_status,
        }
    }

}

const REVOKE_DEVICE_SESSION_BATCH_RESULT_FIELDS: &[&str] = &["revoke_devices_status"];
impl RevokeDeviceSessionBatchResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RevokeDeviceSessionBatchResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RevokeDeviceSessionBatchResult>, V::Error> {
        use serde::de;
        let mut field_revoke_devices_status = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "revoke_devices_status" => {
                    if field_revoke_devices_status.is_some() {
                        return Err(de::Error::duplicate_field("revoke_devices_status"));
                    }
                    field_revoke_devices_status = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REVOKE_DEVICE_SESSION_BATCH_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RevokeDeviceSessionBatchResult {
            revoke_devices_status: field_revoke_devices_status.ok_or_else(|| de::Error::missing_field("revoke_devices_status"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("revoke_devices_status", &self.revoke_devices_status)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeDeviceSessionBatchResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RevokeDeviceSessionBatchResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeDeviceSessionBatchResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RevokeDeviceSessionBatchResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RevokeDeviceSessionBatchResult", REVOKE_DEVICE_SESSION_BATCH_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeDeviceSessionBatchResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RevokeDeviceSessionBatchResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum RevokeDeviceSessionError {
    /// Device session not found.
    DeviceSessionNotFound,
    /// Member not found.
    MemberNotFound,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeDeviceSessionError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RevokeDeviceSessionError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeDeviceSessionError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "device_session_not_found" => Ok(RevokeDeviceSessionError::DeviceSessionNotFound),
                    "member_not_found" => Ok(RevokeDeviceSessionError::MemberNotFound),
                    _ => Ok(RevokeDeviceSessionError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["device_session_not_found",
                                    "member_not_found",
                                    "other"];
        deserializer.deserialize_struct("RevokeDeviceSessionError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeDeviceSessionError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RevokeDeviceSessionError::DeviceSessionNotFound => {
                // unit
                let mut s = serializer.serialize_struct("RevokeDeviceSessionError", 1)?;
                s.serialize_field(".tag", "device_session_not_found")?;
                s.end()
            }
            RevokeDeviceSessionError::MemberNotFound => {
                // unit
                let mut s = serializer.serialize_struct("RevokeDeviceSessionError", 1)?;
                s.serialize_field(".tag", "member_not_found")?;
                s.end()
            }
            RevokeDeviceSessionError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for RevokeDeviceSessionError {
    fn description(&self) -> &str {
        "RevokeDeviceSessionError"
    }
}

impl ::std::fmt::Display for RevokeDeviceSessionError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct RevokeDeviceSessionStatus {
    /// Result of the revoking request.
    pub success: bool,
    /// The error cause in case of a failure.
    pub error_type: Option<RevokeDeviceSessionError>,
}

impl RevokeDeviceSessionStatus {
    pub fn new(success: bool) -> Self {
        RevokeDeviceSessionStatus {
            success,
            error_type: None,
        }
    }

    pub fn with_error_type(mut self, value: Option<RevokeDeviceSessionError>) -> Self {
        self.error_type = value;
        self
    }

}

const REVOKE_DEVICE_SESSION_STATUS_FIELDS: &[&str] = &["success",
                                                       "error_type"];
impl RevokeDeviceSessionStatus {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RevokeDeviceSessionStatus, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RevokeDeviceSessionStatus>, V::Error> {
        use serde::de;
        let mut field_success = None;
        let mut field_error_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "success" => {
                    if field_success.is_some() {
                        return Err(de::Error::duplicate_field("success"));
                    }
                    field_success = Some(map.next_value()?);
                }
                "error_type" => {
                    if field_error_type.is_some() {
                        return Err(de::Error::duplicate_field("error_type"));
                    }
                    field_error_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REVOKE_DEVICE_SESSION_STATUS_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RevokeDeviceSessionStatus {
            success: field_success.ok_or_else(|| de::Error::missing_field("success"))?,
            error_type: field_error_type,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("success", &self.success)?;
        s.serialize_field("error_type", &self.error_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeDeviceSessionStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RevokeDeviceSessionStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeDeviceSessionStatus struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RevokeDeviceSessionStatus::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RevokeDeviceSessionStatus", REVOKE_DEVICE_SESSION_STATUS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeDeviceSessionStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RevokeDeviceSessionStatus", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct RevokeLinkedApiAppArg {
    /// The application's unique id.
    pub app_id: String,
    /// The unique id of the member owning the device.
    pub team_member_id: String,
    /// Whether to keep the application dedicated folder (in case the application uses  one).
    pub keep_app_folder: bool,
}

impl RevokeLinkedApiAppArg {
    pub fn new(app_id: String, team_member_id: String) -> Self {
        RevokeLinkedApiAppArg {
            app_id,
            team_member_id,
            keep_app_folder: true,
        }
    }

    pub fn with_keep_app_folder(mut self, value: bool) -> Self {
        self.keep_app_folder = value;
        self
    }

}

const REVOKE_LINKED_API_APP_ARG_FIELDS: &[&str] = &["app_id",
                                                    "team_member_id",
                                                    "keep_app_folder"];
impl RevokeLinkedApiAppArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RevokeLinkedApiAppArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RevokeLinkedApiAppArg>, V::Error> {
        use serde::de;
        let mut field_app_id = None;
        let mut field_team_member_id = None;
        let mut field_keep_app_folder = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "app_id" => {
                    if field_app_id.is_some() {
                        return Err(de::Error::duplicate_field("app_id"));
                    }
                    field_app_id = Some(map.next_value()?);
                }
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "keep_app_folder" => {
                    if field_keep_app_folder.is_some() {
                        return Err(de::Error::duplicate_field("keep_app_folder"));
                    }
                    field_keep_app_folder = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REVOKE_LINKED_API_APP_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RevokeLinkedApiAppArg {
            app_id: field_app_id.ok_or_else(|| de::Error::missing_field("app_id"))?,
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
            keep_app_folder: field_keep_app_folder.unwrap_or(true),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("app_id", &self.app_id)?;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("keep_app_folder", &self.keep_app_folder)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeLinkedApiAppArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RevokeLinkedApiAppArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeLinkedApiAppArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RevokeLinkedApiAppArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RevokeLinkedApiAppArg", REVOKE_LINKED_API_APP_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeLinkedApiAppArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RevokeLinkedApiAppArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct RevokeLinkedApiAppBatchArg {
    pub revoke_linked_app: Vec<RevokeLinkedApiAppArg>,
}

impl RevokeLinkedApiAppBatchArg {
    pub fn new(revoke_linked_app: Vec<RevokeLinkedApiAppArg>) -> Self {
        RevokeLinkedApiAppBatchArg {
            revoke_linked_app,
        }
    }

}

const REVOKE_LINKED_API_APP_BATCH_ARG_FIELDS: &[&str] = &["revoke_linked_app"];
impl RevokeLinkedApiAppBatchArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RevokeLinkedApiAppBatchArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RevokeLinkedApiAppBatchArg>, V::Error> {
        use serde::de;
        let mut field_revoke_linked_app = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "revoke_linked_app" => {
                    if field_revoke_linked_app.is_some() {
                        return Err(de::Error::duplicate_field("revoke_linked_app"));
                    }
                    field_revoke_linked_app = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REVOKE_LINKED_API_APP_BATCH_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RevokeLinkedApiAppBatchArg {
            revoke_linked_app: field_revoke_linked_app.ok_or_else(|| de::Error::missing_field("revoke_linked_app"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("revoke_linked_app", &self.revoke_linked_app)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeLinkedApiAppBatchArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RevokeLinkedApiAppBatchArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeLinkedApiAppBatchArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RevokeLinkedApiAppBatchArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RevokeLinkedApiAppBatchArg", REVOKE_LINKED_API_APP_BATCH_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeLinkedApiAppBatchArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RevokeLinkedApiAppBatchArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error returned by
/// [`linked_apps_revoke_linked_app_batch()`](linked_apps_revoke_linked_app_batch).
#[derive(Debug)]
pub enum RevokeLinkedAppBatchError {
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeLinkedAppBatchError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RevokeLinkedAppBatchError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeLinkedAppBatchError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    _ => Ok(RevokeLinkedAppBatchError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["other"];
        deserializer.deserialize_struct("RevokeLinkedAppBatchError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeLinkedAppBatchError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        #![allow(unused_variables)]
        Err(::serde::ser::Error::custom("cannot serialize an open union with no defined variants"))
    }
}

impl ::std::error::Error for RevokeLinkedAppBatchError {
    fn description(&self) -> &str {
        "RevokeLinkedAppBatchError"
    }
}

impl ::std::fmt::Display for RevokeLinkedAppBatchError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct RevokeLinkedAppBatchResult {
    pub revoke_linked_app_status: Vec<RevokeLinkedAppStatus>,
}

impl RevokeLinkedAppBatchResult {
    pub fn new(revoke_linked_app_status: Vec<RevokeLinkedAppStatus>) -> Self {
        RevokeLinkedAppBatchResult {
            revoke_linked_app_status,
        }
    }

}

const REVOKE_LINKED_APP_BATCH_RESULT_FIELDS: &[&str] = &["revoke_linked_app_status"];
impl RevokeLinkedAppBatchResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RevokeLinkedAppBatchResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RevokeLinkedAppBatchResult>, V::Error> {
        use serde::de;
        let mut field_revoke_linked_app_status = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "revoke_linked_app_status" => {
                    if field_revoke_linked_app_status.is_some() {
                        return Err(de::Error::duplicate_field("revoke_linked_app_status"));
                    }
                    field_revoke_linked_app_status = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REVOKE_LINKED_APP_BATCH_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RevokeLinkedAppBatchResult {
            revoke_linked_app_status: field_revoke_linked_app_status.ok_or_else(|| de::Error::missing_field("revoke_linked_app_status"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("revoke_linked_app_status", &self.revoke_linked_app_status)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeLinkedAppBatchResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RevokeLinkedAppBatchResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeLinkedAppBatchResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RevokeLinkedAppBatchResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RevokeLinkedAppBatchResult", REVOKE_LINKED_APP_BATCH_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeLinkedAppBatchResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RevokeLinkedAppBatchResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error returned by [`linked_apps_revoke_linked_app()`](linked_apps_revoke_linked_app).
#[derive(Debug)]
pub enum RevokeLinkedAppError {
    /// Application not found.
    AppNotFound,
    /// Member not found.
    MemberNotFound,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeLinkedAppError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RevokeLinkedAppError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeLinkedAppError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "app_not_found" => Ok(RevokeLinkedAppError::AppNotFound),
                    "member_not_found" => Ok(RevokeLinkedAppError::MemberNotFound),
                    _ => Ok(RevokeLinkedAppError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["app_not_found",
                                    "member_not_found",
                                    "other"];
        deserializer.deserialize_struct("RevokeLinkedAppError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeLinkedAppError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RevokeLinkedAppError::AppNotFound => {
                // unit
                let mut s = serializer.serialize_struct("RevokeLinkedAppError", 1)?;
                s.serialize_field(".tag", "app_not_found")?;
                s.end()
            }
            RevokeLinkedAppError::MemberNotFound => {
                // unit
                let mut s = serializer.serialize_struct("RevokeLinkedAppError", 1)?;
                s.serialize_field(".tag", "member_not_found")?;
                s.end()
            }
            RevokeLinkedAppError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for RevokeLinkedAppError {
    fn description(&self) -> &str {
        "RevokeLinkedAppError"
    }
}

impl ::std::fmt::Display for RevokeLinkedAppError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct RevokeLinkedAppStatus {
    /// Result of the revoking request.
    pub success: bool,
    /// The error cause in case of a failure.
    pub error_type: Option<RevokeLinkedAppError>,
}

impl RevokeLinkedAppStatus {
    pub fn new(success: bool) -> Self {
        RevokeLinkedAppStatus {
            success,
            error_type: None,
        }
    }

    pub fn with_error_type(mut self, value: Option<RevokeLinkedAppError>) -> Self {
        self.error_type = value;
        self
    }

}

const REVOKE_LINKED_APP_STATUS_FIELDS: &[&str] = &["success",
                                                   "error_type"];
impl RevokeLinkedAppStatus {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<RevokeLinkedAppStatus, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<RevokeLinkedAppStatus>, V::Error> {
        use serde::de;
        let mut field_success = None;
        let mut field_error_type = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "success" => {
                    if field_success.is_some() {
                        return Err(de::Error::duplicate_field("success"));
                    }
                    field_success = Some(map.next_value()?);
                }
                "error_type" => {
                    if field_error_type.is_some() {
                        return Err(de::Error::duplicate_field("error_type"));
                    }
                    field_error_type = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, REVOKE_LINKED_APP_STATUS_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = RevokeLinkedAppStatus {
            success: field_success.ok_or_else(|| de::Error::missing_field("success"))?,
            error_type: field_error_type,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("success", &self.success)?;
        s.serialize_field("error_type", &self.error_type)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for RevokeLinkedAppStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = RevokeLinkedAppStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a RevokeLinkedAppStatus struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                RevokeLinkedAppStatus::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("RevokeLinkedAppStatus", REVOKE_LINKED_APP_STATUS_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for RevokeLinkedAppStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("RevokeLinkedAppStatus", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct SetCustomQuotaArg {
    /// List of users and their custom quotas.
    pub users_and_quotas: Vec<UserCustomQuotaArg>,
}

impl SetCustomQuotaArg {
    pub fn new(users_and_quotas: Vec<UserCustomQuotaArg>) -> Self {
        SetCustomQuotaArg {
            users_and_quotas,
        }
    }

}

const SET_CUSTOM_QUOTA_ARG_FIELDS: &[&str] = &["users_and_quotas"];
impl SetCustomQuotaArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<SetCustomQuotaArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<SetCustomQuotaArg>, V::Error> {
        use serde::de;
        let mut field_users_and_quotas = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "users_and_quotas" => {
                    if field_users_and_quotas.is_some() {
                        return Err(de::Error::duplicate_field("users_and_quotas"));
                    }
                    field_users_and_quotas = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, SET_CUSTOM_QUOTA_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = SetCustomQuotaArg {
            users_and_quotas: field_users_and_quotas.ok_or_else(|| de::Error::missing_field("users_and_quotas"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("users_and_quotas", &self.users_and_quotas)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for SetCustomQuotaArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = SetCustomQuotaArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SetCustomQuotaArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                SetCustomQuotaArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("SetCustomQuotaArg", SET_CUSTOM_QUOTA_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for SetCustomQuotaArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("SetCustomQuotaArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error returned when setting member custom quota.
#[derive(Debug)]
pub enum SetCustomQuotaError {
    /// A maximum of 1000 users can be set for a single call.
    TooManyUsers,
    Other,
    /// Some of the users are on the excluded users list and can't have custom quota set.
    SomeUsersAreExcluded,
}

impl<'de> ::serde::de::Deserialize<'de> for SetCustomQuotaError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = SetCustomQuotaError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a SetCustomQuotaError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "too_many_users" => Ok(SetCustomQuotaError::TooManyUsers),
                    "some_users_are_excluded" => Ok(SetCustomQuotaError::SomeUsersAreExcluded),
                    _ => Ok(SetCustomQuotaError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["too_many_users",
                                    "other",
                                    "some_users_are_excluded"];
        deserializer.deserialize_struct("SetCustomQuotaError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for SetCustomQuotaError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            SetCustomQuotaError::TooManyUsers => {
                // unit
                let mut s = serializer.serialize_struct("SetCustomQuotaError", 1)?;
                s.serialize_field(".tag", "too_many_users")?;
                s.end()
            }
            SetCustomQuotaError::SomeUsersAreExcluded => {
                // unit
                let mut s = serializer.serialize_struct("SetCustomQuotaError", 1)?;
                s.serialize_field(".tag", "some_users_are_excluded")?;
                s.end()
            }
            SetCustomQuotaError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for SetCustomQuotaError {
    fn description(&self) -> &str {
        "SetCustomQuotaError"
    }
}

impl ::std::fmt::Display for SetCustomQuotaError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Describes the number of users in a specific storage bucket.
#[derive(Debug)]
pub struct StorageBucket {
    /// The name of the storage bucket. For example, '1G' is a bucket of users with storage size up
    /// to 1 Giga.
    pub bucket: String,
    /// The number of people whose storage is in the range of this storage bucket.
    pub users: u64,
}

impl StorageBucket {
    pub fn new(bucket: String, users: u64) -> Self {
        StorageBucket {
            bucket,
            users,
        }
    }

}

const STORAGE_BUCKET_FIELDS: &[&str] = &["bucket",
                                         "users"];
impl StorageBucket {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<StorageBucket, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<StorageBucket>, V::Error> {
        use serde::de;
        let mut field_bucket = None;
        let mut field_users = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "bucket" => {
                    if field_bucket.is_some() {
                        return Err(de::Error::duplicate_field("bucket"));
                    }
                    field_bucket = Some(map.next_value()?);
                }
                "users" => {
                    if field_users.is_some() {
                        return Err(de::Error::duplicate_field("users"));
                    }
                    field_users = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, STORAGE_BUCKET_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = StorageBucket {
            bucket: field_bucket.ok_or_else(|| de::Error::missing_field("bucket"))?,
            users: field_users.ok_or_else(|| de::Error::missing_field("users"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("bucket", &self.bucket)?;
        s.serialize_field("users", &self.users)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for StorageBucket {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = StorageBucket;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a StorageBucket struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                StorageBucket::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("StorageBucket", STORAGE_BUCKET_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for StorageBucket {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("StorageBucket", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamFolderAccessError {
    /// The team folder ID is invalid.
    InvalidTeamFolderId,
    /// The authenticated app does not have permission to manage that team folder.
    NoAccess,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderAccessError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderAccessError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderAccessError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_team_folder_id" => Ok(TeamFolderAccessError::InvalidTeamFolderId),
                    "no_access" => Ok(TeamFolderAccessError::NoAccess),
                    _ => Ok(TeamFolderAccessError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_team_folder_id",
                                    "no_access",
                                    "other"];
        deserializer.deserialize_struct("TeamFolderAccessError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderAccessError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderAccessError::InvalidTeamFolderId => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderAccessError", 1)?;
                s.serialize_field(".tag", "invalid_team_folder_id")?;
                s.end()
            }
            TeamFolderAccessError::NoAccess => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderAccessError", 1)?;
                s.serialize_field(".tag", "no_access")?;
                s.end()
            }
            TeamFolderAccessError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderAccessError {
    fn description(&self) -> &str {
        "TeamFolderAccessError"
    }
}

impl ::std::fmt::Display for TeamFolderAccessError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}


#[derive(Debug)]
pub enum TeamFolderActivateError {
    AccessError(TeamFolderAccessError),
    StatusError(TeamFolderInvalidStatusError),
    TeamSharedDropboxError(TeamFolderTeamSharedDropboxError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderActivateError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderActivateError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderActivateError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        match map.next_key()? {
                            Some("access_error") => Ok(TeamFolderActivateError::AccessError(map.next_value()?)),
                            None => Err(de::Error::missing_field("access_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "status_error" => {
                        match map.next_key()? {
                            Some("status_error") => Ok(TeamFolderActivateError::StatusError(map.next_value()?)),
                            None => Err(de::Error::missing_field("status_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "team_shared_dropbox_error" => {
                        match map.next_key()? {
                            Some("team_shared_dropbox_error") => Ok(TeamFolderActivateError::TeamSharedDropboxError(map.next_value()?)),
                            None => Err(de::Error::missing_field("team_shared_dropbox_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(TeamFolderActivateError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["access_error",
                                    "status_error",
                                    "team_shared_dropbox_error",
                                    "other"];
        deserializer.deserialize_struct("TeamFolderActivateError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderActivateError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderActivateError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderActivateError", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            TeamFolderActivateError::StatusError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderActivateError", 2)?;
                s.serialize_field(".tag", "status_error")?;
                s.serialize_field("status_error", x)?;
                s.end()
            }
            TeamFolderActivateError::TeamSharedDropboxError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderActivateError", 2)?;
                s.serialize_field(".tag", "team_shared_dropbox_error")?;
                s.serialize_field("team_shared_dropbox_error", x)?;
                s.end()
            }
            TeamFolderActivateError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderActivateError {
    fn description(&self) -> &str {
        "TeamFolderActivateError"
    }
}

impl ::std::fmt::Display for TeamFolderActivateError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct TeamFolderArchiveArg {
    /// The ID of the team folder.
    pub team_folder_id: super::common::SharedFolderId,
    /// Whether to force the archive to happen synchronously.
    pub force_async_off: bool,
}

impl TeamFolderArchiveArg {
    pub fn new(team_folder_id: super::common::SharedFolderId) -> Self {
        TeamFolderArchiveArg {
            team_folder_id,
            force_async_off: false,
        }
    }

    pub fn with_force_async_off(mut self, value: bool) -> Self {
        self.force_async_off = value;
        self
    }

}

const TEAM_FOLDER_ARCHIVE_ARG_FIELDS: &[&str] = &["team_folder_id",
                                                  "force_async_off"];
impl TeamFolderArchiveArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderArchiveArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderArchiveArg>, V::Error> {
        use serde::de;
        let mut field_team_folder_id = None;
        let mut field_force_async_off = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_folder_id" => {
                    if field_team_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("team_folder_id"));
                    }
                    field_team_folder_id = Some(map.next_value()?);
                }
                "force_async_off" => {
                    if field_force_async_off.is_some() {
                        return Err(de::Error::duplicate_field("force_async_off"));
                    }
                    field_force_async_off = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_ARCHIVE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderArchiveArg {
            team_folder_id: field_team_folder_id.ok_or_else(|| de::Error::missing_field("team_folder_id"))?,
            force_async_off: field_force_async_off.unwrap_or(false),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_folder_id", &self.team_folder_id)?;
        s.serialize_field("force_async_off", &self.force_async_off)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderArchiveArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderArchiveArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderArchiveArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderArchiveArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderArchiveArg", TEAM_FOLDER_ARCHIVE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderArchiveArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderArchiveArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}


#[derive(Debug)]
pub enum TeamFolderArchiveError {
    AccessError(TeamFolderAccessError),
    StatusError(TeamFolderInvalidStatusError),
    TeamSharedDropboxError(TeamFolderTeamSharedDropboxError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderArchiveError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderArchiveError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderArchiveError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        match map.next_key()? {
                            Some("access_error") => Ok(TeamFolderArchiveError::AccessError(map.next_value()?)),
                            None => Err(de::Error::missing_field("access_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "status_error" => {
                        match map.next_key()? {
                            Some("status_error") => Ok(TeamFolderArchiveError::StatusError(map.next_value()?)),
                            None => Err(de::Error::missing_field("status_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "team_shared_dropbox_error" => {
                        match map.next_key()? {
                            Some("team_shared_dropbox_error") => Ok(TeamFolderArchiveError::TeamSharedDropboxError(map.next_value()?)),
                            None => Err(de::Error::missing_field("team_shared_dropbox_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(TeamFolderArchiveError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["access_error",
                                    "status_error",
                                    "team_shared_dropbox_error",
                                    "other"];
        deserializer.deserialize_struct("TeamFolderArchiveError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderArchiveError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderArchiveError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderArchiveError", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            TeamFolderArchiveError::StatusError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderArchiveError", 2)?;
                s.serialize_field(".tag", "status_error")?;
                s.serialize_field("status_error", x)?;
                s.end()
            }
            TeamFolderArchiveError::TeamSharedDropboxError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderArchiveError", 2)?;
                s.serialize_field(".tag", "team_shared_dropbox_error")?;
                s.serialize_field("team_shared_dropbox_error", x)?;
                s.end()
            }
            TeamFolderArchiveError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderArchiveError {
    fn description(&self) -> &str {
        "TeamFolderArchiveError"
    }
}

impl ::std::fmt::Display for TeamFolderArchiveError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum TeamFolderArchiveJobStatus {
    /// The asynchronous job is still in progress.
    InProgress,
    /// The archive job has finished. The value is the metadata for the resulting team folder.
    Complete(TeamFolderMetadata),
    /// Error occurred while performing an asynchronous job from
    /// [`team_folder_archive()`](team_folder_archive).
    Failed(TeamFolderArchiveError),
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderArchiveJobStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderArchiveJobStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderArchiveJobStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "in_progress" => Ok(TeamFolderArchiveJobStatus::InProgress),
                    "complete" => Ok(TeamFolderArchiveJobStatus::Complete(TeamFolderMetadata::internal_deserialize(map)?)),
                    "failed" => {
                        match map.next_key()? {
                            Some("failed") => Ok(TeamFolderArchiveJobStatus::Failed(map.next_value()?)),
                            None => Err(de::Error::missing_field("failed")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["in_progress",
                                    "complete",
                                    "failed"];
        deserializer.deserialize_struct("TeamFolderArchiveJobStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderArchiveJobStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderArchiveJobStatus::InProgress => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderArchiveJobStatus", 1)?;
                s.serialize_field(".tag", "in_progress")?;
                s.end()
            }
            TeamFolderArchiveJobStatus::Complete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamFolderArchiveJobStatus", 7)?;
                s.serialize_field(".tag", "complete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            TeamFolderArchiveJobStatus::Failed(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderArchiveJobStatus", 2)?;
                s.serialize_field(".tag", "failed")?;
                s.serialize_field("failed", x)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub enum TeamFolderArchiveLaunch {
    /// This response indicates that the processing is asynchronous. The string is an id that can be
    /// used to obtain the status of the asynchronous job.
    AsyncJobId(super::async::AsyncJobId),
    Complete(TeamFolderMetadata),
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderArchiveLaunch {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderArchiveLaunch;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderArchiveLaunch structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "async_job_id" => {
                        match map.next_key()? {
                            Some("async_job_id") => Ok(TeamFolderArchiveLaunch::AsyncJobId(map.next_value()?)),
                            None => Err(de::Error::missing_field("async_job_id")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "complete" => Ok(TeamFolderArchiveLaunch::Complete(TeamFolderMetadata::internal_deserialize(map)?)),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["async_job_id",
                                    "complete"];
        deserializer.deserialize_struct("TeamFolderArchiveLaunch", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderArchiveLaunch {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderArchiveLaunch::AsyncJobId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("TeamFolderArchiveLaunch", 2)?;
                s.serialize_field(".tag", "async_job_id")?;
                s.serialize_field("async_job_id", x)?;
                s.end()
            }
            TeamFolderArchiveLaunch::Complete(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamFolderArchiveLaunch", 7)?;
                s.serialize_field(".tag", "complete")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub struct TeamFolderCreateArg {
    /// Name for the new team folder.
    pub name: String,
    /// The sync setting to apply to this team folder. Only permitted if the team has team selective
    /// sync enabled.
    pub sync_setting: Option<super::files::SyncSettingArg>,
}

impl TeamFolderCreateArg {
    pub fn new(name: String) -> Self {
        TeamFolderCreateArg {
            name,
            sync_setting: None,
        }
    }

    pub fn with_sync_setting(mut self, value: Option<super::files::SyncSettingArg>) -> Self {
        self.sync_setting = value;
        self
    }

}

const TEAM_FOLDER_CREATE_ARG_FIELDS: &[&str] = &["name",
                                                 "sync_setting"];
impl TeamFolderCreateArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderCreateArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderCreateArg>, V::Error> {
        use serde::de;
        let mut field_name = None;
        let mut field_sync_setting = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "sync_setting" => {
                    if field_sync_setting.is_some() {
                        return Err(de::Error::duplicate_field("sync_setting"));
                    }
                    field_sync_setting = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_CREATE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderCreateArg {
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            sync_setting: field_sync_setting,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("sync_setting", &self.sync_setting)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderCreateArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderCreateArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderCreateArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderCreateArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderCreateArg", TEAM_FOLDER_CREATE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderCreateArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderCreateArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamFolderCreateError {
    /// The provided name cannot be used.
    InvalidFolderName,
    /// There is already a team folder with the provided name.
    FolderNameAlreadyUsed,
    /// The provided name cannot be used because it is reserved.
    FolderNameReserved,
    /// An error occurred setting the sync settings.
    SyncSettingsError(super::files::SyncSettingsError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderCreateError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderCreateError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderCreateError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_folder_name" => Ok(TeamFolderCreateError::InvalidFolderName),
                    "folder_name_already_used" => Ok(TeamFolderCreateError::FolderNameAlreadyUsed),
                    "folder_name_reserved" => Ok(TeamFolderCreateError::FolderNameReserved),
                    "sync_settings_error" => {
                        match map.next_key()? {
                            Some("sync_settings_error") => Ok(TeamFolderCreateError::SyncSettingsError(map.next_value()?)),
                            None => Err(de::Error::missing_field("sync_settings_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(TeamFolderCreateError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_folder_name",
                                    "folder_name_already_used",
                                    "folder_name_reserved",
                                    "sync_settings_error",
                                    "other"];
        deserializer.deserialize_struct("TeamFolderCreateError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderCreateError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderCreateError::InvalidFolderName => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderCreateError", 1)?;
                s.serialize_field(".tag", "invalid_folder_name")?;
                s.end()
            }
            TeamFolderCreateError::FolderNameAlreadyUsed => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderCreateError", 1)?;
                s.serialize_field(".tag", "folder_name_already_used")?;
                s.end()
            }
            TeamFolderCreateError::FolderNameReserved => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderCreateError", 1)?;
                s.serialize_field(".tag", "folder_name_reserved")?;
                s.end()
            }
            TeamFolderCreateError::SyncSettingsError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderCreateError", 2)?;
                s.serialize_field(".tag", "sync_settings_error")?;
                s.serialize_field("sync_settings_error", x)?;
                s.end()
            }
            TeamFolderCreateError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderCreateError {
    fn description(&self) -> &str {
        "TeamFolderCreateError"
    }
}

impl ::std::fmt::Display for TeamFolderCreateError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum TeamFolderGetInfoItem {
    /// An ID that was provided as a parameter to [`team_folder_get_info()`](team_folder_get_info)
    /// did not match any of the team's team folders.
    IdNotFound(String),
    /// Properties of a team folder.
    TeamFolderMetadata(TeamFolderMetadata),
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderGetInfoItem {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderGetInfoItem;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderGetInfoItem structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "id_not_found" => {
                        match map.next_key()? {
                            Some("id_not_found") => Ok(TeamFolderGetInfoItem::IdNotFound(map.next_value()?)),
                            None => Err(de::Error::missing_field("id_not_found")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "team_folder_metadata" => Ok(TeamFolderGetInfoItem::TeamFolderMetadata(TeamFolderMetadata::internal_deserialize(map)?)),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["id_not_found",
                                    "team_folder_metadata"];
        deserializer.deserialize_struct("TeamFolderGetInfoItem", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderGetInfoItem {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderGetInfoItem::IdNotFound(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("TeamFolderGetInfoItem", 2)?;
                s.serialize_field(".tag", "id_not_found")?;
                s.serialize_field("id_not_found", x)?;
                s.end()
            }
            TeamFolderGetInfoItem::TeamFolderMetadata(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamFolderGetInfoItem", 7)?;
                s.serialize_field(".tag", "team_folder_metadata")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub struct TeamFolderIdArg {
    /// The ID of the team folder.
    pub team_folder_id: super::common::SharedFolderId,
}

impl TeamFolderIdArg {
    pub fn new(team_folder_id: super::common::SharedFolderId) -> Self {
        TeamFolderIdArg {
            team_folder_id,
        }
    }

}

const TEAM_FOLDER_ID_ARG_FIELDS: &[&str] = &["team_folder_id"];
impl TeamFolderIdArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderIdArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderIdArg>, V::Error> {
        use serde::de;
        let mut field_team_folder_id = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_folder_id" => {
                    if field_team_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("team_folder_id"));
                    }
                    field_team_folder_id = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_ID_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderIdArg {
            team_folder_id: field_team_folder_id.ok_or_else(|| de::Error::missing_field("team_folder_id"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_folder_id", &self.team_folder_id)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderIdArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderIdArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderIdArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderIdArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderIdArg", TEAM_FOLDER_ID_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderIdArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderIdArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderIdListArg {
    /// The list of team folder IDs.
    pub team_folder_ids: Vec<super::common::SharedFolderId>,
}

impl TeamFolderIdListArg {
    pub fn new(team_folder_ids: Vec<super::common::SharedFolderId>) -> Self {
        TeamFolderIdListArg {
            team_folder_ids,
        }
    }

}

const TEAM_FOLDER_ID_LIST_ARG_FIELDS: &[&str] = &["team_folder_ids"];
impl TeamFolderIdListArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderIdListArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderIdListArg>, V::Error> {
        use serde::de;
        let mut field_team_folder_ids = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_folder_ids" => {
                    if field_team_folder_ids.is_some() {
                        return Err(de::Error::duplicate_field("team_folder_ids"));
                    }
                    field_team_folder_ids = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_ID_LIST_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderIdListArg {
            team_folder_ids: field_team_folder_ids.ok_or_else(|| de::Error::missing_field("team_folder_ids"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_folder_ids", &self.team_folder_ids)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderIdListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderIdListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderIdListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderIdListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderIdListArg", TEAM_FOLDER_ID_LIST_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderIdListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderIdListArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamFolderInvalidStatusError {
    /// The folder is active and the operation did not succeed.
    Active,
    /// The folder is archived and the operation did not succeed.
    Archived,
    /// The folder is being archived and the operation did not succeed.
    ArchiveInProgress,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderInvalidStatusError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderInvalidStatusError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderInvalidStatusError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "active" => Ok(TeamFolderInvalidStatusError::Active),
                    "archived" => Ok(TeamFolderInvalidStatusError::Archived),
                    "archive_in_progress" => Ok(TeamFolderInvalidStatusError::ArchiveInProgress),
                    _ => Ok(TeamFolderInvalidStatusError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["active",
                                    "archived",
                                    "archive_in_progress",
                                    "other"];
        deserializer.deserialize_struct("TeamFolderInvalidStatusError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderInvalidStatusError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderInvalidStatusError::Active => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderInvalidStatusError", 1)?;
                s.serialize_field(".tag", "active")?;
                s.end()
            }
            TeamFolderInvalidStatusError::Archived => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderInvalidStatusError", 1)?;
                s.serialize_field(".tag", "archived")?;
                s.end()
            }
            TeamFolderInvalidStatusError::ArchiveInProgress => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderInvalidStatusError", 1)?;
                s.serialize_field(".tag", "archive_in_progress")?;
                s.end()
            }
            TeamFolderInvalidStatusError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderInvalidStatusError {
    fn description(&self) -> &str {
        "TeamFolderInvalidStatusError"
    }
}

impl ::std::fmt::Display for TeamFolderInvalidStatusError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct TeamFolderListArg {
    /// The maximum number of results to return per request.
    pub limit: u32,
}

impl Default for TeamFolderListArg {
    fn default() -> Self {
        TeamFolderListArg {
            limit: 1000,
        }
    }
}

const TEAM_FOLDER_LIST_ARG_FIELDS: &[&str] = &["limit"];
impl TeamFolderListArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamFolderListArg, V::Error> {
        use serde::de;
        let mut field_limit = None;
        while let Some(key) = map.next_key()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_LIST_ARG_FIELDS))
            }
        }
        let result = TeamFolderListArg {
            limit: field_limit.unwrap_or(1000),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderListArg", TEAM_FOLDER_LIST_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderListArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamFolderListContinueArg {
    /// Indicates from what point to get the next set of team folders.
    pub cursor: String,
}

impl TeamFolderListContinueArg {
    pub fn new(cursor: String) -> Self {
        TeamFolderListContinueArg {
            cursor,
        }
    }

}

const TEAM_FOLDER_LIST_CONTINUE_ARG_FIELDS: &[&str] = &["cursor"];
impl TeamFolderListContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderListContinueArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderListContinueArg>, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_LIST_CONTINUE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderListContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderListContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderListContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderListContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderListContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderListContinueArg", TEAM_FOLDER_LIST_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderListContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderListContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamFolderListContinueError {
    /// The cursor is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderListContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderListContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderListContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_cursor" => Ok(TeamFolderListContinueError::InvalidCursor),
                    _ => Ok(TeamFolderListContinueError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_cursor",
                                    "other"];
        deserializer.deserialize_struct("TeamFolderListContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderListContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderListContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderListContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            TeamFolderListContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderListContinueError {
    fn description(&self) -> &str {
        "TeamFolderListContinueError"
    }
}

impl ::std::fmt::Display for TeamFolderListContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct TeamFolderListError {
    pub access_error: TeamFolderAccessError,
}

impl TeamFolderListError {
    pub fn new(access_error: TeamFolderAccessError) -> Self {
        TeamFolderListError {
            access_error,
        }
    }

}

const TEAM_FOLDER_LIST_ERROR_FIELDS: &[&str] = &["access_error"];
impl TeamFolderListError {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderListError, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderListError>, V::Error> {
        use serde::de;
        let mut field_access_error = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "access_error" => {
                    if field_access_error.is_some() {
                        return Err(de::Error::duplicate_field("access_error"));
                    }
                    field_access_error = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_LIST_ERROR_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderListError {
            access_error: field_access_error.ok_or_else(|| de::Error::missing_field("access_error"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("access_error", &self.access_error)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderListError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderListError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderListError struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderListError::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderListError", TEAM_FOLDER_LIST_ERROR_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderListError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderListError", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Result for [`team_folder_list()`](team_folder_list) and
/// [`team_folder_list_continue()`](team_folder_list_continue).
#[derive(Debug)]
pub struct TeamFolderListResult {
    /// List of all team folders in the authenticated team.
    pub team_folders: Vec<TeamFolderMetadata>,
    /// Pass the cursor into [`team_folder_list_continue()`](team_folder_list_continue) to obtain
    /// additional team folders.
    pub cursor: String,
    /// Is true if there are additional team folders that have not been returned yet. An additional
    /// call to [`team_folder_list_continue()`](team_folder_list_continue) can retrieve them.
    pub has_more: bool,
}

impl TeamFolderListResult {
    pub fn new(team_folders: Vec<TeamFolderMetadata>, cursor: String, has_more: bool) -> Self {
        TeamFolderListResult {
            team_folders,
            cursor,
            has_more,
        }
    }

}

const TEAM_FOLDER_LIST_RESULT_FIELDS: &[&str] = &["team_folders",
                                                  "cursor",
                                                  "has_more"];
impl TeamFolderListResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderListResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderListResult>, V::Error> {
        use serde::de;
        let mut field_team_folders = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_folders" => {
                    if field_team_folders.is_some() {
                        return Err(de::Error::duplicate_field("team_folders"));
                    }
                    field_team_folders = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_LIST_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderListResult {
            team_folders: field_team_folders.ok_or_else(|| de::Error::missing_field("team_folders"))?,
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_folders", &self.team_folders)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderListResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderListResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderListResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderListResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderListResult", TEAM_FOLDER_LIST_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderListResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderListResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Properties of a team folder.
#[derive(Debug)]
pub struct TeamFolderMetadata {
    /// The ID of the team folder.
    pub team_folder_id: super::common::SharedFolderId,
    /// The name of the team folder.
    pub name: String,
    /// The status of the team folder.
    pub status: TeamFolderStatus,
    /// True if this team folder is a shared team root.
    pub is_team_shared_dropbox: bool,
    /// The sync setting applied to this team folder.
    pub sync_setting: super::files::SyncSetting,
    /// Sync settings applied to contents of this team folder.
    pub content_sync_settings: Vec<super::files::ContentSyncSetting>,
}

impl TeamFolderMetadata {
    pub fn new(
        team_folder_id: super::common::SharedFolderId,
        name: String,
        status: TeamFolderStatus,
        is_team_shared_dropbox: bool,
        sync_setting: super::files::SyncSetting,
        content_sync_settings: Vec<super::files::ContentSyncSetting>,
    ) -> Self {
        TeamFolderMetadata {
            team_folder_id,
            name,
            status,
            is_team_shared_dropbox,
            sync_setting,
            content_sync_settings,
        }
    }

}

const TEAM_FOLDER_METADATA_FIELDS: &[&str] = &["team_folder_id",
                                               "name",
                                               "status",
                                               "is_team_shared_dropbox",
                                               "sync_setting",
                                               "content_sync_settings"];
impl TeamFolderMetadata {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderMetadata, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderMetadata>, V::Error> {
        use serde::de;
        let mut field_team_folder_id = None;
        let mut field_name = None;
        let mut field_status = None;
        let mut field_is_team_shared_dropbox = None;
        let mut field_sync_setting = None;
        let mut field_content_sync_settings = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_folder_id" => {
                    if field_team_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("team_folder_id"));
                    }
                    field_team_folder_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "status" => {
                    if field_status.is_some() {
                        return Err(de::Error::duplicate_field("status"));
                    }
                    field_status = Some(map.next_value()?);
                }
                "is_team_shared_dropbox" => {
                    if field_is_team_shared_dropbox.is_some() {
                        return Err(de::Error::duplicate_field("is_team_shared_dropbox"));
                    }
                    field_is_team_shared_dropbox = Some(map.next_value()?);
                }
                "sync_setting" => {
                    if field_sync_setting.is_some() {
                        return Err(de::Error::duplicate_field("sync_setting"));
                    }
                    field_sync_setting = Some(map.next_value()?);
                }
                "content_sync_settings" => {
                    if field_content_sync_settings.is_some() {
                        return Err(de::Error::duplicate_field("content_sync_settings"));
                    }
                    field_content_sync_settings = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_METADATA_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderMetadata {
            team_folder_id: field_team_folder_id.ok_or_else(|| de::Error::missing_field("team_folder_id"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            status: field_status.ok_or_else(|| de::Error::missing_field("status"))?,
            is_team_shared_dropbox: field_is_team_shared_dropbox.ok_or_else(|| de::Error::missing_field("is_team_shared_dropbox"))?,
            sync_setting: field_sync_setting.ok_or_else(|| de::Error::missing_field("sync_setting"))?,
            content_sync_settings: field_content_sync_settings.ok_or_else(|| de::Error::missing_field("content_sync_settings"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_folder_id", &self.team_folder_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("status", &self.status)?;
        s.serialize_field("is_team_shared_dropbox", &self.is_team_shared_dropbox)?;
        s.serialize_field("sync_setting", &self.sync_setting)?;
        s.serialize_field("content_sync_settings", &self.content_sync_settings)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderMetadata {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderMetadata;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderMetadata struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderMetadata::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderMetadata", TEAM_FOLDER_METADATA_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderMetadata {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderMetadata", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}


#[derive(Debug)]
pub enum TeamFolderPermanentlyDeleteError {
    AccessError(TeamFolderAccessError),
    StatusError(TeamFolderInvalidStatusError),
    TeamSharedDropboxError(TeamFolderTeamSharedDropboxError),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderPermanentlyDeleteError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderPermanentlyDeleteError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderPermanentlyDeleteError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        match map.next_key()? {
                            Some("access_error") => Ok(TeamFolderPermanentlyDeleteError::AccessError(map.next_value()?)),
                            None => Err(de::Error::missing_field("access_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "status_error" => {
                        match map.next_key()? {
                            Some("status_error") => Ok(TeamFolderPermanentlyDeleteError::StatusError(map.next_value()?)),
                            None => Err(de::Error::missing_field("status_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "team_shared_dropbox_error" => {
                        match map.next_key()? {
                            Some("team_shared_dropbox_error") => Ok(TeamFolderPermanentlyDeleteError::TeamSharedDropboxError(map.next_value()?)),
                            None => Err(de::Error::missing_field("team_shared_dropbox_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(TeamFolderPermanentlyDeleteError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["access_error",
                                    "status_error",
                                    "team_shared_dropbox_error",
                                    "other"];
        deserializer.deserialize_struct("TeamFolderPermanentlyDeleteError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderPermanentlyDeleteError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderPermanentlyDeleteError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderPermanentlyDeleteError", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            TeamFolderPermanentlyDeleteError::StatusError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderPermanentlyDeleteError", 2)?;
                s.serialize_field(".tag", "status_error")?;
                s.serialize_field("status_error", x)?;
                s.end()
            }
            TeamFolderPermanentlyDeleteError::TeamSharedDropboxError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderPermanentlyDeleteError", 2)?;
                s.serialize_field(".tag", "team_shared_dropbox_error")?;
                s.serialize_field("team_shared_dropbox_error", x)?;
                s.end()
            }
            TeamFolderPermanentlyDeleteError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderPermanentlyDeleteError {
    fn description(&self) -> &str {
        "TeamFolderPermanentlyDeleteError"
    }
}

impl ::std::fmt::Display for TeamFolderPermanentlyDeleteError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct TeamFolderRenameArg {
    /// The ID of the team folder.
    pub team_folder_id: super::common::SharedFolderId,
    /// New team folder name.
    pub name: String,
}

impl TeamFolderRenameArg {
    pub fn new(team_folder_id: super::common::SharedFolderId, name: String) -> Self {
        TeamFolderRenameArg {
            team_folder_id,
            name,
        }
    }

}

const TEAM_FOLDER_RENAME_ARG_FIELDS: &[&str] = &["team_folder_id",
                                                 "name"];
impl TeamFolderRenameArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderRenameArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderRenameArg>, V::Error> {
        use serde::de;
        let mut field_team_folder_id = None;
        let mut field_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_folder_id" => {
                    if field_team_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("team_folder_id"));
                    }
                    field_team_folder_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_RENAME_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderRenameArg {
            team_folder_id: field_team_folder_id.ok_or_else(|| de::Error::missing_field("team_folder_id"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_folder_id", &self.team_folder_id)?;
        s.serialize_field("name", &self.name)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderRenameArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderRenameArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderRenameArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderRenameArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderRenameArg", TEAM_FOLDER_RENAME_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderRenameArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderRenameArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamFolderRenameError {
    AccessError(TeamFolderAccessError),
    StatusError(TeamFolderInvalidStatusError),
    TeamSharedDropboxError(TeamFolderTeamSharedDropboxError),
    Other,
    /// The provided folder name cannot be used.
    InvalidFolderName,
    /// There is already a team folder with the same name.
    FolderNameAlreadyUsed,
    /// The provided name cannot be used because it is reserved.
    FolderNameReserved,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderRenameError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderRenameError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderRenameError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        match map.next_key()? {
                            Some("access_error") => Ok(TeamFolderRenameError::AccessError(map.next_value()?)),
                            None => Err(de::Error::missing_field("access_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "status_error" => {
                        match map.next_key()? {
                            Some("status_error") => Ok(TeamFolderRenameError::StatusError(map.next_value()?)),
                            None => Err(de::Error::missing_field("status_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "team_shared_dropbox_error" => {
                        match map.next_key()? {
                            Some("team_shared_dropbox_error") => Ok(TeamFolderRenameError::TeamSharedDropboxError(map.next_value()?)),
                            None => Err(de::Error::missing_field("team_shared_dropbox_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "invalid_folder_name" => Ok(TeamFolderRenameError::InvalidFolderName),
                    "folder_name_already_used" => Ok(TeamFolderRenameError::FolderNameAlreadyUsed),
                    "folder_name_reserved" => Ok(TeamFolderRenameError::FolderNameReserved),
                    _ => Ok(TeamFolderRenameError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["access_error",
                                    "status_error",
                                    "team_shared_dropbox_error",
                                    "other",
                                    "invalid_folder_name",
                                    "folder_name_already_used",
                                    "folder_name_reserved"];
        deserializer.deserialize_struct("TeamFolderRenameError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderRenameError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderRenameError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderRenameError", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            TeamFolderRenameError::StatusError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderRenameError", 2)?;
                s.serialize_field(".tag", "status_error")?;
                s.serialize_field("status_error", x)?;
                s.end()
            }
            TeamFolderRenameError::TeamSharedDropboxError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderRenameError", 2)?;
                s.serialize_field(".tag", "team_shared_dropbox_error")?;
                s.serialize_field("team_shared_dropbox_error", x)?;
                s.end()
            }
            TeamFolderRenameError::InvalidFolderName => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderRenameError", 1)?;
                s.serialize_field(".tag", "invalid_folder_name")?;
                s.end()
            }
            TeamFolderRenameError::FolderNameAlreadyUsed => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderRenameError", 1)?;
                s.serialize_field(".tag", "folder_name_already_used")?;
                s.end()
            }
            TeamFolderRenameError::FolderNameReserved => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderRenameError", 1)?;
                s.serialize_field(".tag", "folder_name_reserved")?;
                s.end()
            }
            TeamFolderRenameError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderRenameError {
    fn description(&self) -> &str {
        "TeamFolderRenameError"
    }
}

impl ::std::fmt::Display for TeamFolderRenameError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub enum TeamFolderStatus {
    /// The team folder and sub-folders are available to all members.
    Active,
    /// The team folder is not accessible outside of the team folder manager.
    Archived,
    /// The team folder is not accessible outside of the team folder manager.
    ArchiveInProgress,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "active" => Ok(TeamFolderStatus::Active),
                    "archived" => Ok(TeamFolderStatus::Archived),
                    "archive_in_progress" => Ok(TeamFolderStatus::ArchiveInProgress),
                    _ => Ok(TeamFolderStatus::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["active",
                                    "archived",
                                    "archive_in_progress",
                                    "other"];
        deserializer.deserialize_struct("TeamFolderStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderStatus::Active => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderStatus", 1)?;
                s.serialize_field(".tag", "active")?;
                s.end()
            }
            TeamFolderStatus::Archived => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderStatus", 1)?;
                s.serialize_field(".tag", "archived")?;
                s.end()
            }
            TeamFolderStatus::ArchiveInProgress => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderStatus", 1)?;
                s.serialize_field(".tag", "archive_in_progress")?;
                s.end()
            }
            TeamFolderStatus::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

#[derive(Debug)]
pub enum TeamFolderTeamSharedDropboxError {
    /// This action is not allowed for a shared team root.
    Disallowed,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderTeamSharedDropboxError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderTeamSharedDropboxError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderTeamSharedDropboxError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "disallowed" => Ok(TeamFolderTeamSharedDropboxError::Disallowed),
                    _ => Ok(TeamFolderTeamSharedDropboxError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["disallowed",
                                    "other"];
        deserializer.deserialize_struct("TeamFolderTeamSharedDropboxError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderTeamSharedDropboxError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderTeamSharedDropboxError::Disallowed => {
                // unit
                let mut s = serializer.serialize_struct("TeamFolderTeamSharedDropboxError", 1)?;
                s.serialize_field(".tag", "disallowed")?;
                s.end()
            }
            TeamFolderTeamSharedDropboxError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderTeamSharedDropboxError {
    fn description(&self) -> &str {
        "TeamFolderTeamSharedDropboxError"
    }
}

impl ::std::fmt::Display for TeamFolderTeamSharedDropboxError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct TeamFolderUpdateSyncSettingsArg {
    /// The ID of the team folder.
    pub team_folder_id: super::common::SharedFolderId,
    /// Sync setting to apply to the team folder itself. Only meaningful if the team folder is not a
    /// shared team root.
    pub sync_setting: Option<super::files::SyncSettingArg>,
    /// Sync settings to apply to contents of this team folder.
    pub content_sync_settings: Option<Vec<super::files::ContentSyncSettingArg>>,
}

impl TeamFolderUpdateSyncSettingsArg {
    pub fn new(team_folder_id: super::common::SharedFolderId) -> Self {
        TeamFolderUpdateSyncSettingsArg {
            team_folder_id,
            sync_setting: None,
            content_sync_settings: None,
        }
    }

    pub fn with_sync_setting(mut self, value: Option<super::files::SyncSettingArg>) -> Self {
        self.sync_setting = value;
        self
    }

    pub fn with_content_sync_settings(
        mut self,
        value: Option<Vec<super::files::ContentSyncSettingArg>>,
    ) -> Self {
        self.content_sync_settings = value;
        self
    }

}

const TEAM_FOLDER_UPDATE_SYNC_SETTINGS_ARG_FIELDS: &[&str] = &["team_folder_id",
                                                               "sync_setting",
                                                               "content_sync_settings"];
impl TeamFolderUpdateSyncSettingsArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamFolderUpdateSyncSettingsArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamFolderUpdateSyncSettingsArg>, V::Error> {
        use serde::de;
        let mut field_team_folder_id = None;
        let mut field_sync_setting = None;
        let mut field_content_sync_settings = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_folder_id" => {
                    if field_team_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("team_folder_id"));
                    }
                    field_team_folder_id = Some(map.next_value()?);
                }
                "sync_setting" => {
                    if field_sync_setting.is_some() {
                        return Err(de::Error::duplicate_field("sync_setting"));
                    }
                    field_sync_setting = Some(map.next_value()?);
                }
                "content_sync_settings" => {
                    if field_content_sync_settings.is_some() {
                        return Err(de::Error::duplicate_field("content_sync_settings"));
                    }
                    field_content_sync_settings = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_FOLDER_UPDATE_SYNC_SETTINGS_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamFolderUpdateSyncSettingsArg {
            team_folder_id: field_team_folder_id.ok_or_else(|| de::Error::missing_field("team_folder_id"))?,
            sync_setting: field_sync_setting,
            content_sync_settings: field_content_sync_settings,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_folder_id", &self.team_folder_id)?;
        s.serialize_field("sync_setting", &self.sync_setting)?;
        s.serialize_field("content_sync_settings", &self.content_sync_settings)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderUpdateSyncSettingsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamFolderUpdateSyncSettingsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderUpdateSyncSettingsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamFolderUpdateSyncSettingsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamFolderUpdateSyncSettingsArg", TEAM_FOLDER_UPDATE_SYNC_SETTINGS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderUpdateSyncSettingsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamFolderUpdateSyncSettingsArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamFolderUpdateSyncSettingsError {
    AccessError(TeamFolderAccessError),
    StatusError(TeamFolderInvalidStatusError),
    TeamSharedDropboxError(TeamFolderTeamSharedDropboxError),
    Other,
    /// An error occurred setting the sync settings.
    SyncSettingsError(super::files::SyncSettingsError),
}

impl<'de> ::serde::de::Deserialize<'de> for TeamFolderUpdateSyncSettingsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamFolderUpdateSyncSettingsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamFolderUpdateSyncSettingsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "access_error" => {
                        match map.next_key()? {
                            Some("access_error") => Ok(TeamFolderUpdateSyncSettingsError::AccessError(map.next_value()?)),
                            None => Err(de::Error::missing_field("access_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "status_error" => {
                        match map.next_key()? {
                            Some("status_error") => Ok(TeamFolderUpdateSyncSettingsError::StatusError(map.next_value()?)),
                            None => Err(de::Error::missing_field("status_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "team_shared_dropbox_error" => {
                        match map.next_key()? {
                            Some("team_shared_dropbox_error") => Ok(TeamFolderUpdateSyncSettingsError::TeamSharedDropboxError(map.next_value()?)),
                            None => Err(de::Error::missing_field("team_shared_dropbox_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "sync_settings_error" => {
                        match map.next_key()? {
                            Some("sync_settings_error") => Ok(TeamFolderUpdateSyncSettingsError::SyncSettingsError(map.next_value()?)),
                            None => Err(de::Error::missing_field("sync_settings_error")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(TeamFolderUpdateSyncSettingsError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["access_error",
                                    "status_error",
                                    "team_shared_dropbox_error",
                                    "other",
                                    "sync_settings_error"];
        deserializer.deserialize_struct("TeamFolderUpdateSyncSettingsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamFolderUpdateSyncSettingsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamFolderUpdateSyncSettingsError::AccessError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderUpdateSyncSettingsError", 2)?;
                s.serialize_field(".tag", "access_error")?;
                s.serialize_field("access_error", x)?;
                s.end()
            }
            TeamFolderUpdateSyncSettingsError::StatusError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderUpdateSyncSettingsError", 2)?;
                s.serialize_field(".tag", "status_error")?;
                s.serialize_field("status_error", x)?;
                s.end()
            }
            TeamFolderUpdateSyncSettingsError::TeamSharedDropboxError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderUpdateSyncSettingsError", 2)?;
                s.serialize_field(".tag", "team_shared_dropbox_error")?;
                s.serialize_field("team_shared_dropbox_error", x)?;
                s.end()
            }
            TeamFolderUpdateSyncSettingsError::SyncSettingsError(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TeamFolderUpdateSyncSettingsError", 2)?;
                s.serialize_field(".tag", "sync_settings_error")?;
                s.serialize_field("sync_settings_error", x)?;
                s.end()
            }
            TeamFolderUpdateSyncSettingsError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamFolderUpdateSyncSettingsError {
    fn description(&self) -> &str {
        "TeamFolderUpdateSyncSettingsError"
    }
}

impl ::std::fmt::Display for TeamFolderUpdateSyncSettingsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug)]
pub struct TeamGetInfoResult {
    /// The name of the team.
    pub name: String,
    /// The ID of the team.
    pub team_id: String,
    /// The number of licenses available to the team.
    pub num_licensed_users: u32,
    /// The number of accounts that have been invited or are already active members of the team.
    pub num_provisioned_users: u32,
    pub policies: super::team_policies::TeamMemberPolicies,
}

impl TeamGetInfoResult {
    pub fn new(
        name: String,
        team_id: String,
        num_licensed_users: u32,
        num_provisioned_users: u32,
        policies: super::team_policies::TeamMemberPolicies,
    ) -> Self {
        TeamGetInfoResult {
            name,
            team_id,
            num_licensed_users,
            num_provisioned_users,
            policies,
        }
    }

}

const TEAM_GET_INFO_RESULT_FIELDS: &[&str] = &["name",
                                               "team_id",
                                               "num_licensed_users",
                                               "num_provisioned_users",
                                               "policies"];
impl TeamGetInfoResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamGetInfoResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamGetInfoResult>, V::Error> {
        use serde::de;
        let mut field_name = None;
        let mut field_team_id = None;
        let mut field_num_licensed_users = None;
        let mut field_num_provisioned_users = None;
        let mut field_policies = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "team_id" => {
                    if field_team_id.is_some() {
                        return Err(de::Error::duplicate_field("team_id"));
                    }
                    field_team_id = Some(map.next_value()?);
                }
                "num_licensed_users" => {
                    if field_num_licensed_users.is_some() {
                        return Err(de::Error::duplicate_field("num_licensed_users"));
                    }
                    field_num_licensed_users = Some(map.next_value()?);
                }
                "num_provisioned_users" => {
                    if field_num_provisioned_users.is_some() {
                        return Err(de::Error::duplicate_field("num_provisioned_users"));
                    }
                    field_num_provisioned_users = Some(map.next_value()?);
                }
                "policies" => {
                    if field_policies.is_some() {
                        return Err(de::Error::duplicate_field("policies"));
                    }
                    field_policies = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_GET_INFO_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamGetInfoResult {
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            team_id: field_team_id.ok_or_else(|| de::Error::missing_field("team_id"))?,
            num_licensed_users: field_num_licensed_users.ok_or_else(|| de::Error::missing_field("num_licensed_users"))?,
            num_provisioned_users: field_num_provisioned_users.ok_or_else(|| de::Error::missing_field("num_provisioned_users"))?,
            policies: field_policies.ok_or_else(|| de::Error::missing_field("policies"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("team_id", &self.team_id)?;
        s.serialize_field("num_licensed_users", &self.num_licensed_users)?;
        s.serialize_field("num_provisioned_users", &self.num_provisioned_users)?;
        s.serialize_field("policies", &self.policies)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamGetInfoResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamGetInfoResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamGetInfoResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamGetInfoResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamGetInfoResult", TEAM_GET_INFO_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamGetInfoResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamGetInfoResult", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Information about a team member.
#[derive(Debug)]
pub struct TeamMemberInfo {
    /// Profile of a user as a member of a team.
    pub profile: TeamMemberProfile,
    /// The user's role in the team.
    pub role: AdminTier,
}

impl TeamMemberInfo {
    pub fn new(profile: TeamMemberProfile, role: AdminTier) -> Self {
        TeamMemberInfo {
            profile,
            role,
        }
    }

}

const TEAM_MEMBER_INFO_FIELDS: &[&str] = &["profile",
                                           "role"];
impl TeamMemberInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMemberInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMemberInfo>, V::Error> {
        use serde::de;
        let mut field_profile = None;
        let mut field_role = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "profile" => {
                    if field_profile.is_some() {
                        return Err(de::Error::duplicate_field("profile"));
                    }
                    field_profile = Some(map.next_value()?);
                }
                "role" => {
                    if field_role.is_some() {
                        return Err(de::Error::duplicate_field("role"));
                    }
                    field_role = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MEMBER_INFO_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMemberInfo {
            profile: field_profile.ok_or_else(|| de::Error::missing_field("profile"))?,
            role: field_role.ok_or_else(|| de::Error::missing_field("role"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("profile", &self.profile)?;
        s.serialize_field("role", &self.role)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMemberInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMemberInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMemberInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMemberInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMemberInfo", TEAM_MEMBER_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMemberInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMemberInfo", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Profile of a user as a member of a team.
#[derive(Debug)]
pub struct TeamMemberProfile {
    /// ID of user as a member of a team.
    pub team_member_id: super::team_common::TeamMemberId,
    /// Email address of user.
    pub email: String,
    /// Is true if the user's email is verified to be owned by the user.
    pub email_verified: bool,
    /// The user's status as a member of a specific team.
    pub status: TeamMemberStatus,
    /// Representations for a person's name.
    pub name: super::users::Name,
    /// The user's membership type: full (normal team member) vs limited (does not use a license; no
    /// access to the team's shared quota).
    pub membership_type: TeamMembershipType,
    /// List of group IDs of groups that the user belongs to.
    pub groups: Vec<super::team_common::GroupId>,
    /// The namespace id of the user's root folder.
    pub member_folder_id: super::common::NamespaceId,
    /// External ID that a team can attach to the user. An application using the API may find it
    /// easier to use their own IDs instead of Dropbox IDs like account_id or team_member_id.
    pub external_id: Option<String>,
    /// A user's account identifier.
    pub account_id: Option<super::users_common::AccountId>,
    /// The date and time the user joined as a member of a specific team.
    pub joined_on: Option<super::common::DropboxTimestamp>,
    /// Persistent ID that a team can attach to the user. The persistent ID is unique ID to be used
    /// for SAML authentication.
    pub persistent_id: Option<String>,
    /// Whether the user is a directory restricted user.
    pub is_directory_restricted: Option<bool>,
}

impl TeamMemberProfile {
    pub fn new(
        team_member_id: super::team_common::TeamMemberId,
        email: String,
        email_verified: bool,
        status: TeamMemberStatus,
        name: super::users::Name,
        membership_type: TeamMembershipType,
        groups: Vec<super::team_common::GroupId>,
        member_folder_id: super::common::NamespaceId,
    ) -> Self {
        TeamMemberProfile {
            team_member_id,
            email,
            email_verified,
            status,
            name,
            membership_type,
            groups,
            member_folder_id,
            external_id: None,
            account_id: None,
            joined_on: None,
            persistent_id: None,
            is_directory_restricted: None,
        }
    }

    pub fn with_external_id(mut self, value: Option<String>) -> Self {
        self.external_id = value;
        self
    }

    pub fn with_account_id(mut self, value: Option<super::users_common::AccountId>) -> Self {
        self.account_id = value;
        self
    }

    pub fn with_joined_on(mut self, value: Option<super::common::DropboxTimestamp>) -> Self {
        self.joined_on = value;
        self
    }

    pub fn with_persistent_id(mut self, value: Option<String>) -> Self {
        self.persistent_id = value;
        self
    }

    pub fn with_is_directory_restricted(mut self, value: Option<bool>) -> Self {
        self.is_directory_restricted = value;
        self
    }

}

const TEAM_MEMBER_PROFILE_FIELDS: &[&str] = &["team_member_id",
                                              "email",
                                              "email_verified",
                                              "status",
                                              "name",
                                              "membership_type",
                                              "groups",
                                              "member_folder_id",
                                              "external_id",
                                              "account_id",
                                              "joined_on",
                                              "persistent_id",
                                              "is_directory_restricted"];
impl TeamMemberProfile {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamMemberProfile, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamMemberProfile>, V::Error> {
        use serde::de;
        let mut field_team_member_id = None;
        let mut field_email = None;
        let mut field_email_verified = None;
        let mut field_status = None;
        let mut field_name = None;
        let mut field_membership_type = None;
        let mut field_groups = None;
        let mut field_member_folder_id = None;
        let mut field_external_id = None;
        let mut field_account_id = None;
        let mut field_joined_on = None;
        let mut field_persistent_id = None;
        let mut field_is_directory_restricted = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "team_member_id" => {
                    if field_team_member_id.is_some() {
                        return Err(de::Error::duplicate_field("team_member_id"));
                    }
                    field_team_member_id = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "email_verified" => {
                    if field_email_verified.is_some() {
                        return Err(de::Error::duplicate_field("email_verified"));
                    }
                    field_email_verified = Some(map.next_value()?);
                }
                "status" => {
                    if field_status.is_some() {
                        return Err(de::Error::duplicate_field("status"));
                    }
                    field_status = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "membership_type" => {
                    if field_membership_type.is_some() {
                        return Err(de::Error::duplicate_field("membership_type"));
                    }
                    field_membership_type = Some(map.next_value()?);
                }
                "groups" => {
                    if field_groups.is_some() {
                        return Err(de::Error::duplicate_field("groups"));
                    }
                    field_groups = Some(map.next_value()?);
                }
                "member_folder_id" => {
                    if field_member_folder_id.is_some() {
                        return Err(de::Error::duplicate_field("member_folder_id"));
                    }
                    field_member_folder_id = Some(map.next_value()?);
                }
                "external_id" => {
                    if field_external_id.is_some() {
                        return Err(de::Error::duplicate_field("external_id"));
                    }
                    field_external_id = Some(map.next_value()?);
                }
                "account_id" => {
                    if field_account_id.is_some() {
                        return Err(de::Error::duplicate_field("account_id"));
                    }
                    field_account_id = Some(map.next_value()?);
                }
                "joined_on" => {
                    if field_joined_on.is_some() {
                        return Err(de::Error::duplicate_field("joined_on"));
                    }
                    field_joined_on = Some(map.next_value()?);
                }
                "persistent_id" => {
                    if field_persistent_id.is_some() {
                        return Err(de::Error::duplicate_field("persistent_id"));
                    }
                    field_persistent_id = Some(map.next_value()?);
                }
                "is_directory_restricted" => {
                    if field_is_directory_restricted.is_some() {
                        return Err(de::Error::duplicate_field("is_directory_restricted"));
                    }
                    field_is_directory_restricted = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_MEMBER_PROFILE_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamMemberProfile {
            team_member_id: field_team_member_id.ok_or_else(|| de::Error::missing_field("team_member_id"))?,
            email: field_email.ok_or_else(|| de::Error::missing_field("email"))?,
            email_verified: field_email_verified.ok_or_else(|| de::Error::missing_field("email_verified"))?,
            status: field_status.ok_or_else(|| de::Error::missing_field("status"))?,
            name: field_name.ok_or_else(|| de::Error::missing_field("name"))?,
            membership_type: field_membership_type.ok_or_else(|| de::Error::missing_field("membership_type"))?,
            groups: field_groups.ok_or_else(|| de::Error::missing_field("groups"))?,
            member_folder_id: field_member_folder_id.ok_or_else(|| de::Error::missing_field("member_folder_id"))?,
            external_id: field_external_id,
            account_id: field_account_id,
            joined_on: field_joined_on,
            persistent_id: field_persistent_id,
            is_directory_restricted: field_is_directory_restricted,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("team_member_id", &self.team_member_id)?;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("email_verified", &self.email_verified)?;
        s.serialize_field("status", &self.status)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("membership_type", &self.membership_type)?;
        s.serialize_field("groups", &self.groups)?;
        s.serialize_field("member_folder_id", &self.member_folder_id)?;
        s.serialize_field("external_id", &self.external_id)?;
        s.serialize_field("account_id", &self.account_id)?;
        s.serialize_field("joined_on", &self.joined_on)?;
        s.serialize_field("persistent_id", &self.persistent_id)?;
        s.serialize_field("is_directory_restricted", &self.is_directory_restricted)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMemberProfile {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamMemberProfile;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMemberProfile struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamMemberProfile::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamMemberProfile", TEAM_MEMBER_PROFILE_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMemberProfile {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamMemberProfile", 13)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The user's status as a member of a specific team.
#[derive(Debug)]
pub enum TeamMemberStatus {
    /// User has successfully joined the team.
    Active,
    /// User has been invited to a team, but has not joined the team yet.
    Invited,
    /// User is no longer a member of the team, but the account can be un-suspended, re-establishing
    /// the user as a team member.
    Suspended,
    /// User is no longer a member of the team. Removed users are only listed when include_removed
    /// is true in members/list.
    Removed(RemovedStatus),
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMemberStatus {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamMemberStatus;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMemberStatus structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "active" => Ok(TeamMemberStatus::Active),
                    "invited" => Ok(TeamMemberStatus::Invited),
                    "suspended" => Ok(TeamMemberStatus::Suspended),
                    "removed" => Ok(TeamMemberStatus::Removed(RemovedStatus::internal_deserialize(map)?)),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["active",
                                    "invited",
                                    "suspended",
                                    "removed"];
        deserializer.deserialize_struct("TeamMemberStatus", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMemberStatus {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamMemberStatus::Active => {
                // unit
                let mut s = serializer.serialize_struct("TeamMemberStatus", 1)?;
                s.serialize_field(".tag", "active")?;
                s.end()
            }
            TeamMemberStatus::Invited => {
                // unit
                let mut s = serializer.serialize_struct("TeamMemberStatus", 1)?;
                s.serialize_field(".tag", "invited")?;
                s.end()
            }
            TeamMemberStatus::Suspended => {
                // unit
                let mut s = serializer.serialize_struct("TeamMemberStatus", 1)?;
                s.serialize_field(".tag", "suspended")?;
                s.end()
            }
            TeamMemberStatus::Removed(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("TeamMemberStatus", 2)?;
                s.serialize_field(".tag", "removed")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub enum TeamMembershipType {
    /// User uses a license and has full access to team resources like the shared quota.
    Full,
    /// User does not have access to the shared quota and team admins have restricted administrative
    /// control.
    Limited,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamMembershipType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamMembershipType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamMembershipType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "full" => Ok(TeamMembershipType::Full),
                    "limited" => Ok(TeamMembershipType::Limited),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["full",
                                    "limited"];
        deserializer.deserialize_struct("TeamMembershipType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamMembershipType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamMembershipType::Full => {
                // unit
                let mut s = serializer.serialize_struct("TeamMembershipType", 1)?;
                s.serialize_field(".tag", "full")?;
                s.end()
            }
            TeamMembershipType::Limited => {
                // unit
                let mut s = serializer.serialize_struct("TeamMembershipType", 1)?;
                s.serialize_field(".tag", "limited")?;
                s.end()
            }
        }
    }
}

#[derive(Debug)]
pub struct TeamNamespacesListArg {
    /// Specifying a value here has no effect.
    pub limit: u32,
}

impl Default for TeamNamespacesListArg {
    fn default() -> Self {
        TeamNamespacesListArg {
            limit: 1000,
        }
    }
}

const TEAM_NAMESPACES_LIST_ARG_FIELDS: &[&str] = &["limit"];
impl TeamNamespacesListArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<TeamNamespacesListArg, V::Error> {
        use serde::de;
        let mut field_limit = None;
        while let Some(key) = map.next_key()? {
            match key {
                "limit" => {
                    if field_limit.is_some() {
                        return Err(de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_NAMESPACES_LIST_ARG_FIELDS))
            }
        }
        let result = TeamNamespacesListArg {
            limit: field_limit.unwrap_or(1000),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("limit", &self.limit)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamNamespacesListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamNamespacesListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamNamespacesListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamNamespacesListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamNamespacesListArg", TEAM_NAMESPACES_LIST_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamNamespacesListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamNamespacesListArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub struct TeamNamespacesListContinueArg {
    /// Indicates from what point to get the next set of team-accessible namespaces.
    pub cursor: String,
}

impl TeamNamespacesListContinueArg {
    pub fn new(cursor: String) -> Self {
        TeamNamespacesListContinueArg {
            cursor,
        }
    }

}

const TEAM_NAMESPACES_LIST_CONTINUE_ARG_FIELDS: &[&str] = &["cursor"];
impl TeamNamespacesListContinueArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamNamespacesListContinueArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamNamespacesListContinueArg>, V::Error> {
        use serde::de;
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_NAMESPACES_LIST_CONTINUE_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamNamespacesListContinueArg {
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamNamespacesListContinueArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamNamespacesListContinueArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamNamespacesListContinueArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamNamespacesListContinueArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamNamespacesListContinueArg", TEAM_NAMESPACES_LIST_CONTINUE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamNamespacesListContinueArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamNamespacesListContinueArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug)]
pub enum TeamNamespacesListContinueError {
    /// The cursor is invalid.
    InvalidCursor,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TeamNamespacesListContinueError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TeamNamespacesListContinueError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamNamespacesListContinueError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "invalid_cursor" => Ok(TeamNamespacesListContinueError::InvalidCursor),
                    _ => Ok(TeamNamespacesListContinueError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["invalid_cursor",
                                    "other"];
        deserializer.deserialize_struct("TeamNamespacesListContinueError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TeamNamespacesListContinueError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TeamNamespacesListContinueError::InvalidCursor => {
                // unit
                let mut s = serializer.serialize_struct("TeamNamespacesListContinueError", 1)?;
                s.serialize_field(".tag", "invalid_cursor")?;
                s.end()
            }
            TeamNamespacesListContinueError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TeamNamespacesListContinueError {
    fn description(&self) -> &str {
        "TeamNamespacesListContinueError"
    }
}

impl ::std::fmt::Display for TeamNamespacesListContinueError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Result for [`namespaces_list()`](namespaces_list).
#[derive(Debug)]
pub struct TeamNamespacesListResult {
    /// List of all namespaces the team can access.
    pub namespaces: Vec<NamespaceMetadata>,
    /// Pass the cursor into [`namespaces_list_continue()`](namespaces_list_continue) to obtain
    /// additional namespaces. Note that duplicate namespaces may be returned.
    pub cursor: String,
    /// Is true if there are additional namespaces that have not been returned yet.
    pub has_more: bool,
}

impl TeamNamespacesListResult {
    pub fn new(namespaces: Vec<NamespaceMetadata>, cursor: String, has_more: bool) -> Self {
        TeamNamespacesListResult {
            namespaces,
            cursor,
            has_more,
        }
    }

}

const TEAM_NAMESPACES_LIST_RESULT_FIELDS: &[&str] = &["namespaces",
                                                      "cursor",
                                                      "has_more"];
impl TeamNamespacesListResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TeamNamespacesListResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TeamNamespacesListResult>, V::Error> {
        use serde::de;
        let mut field_namespaces = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "namespaces" => {
                    if field_namespaces.is_some() {
                        return Err(de::Error::duplicate_field("namespaces"));
                    }
                    field_namespaces = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TEAM_NAMESPACES_LIST_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TeamNamespacesListResult {
            namespaces: field_namespaces.ok_or_else(|| de::Error::missing_field("namespaces"))?,
            cursor: field_cursor.ok_or_else(|| de::Error::missing_field("cursor"))?,
            has_more: field_has_more.ok_or_else(|| de::Error::missing_field("has_more"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("namespaces", &self.namespaces)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TeamNamespacesListResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TeamNamespacesListResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TeamNamespacesListResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TeamNamespacesListResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TeamNamespacesListResult", TEAM_NAMESPACES_LIST_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TeamNamespacesListResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TeamNamespacesListResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Error returned by [`token_get_authenticated_admin()`](token_get_authenticated_admin).
#[derive(Debug)]
pub enum TokenGetAuthenticatedAdminError {
    /// The current token is not associated with a team admin, because mappings were not recorded
    /// when the token was created. Consider re-authorizing a new access token to record its
    /// authenticating admin.
    MappingNotFound,
    /// Either the team admin that authorized this token is no longer an active member of the team
    /// or no longer a team admin.
    AdminNotActive,
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TokenGetAuthenticatedAdminError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TokenGetAuthenticatedAdminError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TokenGetAuthenticatedAdminError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "mapping_not_found" => Ok(TokenGetAuthenticatedAdminError::MappingNotFound),
                    "admin_not_active" => Ok(TokenGetAuthenticatedAdminError::AdminNotActive),
                    _ => Ok(TokenGetAuthenticatedAdminError::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["mapping_not_found",
                                    "admin_not_active",
                                    "other"];
        deserializer.deserialize_struct("TokenGetAuthenticatedAdminError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TokenGetAuthenticatedAdminError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TokenGetAuthenticatedAdminError::MappingNotFound => {
                // unit
                let mut s = serializer.serialize_struct("TokenGetAuthenticatedAdminError", 1)?;
                s.serialize_field(".tag", "mapping_not_found")?;
                s.end()
            }
            TokenGetAuthenticatedAdminError::AdminNotActive => {
                // unit
                let mut s = serializer.serialize_struct("TokenGetAuthenticatedAdminError", 1)?;
                s.serialize_field(".tag", "admin_not_active")?;
                s.end()
            }
            TokenGetAuthenticatedAdminError::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

impl ::std::error::Error for TokenGetAuthenticatedAdminError {
    fn description(&self) -> &str {
        "TokenGetAuthenticatedAdminError"
    }
}

impl ::std::fmt::Display for TokenGetAuthenticatedAdminError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Results for [`token_get_authenticated_admin()`](token_get_authenticated_admin).
#[derive(Debug)]
pub struct TokenGetAuthenticatedAdminResult {
    /// The admin who authorized the token.
    pub admin_profile: TeamMemberProfile,
}

impl TokenGetAuthenticatedAdminResult {
    pub fn new(admin_profile: TeamMemberProfile) -> Self {
        TokenGetAuthenticatedAdminResult {
            admin_profile,
        }
    }

}

const TOKEN_GET_AUTHENTICATED_ADMIN_RESULT_FIELDS: &[&str] = &["admin_profile"];
impl TokenGetAuthenticatedAdminResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TokenGetAuthenticatedAdminResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TokenGetAuthenticatedAdminResult>, V::Error> {
        use serde::de;
        let mut field_admin_profile = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "admin_profile" => {
                    if field_admin_profile.is_some() {
                        return Err(de::Error::duplicate_field("admin_profile"));
                    }
                    field_admin_profile = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, TOKEN_GET_AUTHENTICATED_ADMIN_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TokenGetAuthenticatedAdminResult {
            admin_profile: field_admin_profile.ok_or_else(|| de::Error::missing_field("admin_profile"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("admin_profile", &self.admin_profile)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TokenGetAuthenticatedAdminResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TokenGetAuthenticatedAdminResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a TokenGetAuthenticatedAdminResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TokenGetAuthenticatedAdminResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TokenGetAuthenticatedAdminResult", TOKEN_GET_AUTHENTICATED_ADMIN_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TokenGetAuthenticatedAdminResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TokenGetAuthenticatedAdminResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// The value for [`Feature::UploadApiRateLimit`](Feature::UploadApiRateLimit).
#[derive(Debug)]
pub enum UploadApiRateLimitValue {
    /// This team has unlimited upload API quota. So far both server version account and legacy
    /// account type have unlimited monthly upload api quota.
    Unlimited,
    /// The number of upload API calls allowed per month.
    Limit(u32),
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for UploadApiRateLimitValue {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UploadApiRateLimitValue;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UploadApiRateLimitValue structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "unlimited" => Ok(UploadApiRateLimitValue::Unlimited),
                    "limit" => {
                        match map.next_key()? {
                            Some("limit") => Ok(UploadApiRateLimitValue::Limit(map.next_value()?)),
                            None => Err(de::Error::missing_field("limit")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Ok(UploadApiRateLimitValue::Other)
                }
            }
        }
        const VARIANTS: &[&str] = &["unlimited",
                                    "limit",
                                    "other"];
        deserializer.deserialize_struct("UploadApiRateLimitValue", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UploadApiRateLimitValue {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UploadApiRateLimitValue::Unlimited => {
                // unit
                let mut s = serializer.serialize_struct("UploadApiRateLimitValue", 1)?;
                s.serialize_field(".tag", "unlimited")?;
                s.end()
            }
            UploadApiRateLimitValue::Limit(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("UploadApiRateLimitValue", 2)?;
                s.serialize_field(".tag", "limit")?;
                s.serialize_field("limit", x)?;
                s.end()
            }
            UploadApiRateLimitValue::Other => Err(::serde::ser::Error::custom("cannot serialize 'Other' variant"))
        }
    }
}

/// User and their required custom quota in GB (1 TB = 1024 GB).
#[derive(Debug)]
pub struct UserCustomQuotaArg {
    pub user: UserSelectorArg,
    pub quota_gb: UserQuota,
}

impl UserCustomQuotaArg {
    pub fn new(user: UserSelectorArg, quota_gb: UserQuota) -> Self {
        UserCustomQuotaArg {
            user,
            quota_gb,
        }
    }

}

const USER_CUSTOM_QUOTA_ARG_FIELDS: &[&str] = &["user",
                                                "quota_gb"];
impl UserCustomQuotaArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<UserCustomQuotaArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<UserCustomQuotaArg>, V::Error> {
        use serde::de;
        let mut field_user = None;
        let mut field_quota_gb = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "quota_gb" => {
                    if field_quota_gb.is_some() {
                        return Err(de::Error::duplicate_field("quota_gb"));
                    }
                    field_quota_gb = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_CUSTOM_QUOTA_ARG_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = UserCustomQuotaArg {
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
            quota_gb: field_quota_gb.ok_or_else(|| de::Error::missing_field("quota_gb"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("quota_gb", &self.quota_gb)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserCustomQuotaArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserCustomQuotaArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserCustomQuotaArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserCustomQuotaArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserCustomQuotaArg", USER_CUSTOM_QUOTA_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserCustomQuotaArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserCustomQuotaArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// User and their custom quota in GB (1 TB = 1024 GB).  No quota returns if the user has no custom
/// quota set.
#[derive(Debug)]
pub struct UserCustomQuotaResult {
    pub user: UserSelectorArg,
    pub quota_gb: Option<UserQuota>,
}

impl UserCustomQuotaResult {
    pub fn new(user: UserSelectorArg) -> Self {
        UserCustomQuotaResult {
            user,
            quota_gb: None,
        }
    }

    pub fn with_quota_gb(mut self, value: Option<UserQuota>) -> Self {
        self.quota_gb = value;
        self
    }

}

const USER_CUSTOM_QUOTA_RESULT_FIELDS: &[&str] = &["user",
                                                   "quota_gb"];
impl UserCustomQuotaResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<UserCustomQuotaResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<UserCustomQuotaResult>, V::Error> {
        use serde::de;
        let mut field_user = None;
        let mut field_quota_gb = None;
        let mut nothing = true;
        while let Some(key) = map.next_key()? {
            nothing = false;
            match key {
                "user" => {
                    if field_user.is_some() {
                        return Err(de::Error::duplicate_field("user"));
                    }
                    field_user = Some(map.next_value()?);
                }
                "quota_gb" => {
                    if field_quota_gb.is_some() {
                        return Err(de::Error::duplicate_field("quota_gb"));
                    }
                    field_quota_gb = Some(map.next_value()?);
                }
                _ => return Err(de::Error::unknown_field(key, USER_CUSTOM_QUOTA_RESULT_FIELDS))
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = UserCustomQuotaResult {
            user: field_user.ok_or_else(|| de::Error::missing_field("user"))?,
            quota_gb: field_quota_gb,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user", &self.user)?;
        s.serialize_field("quota_gb", &self.quota_gb)
    }
}

impl<'de> ::serde::de::Deserialize<'de> for UserCustomQuotaResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = UserCustomQuotaResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserCustomQuotaResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                UserCustomQuotaResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("UserCustomQuotaResult", USER_CUSTOM_QUOTA_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for UserCustomQuotaResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("UserCustomQuotaResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Argument for selecting a single user, either by team_member_id, external_id or email.
#[derive(Debug)]
pub enum UserSelectorArg {
    TeamMemberId(super::team_common::TeamMemberId),
    ExternalId(super::team_common::MemberExternalId),
    Email(super::common::EmailAddress),
}

impl<'de> ::serde::de::Deserialize<'de> for UserSelectorArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UserSelectorArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserSelectorArg structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_member_id" => {
                        match map.next_key()? {
                            Some("team_member_id") => Ok(UserSelectorArg::TeamMemberId(map.next_value()?)),
                            None => Err(de::Error::missing_field("team_member_id")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "external_id" => {
                        match map.next_key()? {
                            Some("external_id") => Ok(UserSelectorArg::ExternalId(map.next_value()?)),
                            None => Err(de::Error::missing_field("external_id")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "email" => {
                        match map.next_key()? {
                            Some("email") => Ok(UserSelectorArg::Email(map.next_value()?)),
                            None => Err(de::Error::missing_field("email")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["team_member_id",
                                    "external_id",
                                    "email"];
        deserializer.deserialize_struct("UserSelectorArg", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UserSelectorArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UserSelectorArg::TeamMemberId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("UserSelectorArg", 2)?;
                s.serialize_field(".tag", "team_member_id")?;
                s.serialize_field("team_member_id", x)?;
                s.end()
            }
            UserSelectorArg::ExternalId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("UserSelectorArg", 2)?;
                s.serialize_field(".tag", "external_id")?;
                s.serialize_field("external_id", x)?;
                s.end()
            }
            UserSelectorArg::Email(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("UserSelectorArg", 2)?;
                s.serialize_field(".tag", "email")?;
                s.serialize_field("email", x)?;
                s.end()
            }
        }
    }
}

/// Error that can be returned whenever a struct derived from [`UserSelectorArg`](UserSelectorArg)
/// is used.
#[derive(Debug)]
pub enum UserSelectorError {
    /// No matching user found. The provided team_member_id, email, or external_id does not exist on
    /// this team.
    UserNotFound,
}

impl<'de> ::serde::de::Deserialize<'de> for UserSelectorError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UserSelectorError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UserSelectorError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "user_not_found" => Ok(UserSelectorError::UserNotFound),
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["user_not_found"];
        deserializer.deserialize_struct("UserSelectorError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UserSelectorError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UserSelectorError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("UserSelectorError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
        }
    }
}

impl ::std::error::Error for UserSelectorError {
    fn description(&self) -> &str {
        "UserSelectorError"
    }
}

impl ::std::fmt::Display for UserSelectorError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

/// Argument for selecting a list of users, either by team_member_ids, external_ids or emails.
#[derive(Debug)]
pub enum UsersSelectorArg {
    /// List of member IDs.
    TeamMemberIds(Vec<super::team_common::TeamMemberId>),
    /// List of external user IDs.
    ExternalIds(Vec<super::team_common::MemberExternalId>),
    /// List of email addresses.
    Emails(Vec<super::common::EmailAddress>),
}

impl<'de> ::serde::de::Deserialize<'de> for UsersSelectorArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = UsersSelectorArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.write_str("a UsersSelectorArg structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag"))
                };
                match tag {
                    "team_member_ids" => {
                        match map.next_key()? {
                            Some("team_member_ids") => Ok(UsersSelectorArg::TeamMemberIds(map.next_value()?)),
                            None => Err(de::Error::missing_field("team_member_ids")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "external_ids" => {
                        match map.next_key()? {
                            Some("external_ids") => Ok(UsersSelectorArg::ExternalIds(map.next_value()?)),
                            None => Err(de::Error::missing_field("external_ids")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    "emails" => {
                        match map.next_key()? {
                            Some("emails") => Ok(UsersSelectorArg::Emails(map.next_value()?)),
                            None => Err(de::Error::missing_field("emails")),
                            _ => Err(de::Error::unknown_field(tag, VARIANTS))
                        }
                    }
                    _ => Err(de::Error::unknown_variant(tag, VARIANTS))
                }
            }
        }
        const VARIANTS: &[&str] = &["team_member_ids",
                                    "external_ids",
                                    "emails"];
        deserializer.deserialize_struct("UsersSelectorArg", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for UsersSelectorArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            UsersSelectorArg::TeamMemberIds(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("UsersSelectorArg", 2)?;
                s.serialize_field(".tag", "team_member_ids")?;
                s.serialize_field("team_member_ids", x)?;
                s.end()
            }
            UsersSelectorArg::ExternalIds(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("UsersSelectorArg", 2)?;
                s.serialize_field(".tag", "external_ids")?;
                s.serialize_field("external_ids", x)?;
                s.end()
            }
            UsersSelectorArg::Emails(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("UsersSelectorArg", 2)?;
                s.serialize_field(".tag", "emails")?;
                s.serialize_field("emails", x)?;
                s.end()
            }
        }
    }
}

