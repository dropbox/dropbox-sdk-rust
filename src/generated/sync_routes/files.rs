// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::result_large_err,
    clippy::doc_markdown,
)]

#[allow(unused_imports)]
pub use crate::generated::types::files::*;

/// Returns the metadata for a file or folder. This is an alpha endpoint compatible with the
/// properties API. Note: Metadata for the root folder is unsupported.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
#[deprecated(note = "replaced by get_metadata")]
pub fn alpha_get_metadata(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &AlphaGetMetadataArg,
) -> Result<Metadata, crate::Error<AlphaGetMetadataError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/alpha/get_metadata",
            arg,
            None)
    )
}

/// Create a new file with the contents provided in the request. Note that the behavior of this
/// alpha endpoint is unstable and subject to change. Do not use this to upload a file larger than
/// 150 MB. Instead, create an upload session with [`upload_session_start()`](upload_session_start).
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
#[deprecated(note = "replaced by upload")]
pub fn alpha_upload(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UploadArg,
    body: &[u8],
) -> Result<FileMetadata, crate::Error<UploadError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Upload,
            "files/alpha/upload",
            arg,
            Some(crate::client_helpers::Body::from(body)))
    )
}

/// Copy a file or folder to a different location in the user's Dropbox. If the source path is a
/// folder all its contents will be copied.
pub fn copy_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &RelocationArg,
) -> Result<RelocationResult, crate::Error<RelocationError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/copy_v2",
            arg,
            None)
    )
}

/// Copy a file or folder to a different location in the user's Dropbox. If the source path is a
/// folder all its contents will be copied.
#[deprecated(note = "replaced by copy_v2")]
pub fn copy(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &RelocationArg,
) -> Result<Metadata, crate::Error<RelocationError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/copy",
            arg,
            None)
    )
}

/// Copy multiple files or folders to different locations at once in the user's Dropbox. This route
/// will replace [`copy_batch()`](copy_batch). The main difference is this route will return status
/// for each entry, while [`copy_batch()`](copy_batch) raises failure if any entry fails. This route
/// will either finish synchronously, or return a job ID and do the async copy job in background.
/// Please use [`copy_batch_check_v2()`](copy_batch_check_v2) to check the job status.
pub fn copy_batch_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &CopyBatchArg,
) -> Result<RelocationBatchV2Launch, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/copy_batch_v2",
            arg,
            None)
    )
}

/// Copy multiple files or folders to different locations at once in the user's Dropbox. This route
/// will return job ID immediately and do the async copy job in background. Please use
/// [`copy_batch_check()`](copy_batch_check) to check the job status.
#[deprecated(note = "replaced by copy_batch_v2")]
pub fn copy_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &RelocationBatchArg,
) -> Result<RelocationBatchLaunch, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/copy_batch",
            arg,
            None)
    )
}

/// Returns the status of an asynchronous job for [`copy_batch_v2()`](copy_batch_v2). It returns
/// list of results for each entry.
pub fn copy_batch_check_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::dbx_async::PollArg,
) -> Result<RelocationBatchV2JobStatus, crate::Error<crate::types::dbx_async::PollError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/copy_batch/check_v2",
            arg,
            None)
    )
}

/// Returns the status of an asynchronous job for [`copy_batch()`](copy_batch). If success, it
/// returns list of results for each entry.
#[deprecated(note = "replaced by copy_batch_check_v2")]
pub fn copy_batch_check(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::dbx_async::PollArg,
) -> Result<RelocationBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/copy_batch/check",
            arg,
            None)
    )
}

/// Get a copy reference to a file or folder. This reference string can be used to save that file or
/// folder to another user's Dropbox by passing it to
/// [`copy_reference_save()`](copy_reference_save).
pub fn copy_reference_get(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &GetCopyReferenceArg,
) -> Result<GetCopyReferenceResult, crate::Error<GetCopyReferenceError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/copy_reference/get",
            arg,
            None)
    )
}

/// Save a copy reference returned by [`copy_reference_get()`](copy_reference_get) to the user's
/// Dropbox.
pub fn copy_reference_save(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &SaveCopyReferenceArg,
) -> Result<SaveCopyReferenceResult, crate::Error<SaveCopyReferenceError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/copy_reference/save",
            arg,
            None)
    )
}

/// Create a folder at a given path.
pub fn create_folder_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &CreateFolderArg,
) -> Result<CreateFolderResult, crate::Error<CreateFolderError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/create_folder_v2",
            arg,
            None)
    )
}

/// Create a folder at a given path.
#[deprecated(note = "replaced by create_folder_v2")]
pub fn create_folder(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &CreateFolderArg,
) -> Result<FolderMetadata, crate::Error<CreateFolderError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/create_folder",
            arg,
            None)
    )
}

/// Create multiple folders at once. This route is asynchronous for large batches, which returns a
/// job ID immediately and runs the create folder batch asynchronously. Otherwise, creates the
/// folders and returns the result synchronously for smaller inputs. You can force asynchronous
/// behaviour by using the [`CreateFolderBatchArg::force_async`](CreateFolderBatchArg) flag.  Use
/// [`create_folder_batch_check()`](create_folder_batch_check) to check the job status.
pub fn create_folder_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &CreateFolderBatchArg,
) -> Result<CreateFolderBatchLaunch, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/create_folder_batch",
            arg,
            None)
    )
}

/// Returns the status of an asynchronous job for [`create_folder_batch()`](create_folder_batch). If
/// success, it returns list of result for each entry.
pub fn create_folder_batch_check(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::dbx_async::PollArg,
) -> Result<CreateFolderBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/create_folder_batch/check",
            arg,
            None)
    )
}

/// Delete the file or folder at a given path. If the path is a folder, all its contents will be
/// deleted too. A successful response indicates that the file or folder was deleted. The returned
/// metadata will be the corresponding [`FileMetadata`](FileMetadata) or
/// [`FolderMetadata`](FolderMetadata) for the item at time of deletion, and not a
/// [`DeletedMetadata`](DeletedMetadata) object.
pub fn delete_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &DeleteArg,
) -> Result<DeleteResult, crate::Error<DeleteError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/delete_v2",
            arg,
            None)
    )
}

/// Delete the file or folder at a given path. If the path is a folder, all its contents will be
/// deleted too. A successful response indicates that the file or folder was deleted. The returned
/// metadata will be the corresponding [`FileMetadata`](FileMetadata) or
/// [`FolderMetadata`](FolderMetadata) for the item at time of deletion, and not a
/// [`DeletedMetadata`](DeletedMetadata) object.
#[deprecated(note = "replaced by delete_v2")]
pub fn delete(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &DeleteArg,
) -> Result<Metadata, crate::Error<DeleteError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/delete",
            arg,
            None)
    )
}

/// Delete multiple files/folders at once. This route is asynchronous, which returns a job ID
/// immediately and runs the delete batch asynchronously. Use
/// [`delete_batch_check()`](delete_batch_check) to check the job status.
pub fn delete_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &DeleteBatchArg,
) -> Result<DeleteBatchLaunch, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/delete_batch",
            arg,
            None)
    )
}

/// Returns the status of an asynchronous job for [`delete_batch()`](delete_batch). If success, it
/// returns list of result for each entry.
pub fn delete_batch_check(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::dbx_async::PollArg,
) -> Result<DeleteBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/delete_batch/check",
            arg,
            None)
    )
}

/// Download a file from a user's Dropbox.
pub fn download(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &DownloadArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> Result<crate::client_trait::HttpRequestResult<FileMetadata>, crate::Error<DownloadError>> {
    crate::client_helpers::unwrap_async_body(
        crate::client_helpers::request_with_body(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Download,
            "files/download",
            arg,
            None,
            range_start,
            range_end),
        client,
    )
}

/// Download a folder from the user's Dropbox, as a zip file. The folder must be less than 20 GB in
/// size and any single file within must be less than 4 GB in size. The resulting zip must have
/// fewer than 10,000 total file and folder entries, including the top level folder. The input
/// cannot be a single file. Note: this endpoint does not support HTTP range requests.
pub fn download_zip(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &DownloadZipArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> Result<crate::client_trait::HttpRequestResult<DownloadZipResult>, crate::Error<DownloadZipError>> {
    crate::client_helpers::unwrap_async_body(
        crate::client_helpers::request_with_body(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Download,
            "files/download_zip",
            arg,
            None,
            range_start,
            range_end),
        client,
    )
}

/// Export a file from a user's Dropbox. This route only supports exporting files that cannot be
/// downloaded directly  and whose [`ExportResult::file_metadata`](ExportResult) has
/// [`ExportInfo::export_as`](ExportInfo) populated.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn export(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &ExportArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> Result<crate::client_trait::HttpRequestResult<ExportResult>, crate::Error<ExportError>> {
    crate::client_helpers::unwrap_async_body(
        crate::client_helpers::request_with_body(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Download,
            "files/export",
            arg,
            None,
            range_start,
            range_end),
        client,
    )
}

/// Return the lock metadata for the given list of paths.
pub fn get_file_lock_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &LockFileBatchArg,
) -> Result<LockFileBatchResult, crate::Error<LockFileError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/get_file_lock_batch",
            arg,
            None)
    )
}

/// Returns the metadata for a file or folder. Note: Metadata for the root folder is unsupported.
pub fn get_metadata(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &GetMetadataArg,
) -> Result<Metadata, crate::Error<GetMetadataError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/get_metadata",
            arg,
            None)
    )
}

/// Get a preview for a file. Currently, PDF previews are generated for files with the following
/// extensions: .ai, .doc, .docm, .docx, .eps, .gdoc, .gslides, .odp, .odt, .pps, .ppsm, .ppsx,
/// .ppt, .pptm, .pptx, .rtf. HTML previews are generated for files with the following extensions:
/// .csv, .ods, .xls, .xlsm, .gsheet, .xlsx. Other formats will return an unsupported extension
/// error.
pub fn get_preview(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &PreviewArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> Result<crate::client_trait::HttpRequestResult<FileMetadata>, crate::Error<PreviewError>> {
    crate::client_helpers::unwrap_async_body(
        crate::client_helpers::request_with_body(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Download,
            "files/get_preview",
            arg,
            None,
            range_start,
            range_end),
        client,
    )
}

/// Get a temporary link to stream content of a file. This link will expire in four hours and
/// afterwards you will get 410 Gone. This URL should not be used to display content directly in the
/// browser. The Content-Type of the link is determined automatically by the file's mime type.
pub fn get_temporary_link(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &GetTemporaryLinkArg,
) -> Result<GetTemporaryLinkResult, crate::Error<GetTemporaryLinkError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/get_temporary_link",
            arg,
            None)
    )
}

/// Get a one-time use temporary upload link to upload a file to a Dropbox location.
///
/// This endpoint acts as a delayed [`upload()`](upload). The returned temporary upload link may be
/// used to make a POST request with the data to be uploaded. The upload will then be perfomed with
/// the [`CommitInfo`](CommitInfo) previously provided to
/// [`get_temporary_upload_link()`](get_temporary_upload_link) but evaluated only upon consumption.
/// Hence, errors stemming from invalid [`CommitInfo`](CommitInfo) with respect to the state of the
/// user's Dropbox will only be communicated at consumption time. Additionally, these errors are
/// surfaced as generic HTTP 409 Conflict responses, potentially hiding issue details. The maximum
/// temporary upload link duration is 4 hours. Upon consumption or expiration, a new link will have
/// to be generated. Multiple links may exist for a specific upload path at any given time.
///
/// The POST request on the temporary upload link must have its Content-Type set to
/// "application/octet-stream".
///
/// Example temporary upload link consumption request:
///
/// curl -X POST https://content.dropboxapi.com/apitul/1/bNi2uIYF51cVBND --header "Content-Type:
/// application/octet-stream" --data-binary @local_file.txt
///
/// A successful temporary upload link consumption request returns the content hash of the uploaded
/// data in JSON format.
///
/// Example successful temporary upload link consumption response: {"content-hash":
/// "599d71033d700ac892a0e48fa61b125d2f5994"}
///
/// An unsuccessful temporary upload link consumption request returns any of the following status
/// codes:
///
/// HTTP 400 Bad Request: Content-Type is not one of application/octet-stream and text/plain or
/// request is invalid. HTTP 409 Conflict: The temporary upload link does not exist or is currently
/// unavailable, the upload failed, or another error happened. HTTP 410 Gone: The temporary upload
/// link is expired or consumed.
///
/// Example unsuccessful temporary upload link consumption response: Temporary upload link has been
/// recently consumed.
pub fn get_temporary_upload_link(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &GetTemporaryUploadLinkArg,
) -> Result<GetTemporaryUploadLinkResult, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/get_temporary_upload_link",
            arg,
            None)
    )
}

/// Get a thumbnail for an image. This method currently supports files with the following file
/// extensions: jpg, jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB
/// in size won't be converted to a thumbnail.
pub fn get_thumbnail(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &ThumbnailArg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> Result<crate::client_trait::HttpRequestResult<FileMetadata>, crate::Error<ThumbnailError>> {
    crate::client_helpers::unwrap_async_body(
        crate::client_helpers::request_with_body(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Download,
            "files/get_thumbnail",
            arg,
            None,
            range_start,
            range_end),
        client,
    )
}

/// Get a thumbnail for an image. This method currently supports files with the following file
/// extensions: jpg, jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB
/// in size won't be converted to a thumbnail.
pub fn get_thumbnail_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &ThumbnailV2Arg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> Result<crate::client_trait::HttpRequestResult<PreviewResult>, crate::Error<ThumbnailV2Error>> {
    crate::client_helpers::unwrap_async_body(
        crate::client_helpers::request_with_body(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Download,
            "files/get_thumbnail_v2",
            arg,
            None,
            range_start,
            range_end),
        client,
    )
}

/// Get a thumbnail for an image. This method currently supports files with the following file
/// extensions: jpg, jpeg, png, tiff, tif, gif, webp, ppm and bmp. Photos that are larger than 20MB
/// in size won't be converted to a thumbnail.
pub fn get_thumbnail_v2_app_auth(
    client: &impl crate::client_trait::AppAuthClient,
    arg: &ThumbnailV2Arg,
    range_start: Option<u64>,
    range_end: Option<u64>,
) -> Result<crate::client_trait::HttpRequestResult<PreviewResult>, crate::Error<ThumbnailV2Error>> {
    crate::client_helpers::unwrap_async_body(
        crate::client_helpers::request_with_body(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Download,
            "files/get_thumbnail_v2",
            arg,
            None,
            range_start,
            range_end),
        client,
    )
}

/// Get thumbnails for a list of images. We allow up to 25 thumbnails in a single batch. This method
/// currently supports files with the following file extensions: jpg, jpeg, png, tiff, tif, gif,
/// webp, ppm and bmp. Photos that are larger than 20MB in size won't be converted to a thumbnail.
pub fn get_thumbnail_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &GetThumbnailBatchArg,
) -> Result<GetThumbnailBatchResult, crate::Error<GetThumbnailBatchError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Rpc,
            "files/get_thumbnail_batch",
            arg,
            None)
    )
}

/// Starts returning the contents of a folder. If the result's
/// [`ListFolderResult::has_more`](ListFolderResult) field is `true`, call
/// [`list_folder_continue()`](list_folder_continue) with the returned
/// [`ListFolderResult::cursor`](ListFolderResult) to retrieve more entries. If you're using
/// [`ListFolderArg::recursive`](ListFolderArg) set to `true` to keep a local cache of the contents
/// of a Dropbox account, iterate through each entry in order and process them as follows to keep
/// your local state in sync: For each [`FileMetadata`](FileMetadata), store the new entry at the
/// given path in your local state. If the required parent folders don't exist yet, create them. If
/// there's already something else at the given path, replace it and remove all its children. For
/// each [`FolderMetadata`](FolderMetadata), store the new entry at the given path in your local
/// state. If the required parent folders don't exist yet, create them. If there's already something
/// else at the given path, replace it but leave the children as they are. Check the new entry's
/// [`FolderSharingInfo::read_only`](FolderSharingInfo) and set all its children's read-only
/// statuses to match. For each [`DeletedMetadata`](DeletedMetadata), if your local state has
/// something at the given path, remove it and all its children. If there's nothing at the given
/// path, ignore this entry. Note: [`auth::RateLimitError`](crate::types::auth::RateLimitError) may
/// be returned if multiple [`list_folder()`](list_folder) or
/// [`list_folder_continue()`](list_folder_continue) calls with same parameters are made
/// simultaneously by same API app for same user. If your app implements retry logic, please hold
/// off the retry until the previous request finishes.
pub fn list_folder(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &ListFolderArg,
) -> Result<ListFolderResult, crate::Error<ListFolderError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/list_folder",
            arg,
            None)
    )
}

/// Starts returning the contents of a folder. If the result's
/// [`ListFolderResult::has_more`](ListFolderResult) field is `true`, call
/// [`list_folder_continue()`](list_folder_continue) with the returned
/// [`ListFolderResult::cursor`](ListFolderResult) to retrieve more entries. If you're using
/// [`ListFolderArg::recursive`](ListFolderArg) set to `true` to keep a local cache of the contents
/// of a Dropbox account, iterate through each entry in order and process them as follows to keep
/// your local state in sync: For each [`FileMetadata`](FileMetadata), store the new entry at the
/// given path in your local state. If the required parent folders don't exist yet, create them. If
/// there's already something else at the given path, replace it and remove all its children. For
/// each [`FolderMetadata`](FolderMetadata), store the new entry at the given path in your local
/// state. If the required parent folders don't exist yet, create them. If there's already something
/// else at the given path, replace it but leave the children as they are. Check the new entry's
/// [`FolderSharingInfo::read_only`](FolderSharingInfo) and set all its children's read-only
/// statuses to match. For each [`DeletedMetadata`](DeletedMetadata), if your local state has
/// something at the given path, remove it and all its children. If there's nothing at the given
/// path, ignore this entry. Note: [`auth::RateLimitError`](crate::types::auth::RateLimitError) may
/// be returned if multiple [`list_folder()`](list_folder) or
/// [`list_folder_continue()`](list_folder_continue) calls with same parameters are made
/// simultaneously by same API app for same user. If your app implements retry logic, please hold
/// off the retry until the previous request finishes.
pub fn list_folder_app_auth(
    client: &impl crate::client_trait::AppAuthClient,
    arg: &ListFolderArg,
) -> Result<ListFolderResult, crate::Error<ListFolderError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/list_folder",
            arg,
            None)
    )
}

/// Once a cursor has been retrieved from [`list_folder()`](list_folder), use this to paginate
/// through all files and retrieve updates to the folder, following the same rules as documented for
/// [`list_folder()`](list_folder).
pub fn list_folder_continue(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &ListFolderContinueArg,
) -> Result<ListFolderResult, crate::Error<ListFolderContinueError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/list_folder/continue",
            arg,
            None)
    )
}

/// Once a cursor has been retrieved from [`list_folder()`](list_folder), use this to paginate
/// through all files and retrieve updates to the folder, following the same rules as documented for
/// [`list_folder()`](list_folder).
pub fn list_folder_continue_app_auth(
    client: &impl crate::client_trait::AppAuthClient,
    arg: &ListFolderContinueArg,
) -> Result<ListFolderResult, crate::Error<ListFolderContinueError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/list_folder/continue",
            arg,
            None)
    )
}

/// A way to quickly get a cursor for the folder's state. Unlike [`list_folder()`](list_folder),
/// [`list_folder_get_latest_cursor()`](list_folder_get_latest_cursor) doesn't return any entries.
/// This endpoint is for app which only needs to know about new files and modifications and doesn't
/// need to know about files that already exist in Dropbox.
pub fn list_folder_get_latest_cursor(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &ListFolderArg,
) -> Result<ListFolderGetLatestCursorResult, crate::Error<ListFolderError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/list_folder/get_latest_cursor",
            arg,
            None)
    )
}

/// A longpoll endpoint to wait for changes on an account. In conjunction with
/// [`list_folder_continue()`](list_folder_continue), this call gives you a low-latency way to
/// monitor an account for file changes. The connection will block until there are changes available
/// or a timeout occurs. This endpoint is useful mostly for client-side apps. If you're looking for
/// server-side notifications, check out our [webhooks
/// documentation](https://www.dropbox.com/developers/reference/webhooks).
pub fn list_folder_longpoll(
    client: &impl crate::client_trait::NoauthClient,
    arg: &ListFolderLongpollArg,
) -> Result<ListFolderLongpollResult, crate::Error<ListFolderLongpollError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Notify,
            crate::client_trait_common::Style::Rpc,
            "files/list_folder/longpoll",
            arg,
            None)
    )
}

/// Returns revisions for files based on a file path or a file id. The file path or file id is
/// identified from the latest file entry at the given file path or id. This end point allows your
/// app to query either by file path or file id by setting the mode parameter appropriately. In the
/// [`ListRevisionsMode::Path`](ListRevisionsMode::Path) (default) mode, all revisions at the same
/// file path as the latest file entry are returned. If revisions with the same file id are desired,
/// then mode must be set to [`ListRevisionsMode::Id`](ListRevisionsMode::Id). The
/// [`ListRevisionsMode::Id`](ListRevisionsMode::Id) mode is useful to retrieve revisions for a
/// given file across moves or renames.
pub fn list_revisions(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &ListRevisionsArg,
) -> Result<ListRevisionsResult, crate::Error<ListRevisionsError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/list_revisions",
            arg,
            None)
    )
}

/// Lock the files at the given paths. A locked file will be writable only by the lock holder. A
/// successful response indicates that the file has been locked. Returns a list of the locked file
/// paths and their metadata after this operation.
pub fn lock_file_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &LockFileBatchArg,
) -> Result<LockFileBatchResult, crate::Error<LockFileError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/lock_file_batch",
            arg,
            None)
    )
}

/// Move a file or folder to a different location in the user's Dropbox. If the source path is a
/// folder all its contents will be moved. Note that we do not currently support case-only renaming.
pub fn move_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &RelocationArg,
) -> Result<RelocationResult, crate::Error<RelocationError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/move_v2",
            arg,
            None)
    )
}

/// Move a file or folder to a different location in the user's Dropbox. If the source path is a
/// folder all its contents will be moved.
#[deprecated(note = "replaced by move_v2")]
pub fn do_move(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &RelocationArg,
) -> Result<Metadata, crate::Error<RelocationError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/move",
            arg,
            None)
    )
}

/// Move multiple files or folders to different locations at once in the user's Dropbox. Note that
/// we do not currently support case-only renaming. This route will replace
/// [`move_batch()`](move_batch). The main difference is this route will return status for each
/// entry, while [`move_batch()`](move_batch) raises failure if any entry fails. This route will
/// either finish synchronously, or return a job ID and do the async move job in background. Please
/// use [`move_batch_check_v2()`](move_batch_check_v2) to check the job status.
pub fn move_batch_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &MoveBatchArg,
) -> Result<RelocationBatchV2Launch, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/move_batch_v2",
            arg,
            None)
    )
}

/// Move multiple files or folders to different locations at once in the user's Dropbox. This route
/// will return job ID immediately and do the async moving job in background. Please use
/// [`move_batch_check()`](move_batch_check) to check the job status.
#[deprecated(note = "replaced by move_batch_v2")]
pub fn move_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &RelocationBatchArg,
) -> Result<RelocationBatchLaunch, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/move_batch",
            arg,
            None)
    )
}

/// Returns the status of an asynchronous job for [`move_batch_v2()`](move_batch_v2). It returns
/// list of results for each entry.
pub fn move_batch_check_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::dbx_async::PollArg,
) -> Result<RelocationBatchV2JobStatus, crate::Error<crate::types::dbx_async::PollError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/move_batch/check_v2",
            arg,
            None)
    )
}

/// Returns the status of an asynchronous job for [`move_batch()`](move_batch). If success, it
/// returns list of results for each entry.
#[deprecated(note = "replaced by move_batch_check_v2")]
pub fn move_batch_check(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::dbx_async::PollArg,
) -> Result<RelocationBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/move_batch/check",
            arg,
            None)
    )
}

/// Creates a new Paper doc with the provided content.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn paper_create(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &PaperCreateArg,
    body: &[u8],
) -> Result<PaperCreateResult, crate::Error<PaperCreateError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Upload,
            "files/paper/create",
            arg,
            Some(crate::client_helpers::Body::from(body)))
    )
}

/// Updates an existing Paper doc with the provided content.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn paper_update(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &PaperUpdateArg,
    body: &[u8],
) -> Result<PaperUpdateResult, crate::Error<PaperUpdateError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Upload,
            "files/paper/update",
            arg,
            Some(crate::client_helpers::Body::from(body)))
    )
}

/// Permanently delete the file or folder at a given path (see https://www.dropbox.com/en/help/40).
/// If the given file or folder is not yet deleted, this route will first delete it. It is possible
/// for this route to successfully delete, then fail to permanently delete. Note: This endpoint is
/// only available for Dropbox Business apps.
pub fn permanently_delete(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &DeleteArg,
) -> Result<(), crate::Error<DeleteError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/permanently_delete",
            arg,
            None)
    )
}

#[deprecated]
pub fn properties_add(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::file_properties::AddPropertiesArg,
) -> Result<(), crate::Error<crate::types::file_properties::AddPropertiesError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/properties/add",
            arg,
            None)
    )
}

#[deprecated]
pub fn properties_overwrite(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::file_properties::OverwritePropertyGroupArg,
) -> Result<(), crate::Error<crate::types::file_properties::InvalidPropertyGroupError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/properties/overwrite",
            arg,
            None)
    )
}

#[deprecated]
pub fn properties_remove(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::file_properties::RemovePropertiesArg,
) -> Result<(), crate::Error<crate::types::file_properties::RemovePropertiesError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/properties/remove",
            arg,
            None)
    )
}

#[deprecated]
pub fn properties_template_get(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::file_properties::GetTemplateArg,
) -> Result<crate::types::file_properties::GetTemplateResult, crate::Error<crate::types::file_properties::TemplateError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/properties/template/get",
            arg,
            None)
    )
}

#[deprecated]
pub fn properties_template_list(
    client: &impl crate::client_trait::UserAuthClient,
) -> Result<crate::types::file_properties::ListTemplateResult, crate::Error<crate::types::file_properties::TemplateError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/properties/template/list",
            &(),
            None)
    )
}

#[deprecated]
pub fn properties_update(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::file_properties::UpdatePropertiesArg,
) -> Result<(), crate::Error<crate::types::file_properties::UpdatePropertiesError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/properties/update",
            arg,
            None)
    )
}

/// Restore a specific revision of a file to the given path.
pub fn restore(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &RestoreArg,
) -> Result<FileMetadata, crate::Error<RestoreError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/restore",
            arg,
            None)
    )
}

/// Save the data from a specified URL into a file in user's Dropbox. Note that the transfer from
/// the URL must complete within 15 minutes, or the operation will time out and the job will fail.
/// If the given path already exists, the file will be renamed to avoid the conflict (e.g. myfile
/// (1).txt).
pub fn save_url(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &SaveUrlArg,
) -> Result<SaveUrlResult, crate::Error<SaveUrlError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/save_url",
            arg,
            None)
    )
}

/// Check the status of a [`save_url()`](save_url) job.
pub fn save_url_check_job_status(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::dbx_async::PollArg,
) -> Result<SaveUrlJobStatus, crate::Error<crate::types::dbx_async::PollError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/save_url/check_job_status",
            arg,
            None)
    )
}

/// Searches for files and folders. Note: Recent changes will be reflected in search results within
/// a few seconds and older revisions of existing files may still match your query for up to a few
/// days.
#[deprecated(note = "replaced by search_v2")]
pub fn search(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &SearchArg,
) -> Result<SearchResult, crate::Error<SearchError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/search",
            arg,
            None)
    )
}

/// Searches for files and folders. Note: [`search_v2()`](search_v2) along with
/// [`search_continue_v2()`](search_continue_v2) can only be used to retrieve a maximum of 10,000
/// matches. Recent changes may not immediately be reflected in search results due to a short delay
/// in indexing. Duplicate results may be returned across pages. Some results may not be returned.
pub fn search_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &SearchV2Arg,
) -> Result<SearchV2Result, crate::Error<SearchError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/search_v2",
            arg,
            None)
    )
}

/// Fetches the next page of search results returned from [`search_v2()`](search_v2). Note:
/// [`search_v2()`](search_v2) along with [`search_continue_v2()`](search_continue_v2) can only be
/// used to retrieve a maximum of 10,000 matches. Recent changes may not immediately be reflected in
/// search results due to a short delay in indexing. Duplicate results may be returned across pages.
/// Some results may not be returned.
pub fn search_continue_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &SearchV2ContinueArg,
) -> Result<SearchV2Result, crate::Error<SearchError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/search/continue_v2",
            arg,
            None)
    )
}

/// Add a tag to an item. A tag is a string. The strings are automatically converted to lowercase
/// letters. No more than 20 tags can be added to a given item.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn tags_add(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &AddTagArg,
) -> Result<(), crate::Error<AddTagError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/tags/add",
            arg,
            None)
    )
}

/// Get list of tags assigned to items.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn tags_get(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &GetTagsArg,
) -> Result<GetTagsResult, crate::Error<BaseTagError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/tags/get",
            arg,
            None)
    )
}

/// Remove a tag from an item.
///
/// # Stability
/// *PREVIEW*: This function may change or disappear without notice.
#[cfg(feature = "unstable")]
#[cfg_attr(docsrs, doc(cfg(feature = "unstable")))]
pub fn tags_remove(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &RemoveTagArg,
) -> Result<(), crate::Error<RemoveTagError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/tags/remove",
            arg,
            None)
    )
}

/// Unlock the files at the given paths. A locked file can only be unlocked by the lock holder or,
/// if a business account, a team admin. A successful response indicates that the file has been
/// unlocked. Returns a list of the unlocked file paths and their metadata after this operation.
pub fn unlock_file_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UnlockFileBatchArg,
) -> Result<LockFileBatchResult, crate::Error<LockFileError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/unlock_file_batch",
            arg,
            None)
    )
}

/// Create a new file with the contents provided in the request. Do not use this to upload a file
/// larger than 150 MB. Instead, create an upload session with
/// [`upload_session_start()`](upload_session_start). Calls to this endpoint will count as data
/// transport calls for any Dropbox Business teams with a limit on the number of data transport
/// calls allowed per month. For more information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UploadArg,
    body: &[u8],
) -> Result<FileMetadata, crate::Error<UploadError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Upload,
            "files/upload",
            arg,
            Some(crate::client_helpers::Body::from(body)))
    )
}

/// Append more data to an upload session. When the parameter close is set, this call will close the
/// session. A single request should not upload more than 150 MB. The maximum size of a file one can
/// upload to an upload session is 350 GB. Calls to this endpoint will count as data transport calls
/// for any Dropbox Business teams with a limit on the number of data transport calls allowed per
/// month. For more information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload_session_append_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UploadSessionAppendArg,
    body: &[u8],
) -> Result<(), crate::Error<UploadSessionAppendError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Upload,
            "files/upload_session/append_v2",
            arg,
            Some(crate::client_helpers::Body::from(body)))
    )
}

/// Append more data to an upload session. A single request should not upload more than 150 MB. The
/// maximum size of a file one can upload to an upload session is 350 GB. Calls to this endpoint
/// will count as data transport calls for any Dropbox Business teams with a limit on the number of
/// data transport calls allowed per month. For more information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
#[deprecated(note = "replaced by upload_session_append_v2")]
pub fn upload_session_append(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UploadSessionCursor,
    body: &[u8],
) -> Result<(), crate::Error<UploadSessionAppendError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Upload,
            "files/upload_session/append",
            arg,
            Some(crate::client_helpers::Body::from(body)))
    )
}

/// Finish an upload session and save the uploaded data to the given file path. A single request
/// should not upload more than 150 MB. The maximum size of a file one can upload to an upload
/// session is 350 GB. Calls to this endpoint will count as data transport calls for any Dropbox
/// Business teams with a limit on the number of data transport calls allowed per month. For more
/// information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload_session_finish(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UploadSessionFinishArg,
    body: &[u8],
) -> Result<FileMetadata, crate::Error<UploadSessionFinishError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Upload,
            "files/upload_session/finish",
            arg,
            Some(crate::client_helpers::Body::from(body)))
    )
}

/// This route helps you commit many files at once into a user's Dropbox. Use
/// [`upload_session_start()`](upload_session_start) and
/// [`upload_session_append_v2()`](upload_session_append_v2) to upload file contents. We recommend
/// uploading many files in parallel to increase throughput. Once the file contents have been
/// uploaded, rather than calling [`upload_session_finish()`](upload_session_finish), use this route
/// to finish all your upload sessions in a single request.
/// [`UploadSessionStartArg::close`](UploadSessionStartArg) or
/// [`UploadSessionAppendArg::close`](UploadSessionAppendArg) needs to be true for the last
/// [`upload_session_start()`](upload_session_start) or
/// [`upload_session_append_v2()`](upload_session_append_v2) call. The maximum size of a file one
/// can upload to an upload session is 350 GB. This route will return a job_id immediately and do
/// the async commit job in background. Use
/// [`upload_session_finish_batch_check()`](upload_session_finish_batch_check) to check the job
/// status. For the same account, this route should be executed serially. That means you should not
/// start the next job before current job finishes. We allow up to 1000 entries in a single request.
/// Calls to this endpoint will count as data transport calls for any Dropbox Business teams with a
/// limit on the number of data transport calls allowed per month. For more information, see the
/// [Data transport limit page](https://www.dropbox.com/developers/reference/data-transport-limit).
#[deprecated(note = "replaced by upload_session_finish_batch_v2")]
pub fn upload_session_finish_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UploadSessionFinishBatchArg,
) -> Result<UploadSessionFinishBatchLaunch, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/upload_session/finish_batch",
            arg,
            None)
    )
}

/// This route helps you commit many files at once into a user's Dropbox. Use
/// [`upload_session_start()`](upload_session_start) and
/// [`upload_session_append_v2()`](upload_session_append_v2) to upload file contents. We recommend
/// uploading many files in parallel to increase throughput. Once the file contents have been
/// uploaded, rather than calling [`upload_session_finish()`](upload_session_finish), use this route
/// to finish all your upload sessions in a single request.
/// [`UploadSessionStartArg::close`](UploadSessionStartArg) or
/// [`UploadSessionAppendArg::close`](UploadSessionAppendArg) needs to be true for the last
/// [`upload_session_start()`](upload_session_start) or
/// [`upload_session_append_v2()`](upload_session_append_v2) call of each upload session. The
/// maximum size of a file one can upload to an upload session is 350 GB. We allow up to 1000
/// entries in a single request. Calls to this endpoint will count as data transport calls for any
/// Dropbox Business teams with a limit on the number of data transport calls allowed per month. For
/// more information, see the [Data transport limit
/// page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload_session_finish_batch_v2(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UploadSessionFinishBatchArg,
) -> Result<UploadSessionFinishBatchResult, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/upload_session/finish_batch_v2",
            arg,
            None)
    )
}

/// Returns the status of an asynchronous job for
/// [`upload_session_finish_batch()`](upload_session_finish_batch). If success, it returns list of
/// result for each entry.
pub fn upload_session_finish_batch_check(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &crate::types::dbx_async::PollArg,
) -> Result<UploadSessionFinishBatchJobStatus, crate::Error<crate::types::dbx_async::PollError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/upload_session/finish_batch/check",
            arg,
            None)
    )
}

/// Upload sessions allow you to upload a single file in one or more requests, for example where the
/// size of the file is greater than 150 MB.  This call starts a new upload session with the given
/// data. You can then use [`upload_session_append_v2()`](upload_session_append_v2) to add more data
/// and [`upload_session_finish()`](upload_session_finish) to save all the data to a file in
/// Dropbox. A single request should not upload more than 150 MB. The maximum size of a file one can
/// upload to an upload session is 350 GB. An upload session can be used for a maximum of 7 days.
/// Attempting to use an [`UploadSessionStartResult::session_id`](UploadSessionStartResult) with
/// [`upload_session_append_v2()`](upload_session_append_v2) or
/// [`upload_session_finish()`](upload_session_finish) more than 7 days after its creation will
/// return a [`UploadSessionLookupError::NotFound`](UploadSessionLookupError::NotFound). Calls to
/// this endpoint will count as data transport calls for any Dropbox Business teams with a limit on
/// the number of data transport calls allowed per month. For more information, see the [Data
/// transport limit page](https://www.dropbox.com/developers/reference/data-transport-limit). By
/// default, upload sessions require you to send content of the file in sequential order via
/// consecutive [`upload_session_start()`](upload_session_start),
/// [`upload_session_append_v2()`](upload_session_append_v2),
/// [`upload_session_finish()`](upload_session_finish) calls. For better performance, you can
/// instead optionally use a [`UploadSessionType::Concurrent`](UploadSessionType::Concurrent) upload
/// session. To start a new concurrent session, set
/// [`UploadSessionStartArg::session_type`](UploadSessionStartArg) to
/// [`UploadSessionType::Concurrent`](UploadSessionType::Concurrent). After that, you can send file
/// data in concurrent [`upload_session_append_v2()`](upload_session_append_v2) requests. Finally
/// finish the session with [`upload_session_finish()`](upload_session_finish). There are couple of
/// constraints with concurrent sessions to make them work. You can not send data with
/// [`upload_session_start()`](upload_session_start) or
/// [`upload_session_finish()`](upload_session_finish) call, only with
/// [`upload_session_append_v2()`](upload_session_append_v2) call. Also data uploaded in
/// [`upload_session_append_v2()`](upload_session_append_v2) call must be multiple of 4194304 bytes
/// (except for last [`upload_session_append_v2()`](upload_session_append_v2) with
/// [`UploadSessionStartArg::close`](UploadSessionStartArg) to `true`, that may contain any
/// remaining data).
pub fn upload_session_start(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UploadSessionStartArg,
    body: &[u8],
) -> Result<UploadSessionStartResult, crate::Error<UploadSessionStartError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Content,
            crate::client_trait_common::Style::Upload,
            "files/upload_session/start",
            arg,
            Some(crate::client_helpers::Body::from(body)))
    )
}

/// This route starts batch of upload_sessions. Please refer to `upload_session/start` usage. Calls
/// to this endpoint will count as data transport calls for any Dropbox Business teams with a limit
/// on the number of data transport calls allowed per month. For more information, see the [Data
/// transport limit page](https://www.dropbox.com/developers/reference/data-transport-limit).
pub fn upload_session_start_batch(
    client: &impl crate::client_trait::UserAuthClient,
    arg: &UploadSessionStartBatchArg,
) -> Result<UploadSessionStartBatchResult, crate::Error<crate::NoError>> {
    crate::client_helpers::unwrap_async(
        crate::client_helpers::request(
            client,
            crate::client_trait_common::Endpoint::Api,
            crate::client_trait_common::Style::Rpc,
            "files/upload_session/start_batch",
            arg,
            None)
    )
}

